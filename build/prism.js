(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.prism = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (coll, iteratee, callback) {
    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, iteratee, callback);
};

var _isArrayLike = require('lodash/isArrayLike');

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _eachOfLimit = require('./eachOfLimit');

var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);

var _doLimit = require('./internal/doLimit');

var _doLimit2 = _interopRequireDefault(_doLimit);

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _once = require('lodash/once');

var _once2 = _interopRequireDefault(_once);

var _onlyOnce = require('./internal/onlyOnce');

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eachOf implementation optimized for array-likes
function eachOfArrayLike(coll, iteratee, callback) {
    callback = (0, _once2.default)(callback || _noop2.default);
    var index = 0,
        completed = 0,
        length = coll.length;
    if (length === 0) {
        callback(null);
    }

    function iteratorCallback(err) {
        if (err) {
            callback(err);
        } else if (++completed === length) {
            callback(null);
        }
    }

    for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
    }
}

// a generic version of eachOf which can handle array, object, and iterator cases.
var eachOfGeneric = (0, _doLimit2.default)(_eachOfLimit2.default, Infinity);

/**
 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
 * to the iteratee.
 *
 * @name eachOf
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEachOf
 * @category Collection
 * @see [async.each]{@link module:Collections.each}
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array. The iteratee is passed a `callback(err)` which must be called once it
 * has completed. If no error has occurred, the callback should be run without
 * arguments or with an explicit `null` argument. Invoked with
 * (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @example
 *
 * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
 * var configs = {};
 *
 * async.forEachOf(obj, function (value, key, callback) {
 *     fs.readFile(__dirname + value, "utf8", function (err, data) {
 *         if (err) return callback(err);
 *         try {
 *             configs[key] = JSON.parse(data);
 *         } catch (e) {
 *             return callback(e);
 *         }
 *         callback();
 *     });
 * }, function (err) {
 *     if (err) console.error(err.message);
 *     // configs is now a map of JSON data
 *     doSomethingWith(configs);
 * });
 */
module.exports = exports['default'];
},{"./eachOfLimit":2,"./internal/doLimit":3,"./internal/onlyOnce":8,"lodash/isArrayLike":22,"lodash/noop":30,"lodash/once":31}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = eachOfLimit;

var _eachOfLimit2 = require('./internal/eachOfLimit');

var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name eachOfLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} iteratee - A function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array. The iteratee is passed a `callback(err)` which must be called once it
 * has completed. If no error has occurred, the callback should be run without
 * arguments or with an explicit `null` argument. Invoked with
 * (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
function eachOfLimit(coll, limit, iteratee, callback) {
  (0, _eachOfLimit3.default)(limit)(coll, iteratee, callback);
}
module.exports = exports['default'];
},{"./internal/eachOfLimit":4}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = doLimit;
function doLimit(fn, limit) {
    return function (iterable, iteratee, callback) {
        return fn(iterable, limit, iteratee, callback);
    };
}
module.exports = exports['default'];
},{}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _eachOfLimit;

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _once = require('./once');

var _once2 = _interopRequireDefault(_once);

var _iterator = require('./iterator');

var _iterator2 = _interopRequireDefault(_iterator);

var _onlyOnce = require('./onlyOnce');

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _eachOfLimit(limit) {
    return function (obj, iteratee, callback) {
        callback = (0, _once2.default)(callback || _noop2.default);
        if (limit <= 0 || !obj) {
            return callback(null);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var running = 0;

        function iterateeCallback(err) {
            running -= 1;
            if (err) {
                done = true;
                callback(err);
            } else if (done && running <= 0) {
                return callback(null);
            } else {
                replenish();
            }
        }

        function replenish() {
            while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                    done = true;
                    if (running <= 0) {
                        callback(null);
                    }
                    return;
                }
                running += 1;
                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
            }
        }

        replenish();
    };
}
module.exports = exports['default'];
},{"./iterator":6,"./once":7,"./onlyOnce":8,"lodash/noop":30}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (coll) {
    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
};

var iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;

module.exports = exports['default'];
},{}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = iterator;

var _isArrayLike = require('lodash/isArrayLike');

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _getIterator = require('./getIterator');

var _getIterator2 = _interopRequireDefault(_getIterator);

var _keys = require('lodash/keys');

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createArrayIterator(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
    };
}

function createES2015Iterator(iterator) {
    var i = -1;
    return function next() {
        var item = iterator.next();
        if (item.done) return null;
        i++;
        return { value: item.value, key: i };
    };
}

function createObjectIterator(obj) {
    var okeys = (0, _keys2.default)(obj);
    var i = -1;
    var len = okeys.length;
    return function next() {
        var key = okeys[++i];
        return i < len ? { value: obj[key], key: key } : null;
    };
}

function iterator(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
    }

    var iterator = (0, _getIterator2.default)(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}
module.exports = exports['default'];
},{"./getIterator":5,"lodash/isArrayLike":22,"lodash/keys":29}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = once;
function once(fn) {
    return function () {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}
module.exports = exports['default'];
},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = onlyOnce;
function onlyOnce(fn) {
    return function () {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}
module.exports = exports['default'];
},{}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _parallel;

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _isArrayLike = require('lodash/isArrayLike');

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _rest = require('lodash/rest');

var _rest2 = _interopRequireDefault(_rest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _parallel(eachfn, tasks, callback) {
    callback = callback || _noop2.default;
    var results = (0, _isArrayLike2.default)(tasks) ? [] : {};

    eachfn(tasks, function (task, key, callback) {
        task((0, _rest2.default)(function (err, args) {
            if (args.length <= 1) {
                args = args[0];
            }
            results[key] = args;
            callback(err);
        }));
    }, function (err) {
        callback(err, results);
    });
}
module.exports = exports['default'];
},{"lodash/isArrayLike":22,"lodash/noop":30,"lodash/rest":32}],10:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],11:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":14,"./_isIndex":15,"./isArguments":20,"./isArray":21}],12:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":16,"./_nativeKeys":17}],13:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

module.exports = baseRest;

},{"./_apply":10}],14:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],15:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],16:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],17:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":18}],18:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],19:[function(require,module,exports){
var toInteger = require('./toInteger');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => Allows adding up to 4 contacts to the list.
 */
function before(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

module.exports = before;

},{"./toInteger":34}],20:[function(require,module,exports){
var isArrayLikeObject = require('./isArrayLikeObject');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

module.exports = isArguments;

},{"./isArrayLikeObject":23}],21:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],22:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":24,"./isLength":25}],23:[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":22,"./isObjectLike":27}],24:[function(require,module,exports){
var isObject = require('./isObject');

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

module.exports = isFunction;

},{"./isObject":26}],25:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],26:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],27:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],28:[function(require,module,exports){
var isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

module.exports = isSymbol;

},{"./isObjectLike":27}],29:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":11,"./_baseKeys":12,"./isArrayLike":22}],30:[function(require,module,exports){
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;

},{}],31:[function(require,module,exports){
var before = require('./before');

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */
function once(func) {
  return before(2, func);
}

module.exports = once;

},{"./before":19}],32:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    toInteger = require('./toInteger');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as
 * an array.
 *
 * **Note:** This method is based on the
 * [rest parameter](https://mdn.io/rest_parameters).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.rest(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function rest(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = start === undefined ? start : toInteger(start);
  return baseRest(func, start);
}

module.exports = rest;

},{"./_baseRest":13,"./toInteger":34}],33:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":35}],34:[function(require,module,exports){
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

},{"./toFinite":33}],35:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":26,"./isSymbol":28}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parallelLimit;

var _eachOf = require('./eachOf');

var _eachOf2 = _interopRequireDefault(_eachOf);

var _parallel = require('./internal/parallel');

var _parallel2 = _interopRequireDefault(_parallel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Run the `tasks` collection of functions in parallel, without waiting until
 * the previous function has completed. If any of the functions pass an error to
 * its callback, the main `callback` is immediately called with the value of the
 * error. Once the `tasks` have completed, the results are passed to the final
 * `callback` as an array.
 *
 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
 * parallel execution of code.  If your tasks do not use any timers or perform
 * any I/O, they will actually be executed in series.  Any synchronous setup
 * sections for each task will happen one after the other.  JavaScript remains
 * single-threaded.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 * results from {@link async.parallel}.
 *
 * @name parallel
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection containing functions to run.
 * Each function is passed a `callback(err, result)` which it must call on
 * completion with an error `err` (which can be `null`) and an optional `result`
 * value.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 * @example
 * async.parallel([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     // the results array will equal ['one','two'] even though
 *     // the second function had a shorter timeout.
 * });
 *
 * // an example using an object instead of an array
 * async.parallel({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     // results is now equals to: {one: 1, two: 2}
 * });
 */
function parallelLimit(tasks, callback) {
  (0, _parallel2.default)(_eachOf2.default, tasks, callback);
}
module.exports = exports['default'];
},{"./eachOf":1,"./internal/parallel":9}],37:[function(require,module,exports){
(function () {

    'use strict';

    let Texture2D = require('./Texture2D');
    let ImageLoader = require('../util/ImageLoader');
    let Util = require('../util/Util');

    let MAG_FILTERS = {
        NEAREST: true,
        LINEAR: true
    };
    let MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true,
        NEAREST_MIPMAP_NEAREST: true,
        LINEAR_MIPMAP_NEAREST: true,
        NEAREST_MIPMAP_LINEAR: true,
        LINEAR_MIPMAP_LINEAR: true
    };
    let WRAP_MODES = {
        REPEAT: true,
        MIRRORED_REPEAT: true,
        CLAMP_TO_EDGE: true
    };
    let TYPES = {
        UNSIGNED_BYTE: true,
        FLOAT: true
    };
    let FORMATS = {
        RGB: true,
        RGBA: true
    };

    /**
     * The default type for color textures.
     */
    let DEFAULT_TYPE = 'UNSIGNED_BYTE';

    /**
     * The default format for color textures.
     */
    let DEFAULT_FORMAT = 'RGBA';

    /**
     * The default wrap mode for color textures.
     */
    let DEFAULT_WRAP = 'REPEAT';

    /**
     * The default min / mag filter for color textures.
     */
    let DEFAULT_FILTER = 'LINEAR';

    /**
     * The default for whether alpha premultiplying is enabled.
     */
    let DEFAULT_PREMULTIPLY_ALPHA = true;

    /**
     * The default for whether mipmapping is enabled.
     */
    let DEFAULT_MIPMAP = true;

    /**
     * The default for whether invert-y is enabled.
     */
    let DEFAULT_INVERT_Y = true;

    /**
     * @class ColorTexture2D
     * @classdesc A texture class to represent a 2D color texture.
     * @augments Texture2D
     */
    class ColorTexture2D extends Texture2D {

        /**
         * Instantiates a ColorTexture2D object.
         *
         * @param {Object} spec - The specification arguments.
         * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} spec.image - The HTMLImageElement to buffer.
         * @param {String} spec.url - The HTMLImageElement URL to load and buffer.
         * @param {Uint8Array|Float32Array} spec.src - The data to buffer.
         * @param {Number} spec.width - The width of the texture.
         * @param {Number} spec.height - The height of the texture.
         * @param {String} spec.wrap - The wrapping type over both S and T dimension.
         * @param {String} spec.wrapS - The wrapping type over the S dimension.
         * @param {String} spec.wrapT - The wrapping type over the T dimension.
         * @param {String} spec.filter - The min / mag filter used during scaling.
         * @param {String} spec.minFilter - The minification filter used during scaling.
         * @param {String} spec.magFilter - The magnification filter used during scaling.
         * @param {bool} spec.mipMap - Whether or not mip-mapping is enabled.
         * @param {bool} spec.invertY - Whether or not invert-y is enabled.
         * @param {bool} spec.preMultiplyAlpha - Whether or not alpha premultiplying is enabled.
         * @param {String} spec.format - The texture pixel format.
         * @param {String} spec.type - The texture pixel component type.
         * @param {Function} callback - The callback to be executed if the data is loaded asynchronously via a URL.
         */
        constructor(spec = {}, callback = null) {
            // get specific params
            spec.wrapS = spec.wrapS || spec.wrap;
            spec.wrapT = spec.wrapT || spec.wrap;
            spec.minFilter = spec.minFilter || spec.filter;
            spec.magFilter = spec.magFilter || spec.filter;
            // set texture params
            spec.wrapS = WRAP_MODES[spec.wrapS] ? spec.wrapS : DEFAULT_WRAP;
            spec.wrapT = WRAP_MODES[spec.wrapT] ? spec.wrapT : DEFAULT_WRAP;
            spec.minFilter = MIN_FILTERS[spec.minFilter] ? spec.minFilter : DEFAULT_FILTER;
            spec.magFilter = MAG_FILTERS[spec.magFilter] ? spec.magFilter : DEFAULT_FILTER;
            // set other properties
            spec.mipMap = spec.mipMap !== undefined ? spec.mipMap : DEFAULT_MIPMAP;
            spec.invertY = spec.invertY !== undefined ? spec.invertY : DEFAULT_INVERT_Y;
            spec.preMultiplyAlpha = spec.preMultiplyAlpha !== undefined ? spec.preMultiplyAlpha : DEFAULT_PREMULTIPLY_ALPHA;
            // set format
            spec.format = FORMATS[spec.format] ? spec.format : DEFAULT_FORMAT;
            // buffer the texture based on argument type
            if (typeof spec.src === 'string') {
                // request source from url
                spec.type = 'UNSIGNED_BYTE';
                // call base constructor
                super(spec);
                // TODO: put extension handling for arraybuffer / image / video differentiation
                ImageLoader.load({
                    url: spec.src,
                    success: image => {
                        // set to unsigned byte type
                        image = Util.resizeCanvas(spec, image);
                        // now buffer
                        this.bufferData(image, spec.width, spec.height);
                        this.setParameters(this);
                        // execute callback
                        if (callback) {
                            callback(null, this);
                        }
                    },
                    error: err => {
                        if (callback) {
                            callback(err, null);
                        }
                    }
                });
            } else if (Util.isCanvasType(spec.src)) {
                // is image / canvas / video type
                // set to unsigned byte type
                spec.type = 'UNSIGNED_BYTE';
                spec.src = Util.resizeCanvas(spec, spec.src);
                // call base constructor
                super(spec);
            } else {
                // array, arraybuffer, or null
                if (spec.src === undefined || spec.src === null) {
                    // if no data is provided, assume this texture will be rendered
                    // to. In this case disable mipmapping, there is no need and it
                    // will only introduce very peculiar and difficult to discern
                    // rendering phenomena in which the texture 'transforms' at
                    // certain angles / distances to the mipmapped (empty) portions.
                    spec.mipMap = false;
                }
                // buffer from arg
                spec.type = TYPES[spec.type] ? spec.type : DEFAULT_TYPE;
                // call base constructor
                super(spec);
            }
        }
    }

    module.exports = ColorTexture2D;

}());

},{"../util/ImageLoader":52,"../util/Util":53,"./Texture2D":44}],38:[function(require,module,exports){
(function () {

    'use strict';

    let Texture2D = require('./Texture2D');

    let MAG_FILTERS = {
        NEAREST: true,
        LINEAR: true
    };
    let MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true
    };
    let WRAP_MODES = {
        REPEAT: true,
        CLAMP_TO_EDGE: true,
        MIRRORED_REPEAT: true
    };
    let DEPTH_TYPES = {
        UNSIGNED_BYTE: true,
        UNSIGNED_SHORT: true,
        UNSIGNED_INT: true
    };
    let FORMATS = {
        DEPTH_COMPONENT: true,
        DEPTH_STENCIL: true
    };

    /**
     * The default type for depth textures.
     */
    let DEFAULT_TYPE = 'UNSIGNED_INT';

    /**
     * The default format for depth textures.
     */
    let DEFAULT_FORMAT = 'DEPTH_COMPONENT';

    /**
     * The default wrap mode for depth textures.
     */
    let DEFAULT_WRAP = 'CLAMP_TO_EDGE';

    /**
     * The default min / mag filter for depth textures.
     */
    let DEFAULT_FILTER = 'LINEAR';

    /**
     * @class DepthTexture2D
     * @classdesc A texture class to represent a 2D depth texture.
     * @augments Texture2D
     */
    class DepthTexture2D extends Texture2D {

        /**
         * Instantiates a DepthTexture2D object.
         *
         * @param {Object} spec - The specification arguments.
         * @param {Uint8Array|Uint16Array|Uint32Array} spec.src - The data to buffer.
         * @param {Number} spec.width - The width of the texture.
         * @param {Number} spec.height - The height of the texture.
         * @param {String} spec.wrap - The wrapping type over both S and T dimension.
         * @param {String} spec.wrapS - The wrapping type over the S dimension.
         * @param {String} spec.wrapT - The wrapping type over the T dimension.
         * @param {String} spec.filter - The min / mag filter used during scaling.
         * @param {String} spec.minFilter - The minification filter used during scaling.
         * @param {String} spec.magFilter - The magnification filter used during scaling.
         * @param {String} spec.format - The texture pixel format.
         * @param {String} spec.type - The texture pixel component type.
         */
        constructor(spec = {}) {
            // get specific params
            spec.wrapS = spec.wrapS || spec.wrap;
            spec.wrapT = spec.wrapT || spec.wrap;
            spec.minFilter = spec.minFilter || spec.filter;
            spec.magFilter = spec.magFilter || spec.filter;
            // set texture params
            spec.wrapS = WRAP_MODES[spec.wrapS] ? spec.wrapS : DEFAULT_WRAP;
            spec.wrapT = WRAP_MODES[spec.wrapT] ? spec.wrapT : DEFAULT_WRAP;
            spec.minFilter = MIN_FILTERS[spec.minFilter] ? spec.minFilter : DEFAULT_FILTER;
            spec.magFilter = MAG_FILTERS[spec.magFilter] ? spec.magFilter : DEFAULT_FILTER;
            // set mip-mapping and format
            spec.mipMap = false; // disable mip-mapping
            spec.invertY = false; // no need to invert-y
            spec.preMultiplyAlpha = false; // no alpha to pre-multiply
            spec.format = FORMATS[spec.format] ? spec.format : DEFAULT_FORMAT;
            // check if stencil-depth, or just depth
            if (spec.format === 'DEPTH_STENCIL') {
                spec.type = 'UNSIGNED_INT_24_8_WEBGL';
            } else {
                spec.type = DEPTH_TYPES[spec.type] ? spec.type : DEFAULT_TYPE;
            }
            // call base constructor
            super(spec);
        }
    }

    module.exports = DepthTexture2D;

}());

},{"./Texture2D":44}],39:[function(require,module,exports){
(function () {

    'use strict';

    let WebGLContext = require('./WebGLContext');

    let TYPES = {
        UNSIGNED_BYTE: true,
        UNSIGNED_SHORT: true,
        UNSIGNED_INT: true
    };
    let MODES = {
        POINTS: true,
        LINES: true,
        LINE_STRIP: true,
        LINE_LOOP: true,
        TRIANGLES: true,
        TRIANGLE_STRIP: true,
        TRIANGLE_FAN: true
    };
    let BYTES_PER_TYPE = {
        UNSIGNED_BYTE: 1,
        UNSIGNED_SHORT: 2,
        UNSIGNED_INT: 4
    };

    /**
     * The default component type.
     */
    let DEFAULT_TYPE = 'UNSIGNED_SHORT';

    /**
     * The default render mode (primitive type).
     */
    let DEFAULT_MODE = 'TRIANGLES';

    /**
     * The default byte offset to render from.
     */
    let DEFAULT_BYTE_OFFSET = 0;

    /**
     * The default count of indices to render.
     */
    let DEFAULT_COUNT = 0;

    /**
     * @class IndexBuffer
     * @classdesc An index buffer class to hole indexing information.
     */
    class IndexBuffer {

        /**
         * Instantiates an IndexBuffer object.
         *
         * @param {WebGLBuffer|Uint8Array|Uint16Array|Uin32Array|Array|Number} arg - The index data to buffer.
         * @param {Object} options - The rendering options.
         * @param {String} options.mode - The draw mode / primitive type.
         * @param {String} options.byteOffset - The byte offset into the drawn buffer.
         * @param {String} options.count - The number of vertices to draw.
         */
        constructor(arg, options = {}) {
            this.gl = WebGLContext.get();
            this.buffer = null;
            this.type = TYPES[options.type] ? options.type : DEFAULT_TYPE;
            this.mode = MODES[options.mode] ? options.mode : DEFAULT_MODE;
            this.count = (options.count !== undefined) ? options.count : DEFAULT_COUNT;
            this.byteOffset = (options.byteOffset !== undefined) ? options.byteOffset : DEFAULT_BYTE_OFFSET;
            this.byteLength = 0;
            if (arg) {
                if (arg instanceof WebGLBuffer) {
                    // WebGLBuffer argument
                    if (options.byteLength === undefined) {
                        throw 'Argument of type WebGLBuffer` must be complimented with a corresponding `options.byteLength`';
                    }
                    this.byteLength = options.byteLength;
                    this.buffer = arg;
                } else if (Number.isInteger(arg)) {
                    // byte length argument
                    if (options.type === undefined) {
                        throw 'Argument of type `number` must be complimented with a corresponding `options.type`';
                    }
                    this.bufferData(arg);
                } else if (arg instanceof ArrayBuffer) {
                    // ArrayBuffer arg
                    if (options.type === undefined) {
                        throw 'Argument of type `ArrayBuffer` must be complimented with a corresponding `options.type`';
                    }
                    this.bufferData(arg);
                } else {
                    // Array or ArrayBufferView argument
                    this.bufferData(arg);
                }
            } else {
                if (options.type === undefined) {
                    throw 'Empty buffer must be complimented with a corresponding `options.type`';
                }
            }
        }

        /**
         * Upload index data to the GPU.
         *
         * @param {Array|ArrayBuffer|ArrayBufferView|number} arg - The array of data to buffer.
         *
         * @return {IndexBuffer} The index buffer object, for chaining.
         */
        bufferData(arg) {
            let gl = this.gl;
            // cast array to ArrayBufferView based on provided type
            if (Array.isArray(arg)) {
                // check for type
                if (this.type === 'UNSIGNED_INT') {
                    // buffer to uint32
                    arg = new Uint32Array(arg);
                } else if (this.type === 'UNSIGNED_SHORT') {
                    // buffer to uint16
                    arg = new Uint16Array(arg);
                } else {
                    // buffer to uint8
                    arg = new Uint8Array(arg);
                }
            } else {
                // set ensure type corresponds to data
                if (arg instanceof Uint32Array) {
                    this.type = 'UNSIGNED_INT';
                } else if (arg instanceof Uint16Array) {
                    this.type = 'UNSIGNED_SHORT';
                } else if (arg instanceof Uint8Array) {
                    this.type = 'UNSIGNED_BYTE';
                } else if (
                    !(arg instanceof ArrayBuffer) &&
                    !(Number.isInteger(arg))
                    ) {
                    throw 'Argument must be of type `Array`, `ArrayBuffer`, `ArrayBufferView`, or `number`';
                }
            }
            // check that the type is supported by extension
            if (this.type === 'UNSIGNED_INT' &&
                !WebGLContext.checkExtension('OES_element_index_uint')) {
                throw 'Cannot create IndexBuffer of type `UNSIGNED_INT` as extension `OES_element_index_uint` is not supported';
            }
            // don't overwrite the count if it is already set
            if (this.count === DEFAULT_COUNT) {
                if (Number.isInteger(arg)) {
                    this.count = (arg / BYTES_PER_TYPE[this.type]);
                } else {
                    this.count = arg.length;
                }
            }
            // set byte length
            if (Number.isInteger(arg)) {
                this.byteLength = arg;
            } else {
                this.byteLength = arg.byteLength;
            }
            // create buffer if it doesn't exist already
            if (!this.buffer) {
                this.buffer = gl.createBuffer();
            }
            // buffer the data
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arg, gl.STATIC_DRAW);
            return this;
        }

        /**
         * Upload partial index data to the GPU.
         *
         * @param {Array|ArrayBuffer|ArrayBufferView} array - The array of data to buffer.
         * @param {Number} byteOffset - The byte offset at which to buffer.
         *
         * @return {IndexBuffer} The index buffer object, for chaining.
         */
        bufferSubData(array, byteOffset = DEFAULT_BYTE_OFFSET) {
            let gl = this.gl;
            if (!this.buffer) {
                throw 'Buffer has not yet been allocated, allocate with `bufferData`';
            }
            // cast array to ArrayBufferView based on provided type
            if (Array.isArray(array)) {
                // check for type
                if (this.type === 'UNSIGNED_INT') {
                    // buffer to uint32
                    array = new Uint32Array(array);
                } else if (this.type === 'UNSIGNED_SHORT') {
                    // buffer to uint16
                    array = new Uint16Array(array);
                } else {
                    // buffer to uint8
                    array = new Uint8Array(array);
                }
            } else if (
                !(array instanceof Uint8Array) &&
                !(array instanceof Uint16Array) &&
                !(array instanceof Uint32Array) &&
                !(array instanceof ArrayBuffer)) {
                throw 'Argument must be of type `Array`, `ArrayBuffer`, or `ArrayBufferView`';
            }
            // check that we aren't overflowing the buffer
            if (byteOffset + array.byteLength > this.byteLength) {
                throw `Argument of length ${array.byteLength} bytes with ` +
                    `offset of ${byteOffset} bytes overflows the buffer ` +
                    `length of ${this.byteLength} bytes`;
            }
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, byteOffset, array);
            return this;
        }

        /**
         * Execute the draw command for the bound buffer.
         *
         * @param {Object} options - The options to pass to 'drawElements'. Optional.
         * @param {String} options.mode - The draw mode / primitive type.
         * @param {String} options.byteOffset - The byteOffset into the drawn buffer.
         * @param {String} options.count - The number of vertices to draw.
         *
         * @return {IndexBuffer} The index buffer object, for chaining.
         */
        draw(options = {}) {
            let gl = this.gl;
            let mode = gl[options.mode || this.mode];
            let type = gl[this.type];
            let byteOffset = (options.byteOffset !== undefined) ? options.byteOffset : this.byteOffset;
            let count = (options.count !== undefined) ? options.count : this.count;
            if (count === 0) {
                throw 'Attempting to draw with a count of 0';
            }
            // bind buffer
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            // draw elements
            gl.drawElements(mode, count, type, byteOffset);
            // no need to unbind
            return this;
        }
    }

    module.exports = IndexBuffer;

}());

},{"./WebGLContext":49}],40:[function(require,module,exports){
(function () {

    'use strict';

    let WebGLContext = require('./WebGLContext');

    let TEXTURE_TARGETS = {
        TEXTURE_2D: true,
        TEXTURE_CUBE_MAP: true
    };

    let DEPTH_FORMATS = {
        DEPTH_COMPONENT: true,
        DEPTH_STENCIL: true
    };

    /**
     * @class RenderTarget
     * @classdesc A renderTarget class to allow rendering to textures.
     */
    class RenderTarget {

        /**
         * Instantiates a RenderTarget object.
         */
         constructor() {
            this.gl = WebGLContext.get();
            this.framebuffer = this.gl.createFramebuffer();
            this.textures = {};
        }

        /**
         * Binds the renderTarget object.
         *
         * @return {RenderTarget} The renderTarget object, for chaining.
         */
        bind() {
            // bind framebuffer
            let gl = this.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
            return this;
        }

        /**
         * Unbinds the renderTarget object.
         *
         * @return {RenderTarget} The renderTarget object, for chaining.
         */
        unbind() {
            // unbind framebuffer
            let gl = this.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            return this;
        }

        /**
         * Attaches the provided texture to the provided attachment location.
         *
         * @param {Texture2D} texture - The texture to attach.
         * @param {Number} index - The attachment index. (optional)
         * @param {String} target - The texture target type. (optional)
         *
         * @return {RenderTarget} The renderTarget object, for chaining.
         */
        setColorTarget(texture, index, target) {
            let gl = this.gl;
            if (!texture) {
                throw 'Texture argument is missing';
            }
            if (TEXTURE_TARGETS[index] && target === undefined) {
                target = index;
                index = 0;
            }
            if (index === undefined) {
                index = 0;
            } else if (!Number.isInteger(index) || index < 0) {
                throw 'Texture color attachment index is invalid';
            }
            if (target && !TEXTURE_TARGETS[target]) {
                throw 'Texture target is invalid';
            }
            this.textures['color' + index] = texture;
            this.bind();
            gl.framebufferTexture2D(
                gl.FRAMEBUFFER,
                gl['COLOR_ATTACHMENT' + index],
                gl[target || 'TEXTURE_2D'],
                texture.texture,
                0);
            this.unbind();
            return this;
        }

        /**
         * Attaches the provided texture to the provided attachment location.
         *
         * @param {Texture2D} texture - The texture to attach.
         *
         * @return {RenderTarget} The renderTarget object, for chaining.
         */
        setDepthTarget(texture) {
            if (!texture) {
                throw 'Texture argument is missing';
            }
            if (!DEPTH_FORMATS[texture.format]) {
                throw 'Provided texture is not of format `DEPTH_COMPONENT` or `DEPTH_STENCIL`';
            }
            let gl = this.gl;
            this.textures.depth = texture;
            this.bind();
            gl.framebufferTexture2D(
                gl.FRAMEBUFFER,
                gl.DEPTH_ATTACHMENT,
                gl.TEXTURE_2D,
                texture.texture,
                0);
            this.unbind();
            return this;
        }

        /**
         * Resizes the renderTarget and all attached textures by the provided height and width.
         *
         * @param {Number} width - The new width of the renderTarget.
         * @param {Number} height - The new height of the renderTarget.
         *
         * @return {RenderTarget} The renderTarget object, for chaining.
         */
        resize(width, height) {
            if (typeof width !== 'number' || (width <= 0)) {
                throw `Provided \`width\` of ${width} is invalid`;
            }
            if (typeof height !== 'number' || (height <= 0)) {
                throw `Provided \`height\` of ${height} is invalid`;
            }
            let textures = this.textures;
            Object.keys(textures).forEach(key => {
                textures[key].resize(width, height);
            });
            return this;
        }
    }

    module.exports = RenderTarget;

}());

},{"./WebGLContext":49}],41:[function(require,module,exports){
(function () {

    'use strict';

    let VertexPackage = require('../core/VertexPackage');
    let VertexBuffer = require('../core/VertexBuffer');
    let IndexBuffer = require('../core/IndexBuffer');

    /**
     * Iterates over all vertex buffers and throws an exception if the counts
     * are not equal.
     * @private
     *
     * @param {Array} vertexBuffers - The array of vertexBuffers.
     */
    function checkVertexBufferCounts(vertexBuffers) {
        let count = null;
        vertexBuffers.forEach(buffer => {
            if (count === null) {
                count = buffer.count;
            } else {
                if (count !== buffer.count) {
                    throw `VertexBuffers must all have the same count to be rendered without an IndexBuffer, mismatch of ${count} and ${buffer.count} found`;
                } else {
                    console.log('count ' + count + ' === ' + buffer.count);
                }
            }
        });
    }

    /**
     * Iterates over all attribute pointers and throws an exception if an index
     * occurs more than once.
     * @private
     *
     * @param {Array} vertexBuffers - The array of vertexBuffers.
     */
    function checkIndexCollisions(vertexBuffers) {
        let indices = {};
        vertexBuffers.forEach(buffer => {
            Object.keys(buffer.pointers).forEach(index => {
                indices[index] = indices[index] || 0;
                indices[index]++;
            });
        });
        Object.keys(indices).forEach(index => {
            if (indices[index] > 1) {
                throw `More than one attribute pointer exists for index \`${index}\``;
            }
        });
    }

    /**
     * @class Renderable
     * @classdesc A container for one or more VertexBuffers and an optional IndexBuffer.
     */
    class Renderable {

        /**
         * Instantiates an Renderable object.
         *
         * @param {Object} spec - The renderable specification object.
         * @param {Array|Float32Array} spec.vertices - The vertices to interleave and buffer.
         * @param {VertexBuffer} spec.vertexBuffer - An existing vertex buffer.
         * @param {VertexBuffer[]} spec.vertexBuffers - Multiple existing vertex buffers.
         * @param {Array|Uint16Array|Uint32Array} spec.indices - The indices to buffer.
         * @param {IndexBuffer} spec.indexbuffer - An existing index buffer.
         */
        constructor(spec = {}) {
            if (spec.vertexBuffer || spec.vertexBuffers) {
                // use existing vertex buffer
                this.vertexBuffers = spec.vertexBuffers || [spec.vertexBuffer];
            } else if (spec.vertices) {
                // create vertex package
                let vertexPackage = new VertexPackage(spec.vertices);
                // create vertex buffer
                this.vertexBuffers = [new VertexBuffer(vertexPackage)];
            } else {
                this.vertexBuffers = [];
            }
            if (spec.indexBuffer) {
                // use existing index buffer
                this.indexBuffer = spec.indexBuffer;
            } else if (spec.indices) {
                // create index buffer
                this.indexBuffer = new IndexBuffer(spec.indices);
            } else {
                this.indexBuffer = null;
            }
            // if there is no index buffer, check that vertex buffers all have
            // the same count
            if (!this.indexBuffer) {
                checkVertexBufferCounts(this.vertexBuffers);
            }
            // check that no attribute indices clash
            checkIndexCollisions(this.vertexBuffers);
        }

        /**
         * Execute the draw command for the underlying buffers.
         *
         * @param {Object} options - The options to pass to 'drawElements'. Optional.
         * @param {String} options.mode - The draw mode / primitive type.
         * @param {String} options.byteOffset - The byteOffset into the drawn buffer.
         * @param {String} options.indexOffset - The indexOffset into the drawn buffer.
         * @param {String} options.count - The number of vertices to draw.
         *
         * @return {Renderable} - The renderable object, for chaining.
         */
        draw(options = {}) {
            // draw the renderable
            if (this.indexBuffer) {
                // use index buffer to draw elements
                // bind vertex buffers and enable attribute pointers
                this.vertexBuffers.forEach(vertexBuffer => {
                    vertexBuffer.bind();
                });
                // draw primitives using index buffer
                this.indexBuffer.draw(options);
                // disable attribute pointers
                this.vertexBuffers.forEach(vertexBuffer => {
                    vertexBuffer.unbind();
                });
                // no advantage to unbinding as there is no stack used
            } else {
                // no index buffer, use draw arrays
                // set all attribute pointers
                this.vertexBuffers.forEach(vertexBuffer => {
                    vertexBuffer.bind();
                });
                if (this.vertexBuffers.length > 0) {
                    // draw the buffer
                    this.vertexBuffers[0].draw(options);
                }
                // disable all attribute pointers
                this.vertexBuffers.forEach(vertexBuffer => {
                    vertexBuffer.unbind();
                });
            }
            return this;
        }
    }

    module.exports = Renderable;

}());

},{"../core/IndexBuffer":39,"../core/VertexBuffer":46,"../core/VertexPackage":47}],42:[function(require,module,exports){
(function () {

    'use strict';

    let WebGLContext = require('./WebGLContext');
    let ShaderParser = require('./ShaderParser');
    let Async = require('../util/Async');
    let XHRLoader = require('../util/XHRLoader');

    let UNIFORM_FUNCTIONS = {
        'bool': 'uniform1i',
        'bool[]': 'uniform1iv',
        'float': 'uniform1f',
        'float[]': 'uniform1fv',
        'int': 'uniform1i',
        'int[]': 'uniform1iv',
        'uint': 'uniform1i',
        'uint[]': 'uniform1iv',
        'vec2': 'uniform2fv',
        'vec2[]': 'uniform2fv',
        'ivec2': 'uniform2iv',
        'ivec2[]': 'uniform2iv',
        'vec3': 'uniform3fv',
        'vec3[]': 'uniform3fv',
        'ivec3': 'uniform3iv',
        'ivec3[]': 'uniform3iv',
        'vec4': 'uniform4fv',
        'vec4[]': 'uniform4fv',
        'ivec4': 'uniform4iv',
        'ivec4[]': 'uniform4iv',
        'mat2': 'uniformMatrix2fv',
        'mat2[]': 'uniformMatrix2fv',
        'mat3': 'uniformMatrix3fv',
        'mat3[]': 'uniformMatrix3fv',
        'mat4': 'uniformMatrix4fv',
        'mat4[]': 'uniformMatrix4fv',
        'sampler2D': 'uniform1i',
        'samplerCube': 'uniform1i'
    };

    /**
     * Given a map of existing attributes, find the lowest index that is not
     * already used. If the attribute ordering was already provided, use that
     * instead.
     * @private
     *
     * @param {Object} attributes - The existing attributes object.
     * @param {Object} declaration - The attribute declaration object.
     *
     * @return {Number} The attribute index.
     */
    function getAttributeIndex(attributes, declaration) {
        // check if attribute is already declared, if so, use that index
        if (attributes[declaration.name]) {
            return attributes[declaration.name].index;
        }
        // return next available index
        return Object.keys(attributes).length;
    }

    /**
     * Given vertex and fragment shader source, parses the declarations and appends information pertaining to the uniforms and attribtues declared.
     * @private
     *
     * @param {Shader} shader - The shader object.
     * @param {String} vertSource - The vertex shader source.
     * @param {String} fragSource - The fragment shader source.
     *
     * @return {Object} The attribute and uniform information.
     */
    function setAttributesAndUniforms(shader, vertSource, fragSource) {
        let declarations = ShaderParser.parseDeclarations(
            [vertSource, fragSource],
            ['uniform', 'attribute']);
        // for each declaration in the shader
        declarations.forEach(declaration => {
            // check if its an attribute or uniform
            if (declaration.qualifier === 'attribute') {
                // if attribute, store type and index
                let index = getAttributeIndex(shader.attributes, declaration);
                shader.attributes[declaration.name] = {
                    type: declaration.type,
                    index: index
                };
            } else { // if (declaration.qualifier === 'uniform') {
                // if uniform, store type and buffer function name
                shader.uniforms[declaration.name] = {
                    type: declaration.type,
                    func: UNIFORM_FUNCTIONS[declaration.type + (declaration.count > 1 ? '[]' : '')]
                };
            }
        });
    }

    /**
     * Given a shader source string and shader type, compiles the shader and returns the resulting WebGLShader object.
     * @private
     *
     * @param {WebGLRenderingContext} gl - The webgl rendering context.
     * @param {String} shaderSource - The shader source.
     * @param {String} type - The shader type.
     *
     * @return {WebGLShader} The compiled shader object.
     */
    function compileShader(gl, shaderSource, type) {
        let shader = gl.createShader(gl[type]);
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            throw 'An error occurred compiling the shaders:\n' + gl.getShaderInfoLog(shader);
        }
        return shader;
    }

    /**
     * Binds the attribute locations for the Shader object.
     * @private
     *
     * @param {Shader} shader - The Shader object.
     */
    function bindAttributeLocations(shader) {
        let gl = shader.gl;
        let attributes = shader.attributes;
        Object.keys(attributes).forEach(key => {
            // bind the attribute location
            gl.bindAttribLocation(
                shader.program,
                attributes[key].index,
                key);
        });
    }

    /**
     * Queries the webgl rendering context for the uniform locations.
     * @private
     *
     * @param {Shader} shader - The Shader object.
     */
    function getUniformLocations(shader) {
        let gl = shader.gl;
        let uniforms = shader.uniforms;
        Object.keys(uniforms).forEach(key => {
            // get the uniform location
            let location = gl.getUniformLocation(shader.program, key);
            // check if null, parse may detect uniform that is compiled out
            // due to a preprocessor evaluation.
            // TODO: fix parser so that it evaluates these correctly.
            if (location === null) {
                delete uniforms[key];
            } else {
                uniforms[key].location = location;
            }
        });
    }

    /**
     * Returns a function to load shader source from a url.
     * @private
     *
     * @param {String} url - The url to load the resource from.
     *
     * @return {Function} The function to load the shader source.
     */
    function loadShaderSource(url) {
        return function(done) {
            XHRLoader.load({
                url: url,
                responseType: 'text',
                success: function(res) {
                    done(null, res);
                },
                error: function(err) {
                    done(err, null);
                }
            });
        };
    }

    /**
     * Returns a function to pass through the shader source.
     * @private
     *
     * @param {String} source - The source of the shader.
     *
     * @return {Function} The function to pass through the shader source.
     */
    function passThroughSource(source) {
        return function(done) {
            done(null, source);
        };
    }

    /**
     * Returns a function that takes an array of GLSL source strings and URLs, and resolves them into and array of GLSL source.
     * @private
     *
     * @param {Array} sources - The shader sources.
     *
     * @return {Function} A function to resolve the shader sources.
     */
    function resolveSources(sources) {
        return function(done) {
            let tasks = [];
            sources = sources || [];
            sources = !Array.isArray(sources) ? [sources] : sources;
            sources.forEach(source => {
                if (ShaderParser.isGLSL(source)) {
                    tasks.push(passThroughSource(source));
                } else {
                    tasks.push(loadShaderSource(source));
                }
            });
            Async.parallel(tasks, done);
        };
    }

    /**
     * Creates the shader program object from source strings. This includes:
     *    1) Compiling and linking the shader program.
     *    2) Parsing shader source for attribute and uniform information.
     *    3) Binding attribute locations, by order of delcaration.
     *    4) Querying and storing uniform location.
     * @private
     *
     * @param {Shader} shader - The Shader object.
     * @param {Object} sources - A map containing sources under 'vert' and 'frag' attributes.
     *
     * @return {Shader} The shader object, for chaining.
     */
    function createProgram(shader, sources) {
        let gl = shader.gl;
        let common = sources.common.join('');
        let vert = sources.vert.join('');
        let frag = sources.frag.join('');
        // compile shaders
        let vertexShader = compileShader(gl, common + vert, 'VERTEX_SHADER');
        let fragmentShader = compileShader(gl, common + frag, 'FRAGMENT_SHADER');
        // parse source for attribute and uniforms
        setAttributesAndUniforms(shader, vert, frag);
        // create the shader program
        shader.program = gl.createProgram();
        // attach vertex and fragment shaders
        gl.attachShader(shader.program, vertexShader);
        gl.attachShader(shader.program, fragmentShader);
        // bind vertex attribute locations BEFORE linking
        bindAttributeLocations(shader);
        // link shader
        gl.linkProgram(shader.program);
        // If creating the shader program failed, alert
        if (!gl.getProgramParameter(shader.program, gl.LINK_STATUS)) {
            throw 'An error occured linking the shader:\n' + gl.getProgramInfoLog(shader.program);
        }
        // get shader uniform locations
        getUniformLocations(shader);
    }

    /**
     * @class Shader
     * @classdesc A shader class to assist in compiling and linking webgl shaders, storing attribute and uniform locations, and buffering uniforms.
     */
    class Shader {

        /**
         * Instantiates a Shader object.
         *
         * @param {Object} spec - The shader specification object.
         * @param {String|String[]|Object} spec.common - Sources / URLs to be shared by both vertex and fragment shaders.
         * @param {String|String[]|Object} spec.vert - The vertex shader sources / URLs.
         * @param {String|String[]|Object} spec.frag - The fragment shader sources / URLs.
         * @param {String[]} spec.attributes - The attribute index orderings.
         * @param {Function} callback - The callback function to execute once the shader has been successfully compiled and linked.
         */
        constructor(spec = {}, callback = null) {
            // check source arguments
            if (!spec.vert) {
                throw 'Vertex shader argument `vert` has not been provided';
            }
            if (!spec.frag) {
                throw 'Fragment shader argument `frag` has not been provided';
            }
            this.program = 0;
            this.gl = WebGLContext.get();
            this.version = spec.version || '1.00';
            this.attributes = {};
            this.uniforms = {};
            // if attribute ordering is provided, use those indices
            if (spec.attributes) {
                spec.attributes.forEach((attr, index) => {
                    this.attributes[attr] = {
                        index: index
                    };
                });
            }
            // create the shader
            Async.parallel({
                common: resolveSources(spec.common),
                vert: resolveSources(spec.vert),
                frag: resolveSources(spec.frag),
            }, (err, sources) => {
                if (err) {
                    if (callback) {
                        setTimeout(() => {
                            callback(err, null);
                        });
                    }
                    return;
                }
                // once all shader sources are loaded
                createProgram(this, sources);
                if (callback) {
                    setTimeout(() => {
                        callback(null, this);
                    });
                }
            });
        }

        /**
         * Binds the shader program for use.
         *
         * @return {Shader} The shader object, for chaining.
         */
        use() {
            // use the shader
            this.gl.useProgram(this.program);
            return this;
        }

        /**
         * Buffer a uniform value by name.
         *
         * @param {String} name - The uniform name in the shader source.
         * @param {*} value - The uniform value to buffer.
         *
         * @return {Shader} - The shader object, for chaining.
         */
        setUniform(name, value) {
            let uniform = this.uniforms[name];
            // ensure that the uniform spec exists for the name
            if (!uniform) {
                throw `No uniform found under name \`${name}\``;
            }
            // check value
            if (value === undefined || value === null) {
                // ensure that the uniform argument is defined
                throw `Value passed for uniform \`${name}\` is undefined or null`;
            } else if (typeof value === 'boolean') {
                // convert boolean's to 0 or 1
                // TODO: is this necessary?
                value = value ? 1 : 0;
            }
            // pass the arguments depending on the type
            // TODO: remove string comparions from here...
            if (uniform.type === 'mat2' || uniform.type === 'mat3' || uniform.type === 'mat4') {
                this.gl[uniform.func](uniform.location, false, value);
            } else {
                this.gl[uniform.func](uniform.location, value);
            }
            return this;
        }

        /**
         * Buffer a map of uniform values.
         *
         * @param {Object} uniforms - The map of uniforms keyed by name.
         *
         * @return {Shader} The shader object, for chaining.
         */
        setUniforms(args) {
            Object.keys(args).forEach(name => {
                this.setUniform(name, args[name]);
            });
            return this;
        }
    }

    module.exports = Shader;

}());

},{"../util/Async":51,"../util/XHRLoader":54,"./ShaderParser":43,"./WebGLContext":49}],43:[function(require,module,exports){
(function () {

    'use strict';

    let COMMENTS_REGEXP = /(\/\*([\s\S]*?)\*\/)|(\/\/(.*)$)/gm;
    let ENDLINE_REGEXP = /(\r\n|\n|\r)/gm;
    let WHITESPACE_REGEXP = /\s{2,}/g;
    let BRACKET_WHITESPACE_REGEXP = /(\s*)(\[)(\s*)(\d+)(\s*)(\])(\s*)/g;
    let NAME_COUNT_REGEXP = /([a-zA-Z_][a-zA-Z0-9_]*)(?:\[(\d+)\])?/;
    let PRECISION_REGEX = /\bprecision\s+\w+\s+\w+;/g;
    let INLINE_PRECISION_REGEX = /\b(highp|mediump|lowp)\s+/g;
    let GLSL_REGEXP = /void\s+main\s*\(\s*(void)*\s*\)\s*/mi;
    let PREP_REGEXP = /#([\W\w\s\d])(?:.*\\r?\n)*.*$/gm;

    /**
     * Removes standard comments from the provided string.
     * @private
     *
     * @param {String} str - The string to strip comments from.
     *
     * @return {String} The commentless string.
     */
    function stripComments(str) {
        // regex source: https://github.com/moagrius/stripcomments
        return str.replace(COMMENTS_REGEXP, '');
    }

    /**
     * Removes an precision statements.
     * @private
     *
     * @param {String} source - The unprocessed source code.
     *
     * @return {String} The processed source code.
     */
    function stripPrecision(source) {
        // remove global precision declarations
        source = source.replace(PRECISION_REGEX, '');
        // remove inline precision declarations
        return source.replace(INLINE_PRECISION_REGEX, '');
    }

    /**
     * Converts all whitespace into a single ' ' space character.
     * @private
     *
     * @param {String} str - The string to normalize whitespace from.
     *
     * @return {String} The normalized string.
     */
    function normalizeWhitespace(str) {
        return str.replace(ENDLINE_REGEXP, ' ') // remove line endings
            .replace(WHITESPACE_REGEXP, ' ') // normalize whitespace to single ' '
            .replace(BRACKET_WHITESPACE_REGEXP, '$2$4$6'); // remove whitespace in brackets
    }

    /**
     * Parses the name and count out of a name statement, returning the declaration object.
     * @private
     *
     * @param {String} qualifier - The qualifier string.
     * @param {String} type - The type string.
     * @param {String} entry - The variable declaration string.
     *
     * @return {Object} The declaration object.
     */
    function parseNameAndCount(qualifier, type, entry) {
        // determine name and size of variable
        let matches = entry.match(NAME_COUNT_REGEXP);
        let name = matches[1];
        let count = (matches[2] === undefined) ? 1 : parseInt(matches[2], 10);
        return {
            qualifier: qualifier,
            type: type,
            name: name,
            count: count
        };
    }

    /**
     * Parses a single 'statement'. A 'statement' is considered any sequence of
     * characters followed by a semi-colon. Therefore, a single 'statement' in
     * this sense could contain several comma separated declarations. Returns
     * all resulting declarations.
     * @private
     *
     * @param {String} statement - The statement to parse.
     *
     * @return {Array} The array of parsed declaration objects.
     */
    function parseStatement(statement) {
        // split statement on commas
        //
        // ['uniform mat4 A[10]', 'B', 'C[2]']
        //
        let split = statement.split(',').map(elem => {
            return elem.trim();
        });

        // split declaration header from statement
        //
        // ['uniform', 'mat4', 'A[10]']
        //
        let header = split.shift().split(' ');

        // qualifier is always first element
        //
        // 'uniform'
        //
        let qualifier = header.shift();

        // type will be the second element
        //
        // 'mat4'
        //
        let type = header.shift();

        // last part of header will be the first, and possible only variable name
        //
        // ['A[10]', 'B', 'C[2]']
        //
        let names = header.concat(split);

        // if there are other names after a ',' add them as well
        return names.map(name => {
            return parseNameAndCount(qualifier, type, name);
        });
    }

    /**
     * Splits the source string by semi-colons and constructs an array of
     * declaration objects based on the provided qualifier keywords.
     * @private
     *
     * @param {String} source - The shader source string.
     * @param {String|Array} keywords - The qualifier declaration keywords.
     *
     * @return {Array} The array of qualifier declaration objects.
     */
    function parseSource(source, keywords) {
        // get individual statements (any sequence ending in ;)
        let statements = source.split(';');
        // build regex for parsing statements with targetted keywords
        let keywordStr = keywords.join('|');
        let keywordRegex = new RegExp('\\b(' + keywordStr + ')\\b.*');
        // parse and store global precision statements and any declarations
        let matched = [];
        // for each statement
        statements.forEach(statement => {
            // check for keywords
            //
            // ['uniform float uTime']
            //
            let kmatch = statement.match(keywordRegex);
            if (kmatch) {
                // parse statement and add to array
                matched = matched.concat(parseStatement(kmatch[0]));
            }
        });
        return matched;
    }

    /**
     * Filters out duplicate declarations present between shaders. Currently
     * just removes all # statements.
     * @private
     *
     * @param {Array} declarations - The array of declarations.
     *
     * @return {Array} The filtered array of declarations.
     */
    function filterDuplicatesByName(declarations) {
        // in cases where the same declarations are present in multiple
        // sources, this function will remove duplicates from the results
        let seen = {};
        return declarations.filter(declaration => {
            if (seen[declaration.name]) {
                return false;
            }
            seen[declaration.name] = true;
            return true;
        });
    }

    /**
     * Runs the preprocessor on the glsl code.
     * @private
     *
     * @param {String} source - The unprocessed source code.
     *
     * @return {String} The processed source code.
     */
    function preprocess(source) {
        // TODO: implement this correctly...
        return source.replace(PREP_REGEXP, '');
    }

    module.exports = {

        /**
         * Parses the provided GLSL source, and returns all declaration statements that contain the provided qualifier type. This can be used to extract all attributes and uniform names and types from a shader.
         *
         * For example, when provided a 'uniform' qualifiers, the declaration:
         *
         *     'uniform highp vec3 uSpecularColor;'
         *
         * Would be parsed to:
         *     {
         *         qualifier: 'uniform',
         *         type: 'vec3',
         *         name: 'uSpecularColor',
         *         count: 1
         *     }
         * @param {Array} sources - The shader sources.
         * @param {Array} qualifiers - The qualifiers to extract.
         *
         * @return {Array} The array of qualifier declaration statements.
         */
        parseDeclarations: function(sources = [], qualifiers = []) {
            // if no sources or qualifiers are provided, return empty array
            if (sources.length === 0 || qualifiers.length === 0) {
                return [];
            }
            sources = Array.isArray(sources) ? sources : [sources];
            qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
            // parse out targetted declarations
            let declarations = [];
            sources.forEach(source => {
                // run preprocessor
                source = preprocess(source);
                // remove precision statements
                source = stripPrecision(source);
                // remove comments
                source = stripComments(source);
                // finally, normalize the whitespace
                source = normalizeWhitespace(source);
                // parse out declarations
                declarations = declarations.concat(parseSource(source, qualifiers));
            });
            // remove duplicates and return
            return filterDuplicatesByName(declarations);
        },

        /**
         * Detects based on the existence of a 'void main() {' statement, if the string is glsl source code.
         *
         * @param {String} str - The input string to test.
         *
         * @return {boolean} Whether or not the string is glsl code.
         */
        isGLSL: function(str) {
            return GLSL_REGEXP.test(str);
        }

    };

}());

},{}],44:[function(require,module,exports){
(function () {

    'use strict';

    let WebGLContext = require('./WebGLContext');
    let Util = require('../util/Util');

    let MAG_FILTERS = {
        NEAREST: true,
        LINEAR: true
    };
    let MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true,
        NEAREST_MIPMAP_NEAREST: true,
        LINEAR_MIPMAP_NEAREST: true,
        NEAREST_MIPMAP_LINEAR: true,
        LINEAR_MIPMAP_LINEAR: true
    };
    let NON_MIPMAP_MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true,
    };
    let MIPMAP_MIN_FILTERS = {
        NEAREST_MIPMAP_NEAREST: true,
        LINEAR_MIPMAP_NEAREST: true,
        NEAREST_MIPMAP_LINEAR: true,
        LINEAR_MIPMAP_LINEAR: true
    };
    let WRAP_MODES = {
        REPEAT: true,
        MIRRORED_REPEAT: true,
        CLAMP_TO_EDGE: true
    };
    let DEPTH_TYPES = {
        DEPTH_COMPONENT: true,
        DEPTH_STENCIL: true
    };

    /**
     * The default type for textures.
     */
    let DEFAULT_TYPE = 'UNSIGNED_BYTE';

    /**
     * The default format for textures.
     */
    let DEFAULT_FORMAT = 'RGBA';

    /**
     * The default wrap mode for textures.
     */
    let DEFAULT_WRAP = 'REPEAT';

    /**
     * The default min / mag filter for textures.
     */
    let DEFAULT_FILTER = 'LINEAR';

    /**
     * The default for whether alpha premultiplying is enabled.
     */
    let DEFAULT_PREMULTIPLY_ALPHA = true;

    /**
     * The default for whether mipmapping is enabled.
     */
    let DEFAULT_MIPMAP = true;

    /**
     * The default for whether invert-y is enabled.
     */
    let DEFAULT_INVERT_Y = true;

    /**
     * The default mip-mapping filter suffix.
     */
    let DEFAULT_MIPMAP_MIN_FILTER_SUFFIX = '_MIPMAP_LINEAR';

    /**
     * @class Texture2D
     * @classdesc A texture class to represent a 2D texture.
     */
    class Texture2D {

        /**
         * Instantiates a Texture2D object.
         *
         * @param {Uint8Array|Uint16Array|Uint32Array|Float32Array|ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} spec.src - The data to buffer.
         * @param {Number} spec.width - The width of the texture.
         * @param {Number} spec.height - The height of the texture.
         * @param {String} spec.wrap - The wrapping type over both S and T dimension.
         * @param {String} spec.wrapS - The wrapping type over the S dimension.
         * @param {String} spec.wrapT - The wrapping type over the T dimension.
         * @param {String} spec.filter - The min / mag filter used during scaling.
         * @param {String} spec.minFilter - The minification filter used during scaling.
         * @param {String} spec.magFilter - The magnification filter used during scaling.
         * @param {bool} spec.mipMap - Whether or not mip-mapping is enabled.
         * @param {bool} spec.invertY - Whether or not invert-y is enabled.
         * @param {bool} spec.preMultiplyAlpha - Whether or not alpha premultiplying is enabled.
         * @param {String} spec.format - The texture pixel format.
         * @param {String} spec.type - The texture pixel component type.
         */
        constructor(spec = {}) {
            // get specific params
            spec.wrapS = spec.wrapS || spec.wrap;
            spec.wrapT = spec.wrapT || spec.wrap;
            spec.minFilter = spec.minFilter || spec.filter;
            spec.magFilter = spec.magFilter || spec.filter;
            // set context
            this.gl = WebGLContext.get();
            // empty texture
            this.texture = null;
            // set texture params
            this.wrapS = spec.wrapS || DEFAULT_WRAP;
            this.wrapT = spec.wrapT || DEFAULT_WRAP;
            this.minFilter = spec.minFilter || DEFAULT_FILTER;
            this.magFilter = spec.magFilter || DEFAULT_FILTER;
            // set other properties
            this.mipMap = spec.mipMap !== undefined ? spec.mipMap : DEFAULT_MIPMAP;
            this.invertY = spec.invertY !== undefined ? spec.invertY : DEFAULT_INVERT_Y;
            this.preMultiplyAlpha = spec.preMultiplyAlpha !== undefined ? spec.preMultiplyAlpha : DEFAULT_PREMULTIPLY_ALPHA;
            // set format
            this.format = spec.format || DEFAULT_FORMAT;
            if (DEPTH_TYPES[this.format] && !WebGLContext.checkExtension('WEBGL_depth_texture')) {
                throw `Cannot create Texture2D of format \`${this.format}\` as \`WEBGL_depth_texture\` extension is unsupported`;
            }
            // set type
            this.type = spec.type || DEFAULT_TYPE;
            if (this.type === 'FLOAT' && !WebGLContext.checkExtension('OES_texture_float')) {
                throw `Cannot create Texture2D of type \`FLOAT\` as \`OES_texture_float\` extension is unsupported`;
            }
            // url will not be resolved yet, so don't buffer in that case
            if (typeof spec.src !== 'string') {
                // check size
                if (!Util.isCanvasType(spec.src)) {
                    // if not a canvas type, dimensions MUST be specified
                    if (typeof spec.width !== 'number' || spec.width <= 0) {
                        throw '`width` argument is missing or invalid';
                    }
                    if (typeof spec.height !== 'number' || spec.height <= 0) {
                        throw '`height` argument is missing or invalid';
                    }
                    if (Util.mustBePowerOfTwo(this)) {
                        if (!Util.isPowerOfTwo(spec.width)) {
                            throw `Parameters require a power-of-two texture, yet provided width of \`${spec.width}\` is not a power of two`;
                        }
                        if (!Util.isPowerOfTwo(spec.height)) {
                            throw `Parameters require a power-of-two texture, yet provided height of \`${spec.height}\` is not a power of two`;
                        }
                    }
                }
                // buffer the data
                this.bufferData(spec.src || null, spec.width, spec.height);
                this.setParameters(this);
            }
        }

        /**
         * Binds the texture object to the provided texture unit location.
         *
         * @param {Number} location - The texture unit location index. Defaults to 0.
         *
         * @return {Texture2D} The texture object, for chaining.
         */
        bind(location = 0) {
            if (!Number.isInteger(location) || location < 0) {
                throw `Texture unit location is invalid`;
            }
            // bind texture
            let gl = this.gl;
            gl.activeTexture(gl['TEXTURE' + location]);
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            return this;
        }

        /**
         * Unbinds the texture object.
         *
         * @return {Texture2D} The texture object, for chaining.
         */
        unbind() {
            // unbind texture
            let gl = this.gl;
            gl.bindTexture(gl.TEXTURE_2D, null);
            return this;
        }

        /**
         * Buffer data into the texture.
         *
         * @param {Array|ArrayBufferView|null} data - The data array to buffer.
         * @param {Number} width - The width of the data.
         * @param {Number} height - The height of the data.
         *
         * @return {Texture2D} The texture object, for chaining.
         */
        bufferData(data, width, height) {
            let gl = this.gl;
            // create texture object if it doesn't already exist
            if (!this.texture) {
                this.texture = gl.createTexture();
            }
            // bind texture
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            // invert y if specified
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.invertY);
            // premultiply alpha if specified
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.preMultiplyAlpha);
            // cast array arg
            if (Array.isArray(data)) {
                if (this.type === 'UNSIGNED_SHORT') {
                    data = new Uint16Array(data);
                } else if (this.type === 'UNSIGNED_INT') {
                    data = new Uint32Array(data);
                } else if (this.type === 'FLOAT') {
                    data = new Float32Array(data);
                } else {
                    data = new Uint8Array(data);
                }
            }
            // set ensure type corresponds to data
            if (data instanceof Uint8Array) {
                this.type = 'UNSIGNED_BYTE';
            } else if (data instanceof Uint16Array) {
                this.type = 'UNSIGNED_SHORT';
            } else if (data instanceof Uint32Array) {
                this.type = 'UNSIGNED_INT';
            } else if (data instanceof Float32Array) {
                this.type = 'FLOAT';
            } else if (data && !(data instanceof ArrayBuffer) && !Util.isCanvasType(data)) {
                throw 'Argument must be of type `Array`, `ArrayBuffer`, ' +
                    '`ArrayBufferView`, `ImageData`, `HTMLImageElement`, ' +
                    '`HTMLCanvasElement`, `HTMLVideoElement`, or null';
            }
            if (Util.isCanvasType(data)) {
                // store width and height
                this.width = data.width;
                this.height = data.height;
                // buffer the texture
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0, // mip-map level,
                    gl[this.format], // webgl requires format === internalFormat
                    gl[this.format],
                    gl[this.type],
                    data);
            } else {
                // store width and height
                this.width = width || this.width;
                this.height = height || this.height;
                // buffer the texture data
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0, // mip-map level
                    gl[this.format], // webgl requires format === internalFormat
                    this.width,
                    this.height,
                    0, // border, must be 0
                    gl[this.format],
                    gl[this.type],
                    data);
            }
            // generate mip maps
            if (this.mipMap) {
                gl.generateMipmap(gl.TEXTURE_2D);
            }
            // unbind texture
            gl.bindTexture(gl.TEXTURE_2D, null);
            return this;
        }

        /**
         * Set the texture parameters.
         *
         * @param {Object} params - The parameters by name.
         * @param {String} params.wrap - The wrapping type over both S and T dimension.
         * @param {String} params.wrapS - The wrapping type over the S dimension.
         * @param {String} params.wrapT - The wrapping type over the T dimension.
         * @param {String} params.filter - The min / mag filter used during scaling.
         * @param {String} params.minFilter - The minification filter used during scaling.
         * @param {String} params.magFilter - The magnification filter used during scaling.
         *
         * @return {Texture2D} The texture object, for chaining.
         */
        setParameters(params) {
            let gl = this.gl;
            // bind texture
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            // set wrap S parameter
            let param = params.wrapS || params.wrap;
            if (param) {
                if (WRAP_MODES[param]) {
                    this.wrapS = param;
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl[this.wrapS]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_WRAP_S\``;
                }
            }
            // set wrap T parameter
            param = params.wrapT || params.wrap;
            if (param) {
                if (WRAP_MODES[param]) {
                    this.wrapT = param;
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl[this.wrapT]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_WRAP_T\``;
                }
            }
            // set mag filter parameter
            param = params.magFilter || params.filter;
            if (param) {
                if (MAG_FILTERS[param]) {
                    this.magFilter = param;
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl[this.magFilter]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for 'TEXTURE_MAG_FILTER\``;
                }
            }
            // set min filter parameter
            param = params.minFilter || params.filter;
            if (param) {
                if (this.mipMap) {
                    if (NON_MIPMAP_MIN_FILTERS[param]) {
                        // upgrade to mip-map min filter
                        param += DEFAULT_MIPMAP_MIN_FILTER_SUFFIX;
                    }
                    if (MIPMAP_MIN_FILTERS[param]) {
                        this.minFilter = param;
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl[this.minFilter]);
                    } else  {
                        throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_MIN_FILTER\``;
                    }
                } else {
                    if (MIN_FILTERS[param]) {
                        this.minFilter = param;
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl[this.minFilter]);
                    } else {
                        throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_MIN_FILTER\``;
                    }
                }
            }
            // unbind texture
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            return this;
        }

        /**
         * Resize the underlying texture. This clears the texture data.
         *
         * @param {Number} width - The new width of the texture.
         * @param {Number} height - The new height of the texture.
         *
         * @return {Texture2D} The texture object, for chaining.
         */
        resize(width, height) {
            if (typeof width !== 'number' || (width <= 0)) {
                throw `Provided width of \`${width}\` is invalid`;
            }
            if (typeof height !== 'number' || (height <= 0)) {
                throw `Provided height of \`${height}\` is invalid`;
            }
            this.bufferData(null, width, height);
            return this;
        }
    }

    module.exports = Texture2D;

}());

},{"../util/Util":53,"./WebGLContext":49}],45:[function(require,module,exports){
(function () {

    'use strict';

    let WebGLContext = require('./WebGLContext');
    let Async = require('../util/Async');
    let Util = require('../util/Util');
    let ImageLoader = require('../util/ImageLoader');

    let FACES = [
        '-x', '+x',
        '-y', '+y',
        '-z', '+z'
    ];
    let FACE_TARGETS = {
        '+z': 'TEXTURE_CUBE_MAP_POSITIVE_Z',
        '-z': 'TEXTURE_CUBE_MAP_NEGATIVE_Z',
        '+x': 'TEXTURE_CUBE_MAP_POSITIVE_X',
        '-x': 'TEXTURE_CUBE_MAP_NEGATIVE_X',
        '+y': 'TEXTURE_CUBE_MAP_POSITIVE_Y',
        '-y': 'TEXTURE_CUBE_MAP_NEGATIVE_Y'
    };
    let TARGETS = {
        TEXTURE_CUBE_MAP_POSITIVE_Z: true,
        TEXTURE_CUBE_MAP_NEGATIVE_Z: true,
        TEXTURE_CUBE_MAP_POSITIVE_X: true,
        TEXTURE_CUBE_MAP_NEGATIVE_X: true,
        TEXTURE_CUBE_MAP_POSITIVE_Y: true,
        TEXTURE_CUBE_MAP_NEGATIVE_Y: true
    };
    let MAG_FILTERS = {
        NEAREST: true,
        LINEAR: true
    };
    let MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true,
        NEAREST_MIPMAP_NEAREST: true,
        LINEAR_MIPMAP_NEAREST: true,
        NEAREST_MIPMAP_LINEAR: true,
        LINEAR_MIPMAP_LINEAR: true
    };
    let NON_MIPMAP_MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true,
    };
    let MIPMAP_MIN_FILTERS = {
        NEAREST_MIPMAP_NEAREST: true,
        LINEAR_MIPMAP_NEAREST: true,
        NEAREST_MIPMAP_LINEAR: true,
        LINEAR_MIPMAP_LINEAR: true
    };
    let WRAP_MODES = {
        REPEAT: true,
        MIRRORED_REPEAT: true,
        CLAMP_TO_EDGE: true
    };
    let FORMATS = {
        RGB: true,
        RGBA: true
    };

    /**
     * The default type for textures.
     */
    let DEFAULT_TYPE = 'UNSIGNED_BYTE';

    /**
     * The default format for textures.
     */
    let DEFAULT_FORMAT = 'RGBA';

    /**
     * The default wrap mode for textures.
     */
    let DEFAULT_WRAP = 'CLAMP_TO_EDGE';

    /**
     * The default min / mag filter for textures.
     */
    let DEFAULT_FILTER = 'LINEAR';

    /**
     * The default for whether alpha premultiplying is enabled.
     */
    let DEFAULT_PREMULTIPLY_ALPHA = true;

    /**
     * The default for whether mipmapping is enabled.
     */
    let DEFAULT_MIPMAP = true;

    /**
     * The default for whether invert-y is enabled.
     */
    let DEFAULT_INVERT_Y = true;

    /**
     * The default mip-mapping filter suffix.
     */
    let DEFAULT_MIPMAP_MIN_FILTER_SUFFIX = '_MIPMAP_LINEAR';

    /**
     * Checks the width and height of the cubemap and throws an exception if
     * it does not meet requirements.
     * @private
     *
     * @param {TextureCubeMap} cubeMap - The cube map texture object.
     */
    function checkDimensions(cubeMap) {
        if (typeof cubeMap.width !== 'number' || cubeMap.width <= 0) {
            throw '`width` argument is missing or invalid';
        }
        if (typeof cubeMap.height !== 'number' || cubeMap.height <= 0) {
            throw '`height` argument is missing or invalid';
        }
        if (cubeMap.width !== cubeMap.height) {
            throw 'Provided `width` must be equal to `height`';
        }
        if (Util.mustBePowerOfTwo(cubeMap) && !Util.isPowerOfTwo(cubeMap.width)) {
            throw `Parameters require a power-of-two texture, yet provided size of ${cubeMap.width} is not a power of two`;
        }
    }

    /**
     * Returns a function to load a face from a url.
     * @private
     *
     * @param {TextureCubeMap} cubeMap - The cube map texture object.
     * @param {String} target - The texture target.
     * @param {String} url - The url to load the face from.
     *
     * @return {Function} The loader function.
     */
    function loadFaceURL(cubeMap, target, url) {
        return function(done) {
            // TODO: put extension handling for arraybuffer / image / video differentiation
            ImageLoader.load({
                url: url,
                success: image => {
                    image = Util.resizeCanvas(cubeMap, image);
                    cubeMap.bufferData(target, image);
                    done(null);
                },
                error: err => {
                    done(err, null);
                }
            });
        };
    }

    /**
     * Returns a function to load a face from a canvas type object.
     * @private
     *
     * @param {TextureCubeMap} cubeMap - The cube map texture object.
     * @param {String} target - The texture target.
     * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} canvas - The canvas type object.
     *
     * @return {Function} - The loader function.
     */
    function loadFaceCanvas(cubeMap, target, canvas) {
        return function(done) {
            canvas = Util.resizeCanvas(cubeMap, canvas);
            cubeMap.bufferData(target, canvas);
            done(null);
        };
    }

    /**
     * Returns a function to load a face from an array type object.
     * @private
     *
     * @param {TextureCubeMap} cubeMap - The cube map texture object.
     * @param {String} target - The texture target.
     * @param {Array|ArrayBuffer|ArrayBufferView} arr - The array type object.
     *
     * @return {Function} The loader function.
     */
    function loadFaceArray(cubeMap, target, arr) {
        checkDimensions(cubeMap);
        return function(done) {
            cubeMap.bufferData(target, arr);
            done(null);
        };
    }

    /**
     * @class TextureCubeMap
     * @classdesc A texture class to represent a cube map texture.
     */
    class TextureCubeMap {

        /**
         * Instantiates a TextureCubeMap object.
         *
         * @param {Object} spec - The specification arguments
         * @param {Object} spec.faces - The faces to buffer, under keys '+x', '+y', '+z', '-x', '-y', and '-z'.
         * @param {Number} spec.width - The width of the faces.
         * @param {Number} spec.height - The height of the faces.
         * @param {String} spec.wrap - The wrapping type over both S and T dimension.
         * @param {String} spec.wrapS - The wrapping type over the S dimension.
         * @param {String} spec.wrapT - The wrapping type over the T dimension.
         * @param {String} spec.filter - The min / mag filter used during scaling.
         * @param {String} spec.minFilter - The minification filter used during scaling.
         * @param {String} spec.magFilter - The magnification filter used during scaling.
         * @param {bool} spec.mipMap - Whether or not mip-mapping is enabled.
         * @param {bool} spec.invertY - Whether or not invert-y is enabled.
         * @param {bool} spec.preMultiplyAlpha - Whether or not alpha premultiplying is enabled.
         * @param {String} spec.format - The texture pixel format.
         * @param {String} spec.type - The texture pixel component type.
         */
        constructor(spec = {}, callback = null) {
            this.gl = WebGLContext.get();
            this.texture = null;
            // get specific params
            spec.wrapS = spec.wrapS || spec.wrap;
            spec.wrapT = spec.wrapT || spec.wrap;
            spec.minFilter = spec.minFilter || spec.filter;
            spec.magFilter = spec.magFilter || spec.filter;
            // set texture params
            this.wrapS = WRAP_MODES[spec.wrapS] ? spec.wrapS : DEFAULT_WRAP;
            this.wrapT = WRAP_MODES[spec.wrapT] ? spec.wrapT : DEFAULT_WRAP;
            this.minFilter = MIN_FILTERS[spec.minFilter] ? spec.minFilter : DEFAULT_FILTER;
            this.magFilter = MAG_FILTERS[spec.magFilter] ? spec.magFilter : DEFAULT_FILTER;
            // set other properties
            this.mipMap = spec.mipMap !== undefined ? spec.mipMap : DEFAULT_MIPMAP;
            this.invertY = spec.invertY !== undefined ? spec.invertY : DEFAULT_INVERT_Y;
            this.preMultiplyAlpha = spec.preMultiplyAlpha !== undefined ? spec.preMultiplyAlpha : DEFAULT_PREMULTIPLY_ALPHA;
            // set format and type
            this.format = FORMATS[spec.format] ? spec.format : DEFAULT_FORMAT;
            this.type = spec.type || DEFAULT_TYPE;
            if (this.type === 'FLOAT' && !WebGLContext.checkExtension('OES_texture_float')) {
                throw 'Cannot create Texture2D of type `FLOAT` as `OES_texture_float` extension is unsupported';
            }
            // set dimensions if provided
            this.width = spec.width;
            this.height = spec.height;
            // set buffered faces
            this.bufferedFaces = [];
            // create cube map based on input
            if (spec.faces) {
                let tasks = [];
                FACES.forEach(id => {
                    let face = spec.faces[id];
                    let target = FACE_TARGETS[id];
                    // load based on type
                    if (typeof face === 'string') {
                        // url
                        tasks.push(loadFaceURL(this, target, face));
                    } else if (Util.isCanvasType(face)) {
                        // canvas
                        tasks.push(loadFaceCanvas(this, target, face));
                    } else {
                        // array / arraybuffer or null
                        tasks.push(loadFaceArray(this, target, face));
                    }
                });
                Async.parallel(tasks, err => {
                    if (err) {
                        if (callback) {
                            setTimeout(() => {
                                callback(err, null);
                            });
                        }
                        return;
                    }
                    // set parameters
                    this.setParameters(this);
                    if (callback) {
                        setTimeout(() => {
                            callback(null, this);
                        });
                    }
                });
            } else {
                // null
                checkDimensions(this);
                FACES.forEach(id => {
                    this.bufferData(FACE_TARGETS[id], null);
                });
                // set parameters
                this.setParameters(this);
            }
        }

        /**
         * Binds the texture object to the provided texture unit location.
         *
         * @param {Number} location - The texture unit location index. Defaults to 0.
         *
         * @return {TextureCubeMap} The texture object, for chaining.
         */
        bind(location = 0) {
            if (!Number.isInteger(location) || location < 0) {
                throw 'Texture unit location is invalid';
            }
            // bind cube map texture
            let gl = this.gl;
            gl.activeTexture(gl['TEXTURE' + location]);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
            return this;
        }

        /**
         * Unbinds the texture object.
         *
         * @return {TextureCubeMap} - The texture object, for chaining.
         */
        unbind() {
            // unbind cube map texture
            let gl = this.gl;
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            return this;
        }

        /**
         * Buffer data into the respective cube map face.
         *
         * @param {String} target - The face target.
         * @param {Object|null} data - The face data.
         *
         * @return {TextureCubeMap} The texture object, for chaining.
         */
        bufferData(target, data) {
            if (!TARGETS[target]) {
                throw `Provided \`target\` of ${target}  is invalid`;
            }
            let gl = this.gl;
            // create texture object if it doesn't already exist
            if (!this.texture) {
                this.texture = gl.createTexture();
            }
            // bind texture
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
            // invert y if specified
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.invertY);
            // premultiply alpha if specified
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.preMultiplyAlpha);
            // cast array arg
            if (Array.isArray(data)) {
                if (this.type === 'UNSIGNED_SHORT') {
                    data = new Uint16Array(data);
                } else if (this.type === 'UNSIGNED_INT') {
                    data = new Uint32Array(data);
                } else if (this.type === 'FLOAT') {
                    data = new Float32Array(data);
                } else {
                    data = new Uint8Array(data);
                }
            }
            // set ensure type corresponds to data
            if (data instanceof Uint8Array) {
                this.type = 'UNSIGNED_BYTE';
            } else if (data instanceof Uint16Array) {
                this.type = 'UNSIGNED_SHORT';
            } else if (data instanceof Uint32Array) {
                this.type = 'UNSIGNED_INT';
            } else if (data instanceof Float32Array) {
                this.type = 'FLOAT';
            } else if (data && !(data instanceof ArrayBuffer) && !Util.isCanvasType(data)) {
                throw 'Argument must be of type `Array`, `ArrayBuffer`, ' +
                    '`ArrayBufferView`, `ImageData`, `HTMLImageElement`, ' +
                    '`HTMLCanvasElement`, `HTMLVideoElement`, or null';
            }
            // buffer the data
            if (Util.isCanvasType(data)) {
                // store width and height
                this.width = data.width;
                this.height = data.height;
                // buffer the texture
                gl.texImage2D(
                    gl[target],
                    0, // mip-map level,
                    gl[this.format], // webgl requires format === internalFormat
                    gl[this.format],
                    gl[this.type],
                    data);
            } else {
                // buffer the texture data
                gl.texImage2D(
                    gl[target],
                    0, // mip-map level
                    gl[this.format], // webgl requires format === internalFormat
                    this.width,
                    this.height,
                    0, // border, must be 0
                    gl[this.format],
                    gl[this.type],
                    data);
            }
            // track the face that was buffered
            if (this.bufferedFaces.indexOf(target) < 0) {
                this.bufferedFaces.push(target);
            }
            // if all faces buffered, generate mipmaps
            if (this.mipMap && this.bufferedFaces.length === 6) {
                // only generate mipmaps if all faces are buffered
                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
            }
            // unbind texture
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            return this;
        }

        /**
         * Set the texture parameters.
         *
         * @param {Object} params - The parameters by name.
         * @param {String} params.wrap - The wrapping type over both S and T dimension.
         * @param {String} params.wrapS - The wrapping type over the S dimension.
         * @param {String} params.wrapT - The wrapping type over the T dimension.
         * @param {String} params.filter - The min / mag filter used during scaling.
         * @param {String} params.minFilter - The minification filter used during scaling.
         * @param {String} params.magFilter - The magnification filter used during scaling.
         *
         * @return {TextureCubeMap} The texture object, for chaining.
         */
        setParameters(params) {
            let gl = this.gl;
            // bind texture
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
            // set wrap S parameter
            let param = params.wrapS || params.wrap;
            if (param) {
                if (WRAP_MODES[param]) {
                    this.wrapS = param;
                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl[this.wrapS]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_WRAP_S\``;
                }
            }
            // set wrap T parameter
            param = params.wrapT || params.wrap;
            if (param) {
                if (WRAP_MODES[param]) {
                    this.wrapT = param;
                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl[this.wrapT]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_WRAP_T\``;
                }
            }
            // set mag filter parameter
            param = params.magFilter || params.filter;
            if (param) {
                if (MAG_FILTERS[param]) {
                    this.magFilter = param;
                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl[this.magFilter]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for 'TEXTURE_MAG_FILTER\``;
                }
            }
            // set min filter parameter
            param = params.minFilter || params.filter;
            if (param) {
                if (this.mipMap) {
                    if (NON_MIPMAP_MIN_FILTERS[param]) {
                        // upgrade to mip-map min filter
                        param += DEFAULT_MIPMAP_MIN_FILTER_SUFFIX;
                    }
                    if (MIPMAP_MIN_FILTERS[param]) {
                        this.minFilter = param;
                        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl[this.minFilter]);
                    } else  {
                        throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_MIN_FILTER\``;
                    }
                } else {
                    if (MIN_FILTERS[param]) {
                        this.minFilter = param;
                        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl[this.minFilter]);
                    } else {
                        throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_MIN_FILTER\``;
                    }
                }
            }
            // unbind texture
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            return this;
        }
    }

    module.exports = TextureCubeMap;

}());

},{"../util/Async":51,"../util/ImageLoader":52,"../util/Util":53,"./WebGLContext":49}],46:[function(require,module,exports){
(function () {

    'use strict';

    let WebGLContext = require('./WebGLContext');
    let VertexPackage = require('./VertexPackage');

    let MODES = {
        POINTS: true,
        LINES: true,
        LINE_STRIP: true,
        LINE_LOOP: true,
        TRIANGLES: true,
        TRIANGLE_STRIP: true,
        TRIANGLE_FAN: true
    };
    let TYPES = {
        BYTE: true,
        UNSIGNED_BYTE: true,
        SHORT: true,
        UNSIGNED_SHORT: true,
        FIXED: true,
        FLOAT: true
    };
    let BYTES_PER_TYPE = {
        BYTE: 1,
        UNSIGNED_BYTE: 1,
        SHORT: 2,
        UNSIGNED_SHORT: 2,
        FIXED: 4,
        FLOAT: 4
    };
    let SIZES = {
        1: true,
        2: true,
        3: true,
        4: true
    };

    /**
     * The default attribute point byte offset.
     */
    let DEFAULT_BYTE_OFFSET = 0;

    /**
     * The default render mode (primitive type).
     */
    let DEFAULT_MODE = 'TRIANGLES';

    /**
     * The default index offset to render from.
     */
    let DEFAULT_INDEX_OFFSET = 0;

    /**
     * The default count of indices to render.
     */
    let DEFAULT_COUNT = 0;

    /**
     * Parse the attribute pointers and determine the byte stride of the buffer.
     * @private
     *
     * @param {Object} attributePointers - The attribute pointer map.
     *
     * @return {Number} The byte stride of the buffer.
     */
    function getStride(attributePointers) {
        // if there is only one attribute pointer assigned to this buffer,
        // there is no need for stride, set to default of 0
        let indices = Object.keys(attributePointers);
        if (indices.length === 1) {
            return 0;
        }
        let maxByteOffset = 0;
        let byteSizeSum = 0;
        let byteStride = 0;
        indices.forEach(index => {
            let pointer = attributePointers[index];
            let byteOffset = pointer.byteOffset;
            let size = pointer.size;
            let type = pointer.type;
            // track the sum of each attribute size
            byteSizeSum += size * BYTES_PER_TYPE[type];
            // track the largest offset to determine the byte stride of the buffer
            if (byteOffset > maxByteOffset) {
                maxByteOffset = byteOffset;
                byteStride = byteOffset + (size * BYTES_PER_TYPE[type]);
            }
        });
        // check if the max byte offset is greater than or equal to the the sum of
        // the sizes. If so this buffer is not interleaved and does not need a
        // stride.
        if (maxByteOffset >= byteSizeSum) {
            // TODO: test what stride === 0 does for an interleaved buffer of
            // length === 1.
            return 0;
        }
        return byteStride;
    }

    /**
     * Parse the attribute pointers to ensure they are valid.
     * @private
     *
     * @param {Object} attributePointers - The attribute pointer map.
     *
     * @return {Object} The validated attribute pointer map.
     */
    function getAttributePointers(attributePointers) {
        // parse pointers to ensure they are valid
        let pointers = {};
        Object.keys(attributePointers).forEach(key => {
            let index = parseInt(key, 10);
            // check that key is an valid integer
            if (isNaN(index)) {
                throw `Attribute index \`${key}\` does not represent an integer`;
            }
            let pointer = attributePointers[key];
            let size = pointer.size;
            let type = pointer.type;
            let byteOffset = pointer.byteOffset;
            // check size
            if (!SIZES[size]) {
                throw 'Attribute pointer `size` parameter is invalid, must be one of ' +
                    JSON.stringify(Object.keys(SIZES));
            }
            // check type
            if (!TYPES[type]) {
                throw 'Attribute pointer `type` parameter is invalid, must be one of ' +
                    JSON.stringify(Object.keys(TYPES));
            }
            pointers[index] = {
                size: size,
                type: type,
                byteOffset: (byteOffset !== undefined) ? byteOffset : DEFAULT_BYTE_OFFSET
            };
        });
        return pointers;
    }

    /**
     * @class VertexBuffer
     * @classdesc A vertex buffer object.
     */
    class VertexBuffer {

        /**
         * Instantiates an VertexBuffer object.
         *
         * @param {WebGLBuffer|VertexPackage|Float32Array|Array|Number} arg - The buffer or length of the buffer.
         * @param {Object} attributePointers - The array pointer map, or in the case of a vertex package arg, the options.
         * @param {Object} options - The rendering options.
         * @param {String} options.mode - The draw mode / primitive type.
         * @param {String} options.indexOffset - The index offset into the drawn buffer.
         * @param {String} options.count - The number of indices to draw.
         */
        constructor(arg, attributePointers = {}, options = {}) {
            this.gl = WebGLContext.get();
            this.buffer = null;
            this.mode = MODES[options.mode] ? options.mode : DEFAULT_MODE;
            this.count = (options.count !== undefined) ? options.count : DEFAULT_COUNT;
            this.indexOffset = (options.indexOffset !== undefined) ? options.indexOffset : DEFAULT_INDEX_OFFSET;
            this.byteLength = 0;
            // first, set the attribute pointers
            if (arg && arg.buffer && arg.pointers) {
                // VertexPackage argument, use its attribute pointers
                this.pointers = arg.pointers;
                // shift options arg since there will be no attrib pointers arg
                options = attributePointers;
            } else {
                this.pointers = getAttributePointers(attributePointers);
            }
            // set the byte stride
            this.byteStride = getStride(this.pointers);
            // then buffer the data
            if (arg) {
                if (arg instanceof VertexPackage) {
                    // VertexPackage argument
                    this.bufferData(arg.buffer);
                } else if (arg instanceof WebGLBuffer) {
                    // WebGLBuffer argument
                    if (options.byteLength === undefined) {
                        throw 'Argument of type `WebGLBuffer` must be complimented with a corresponding `options.byteLength`';
                    }
                    this.buffer = arg;
                    this.byteLength = options.byteLength;
                } else {
                    // Array or ArrayBuffer or number argument
                    this.bufferData(arg);
                }
            }
        }

        /**
         * Upload vertex data to the GPU.
         *
         * @param {Array|ArrayBuffer|ArrayBufferView|number} arg - The array of data to buffer, or size of the buffer in bytes.
         *
         * @return {VertexBuffer} The vertex buffer object, for chaining.
         */
        bufferData(arg) {
            let gl = this.gl;
            // ensure argument is valid
            if (Array.isArray(arg)) {
                // cast array into Float32Array
                arg = new Float32Array(arg);
            } else if (
                !(arg instanceof ArrayBuffer) &&
                !(ArrayBuffer.isView(arg)) &&
                !(Number.isInteger(arg))
                ) {
                // if not arraybuffer or a numeric size
                throw 'Argument must be of type `Array`, `ArrayBuffer`, `ArrayBufferView`, or `Number`';
            }
            // set byte length
            if (Number.isInteger(arg)) {
                this.byteLength = arg;
            } else {
                this.byteLength = arg.byteLength;
            }
            // create buffer if it doesn't exist already
            if (!this.buffer) {
                this.buffer = gl.createBuffer();
            }
            // buffer the data
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.bufferData(gl.ARRAY_BUFFER, arg, gl.STATIC_DRAW);
        }

        /**
         * Upload partial vertex data to the GPU.
         *
         * @param {Array|ArrayBuffer|ArrayBufferView} array - The array of data to buffer.
         * @param {Number} byteOffset - The byte offset at which to buffer.
         *
         * @return {VertexBuffer} The vertex buffer object, for chaining.
         */
        bufferSubData(array, byteOffset = DEFAULT_BYTE_OFFSET) {
            let gl = this.gl;
            // ensure the buffer exists
            if (!this.buffer) {
                throw 'Buffer has not yet been allocated, allocate with ' +
                    '`bufferData`';
            }
            // ensure argument is valid
            if (Array.isArray(array)) {
                array = new Float32Array(array);
            } else if (
                !(array instanceof ArrayBuffer) &&
                !ArrayBuffer.isView(array)
                ) {
                throw 'Argument must be of type `Array`, `ArrayBuffer`, ' +
                    'or `ArrayBufferView`';
            }
            // check that we aren't overflowing the buffer
            if (byteOffset + array.byteLength > this.byteLength) {
                throw `Argument of length ${array.byteLength} bytes with ` +
                    `offset of ${byteOffset} bytes overflows the buffer ` +
                    `length of ${this.byteLength} bytes`;
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, byteOffset, array);
            return this;
        }

        /**
         * Binds the vertex buffer object.
         *
         * @return {VertexBuffer} - Returns the vertex buffer object for chaining.
         */
        bind() {
            let gl = this.gl;
            // bind buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            // for each attribute pointer
            Object.keys(this.pointers).forEach(index => {
                let pointer = this.pointers[index];
                // set attribute pointer
                gl.vertexAttribPointer(
                    index,
                    pointer.size,
                    gl[pointer.type],
                    false,
                    this.byteStride,
                    pointer.byteOffset);
                // enable attribute index
                gl.enableVertexAttribArray(index);
            });
            return this;
        }

        /**
         * Unbinds the vertex buffer object.
         *
         * @return {VertexBuffer} The vertex buffer object, for chaining.
         */
        unbind() {
            let gl = this.gl;
            // unbind buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            Object.keys(this.pointers).forEach(index => {
                // disable attribute index
                gl.disableVertexAttribArray(index);
            });
            return this;
        }

        /**
         * Execute the draw command for the bound buffer.
         *
         * @param {Object} options - The options to pass to 'drawArrays'. Optional.
         * @param {String} options.mode - The draw mode / primitive type.
         * @param {String} options.indexOffset - The index offset into the drawn buffer.
         * @param {String} options.count - The number of indices to draw.
         *
         * @return {VertexBuffer} The vertex buffer object, for chaining.
         */
        draw(options = {}) {
            let gl = this.gl;
            let mode = gl[options.mode || this.mode];
            let indexOffset = (options.indexOffset !== undefined) ? options.indexOffset : this.indexOffset;
            let count = (options.count !== undefined) ? options.count : this.count;
            if (count === 0) {
                throw 'Attempting to draw with a count of 0';
            }
            // draw elements
            gl.drawArrays(mode, indexOffset, count);
            return this;
        }
    }

    module.exports = VertexBuffer;

}());

},{"./VertexPackage":47,"./WebGLContext":49}],47:[function(require,module,exports){
(function () {

    'use strict';

    let COMPONENT_TYPE = 'FLOAT';
    let BYTES_PER_COMPONENT = 4;

    /**
     * Removes invalid attribute arguments. A valid argument must be an Array of length > 0 key by a string representing an int.
     * @private
     *
     * @param {Object} attributes - The map of vertex attributes.
     *
     * @return {Array} The valid array of arguments.
     */
    function parseAttributeMap(attributes) {
        let goodAttributes = [];
        Object.keys(attributes).forEach(key => {
            let index = parseFloat(key);
            // check that key is an valid integer
            if (!Number.isInteger(index) || index < 0) {
                throw `Attribute index \`${key}\` does not represent a valid integer`;
            }
            let vertices = attributes[key];
            // ensure attribute is valid
            if (Array.isArray(vertices) && vertices.length > 0) {
                // add attribute data and index
                goodAttributes.push({
                    index: index,
                    data: vertices
                });
            } else {
                throw `Error parsing attribute of index \`${index}\``;
            }
        });
        // sort attributes ascending by index
        goodAttributes.sort((a, b) => {
            return a.index - b.index;
        });
        return goodAttributes;
    }

    /**
     * Returns a component's byte size.
     * @private
     *
     * @param {Object|Array} component - The component to measure.
     *
     * @return {Number} The byte size of the component.
     */
    function getComponentSize(component) {
        // check if array
        if (Array.isArray(component)) {
            return component.length;
        }
        // check if vector
        if (component.x !== undefined) {
            // 1 component vector
            if (component.y !== undefined) {
                // 2 component vector
                if (component.z !== undefined) {
                    // 3 component vector
                    if (component.w !== undefined) {
                        // 4 component vector
                        return 4;
                    }
                    return 3;
                }
                return 2;
            }
            return 1;
        }
        // single component
        return 1;
    }

    /**
     * Calculates the type, size, and offset for each attribute in the attribute array along with the length and stride of the package.
     * @private
     *
     * @param {VertexPackage} vertexPackage - The VertexPackage object.
     * @param {Array} attributes The array of vertex attributes.
     */
    function setPointersAndStride(vertexPackage, attributes) {
        let shortestArray = Number.MAX_VALUE;
        let offset = 0;
        // clear pointers
        vertexPackage.pointers = {};
        // for each attribute
        attributes.forEach(vertices => {
            // set size to number of components in the attribute
            let size = getComponentSize(vertices.data[0]);
            // length of the package will be the shortest attribute array length
            shortestArray = Math.min(shortestArray, vertices.data.length);
            // store pointer under index
            vertexPackage.pointers[vertices.index] = {
                type: COMPONENT_TYPE,
                size: size,
                byteOffset: offset * BYTES_PER_COMPONENT
            };
            // accumulate attribute offset
            offset += size;
        });
        // set stride to total offset
        vertexPackage.stride = offset; // not in bytes
        // set length of package to the shortest attribute array length
        vertexPackage.length = shortestArray;
    }

    /**
     * Fill the arraybuffer with a single component attribute.
     * @private
     *
     * @param {Float32Array} buffer - The arraybuffer to fill.
     * @param {Array} vertices - The vertex attribute array to copy from.
     * @param {Number} length - The length of the buffer to copy from.
     * @param {Number} offset - The offset to the attribute, not in bytes.
     * @param {Number} stride - The stride of the buffer, not in bytes.
     */
    function set1ComponentAttr(buffer, vertices, length, offset, stride) {
        let vertex, i, j;
        for (i=0; i<length; i++) {
            vertex = vertices[i];
            // get the index in the buffer to the particular vertex
            j = offset + (stride * i);
            if (vertex.x !== undefined) {
                buffer[j] = vertex.x;
            } else if (vertex[0] !== undefined) {
                buffer[j] = vertex[0];
            } else {
                buffer[j] = vertex;
            }
        }
    }

    /**
     * Fill the arraybuffer with a double component attribute.
     * @private
     *
     * @param {Float32Array} buffer - The arraybuffer to fill.
     * @param {Array} vertices - The vertex attribute array to copy from.
     * @param {Number} length - The length of the buffer to copy from.
     * @param {Number} offset - The offset to the attribute, not in bytes.
     * @param {Number} stride - The stride of the buffer, not in bytes.
     */
    function set2ComponentAttr(buffer, vertices, length, offset, stride) {
        let vertex, i, j;
        for (i=0; i<length; i++) {
            vertex = vertices[i];
            // get the index in the buffer to the particular vertex
            j = offset + (stride * i);
            buffer[j] = (vertex.x !== undefined) ? vertex.x : vertex[0];
            buffer[j+1] = (vertex.y !== undefined) ? vertex.y : vertex[1];
        }
    }

    /**
     * Fill the arraybuffer with a triple component attribute.
     * @private
     *
     * @param {Float32Array} buffer - The arraybuffer to fill.
     * @param {Array} vertices - The vertex attribute array to copy from.
     * @param {Number} length - The length of the buffer to copy from.
     * @param {Number} offset - The offset to the attribute, not in bytes.
     * @param {Number} stride - The stride of the buffer, not in bytes.
     */
    function set3ComponentAttr(buffer, vertices, length, offset, stride) {
        let vertex, i, j;
        for (i=0; i<length; i++) {
            vertex = vertices[i];
            // get the index in the buffer to the particular vertex
            j = offset + (stride * i);
            buffer[j] = (vertex.x !== undefined) ? vertex.x : vertex[0];
            buffer[j+1] = (vertex.y !== undefined) ? vertex.y : vertex[1];
            buffer[j+2] = (vertex.z !== undefined) ? vertex.z : vertex[2];
        }
    }

    /**
     * Fill the arraybuffer with a quadruple component attribute.
     * @private
     *
     * @param {Float32Array} buffer - The arraybuffer to fill.
     * @param {Array} vertices - The vertex attribute array to copy from.
     * @param {Number} length - The length of the buffer to copy from.
     * @param {Number} offset - The offset to the attribute, not in bytes.
     * @param {Number} stride - The stride of the buffer, not in bytes.
     */
    function set4ComponentAttr(buffer, vertices, length, offset, stride) {
        let vertex, i, j;
        for (i=0; i<length; i++) {
            vertex = vertices[i];
            // get the index in the buffer to the particular vertex
            j = offset + (stride * i);
            buffer[j] = (vertex.x !== undefined) ? vertex.x : vertex[0];
            buffer[j+1] = (vertex.y !== undefined) ? vertex.y : vertex[1];
            buffer[j+2] = (vertex.z !== undefined) ? vertex.z : vertex[2];
            buffer[j+3] = (vertex.w !== undefined) ? vertex.w : vertex[3];
        }
    }

    /**
     * @class VertexPackage
     * @classdesc A vertex package to assist in interleaving vertex data and building the associated vertex attribute pointers.
     */
    class VertexPackage {

        /**
         * Instantiates a VertexPackage object.
          *
         * @param {Object} attributes - The attributes to interleave keyed by index.
         */
        constructor(attributes) {
            if (attributes !== undefined) {
                this.set(attributes);
            } else {
                this.buffer = new Float32Array(0);
                this.pointers = {};
            }
        }

        /**
         * Set the data to be interleaved inside the package. This clears any previously existing data.
         *
         * @param {Object} attributes - The attributes to interleaved, keyed by index.
         *
         * @return {VertexPackage} The vertex package object, for chaining.
         */
        set(attributes) {
            // remove bad attributes
            attributes = parseAttributeMap(attributes);
            // set attribute pointers and stride
            setPointersAndStride(this, attributes);
            // set size of data vector
            let length = this.length;
            let stride = this.stride; // not in bytes
            let pointers = this.pointers;
            let buffer = this.buffer = new Float32Array(length * stride);
            // for each vertex attribute array
            attributes.forEach(vertices => {
                // get the pointer
                let pointer = pointers[vertices.index];
                // get the pointers offset
                let offset = pointer.byteOffset / BYTES_PER_COMPONENT;
                // copy vertex data into arraybuffer
                switch (pointer.size) {
                    case 2:
                        set2ComponentAttr(buffer, vertices.data, length, offset, stride);
                        break;
                    case 3:
                        set3ComponentAttr(buffer, vertices.data, length, offset, stride);
                        break;
                    case 4:
                        set4ComponentAttr(buffer, vertices.data, length, offset, stride);
                        break;
                    default:
                        set1ComponentAttr(buffer, vertices.data, length, offset, stride);
                        break;
                }
            });
            return this;
        }
    }

    module.exports = VertexPackage;

}());

},{}],48:[function(require,module,exports){
(function() {

    'use strict';

    let WebGLContext = require('./WebGLContext');

    /**
     * Bind the viewport to the rendering context.
     *
     * @param {Viewport} viewport - The viewport object.
     * @param {Number} width - The width override.
     * @param {Number} height - The height override.
     * @param {Number} x - The horizontal offset override.
     * @param {Number} y - The vertical offset override.
     */
    function set(viewport, x, y, width, height) {
        let gl = viewport.gl;
        x = (x !== undefined) ? x : viewport.x;
        y = (y !== undefined) ? y : viewport.y;
        width = (width !== undefined) ? width : viewport.width;
        height = (height !== undefined) ? height : viewport.height;
        gl.viewport(x, y, width, height);
    }

    /**
     * @class Viewport
     * @classdesc A viewport class for managing WebGL viewports.
     */
    class Viewport {

        /**
         * Instantiates a Viewport object.
         *
         * @param {Object} spec - The viewport specification object.
         * @param {Number} spec.width - The width of the viewport.
         * @param {Number} spec.height - The height of the viewport.
         */
        constructor(spec = {}) {
            this.gl = WebGLContext.get();
            this.stack = [];
            // set size
            this.resize(
                spec.width || this.gl.canvas.width,
                spec.height || this.gl.canvas.height);
        }

        /**
         * Updates the viewports width and height. This resizes the underlying canvas element.
         *
         * @param {Number} width - The width of the viewport.
         * @param {Number} height - The height of the viewport.
         *
         * @return {Viewport} The viewport object, for chaining.
         */
        resize(width = 0, height = 0) {
            if (typeof width !== 'number' || width <= 0) {
                throw `Provided \`width\` of \`${width}\` is invalid`;
            }
            if (typeof height !== 'number' || height <= 0) {
                throw `Provided \`height\` of \`${height}\` is invalid`;
            }
            this.width = width;
            this.height = height;
            this.gl.canvas.width = width;
            this.gl.canvas.height = height;
            return this;
        }

        /**
         * Sets the viewport dimensions and position. The underlying canvas element is not affected.
         *
         * @param {Number} width - The width override.
         * @param {Number} height - The height override.
         * @param {Number} x - The horizontal offset override.
         * @param {Number} y - The vertical offset override.
         *
         * @return {Viewport} - The viewport object, for chaining.
         */
        push(x = 0, y = 0, width = this.width, height = this.height) {
            if (typeof x !== 'number') {
                throw `Provided \`x\` of \`${x}\` is invalid`;
            }
            if (typeof y !== 'number') {
                throw `Provided \`y\` of \`${y}\` is invalid`;
            }
            if (typeof width !== 'number' || width <= 0) {
                throw `Provided \`width\` of \`${width}\` is invalid`;
            }
            if (typeof height !== 'number' || height <= 0) {
                throw `Provided \`height\` of \`${height}\` is invalid`;
            }
            // push onto stack
            this.stack.push({
                x: x,
                y: y,
                width: width,
                height: height
            });
            // set viewport
            set(this, x, y, width, height);
            return this;
        }

        /**
         * Pops current the viewport object and sets the viewport beneath it.
         *
         * @return {Viewport} The viewport object, for chaining.
         */
        pop() {
            if (this.stack.length === 0) {
                throw 'Viewport stack is empty';
            }
            this.stack.pop();
            if (this.stack.length > 0) {
                let top = this.stack[this.stack.length - 1];
                set(this, top.x, top.y, top.width, top.height);
            } else {
                set(this);
            }
            return this;
        }
    }

    module.exports = Viewport;

}());

},{"./WebGLContext":49}],49:[function(require,module,exports){
(function() {

    'use strict';

    let EXTENSIONS = [
        // ratified
        'OES_texture_float',
        'OES_texture_half_float',
        'WEBGL_lose_context',
        'OES_standard_derivatives',
        'OES_vertex_array_object',
        'WEBGL_debug_renderer_info',
        'WEBGL_debug_shaders',
        'WEBGL_compressed_texture_s3tc',
        'WEBGL_depth_texture',
        'OES_element_index_uint',
        'EXT_texture_filter_anisotropic',
        'EXT_frag_depth',
        'WEBGL_draw_buffers',
        'ANGLE_instanced_arrays',
        'OES_texture_float_linear',
        'OES_texture_half_float_linear',
        'EXT_blend_minmax',
        'EXT_shader_texture_lod',
        // community
        'WEBGL_compressed_texture_atc',
        'WEBGL_compressed_texture_pvrtc',
        'EXT_color_buffer_half_float',
        'WEBGL_color_buffer_float',
        'EXT_sRGB',
        'WEBGL_compressed_texture_etc1',
        'EXT_disjoint_timer_query',
        'EXT_color_buffer_float'
    ];

    let _boundContext = null;
    let _contexts = {};

    /**
     * Returns an rfc4122 version 4 compliant UUID.
     * @private
     *
     * @return {String} - The UUID string.
     */
    function getUUID() {
        let replace = function(c) {
            let r = Math.random() * 16 | 0;
            let v = (c === 'x') ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        };
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, replace);
    }

    /**
     * Returns the id of the HTMLCanvasElement element. If there is no id, it generates one and appends it.
     * @private
     *
     * @param {HTMLCanvasElement} canvas - The Canvas object.
     *
     * @return {String} The Canvas id string.
     */
    function getId(canvas) {
        if (!canvas.id) {
            canvas.id = getUUID();
        }
        return canvas.id;
    }

    /**
     * Returns a Canvas element object from either an existing object, or identification string.
     * @private
     *
     * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas id or selector string.
     *
     * @return {HTMLCanvasElement} The Canvas element object.
     */
    function getCanvas(arg) {
        if (arg instanceof HTMLCanvasElement) {
            return arg;
        } else if (typeof arg === 'string') {
            return document.getElementById(arg) ||
                document.querySelector(arg);
        }
        return null;
    }

    /**
     * Attempts to retrieve a wrapped WebGLRenderingContext.
     * @private
     *
     * @param {HTMLCanvasElement} The Canvas element object to create the context under.
     *
     * @return {Object} The context wrapper.
     */
    function getContextWrapper(arg) {
        if (arg === undefined) {
            if (_boundContext) {
                // return last bound context
                return _boundContext;
            }
        } else {
            let canvas = getCanvas(arg);
            if (canvas) {
                return _contexts[getId(canvas)];
            }
        }
        // no bound context or argument
        return null;
    }

    /**
     * Attempts to load all known extensions for a provided WebGLRenderingContext. Stores the results in the context wrapper for later queries.
     * @private
     *
     * @param {Object} contextWrapper - The context wrapper.
     */
    function loadExtensions(contextWrapper) {
        let gl = contextWrapper.gl;
        EXTENSIONS.forEach(id => {
            contextWrapper.extensions[id] = gl.getExtension(id);
        });
    }

    /**
     * Attempts to create a WebGLRenderingContext and load all extensions.
     * @private
     *
     * @param {HTMLCanvasElement} - The Canvas element object to create the context under.
     * @param {Object}} options - Parameters to the webgl context, only used during instantiation. Optional.
     *
     * @return {Object} The context wrapper.
     */
    function createContextWrapper(canvas, options) {
        let gl = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);
        // wrap context
        let contextWrapper = {
            id: getId(canvas),
            gl: gl,
            extensions: {}
        };
        // load WebGL extensions
        loadExtensions(contextWrapper);
        // add context wrapper to map
        _contexts[getId(canvas)] = contextWrapper;
        // bind the context
        _boundContext = contextWrapper;
        return contextWrapper;
    }

    module.exports = {

        /**
         * Retrieves an existing WebGL context associated with the provided argument and binds it. While bound, the active context will be used implicitly by any instantiated `esper` constructs.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string.
         *
         * @return {WebGLContext} The namespace, used for chaining.
         */
        bind: function(arg) {
            let wrapper = getContextWrapper(arg);
            if (wrapper) {
                _boundContext = wrapper;
                return this;
            }
            throw `No context exists for provided argument '${arg}'`;
        },

        /**
         * Retrieves an existing WebGL context associated with the provided argument. If no context exists, one is created.
         * During creation attempts to load all extensions found at: https://www.khronos.org/registry/webgl/extensions/.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         * @param {Object} options - Parameters to the webgl context, only used during instantiation. Optional.
         *
         * @return {WebGLRenderingContext} The WebGLRenderingContext object.
         */
        get: function(arg, options) {
            let wrapper = getContextWrapper(arg);
            if (wrapper) {
               // return the native WebGLRenderingContext
               return wrapper.gl;
            }
            // get canvas element
            let canvas = getCanvas(arg);
            // try to find or create context
            if (!canvas) {
                throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
            }
            // create context
            return createContextWrapper(canvas, options).gl;
        },

        /**
         * Removes an existing WebGL context object for the provided or currently bound context object.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         * @param {Object}} options - Parameters to the webgl context, only used during instantiation. Optional.
         *
         * @return {WebGLRenderingContext} The WebGLRenderingContext object.
         */
        remove: function(arg) {
            let wrapper = getContextWrapper(arg);
            if (wrapper) {
                // delete the context
                delete _contexts[wrapper.id];
                // remove if currently bound
                if (wrapper === _boundContext) {
                    _boundContext = null;
                }
            } else {
                throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
            }
        },

        /**
         * Returns an array of all supported extensions for the provided or currently bound context object.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         *
         * @return {Array} All supported extensions.
         */
        supportedExtensions: function(arg) {
            let wrapper = getContextWrapper(arg);
            if (wrapper) {
                let extensions = wrapper.extensions;
                let supported = [];
                Object.keys(extensions).forEach(function(key) {
                    if (extensions[key]) {
                        supported.push(key);
                    }
                });
                return supported;
            }
            throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
        },

        /**
         * Returns an array of all unsupported extensions for the provided or currently bound context object.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         *
         * @return {Array} All unsupported extensions.
         */
        unsupportedExtensions: function(arg) {
            let wrapper = getContextWrapper(arg);
            if (wrapper) {
                let extensions = wrapper.extensions;
                let unsupported = [];
                Object.keys(extensions).forEach(function(key) {
                    if (!extensions[key]) {
                        unsupported.push(key);
                    }
                });
                return unsupported;
            }
            throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
        },

        /**
         * Checks if an extension has been successfully loaded for the provided or currently bound context object.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         * @param {String} extension - The extension name.
         *
         * @return {boolean} Whether or not the provided extension has been loaded successfully.
         */
        checkExtension: function(arg, extension) {
            if (!extension) {
                // shift parameters if no canvas arg is provided
                extension = arg;
                arg = undefined;
            }
            let wrapper = getContextWrapper(arg);
            if (wrapper) {
                let extensions = wrapper.extensions;
                return extensions[extension] ? true : false;
            }
            throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
        },

        /**
         * Returns an extension if it has been successfully loaded for the provided or currently bound context object.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         * @param {String} extension - The extension name.
         *
         * @return {boolean} Whether or not the provided extension has been loaded successfully.
         */
        getExtension: function(arg, extension) {
            if (!extension) {
                // shift parameters if no canvas arg is provided
                extension = arg;
                arg = undefined;
            }
            let wrapper = getContextWrapper(arg);
            if (wrapper) {
                let extensions = wrapper.extensions;
                return extensions[extension] || null;
            }
            throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
        }
    };

}());

},{}],50:[function(require,module,exports){
(function () {

    'use strict';

    module.exports = {
        IndexBuffer: require('./core/IndexBuffer'),
        Renderable: require('./core/Renderable'),
        RenderTarget: require('./core/RenderTarget'),
        Shader: require('./core/Shader'),
        Texture2D: require('./core/Texture2D'),
        ColorTexture2D: require('./core/ColorTexture2D'),
        DepthTexture2D: require('./core/DepthTexture2D'),
        TextureCubeMap: require('./core/TextureCubeMap'),
        VertexBuffer: require('./core/VertexBuffer'),
        VertexPackage: require('./core/VertexPackage'),
        Viewport: require('./core/Viewport'),
        WebGLContext: require('./core/WebGLContext')
    };

}());

},{"./core/ColorTexture2D":37,"./core/DepthTexture2D":38,"./core/IndexBuffer":39,"./core/RenderTarget":40,"./core/Renderable":41,"./core/Shader":42,"./core/Texture2D":44,"./core/TextureCubeMap":45,"./core/VertexBuffer":46,"./core/VertexPackage":47,"./core/Viewport":48,"./core/WebGLContext":49}],51:[function(require,module,exports){
(function () {

    'use strict';

    function getIterator(arg) {
        let i = -1;
        let len;
        if (Array.isArray(arg)) {
            len = arg.length;
            return function() {
                i++;
                return i < len ? i : null;
            };
        }
        let keys = Object.keys(arg);
        len = keys.length;
        return function() {
            i++;
            return i < len ? keys[i] : null;
        };
    }

    function once(fn) {
        return function() {
            if (fn === null) {
                return;
            }
            fn.apply(this, arguments);
            fn = null;
        };
    }

    function each(object, iterator, callback) {
        callback = once(callback);
        let key;
        let completed = 0;

        function done(err) {
            completed--;
            if (err) {
                callback(err);
            } else if (key === null && completed <= 0) {
                // check if key is null in case iterator isn't exhausted and done
                // was resolved synchronously.
                callback(null);
            }
        }

        let iter = getIterator(object);
        while ((key = iter()) !== null) {
            completed += 1;
            iterator(object[key], key, done);
        }
        if (completed === 0) {
            callback(null);
        }
    }

    module.exports = {

        /**
         * Execute a set of functions asynchronously, once all have been
         * completed, execute the provided callback function. Jobs may be passed
         * as an array or object. The callback function will be passed the
         * results in the same format as the tasks. All tasks must have accept
         * and execute a callback function upon completion.
         *
         * @param {Array|Object} tasks - The set of functions to execute.
         * @param {Function} callback - The callback function to be executed upon completion.
         */
        parallel: function(tasks, callback) {
            let results = Array.isArray(tasks) ? [] : {};
            each(tasks, function(task, key, done) {
                task(function(err, res) {
                    results[key] = res;
                    done(err);
                });
            }, function(err) {
                callback(err, results);
            });
        }

    };

}());

},{}],52:[function(require,module,exports){
(function() {

    'use strict';

    module.exports = {

        /**
         * Sends an GET request create an Image object.
         *
         * @param {Object} options - The XHR options.
         * @param {String} options.url - The URL for the resource.
         * @param {Function} options.success - The success callback function.
         * @param {Function} options.error - The error callback function.
         */
        load: function (options = {}) {
            let image = new Image();
            image.onload = () => {
                if (options.success) {
                    options.success(image);
                }
            };
            image.onerror = (event) => {
                if (options.error) {
                    let err = 'Unable to load image from URL: `' + event.path[0].currentSrc + '`';
                    options.error(err);
                }
            };
            image.src = options.url;
        }
    };

}());

},{}],53:[function(require,module,exports){
(function () {

    'use strict';

    let Util = {};

    /**
     * Returns true if the argument is one of the WebGL `texImage2D` overridden
     * canvas types.
     *
     * @param {*} arg - The argument to test.
     *
     * @return {bool} - Whether or not it is a canvas type.
     */
    Util.isCanvasType = function(arg) {
        return arg instanceof ImageData ||
            arg instanceof HTMLImageElement ||
            arg instanceof HTMLCanvasElement ||
            arg instanceof HTMLVideoElement;
    };

    /**
     * Returns true if the texture MUST be a power-of-two. Otherwise return false.
     *
     * @param {Object} spec - The texture specification object.
     *
     * @return {bool} - Whether or not the texture must be a power of two.
     */
    Util.mustBePowerOfTwo = function(spec) {
        // According to:
        // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL#Non_power-of-two_textures
        // N-POT textures cannot be used with mipmapping and they must not "REPEAT"
        return spec.mipMap ||
            spec.wrapS === 'REPEAT' ||
            spec.wrapS === 'MIRRORED_REPEAT' ||
            spec.wrapT === 'REPEAT' ||
            spec.wrapT === 'MIRRORED_REPEAT';
    };

    /**
     * Returns true if the provided integer is a power of two.
     *
     * @param {Number} num - The number to test.
     *
     * @return {boolean} - Whether or not the number is a power of two.
     */
    Util.isPowerOfTwo = function(num) {
        return (num !== 0) ? (num & (num - 1)) === 0 : false;
    };

    /**
     * Returns the next highest power of two for a number.
     *
     * Ex.
     *
     *     200 -> 256
     *     256 -> 256
     *     257 -> 512
     *
     * @param {Number} num - The number to modify.
     *
     * @return {Number} - Next highest power of two.
     */
    Util.nextHighestPowerOfTwo = function(num) {
        let i;
        if (num !== 0) {
            num = num-1;
        }
        for (i=1; i<32; i<<=1) {
            num = num | num >> i;
        }
        return num + 1;
    };

    /**
     * If the texture must be a POT, resizes and returns the image.
     * @private
     *
     * @param {Object} spec - The texture specification object.
     * @param {HTMLImageElement} img - The image object.
     *
     * @return {HTMLImageElement|HTMLCanvasElement} - The original image, or the resized canvas element.
     */
    Util.resizeCanvas = function(spec, img) {
        if (!Util.mustBePowerOfTwo(spec) ||
            (Util.isPowerOfTwo(img.width) && Util.isPowerOfTwo(img.height))) {
            return img;
        }
        // create an empty canvas element
        let canvas = document.createElement('canvas');
        canvas.width = Util.nextHighestPowerOfTwo(img.width);
        canvas.height = Util.nextHighestPowerOfTwo(img.height);
        // copy the image contents to the canvas
        let ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);
        return canvas;
    };

    module.exports = Util;

}());

},{}],54:[function(require,module,exports){
(function() {

    'use strict';

    module.exports = {

        /**
         * Sends an XMLHttpRequest GET request to the supplied url.
         *
         * @param {Object} options - The XHR options.
         * @param {String} options.url - The URL for the resource.
         * @param {Function} options.success - The success callback function.
         * @param {Function} options.error - The error callback function.
         * @param {Function} options.responseType - The responseType of the XHR.
         */
        load: function (options) {
            let request = new XMLHttpRequest();
            request.open('GET', options.url, true);
            request.responseType = options.responseType;
            request.onreadystatechange = () => {
                if (request.readyState === 4) {
                    if (request.status === 200) {
                        if (options.success) {
                            options.success(request.response);
                        }
                    } else {
                        if (options.error) {
                            options.error('GET ' + request.responseURL + ' ' + request.status + ' (' + request.statusText + ')');
                        }
                    }
                }
            };
            request.send();
        }
    };

}());

},{}],55:[function(require,module,exports){
var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};

},{"jsonify":56}],56:[function(require,module,exports){
exports.parse = require('./lib/parse');
exports.stringify = require('./lib/stringify');

},{"./lib/parse":57,"./lib/stringify":58}],57:[function(require,module,exports){
var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

},{}],58:[function(require,module,exports){
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

},{}],59:[function(require,module,exports){
//! moment.js
//! version : 2.14.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        return Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        var k;
        for (k in obj) {
            // even if its not own property I'd still call it non-empty
            return false;
        }
        return true;
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    function isUndefined(input) {
        return input === void 0;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (utils_hooks__hooks.deprecationHandler != null) {
                utils_hooks__hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (utils_hooks__hooks.deprecationHandler != null) {
            utils_hooks__hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;
    utils_hooks__hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function get_set__set (mom, unit, value) {
        if (mom.isValid()) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function units_month__handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = create_utc__createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return units_month__handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (typeof value !== 'number') {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        //the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function day_of_week__handleStrictParse(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = create_utc__createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = create_utc__createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        ordinalParse: defaultOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    // treat as if there is no base config
                    deprecateSimple('parentLocaleUndefined',
                            'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, parentConfig = baseConfig;
            // MERGE
            if (locales[name] != null) {
                parentConfig = locales[name]._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function locale_locales__listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (isDate(input)) {
            config._d = input;
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!valid__isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = ((string || '').match(matcher) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
            } else if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(matchOffset, this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            delta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
            case 'date':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIOROITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add               = add_subtract__add;
    momentPrototype__proto.calendar          = moment_calendar__calendar;
    momentPrototype__proto.clone             = clone;
    momentPrototype__proto.diff              = diff;
    momentPrototype__proto.endOf             = endOf;
    momentPrototype__proto.format            = format;
    momentPrototype__proto.from              = from;
    momentPrototype__proto.fromNow           = fromNow;
    momentPrototype__proto.to                = to;
    momentPrototype__proto.toNow             = toNow;
    momentPrototype__proto.get               = stringGet;
    momentPrototype__proto.invalidAt         = invalidAt;
    momentPrototype__proto.isAfter           = isAfter;
    momentPrototype__proto.isBefore          = isBefore;
    momentPrototype__proto.isBetween         = isBetween;
    momentPrototype__proto.isSame            = isSame;
    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
    momentPrototype__proto.isValid           = moment_valid__isValid;
    momentPrototype__proto.lang              = lang;
    momentPrototype__proto.locale            = locale;
    momentPrototype__proto.localeData        = localeData;
    momentPrototype__proto.max               = prototypeMax;
    momentPrototype__proto.min               = prototypeMin;
    momentPrototype__proto.parsingFlags      = parsingFlags;
    momentPrototype__proto.set               = stringSet;
    momentPrototype__proto.startOf           = startOf;
    momentPrototype__proto.subtract          = add_subtract__subtract;
    momentPrototype__proto.toArray           = toArray;
    momentPrototype__proto.toObject          = toObject;
    momentPrototype__proto.toDate            = toDate;
    momentPrototype__proto.toISOString       = moment_format__toISOString;
    momentPrototype__proto.toJSON            = toJSON;
    momentPrototype__proto.toString          = toString;
    momentPrototype__proto.unix              = unix;
    momentPrototype__proto.valueOf           = to_type__valueOf;
    momentPrototype__proto.creationData      = creationData;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var prototype__proto = Locale.prototype;

    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto.ordinal         = ordinal;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months            =        localeMonths;
    prototype__proto.monthsShort       =        localeMonthsShort;
    prototype__proto.monthsParse       =        localeMonthsParse;
    prototype__proto.monthsRegex       = monthsRegex;
    prototype__proto.monthsShortRegex  = monthsShortRegex;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    prototype__proto.weekdaysRegex       =        weekdaysRegex;
    prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
    prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = lists__get(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = locale_locales__getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return lists__get(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = lists__get(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function lists__listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function lists__listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function lists__listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function lists__listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes <= 1           && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   <= 1           && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    <= 1           && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  <= 1           && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   <= 1           && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function duration_humanize__getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.14.1';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.now                   = now;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.updateLocale          = updateLocale;
    utils_hooks__hooks.locales               = locale_locales__listLocales;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    utils_hooks__hooks.calendarFormat        = getCalendarFormat;
    utils_hooks__hooks.prototype             = momentPrototype;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],60:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Graph = require('../projection/Graph');

    L.CRS.Graph = L.extend({}, L.CRS, {

        projection: Graph,

        transformation: new L.Transformation(1, 0, 1, 0),

        infinite: false,

        scale: function scale(zoom) {
            return Math.pow(2, zoom);
        },

        zoom: function zoom(scale) {
            return Math.log(scale) / Math.LN2;
        },

        distance: function distance(latlng1, latlng2) {
            var dx = latlng2.lng - latlng1.lng;
            var dy = latlng2.lat - latlng1.lat;
            return Math.sqrt(dx * dx + dy * dy);
        }
    });

    module.exports = L.CRS.Graph;
})();

},{"../projection/Graph":99}],61:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    module.exports = {
        Graph: require('./Graph')
    };
})();

},{"./Graph":60}],62:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    module.exports = {
        Map: require('./map/Map'),
        Projection: require('./projection/exports'),
        CRS: require('./CRS/exports'),
        TileLayer: require('./layer/exports'),
        Renderer: require('./renderer/exports'),
        TileRequestor: require('./request/TileRequestor'),
        MetaRequestor: require('./request/MetaRequestor'),
        ColorRamp: {
            // expose as static method
            getColorRamp: require('./renderer/mixin/ColorRamp').getColorRamp
        }
    };
})();

},{"./CRS/exports":61,"./layer/exports":76,"./map/Map":98,"./projection/exports":100,"./renderer/exports":106,"./renderer/mixin/ColorRamp":107,"./request/MetaRequestor":130,"./request/TileRequestor":132}],63:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var setDateHistogram = function setDateHistogram(field, from, to, interval) {
        if (!field) {
            throw 'DateHistogram `field` is missing from argument';
        }
        if (from === undefined) {
            throw 'DateHistogram `from` are missing from argument';
        }
        if (to === undefined) {
            throw 'DateHistogram `to` are missing from argument';
        }
        this._params.date_histogram = {
            field: field,
            from: from,
            to: to,
            interval: interval
        };
        this.clearExtrema();
        return this;
    };

    var getDateHistogram = function getDateHistogram() {
        return this._params.date_histogram;
    };

    module.exports = {
        setDateHistogram: setDateHistogram,
        getDateHistogram: getDateHistogram
    };
})();

},{}],64:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (!meta.extrema) {
                throw 'Histogram `field` ' + field + ' is not ordinal in meta data';
            }
        } else {
            throw 'Histogram `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setHistogram = function setHistogram(field, interval) {
        if (!field) {
            throw 'Histogram `field` is missing from argument';
        }
        if (!interval) {
            throw 'Histogram `interval` are missing from argument';
        }
        checkField(this._meta[field], field);
        this._params.histogram = {
            field: field,
            interval: interval
        };
        this.clearExtrema();
        return this;
    };

    var getHistogram = function getHistogram() {
        return this._params.histogram;
    };

    module.exports = {
        setHistogram: setHistogram,
        getHistogram: getHistogram
    };
})();

},{}],65:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var METRICS = {
        'min': true,
        'max': true,
        'sum': true,
        'avg': true
    };

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (!meta.extrema) {
                throw 'Metrix `field` ' + field + ' is not ordinal in meta data';
            }
        } else {
            throw 'Metric `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setMetric = function setMetric(field, type) {
        if (!field) {
            throw 'Metric `field` is missing from argument';
        }
        if (!type) {
            throw 'Metric `type` is missing from argument';
        }
        checkField(this._meta[field], field);
        if (!METRICS[type]) {
            throw 'Metric type `' + type + '` is not supported';
        }
        this._params.metric = {
            field: field,
            type: type
        };
        this.clearExtrema();
        return this;
    };

    var getMetric = function getMetric() {
        return this._params.metric;
    };

    module.exports = {
        // tiling
        setMetric: setMetric,
        getMetric: getMetric
    };
})();

},{}],66:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'Terms `field` ' + field + ' is not of type `string` in meta data';
            }
        } else {
            throw 'Terms `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setTerms = function setTerms(field, size) {
        if (!field) {
            throw 'Terms `field` is missing from argument';
        }
        checkField(this._meta[field], field);
        this._params.terms = {
            field: field,
            size: size
        };
        this.clearExtrema();
        return this;
    };

    var getTerms = function getTerms() {
        return this._params.terms;
    };

    module.exports = {
        setTerms: setTerms,
        getTerms: getTerms
    };
})();

},{}],67:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'Terms `field` ' + field + ' is not of type `string` in meta data';
            }
        } else {
            throw 'Terms `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setTermsFilter = function setTermsFilter(field, terms) {
        if (!field) {
            throw 'Terms `field` is missing from argument';
        }
        if (terms === undefined) {
            throw 'Terms `terms` are missing from argument';
        }
        checkField(this._meta[field], field);
        this._params.terms_filter = {
            field: field,
            terms: terms
        };
        this.clearExtrema();
        return this;
    };

    var getTermsFilter = function getTermsFilter() {
        return this._params.terms_filter;
    };

    module.exports = {
        setTermsFilter: setTermsFilter,
        getTermsFilter: getTermsFilter
    };
})();

},{}],68:[function(require,module,exports){
'use strict';

// Provides top hits query functionality. 'size' indicates the number of top
// hits to return, 'include' is the list of fields to include in the returned
// data, 'sort' is the field to use for sort critera, and 'order' is value of
// 'asc' or 'desc' to indicate sort ordering.
(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (!meta.extrema) {
                throw 'Range `field` ' + field + ' is not ordinal in meta data.';
            }
        } else {
            throw 'TopTerms `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setTopHits = function setTopHits(size, include, sort, order) {
        if (sort) {
            checkField(this._meta[sort], sort);
        }
        this._params.top_hits = {
            size: size,
            include: include,
            sort: sort,
            order: order
        };
        this.clearExtrema();
        return this;
    };

    var getTopHits = function getTopHits() {
        return this._params.top_hits;
    };

    // bind point for external controls
    var setSortField = function setSortField(sort) {
        if (!sort) {
            throw 'TopHits `sort` argument is missing';
        }
        checkField(this._meta[sort], sort);
        if (sort !== this._params.top_hits.sort) {
            this._params.top_hits.sort = sort;
            this.clearExtrema();
        }
        return this;
    };

    // bind point for external controls
    var getSortField = function getSortField() {
        return this._params.top_hits.sort;
    };

    module.exports = {
        setTopHits: setTopHits,
        getTopHits: getTopHits,
        setSortField: setSortField,
        getSortField: getSortField
    };
})();

},{}],69:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'TopTerms `field` ' + field + ' is not of type `string` in meta data';
            }
        } else {
            throw 'TopTerms `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setTopTerms = function setTopTerms(field, size) {
        if (!field) {
            throw 'TopTerms `field` is missing from argument';
        }
        checkField(this._meta[field], field);
        this._params.top_terms = {
            field: field,
            size: size
        };
        this.clearExtrema();
        return this;
    };

    var getTopTerms = function getTopTerms() {
        return this._params.top_terms;
    };

    module.exports = {
        setTopTerms: setTopTerms,
        getTopTerms: getTopTerms
    };
})();

},{}],70:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    function mod(n, m) {
        return (n % m + m) % m;
    }

    var Base = L.GridLayer.extend({

        options: {
            tms: false
        },

        getOpacity: function getOpacity() {
            return this.options.opacity;
        },

        show: function show() {
            this._hidden = false;
            this._prevMap.addLayer(this);
        },

        hide: function hide() {
            this._hidden = true;
            this._prevMap = this._map;
            this._map.removeLayer(this);
        },

        isHidden: function isHidden() {
            return this._hidden;
        },

        setBrightness: function setBrightness(brightness) {
            this._brightness = brightness;
            $(this._container).css('-webkit-filter', 'brightness(' + this._brightness * 100 + '%)');
            $(this._container).css('filter', 'brightness(' + this._brightness * 100 + '%)');
        },

        getBrightness: function getBrightness() {
            return this._brightness !== undefined ? this._brightness : 1;
        },

        isTargetLayer: function isTargetLayer(elem) {
            return this._container && this._container === elem || $.contains(this._container, elem);
        },

        _getLayerPointFromLonLat: function _getLayerPointFromLonLat(lonlatPoint, zoom) {
            zoom = zoom !== undefined ? zoom : this._map.getZoom();
            var pixel = this._map.project(lonlatPoint, zoom);
            var pow = Math.pow(2, zoom);
            var tileSize = this.options.tileSize;
            return {
                x: mod(pixel.x, pow * tileSize),
                y: mod(pixel.y, pow * tileSize)
            };
        },

        getLayerPointFromEvent: function getLayerPointFromEvent(e) {
            var lonlat = this._map.mouseEventToLatLng(e);
            return this._getLayerPointFromLonLat(lonlat);
        },

        getTileCoordFromLayerPoint: function getTileCoordFromLayerPoint(layerPoint) {
            var tileSize = this.options.tileSize;
            return {
                x: Math.floor(layerPoint.x / tileSize),
                y: Math.floor(layerPoint.y / tileSize),
                z: this._map.getZoom()
            };
        },

        getBinCoordFromLayerPoint: function getBinCoordFromLayerPoint(layerPoint, res) {
            var tileSize = this.options.tileSize;
            var resolution = res || this.getResolution() || tileSize;
            var tx = mod(layerPoint.x, tileSize);
            var y = this.options.tms ? resolution - layerPoint.y : layerPoint.y;
            var ty = mod(y, tileSize);
            var pixelSize = tileSize / resolution;
            var bx = Math.floor(tx / pixelSize);
            var by = Math.floor(ty / pixelSize);
            return {
                x: bx,
                y: by,
                index: bx + by * resolution,
                size: pixelSize
            };
        },

        _addTile: function _addTile(coords, container) {
            var tilePos = this._getTilePos(coords);
            var key = this._tileCoordsToKey(coords);
            // Override so that we don't pass in wrapped coords here
            var tile = this.createTile(coords, L.bind(this._tileReady, this, coords));
            this._initTile(tile);
            // if createTile is defined with a second argument ("done" callback),
            // we know that tile is async and will be ready later; otherwise
            if (this.createTile.length < 2) {
                // mark tile as ready, but delay one frame for opacity animation to happen
                L.Util.requestAnimFrame(L.bind(this._tileReady, this, coords, null, tile));
            }
            L.DomUtil.setPosition(tile, tilePos);
            // save tile in cache
            this._tiles[key] = {
                el: tile,
                coords: coords,
                current: true
            };
            container.appendChild(tile);
            // @event tileloadstart: TileEvent
            // Fired when a tile is requested and starts loading.
            this.fire('tileloadstart', {
                tile: tile,
                coords: coords
            });
        }
    });

    module.exports = Base;
})();

},{}],71:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    function validToCopy(funcName) {
        return funcName !== 'constructor' && funcName !== 'on' && funcName !== 'off' && funcName !== 'setQuery' && funcName !== 'clearQuery' && funcName[0] !== '_';
    }

    var Composite = L.Class.extend({

        initialize: function initialize() {
            var _this = this;

            var layers = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

            var functions = {};
            // get a list of all functions for each layer
            layers.forEach(function (layer) {
                _.forIn(layer, function (val, key) {
                    if (_.isFunction(val) && validToCopy(key)) {
                        functions[key] = functions[key] || [];
                        functions[key].push(layer);
                    }
                });
            });
            // set properties
            this._layers = layers;
            this._functions = functions;
            this._handlers = {};
            this._query = null;
            // extend this composite class for each function
            _.forIn(functions, function (layers, func) {
                _this._extend(func);
            });
        },

        on: function on(evt, func) {
            this._layers.forEach(function (layer) {
                layer.on(evt, func);
            });
            this._handlers[evt] = this._handlers[evt] || [];
            this._handlers[evt].push(func);
        },

        off: function off(evt, func) {
            var handlers = this._handlers[evt];
            if (handlers) {
                var index = handlers.indexOf(func);
                if (index !== -1) {
                    this._layers.forEach(function (layer) {
                        layer.off(evt, func);
                    });
                    handlers.splice(index, 1);
                    if (handlers.length === 0) {
                        delete this._handlers[evt];
                    }
                }
            }
        },

        setQuery: function setQuery(query) {
            this._layers.forEach(function (layer) {
                layer.setQuery(query);
            });
            this._query = query;
        },

        clearQuery: function clearQuery() {
            if (this._query) {
                this._layers.forEach(function (layer) {
                    layer.clearQuery();
                });
                this._query = null;
            }
        },

        _extend: function _extend(func) {
            var functions = this._functions;
            this[func] = function () {
                var layers = functions[func];
                var layer = void 0,
                    i = void 0;
                var result = void 0;
                for (i = 0; i < layers.length; i++) {
                    layer = layers[i];
                    result = layer[func].apply(layer, arguments);
                    if (result !== undefined && result !== layer) {
                        return result;
                    }
                }
            };
        },

        addSubLayer: function addSubLayer(layer) {
            var _this2 = this;

            var index = this._layers.indexOf(layer);
            if (index !== -1) {
                return;
            }
            var functions = this._functions;
            _.forIn(layer, function (val, key) {
                // if it is a function and valid to copy
                if (_.isFunction(val) && validToCopy(key)) {
                    // add layer to functions
                    functions[key] = functions[key] || [];
                    functions[key].push(layer);
                    if (functions[key].length === 1) {
                        // if a new function, extend the object
                        _this2._extend(key);
                    }
                }
            });
            // add to layers
            this._layers.push(layer);
            // add handlers to layer
            _.forIn(this._handlers, function (handlers, evt) {
                handlers.forEach(function (func) {
                    layer.on(evt, func);
                });
            });
            if (this._query) {
                // add query to layer
                layer.setQuery(this._query);
            }
        },

        removeSubLayer: function removeSubLayer(layer) {
            var _this3 = this;

            var index = this._layers.indexOf(layer);
            if (index === -1) {
                return;
            }
            var functions = this._functions;
            // remove all functions used exclusively by this layer
            _.forIn(layer, function (val, key) {
                if (_.isFunction(val) && validToCopy(key)) {
                    var _index = functions[key].indexOf(layer);
                    if (_index !== -1) {
                        // remove from function list
                        functions[key].splice(_index, 1);
                    }
                    // if exclusive owner of function
                    if (functions[key].length === 0) {
                        // no more use for this function, remove it
                        delete functions[key];
                        delete _this3[key];
                    }
                }
            });
            // remove layer
            this._layers.splice(index, 1);
            // remove handlers from layer
            _.forIn(this._handlers, function (handlers, evt) {
                handlers.forEach(function (func) {
                    layer.off(evt, func);
                });
            });
            // clear the query from the layer
            layer.clearQuery();
        }
    });

    module.exports = Composite;
})();

},{}],72:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Base = require('./Base');

    var Debug = Base.extend({

        options: {
            unloadInvisibleTiles: true,
            zIndex: 5000
        },

        initialize: function initialize(options) {
            // set renderer
            if (!options.rendererClass) {
                throw 'No `rendererClass` option found.';
            } else {
                // recursively extend
                $.extend(true, this, options.rendererClass);
            }
            // set options
            L.setOptions(this, options);
        },

        createTile: function createTile(coord) {
            // create a <div> element for drawing
            var tile = L.DomUtil.create('div', 'leaflet-tile');
            // draw to it
            this.renderTile(tile, coord);
            // pass tile to callback
            return tile;
        },

        renderTile: function renderTile() {
            // override
        }

    });

    module.exports = Debug;
})();

},{"./Base":70}],73:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Image = L.TileLayer.extend({

        getOpacity: function getOpacity() {
            return this.options.opacity;
        },

        show: function show() {
            this._hidden = false;
            this._prevMap.addLayer(this);
        },

        hide: function hide() {
            this._hidden = true;
            this._prevMap = this._map;
            this._map.removeLayer(this);
        },

        isHidden: function isHidden() {
            return this._hidden;
        },

        setBrightness: function setBrightness(brightness) {
            this._brightness = brightness;
            $(this._container).css('-webkit-filter', 'brightness(' + this._brightness * 100 + '%)');
            $(this._container).css('filter', 'brightness(' + this._brightness * 100 + '%)');
        },

        getBrightness: function getBrightness() {
            return this._brightness !== undefined ? this._brightness : 1;
        }
    });

    module.exports = Image;
})();

},{}],74:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var boolQueryCheck = require('../query/Bool');

    function mod(n, m) {
        return (n % m + m) % m;
    }

    var Live = L.Class.extend({

        options: {
            transform: function transform(val) {
                return val;
            }
        },

        initialize: function initialize(meta) {
            var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            // set renderer
            if (options.rendererClass) {
                var renderer = void 0;
                // recursively extend and initialize
                if (options.rendererClass.prototype) {
                    renderer = new options.rendererClass();
                } else {
                    renderer = options.rendererClass;
                }
                // extend this object
                $.extend(true, this, renderer);
                // copy prototype options property by value, this is important
                this.options = $.extend(true, {}, this.options);
                delete options.rendererClass;
            }
            // set options
            L.setOptions(this, options);
            // set meta
            this._meta = meta;
            // set params
            this._params = {
                binning: {}
            };
            // set extrema / cache
            this._cache = {};
            this.clearExtrema();
        },

        clearExtrema: function clearExtrema() {
            this._extrema = {
                min: Number.MAX_VALUE,
                max: 0
            };
        },

        getExtrema: function getExtrema() {
            return this._extrema;
        },

        updateExtrema: function updateExtrema(data) {
            var extrema = this.extractExtrema(data);
            var changed = false;
            if (extrema.min < this._extrema.min) {
                changed = true;
                this._extrema.min = extrema.min;
            }
            if (extrema.max > this._extrema.max) {
                changed = true;
                this._extrema.max = extrema.max;
            }
            return changed;
        },

        extractExtrema: function extractExtrema(data) {
            return {
                min: _.min(data),
                max: _.max(data)
            };
        },

        setQuery: function setQuery(query) {
            if (!query.must && !query.must_not && !query.should) {
                throw 'Root query must have at least one `must`, `must_not`, or `should` argument.';
            }
            // check that the query is valid
            boolQueryCheck(this._meta, query);
            // set query
            this._params.must = query.must;
            this._params.must_not = query.must_not;
            this._params.should = query.should;
            // cleat extrema
            this.clearExtrema();
        },

        getQuery: function getQuery() {
            return {
                must: this._params.must,
                must_not: this._params.must_not,
                should: this._params.should
            };
        },

        clearQuery: function clearQuery() {
            // clear query
            this._params.must = undefined;
            this._params.must_not = undefined;
            this._params.should = undefined;
            // cleat extrema
            this.clearExtrema();
        },

        getMeta: function getMeta() {
            return this._meta;
        },

        getParams: function getParams() {
            return this._params;
        },

        getNormalizedCoords: function getNormalizedCoords(coords) {
            var pow = Math.pow(2, coords.z);
            return {
                x: mod(coords.x, pow),
                y: mod(coords.y, pow),
                z: coords.z
            };
        },

        cacheKeyFromCoord: function cacheKeyFromCoord(coords, normalize) {
            if (normalize) {
                // leaflet layer x and y may be > n^2, and < 0 in the case
                // of a wraparound. If normalize is true, mod the coords
                coords = this.getNormalizedCoords(coords);
            }
            return coords.z + ':' + coords.x + ':' + coords.y;
        },

        coordFromCacheKey: function coordFromCacheKey(key) {
            var arr = key.split(':');
            return {
                x: parseInt(arr[1], 10),
                y: parseInt(arr[2], 10),
                z: parseInt(arr[0], 10)
            };
        },

        onTileUnload: function onTileUnload(event) {
            var coords = event.coords;
            // respect the TMS setting in the options
            if (this.options.tms) {
                coords = {
                    x: event.coords.x,
                    y: Math.pow(2, event.coords.z) - 1 - event.coords.y,
                    z: event.coords.z
                };
            }
            // cache key from coords
            var key = this.cacheKeyFromCoord(coords);
            // cache key from normalized coords
            var nkey = this.cacheKeyFromCoord(coords, true);
            // get cache entry
            var cached = this._cache[nkey];
            // could the be case where the cache is cleared before tiles are
            // unloaded
            if (!cached) {
                return;
            }
            // remove the tile from the cache
            delete cached.tiles[key];
            // don't remove cache entry unless to tiles use it anymore
            if (_.keys(cached.tiles).length === 0) {
                // get the tile being deleted
                var tile = cached.tiles[key];
                // no more tiles use this cached data, so delete it
                this.fire('cacheunload', {
                    tile: tile,
                    coords: coords,
                    entry: cached
                });
                delete this._cache[nkey];
            }
        },

        _requestTile: function _requestTile(coords, tile, callback) {
            var _this = this;

            // respect the TMS setting in the options
            if (this.options.tms) {
                coords = {
                    x: coords.x,
                    y: Math.pow(2, coords.z) - 1 - coords.y,
                    z: coords.z
                };
            }
            var ncoords = this.getNormalizedCoords(coords);
            // cache key from coords
            var key = this.cacheKeyFromCoord(coords);
            // cache key from normalized coords
            var nkey = this.cacheKeyFromCoord(coords, true);
            // check cache
            var cached = this._cache[nkey];
            if (cached) {
                // add tile under normalize coords
                cached.tiles[key] = tile;
                if (!cached.isPending) {
                    // cache entry already exists
                    this.fire('cachehit', {
                        tile: tile,
                        coords: coords,
                        entry: cached
                    });
                    // execute callback
                    window.requestAnimationFrame(callback);
                } else {
                    // tile is already pending, add callback
                    cached.callbacks.push(callback);
                }
            } else {
                // create a cache entry
                this._cache[nkey] = {
                    isPending: true,
                    tiles: {},
                    data: null,
                    callbacks: [callback]
                };
                // add tile to the cache entry
                this._cache[nkey].tiles[key] = tile;
                // request the tile
                this.requestTile(ncoords, function (data) {
                    var cached = _this._cache[nkey];
                    if (!cached) {
                        // tile is no longer being tracked, ignore
                        return;
                    }
                    // flag as no longer pending
                    cached.isPending = false;
                    // transform and store tile data in cache
                    cached.data = _this.options.transform(data);
                    // execute pending callbacks
                    cached.callbacks.forEach(function (callback) {
                        callback();
                    });
                    cached.callbacks = [];
                    // data is loaded into cache
                    _this.fire('cacheload', {
                        tile: tile,
                        coords: coords,
                        entry: cached
                    });
                    if (cached.data) {
                        // update the extrema
                        if (_this.updateExtrema(cached.data)) {
                            // if extrema changed, fire event
                            _this.fire('extremachange', {
                                tile: tile,
                                coords: coords,
                                entry: cached
                            });
                        }
                    }
                });
            }
        },

        requestTile: function requestTile() {
            // override
        }

    });

    module.exports = Live;
})();

},{"../query/Bool":80}],75:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Base = require('./Base');

    function mod(n, m) {
        return (n % m + m) % m;
    }

    var Pending = Base.extend({

        options: {
            unloadInvisibleTiles: true,
            zIndex: 5000
        },

        initialize: function initialize(options) {
            this._pendingTiles = {};
            // set renderer
            if (!options.rendererClass) {
                throw 'No `rendererClass` option found.';
            } else {
                // recursively extend
                $.extend(true, this, options.rendererClass);
            }
            // set options
            L.setOptions(this, options);
        },

        add: function add(layer) {
            var _this = this;

            layer._incrementHandler = function (tile) {
                _this._increment(tile.coords);
            };
            layer._decrementHandler = function (tile) {
                _this._decrement(tile.coords);
            };
            layer.on('tilestartload', layer._incrementHandler);
            layer.on('tileload', layer._decrementHandler);
            layer.on('tileerror', layer._decrementHandler);
        },

        remove: function remove(layer) {
            layer.off('tilestartload', layer._incrementHandler);
            layer.off('tileload', layer._decrementHandler);
            layer.off('tileerror', layer._decrementHandler);
            layer._incrementHandler = null;
            layer._decrementHandler = null;
        },

        _increment: function _increment(coord) {
            var _this2 = this;

            var hash = this._getTileHash(coord);
            if (this._pendingTiles[hash] === undefined) {
                this._pendingTiles[hash] = 1;
                var tiles = this._getTilesWithHash(hash);
                tiles.forEach(function (tile) {
                    _this2._updateTile(coord, tile);
                });
            } else {
                this._pendingTiles[hash]++;
            }
        },

        _decrement: function _decrement(coord) {
            var _this3 = this;

            var hash = this._getTileHash(coord);
            this._pendingTiles[hash]--;
            if (this._pendingTiles[hash] === 0) {
                delete this._pendingTiles[hash];
                var tiles = this._getTilesWithHash(hash);
                tiles.forEach(function (tile) {
                    _this3._updateTile(coord, tile);
                });
            }
        },

        _getTileClass: function _getTileClass(hash) {
            return 'leaflet-pending-' + hash;
        },

        _getNormalizedCoords: function _getNormalizedCoords(coords) {
            var pow = Math.pow(2, coords.z);
            return {
                x: mod(coords.x, pow),
                y: mod(coords.y, pow),
                z: coords.z
            };
        },

        _getTileHash: function _getTileHash(coords) {
            var ncoords = this._getNormalizedCoords(coords);
            return ncoords.z + '-' + ncoords.x + '-' + ncoords.y;
        },

        _getTilesWithHash: function _getTilesWithHash(hash) {
            var _this4 = this;

            var className = this._getTileClass(hash);
            var tiles = [];
            $(this._container).find('.' + className).each(function () {
                tiles.push(_this4);
            });
            return tiles;
        },

        _updateTile: function _updateTile(coord, tile) {
            // get hash
            var hash = this._getTileHash(coord);
            $(tile).addClass(this._getTileClass(hash) + ' pending');
            if (this._pendingTiles[hash] > 0) {
                this.renderTile(tile, coord);
            } else {
                $(tile).removeClass('pending');
                tile.innerHTML = '';
            }
        },

        createTile: function createTile(coord) {
            // create a <div> element for drawing
            var tile = L.DomUtil.create('div', 'leaflet-tile leaflet-tile-pending');
            // get hash
            this._updateTile(coord, tile);
            // pass tile to callback
            return tile;
        },

        renderTile: function renderTile() {
            // override
        }

    });

    module.exports = Pending;
})();

},{"./Base":70}],76:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    // debug tile layer

    var Debug = require('./core/Debug');

    // pending tile layer
    var Pending = require('./core/Pending');

    // image layer
    var Image = require('./core/Image');

    // composite layer
    var Composite = require('./core/Composite');

    // live layer - base type for extension
    var Live = require('./core/Live');

    // live tile layers
    var Heatmap = require('./type/Heatmap');
    var TopTrails = require('./type/TopTrails');
    var TopCount = require('./type/TopCount');
    var TopFrequency = require('./type/TopFrequency');
    var TopicCount = require('./type/TopicCount');
    var TopicFrequency = require('./type/TopicFrequency');
    var Preview = require('./type/Preview');
    var Macro = require('./type/Macro');
    var Micro = require('./type/Micro');
    var Count = require('./type/Count');
    var Community = require('./type/Community');

    module.exports = {
        Debug: Debug,
        Pending: Pending,
        Image: Image,
        Composite: Composite,
        Live: Live,
        Heatmap: Heatmap,
        TopCount: TopCount,
        TopTrails: TopTrails,
        TopFrequency: TopFrequency,
        TopicCount: TopicCount,
        TopicFrequency: TopicFrequency,
        Preview: Preview,
        Macro: Macro,
        Micro: Micro,
        Count: Count,
        Community: Community
    };
})();

},{"./core/Composite":71,"./core/Debug":72,"./core/Image":73,"./core/Live":74,"./core/Pending":75,"./type/Community":87,"./type/Count":88,"./type/Heatmap":89,"./type/Macro":90,"./type/Micro":91,"./type/Preview":92,"./type/TopCount":93,"./type/TopFrequency":94,"./type/TopTrails":95,"./type/TopicCount":96,"./type/TopicFrequency":97}],77:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DEFAULT_RESOLUTION = 256;

    var Tiling = require('./Tiling');

    var setResolution = function setResolution(resolution) {
        if (resolution !== this._params.binning.resolution) {
            this._params.binning.resolution = resolution;
            this.clearExtrema();
        }
        return this;
    };

    var getResolution = function getResolution() {
        return this._params.binning.resolution || DEFAULT_RESOLUTION;
    };

    module.exports = {
        // tiling
        setXField: Tiling.setXField,
        getXField: Tiling.getXField,
        setYField: Tiling.setYField,
        getYField: Tiling.getYField,
        getLayerPointFromDataPoint: Tiling.getLayerPointFromDataPoint,
        getDataPointFromLayerPoint: Tiling.getDataPointFromLayerPoint,
        DEFAULT_X_FIELD: Tiling.DEFAULT_X_FIELD,
        DEFAULT_Y_FIELD: Tiling.DEFAULT_Y_FIELD,
        DEFAULT_PIXEL_MAX: Tiling.DEFAULT_PIXEL_MAX,
        // binning
        setResolution: setResolution,
        getResolution: getResolution,
        DEFAULT_RESOLUTION: DEFAULT_RESOLUTION
    };
})();

},{"./Tiling":79}],78:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var getTypes = function getTypes() {
        return this._params.elastic ? this._params.elastic.type : undefined;
    };

    var setTypes = function setTypes(types) {
        if (!types) {
            throw 'QueryString `types` are not provided.';
        }
        types = Array.isArray(types) ? types : [types];
        this._params.elastic = {
            types: types
        };
    };

    module.exports = {
        setTypes: setTypes,
        getTypes: getTypes
    };
})();

},{}],79:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var moment = require('moment');

    var DEFAULT_TILE_SIZE = 256;
    var DEFAULT_X_FIELD = 'pixel.x';
    var DEFAULT_Y_FIELD = 'pixel.y';
    var DEFAULT_PIXEL_MIN = 0;
    var DEFAULT_PIXEL_MAX = Math.pow(2, 32);

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.extrema) {
                return true;
            } else {
                throw 'Field `' + field + '` is not ordinal in meta data.';
            }
        } else {
            throw 'Field `' + field + '` is not recognized in meta data.';
        }
        return false;
    };

    var setXField = function setXField(field) {
        if (field !== this._params.binning.x) {
            if (field === DEFAULT_X_FIELD) {
                // reset if default
                this._params.binning.x = DEFAULT_X_FIELD;
                this._params.binning.left = DEFAULT_PIXEL_MIN;
                this._params.binning.right = DEFAULT_PIXEL_MAX;
                this.clearExtrema();
            } else {
                var meta = this._meta[field];
                if (checkField(meta, field)) {
                    this._params.binning.x = field;
                    this._params.binning.left = meta.extrema.min;
                    this._params.binning.right = meta.extrema.max;
                    this.clearExtrema();
                }
            }
        }
        return this;
    };

    var getXField = function getXField() {
        return this._params.binning.x;
    };

    var setYField = function setYField(field) {
        if (field !== this._params.binning.y) {
            if (field === DEFAULT_Y_FIELD) {
                // reset if default
                this._params.binning.y = DEFAULT_Y_FIELD;
                this._params.binning.bottom = DEFAULT_PIXEL_MAX;
                this._params.binning.top = DEFAULT_PIXEL_MIN;
                this.clearExtrema();
            } else {
                var meta = this._meta[field];
                if (checkField(meta, field)) {
                    this._params.binning.y = field;
                    this._params.binning.bottom = meta.extrema.min;
                    this._params.binning.top = meta.extrema.max;
                    this.clearExtrema();
                }
            }
        }
        return this;
    };

    var getYField = function getYField() {
        return this._params.binning.y;
    };

    var getLayerPointFromDataPoint = function getLayerPointFromDataPoint(x, y, zoom) {
        var binning = this._params.binning;
        var tileSize = this.options.tileSize || DEFAULT_TILE_SIZE;
        var pow = Math.pow(2, zoom);
        var extent = tileSize * pow;
        var meta = this.getMeta();

        var left = void 0,
            right = void 0,
            bottom = void 0,
            top = void 0;
        if (meta[binning.x].type === 'date') {
            left = moment(binning.left).valueOf();
            right = moment(binning.right).valueOf();
            x = moment(x).valueOf();
        } else {
            left = binning.left;
            right = binning.right;
        }
        if (meta[binning.y].type === 'date') {
            bottom = moment(binning.bottom).valueOf();
            top = moment(binning.top).valueOf();
            y = moment(y).valueOf();
        } else {
            bottom = binning.bottom;
            top = binning.top;
        }

        var xRange = Math.abs(right - left);
        var yRange = Math.abs(bottom - top);
        var nx = void 0,
            ny = void 0;
        if (left > right) {
            nx = 1 - (x - right) / xRange;
        } else {
            nx = (x - left) / xRange;
        }
        if (top > bottom) {
            ny = 1 - (y - bottom) / yRange;
        } else {
            ny = (y - top) / yRange;
        }
        return {
            x: extent * nx,
            y: extent * ny
        };
    };

    var getDataPointFromLayerPoint = function getDataPointFromLayerPoint(x, y, zoom) {
        var binning = this._params.binning;
        var tileSize = this.options.tileSize || DEFAULT_TILE_SIZE;
        var pow = Math.pow(2, zoom);
        var extent = tileSize * pow;
        var nx = x / extent;
        var ny = y / extent;
        var xRange = Math.abs(binning.right - binning.left);
        var yRange = Math.abs(binning.bottom - binning.top);
        var px = void 0,
            py = void 0;
        if (binning.left > binning.right) {
            px = binning.right + (1 - nx) * xRange;
        } else {
            px = binning.left + nx * xRange;
        }
        if (binning.top > binning.bottom) {
            py = binning.bottom + (1 - ny) * yRange;
        } else {
            py = binning.top + ny * yRange;
        }
        return {
            x: px,
            y: py
        };
    };

    module.exports = {
        setXField: setXField,
        getXField: getXField,
        setYField: setYField,
        getYField: getYField,
        getLayerPointFromDataPoint: getLayerPointFromDataPoint,
        getDataPointFromLayerPoint: getDataPointFromLayerPoint,
        DEFAULT_X_FIELD: DEFAULT_X_FIELD,
        DEFAULT_Y_FIELD: DEFAULT_Y_FIELD,
        DEFAULT_PIXEL_MAX: DEFAULT_PIXEL_MAX
    };
})();

},{"moment":59}],80:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var check = void 0;

    function checkQuery(meta, query) {
        var keys = _.keys(query);
        if (keys.length !== 1) {
            throw 'Bool sub-query must only have a single key, query has multiple keys: `' + JSON.stringify(keys) + '`.';
        }
        var type = keys[0];
        var checkFunc = check[type];
        if (!checkFunc) {
            throw 'Query type `' + type + '` is not recognized.';
        }
        // check query by type
        check[type](meta, query[type]);
    }

    function checkQueries(meta, queries) {
        if (_.isArray(queries)) {
            queries.forEach(function (query) {
                checkQuery(meta, query);
            });
            return queries;
        }
        checkQuery(meta, queries);
        return [queries];
    }

    function checkBool(meta, query) {
        if (!query.must && !query.must_not && !query.should) {
            throw 'Bool must have at least one `must`, `must_not`, or `should` query argument.';
        }
        if (query.must) {
            checkQueries(meta, query.must);
        }
        if (query.must_not) {
            checkQueries(meta, query.must_not);
        }
        if (query.should) {
            checkQueries(meta, query.should);
        }
    }

    check = {
        bool: checkBool,
        exists: require('./Exists'),
        prefix: require('./Prefix'),
        query_string: require('./QueryString'),
        range: require('./Range'),
        terms: require('./Terms'),
        match: require('./Match')
    };

    module.exports = checkBool;
})();

},{"./Exists":81,"./Match":82,"./Prefix":83,"./QueryString":84,"./Range":85,"./Terms":86}],81:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (!meta) {
            throw 'Terms `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'Exists `field` is missing from argument.';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],82:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'Match `field` ' + field + ' is not `string` in meta data.';
            }
        } else {
            throw 'Match `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'Match `field` is missing from argument.';
        }
        if (!query.string) {
            throw 'Match `string` is missing from argument.';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],83:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'Prefix `field` ' + field + ' is not of type `string` in meta data.';
            }
        } else {
            throw 'Prefix `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'Prefix `field` is missing from argument';
        }
        if (query.prefixes === undefined) {
            throw 'Prefix `prefixes` are missing from argument';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],84:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'QueryString `field` ' + field + ' is not `string` in meta data.';
            }
        } else {
            throw 'QueryString `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'QueryString `field` is missing from argument.';
        }
        if (!query.string) {
            throw 'QueryString `string` is missing from argument.';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],85:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (!meta.extrema) {
                throw 'Range `field` ' + field + ' is not ordinal in meta data.';
            }
        } else {
            throw 'Range `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'Range `field` is missing from argument.';
        }
        if (query.from === undefined) {
            throw 'Range `from` is missing from argument.';
        }
        if (query.to === undefined) {
            throw 'Range `to` is missing from argument.';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],86:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'Terms `field` ' + field + ' is not of type `string` in meta data.';
            }
        } else {
            throw 'Terms `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'Terms `field` is missing from argument.';
        }
        if (query.terms === undefined) {
            throw 'Terms `terms` are missing from argument.';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],87:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');

    var Community = Live.extend({

        type: 'community',

        extractExtrema: function extractExtrema() {
            return {
                min: Infinity,
                max: -Infinity
            };
        }
    });

    module.exports = Community;
})();

},{"../core/Live":74}],88:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');

    var Count = Live.extend({

        includes: [
        // params
        Elastic, Tiling],

        type: 'count',

        // extreme not relevant for count tile
        extractExtrema: function extractExtrema() {
            return {
                min: Infinity,
                max: -Infinity
            };
        }
    });

    module.exports = Count;
})();

},{"../core/Live":74,"../param/Elastic":78,"../param/Tiling":79}],89:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Binning = require('../param/Binning');
    var Metric = require('../agg/Metric');

    var Heatmap = Live.extend({

        includes: [
        // params
        Elastic, Binning,
        // aggs
        Metric],

        type: 'heatmap',

        extractExtrema: function extractExtrema(data) {
            var bins = new Float64Array(data);
            return {
                min: _.min(bins),
                max: _.max(bins)
            };
        }

    });

    module.exports = Heatmap;
})();

},{"../agg/Metric":65,"../core/Live":74,"../param/Binning":77,"../param/Elastic":78}],90:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Binning = require('../param/Binning');

    var Macro = Live.extend({

        includes: [
        // params
        Elastic, Binning],

        type: 'macro',

        extractExtrema: function extractExtrema(data) {
            var bins = new Float64Array(data);
            return {
                min: _.min(bins),
                max: _.max(bins)
            };
        }

    });

    module.exports = Macro;
})();

},{"../core/Live":74,"../param/Binning":77,"../param/Elastic":78}],91:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var TopHits = require('../agg/TopHits');

    var Micro = Live.extend({

        includes: [
        // params
        Elastic, Tiling,
        // aggs
        TopHits],

        type: 'micro',

        // extreme not relevant for micro
        extractExtrema: function extractExtrema() {
            return {
                min: Infinity,
                max: -Infinity
            };
        }
    });

    module.exports = Micro;
})();

},{"../agg/TopHits":68,"../core/Live":74,"../param/Elastic":78,"../param/Tiling":79}],92:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Binning = require('../param/Binning');
    var TopHits = require('../agg/TopHits');

    var Preview = Live.extend({

        includes: [
        // params
        Elastic, Binning,
        // aggs
        TopHits],

        type: 'preview',

        // extreme not relevant for preview
        extractExtrema: function extractExtrema() {
            return {
                min: Infinity,
                max: -Infinity
            };
        }
    });

    module.exports = Preview;
})();

},{"../agg/TopHits":68,"../core/Live":74,"../param/Binning":77,"../param/Elastic":78}],93:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var TopTerms = require('../agg/TopTerms');
    var Histogram = require('../agg/Histogram');

    var TopCount = Live.extend({

        includes: [
        // params
        Elastic, Tiling, TopTerms,
        // aggs
        Histogram],

        type: 'top_count'

    });

    module.exports = TopCount;
})();

},{"../agg/Histogram":64,"../agg/TopTerms":69,"../core/Live":74,"../param/Elastic":78,"../param/Tiling":79}],94:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var TopTerms = require('../agg/TopTerms');
    var DateHistogram = require('../agg/DateHistogram');
    var Histogram = require('../agg/Histogram');

    var TopFrequency = Live.extend({

        includes: [
        // params
        Elastic, Tiling,
        // aggs
        TopTerms, DateHistogram, Histogram],

        type: 'top_frequency'

    });

    module.exports = TopFrequency;
})();

},{"../agg/DateHistogram":63,"../agg/Histogram":64,"../agg/TopTerms":69,"../core/Live":74,"../param/Elastic":78,"../param/Tiling":79}],95:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Binning = require('../param/Binning');
    var Terms = require('../agg/Terms');

    var TopTrails = Live.extend({

        includes: [
        // params
        Elastic, Binning,
        // aggs
        Terms],

        type: 'top_trails',

        extractExtrema: function extractExtrema() {
            return {
                min: Infinity,
                max: -Infinity
            };
        }

    });

    module.exports = TopTrails;
})();

},{"../agg/Terms":66,"../core/Live":74,"../param/Binning":77,"../param/Elastic":78}],96:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var TermsFilter = require('../agg/TermsFilter');
    var Histogram = require('../agg/Histogram');

    var TopicCount = Live.extend({

        includes: [
        // params
        Elastic, Tiling,
        // aggs
        TermsFilter, Histogram],

        type: 'topic_count'

    });

    module.exports = TopicCount;
})();

},{"../agg/Histogram":64,"../agg/TermsFilter":67,"../core/Live":74,"../param/Elastic":78,"../param/Tiling":79}],97:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var TermsFilter = require('../agg/TermsFilter');
    var DateHistogram = require('../agg/DateHistogram');
    var Histogram = require('../agg/Histogram');

    var TopicFrequency = Live.extend({

        includes: [
        // params            
        Elastic, Tiling,
        // aggs
        TermsFilter, DateHistogram, Histogram],

        type: 'topic_frequency'

    });

    module.exports = TopicFrequency;
})();

},{"../agg/DateHistogram":63,"../agg/Histogram":64,"../agg/TermsFilter":67,"../core/Live":74,"../param/Elastic":78,"../param/Tiling":79}],98:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var resetMouseCursorStyle = function resetMouseCursorStyle() {
        // we only want this bound ONCE per map
        $(this._container).css('cursor', '');
    };

    var Map = L.Map.extend({

        initialize: function initialize() {
            L.Map.prototype.initialize.apply(this, arguments);
            this.on('mousemove', resetMouseCursorStyle, this);
        }

    });

    module.exports = Map;
})();

},{}],99:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    // cartesian projection in (0,0), (256, 256) coordinate space

    L.Projection.Graph = {

        project: function project(latlng) {
            return new L.Point(latlng.lng, latlng.lat);
        },

        unproject: function unproject(point) {
            return new L.LatLng(point.y, point.x);
        },

        bounds: L.bounds([0, 0], [256, 256])
    };

    module.exports = L.Projection.Graph;
})();

},{}],100:[function(require,module,exports){
arguments[4][61][0].apply(exports,arguments)
},{"./Graph":99,"dup":61}],101:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DOM = require('./DOM');

    var Canvas = DOM.extend({

        onAdd: function onAdd(map) {
            DOM.prototype.onAdd.call(this, map);
            // handlers
            map.on('click', this.onClick, this);
            map.on('mousemove', this.onMouseMove, this);
        },

        onRemove: function onRemove(map) {
            // handlers
            map.off('click', this.onClick, this);
            map.off('mousemove', this.onMouseMove, this);
            DOM.prototype.onRemove.call(this, map);
        },

        createTile: function createTile(coords, done) {
            var tile = L.DomUtil.create('canvas', 'leaflet-tile');
            tile.style['pointer-events'] = 'all';
            tile.width = this.options.tileSize;
            tile.height = this.options.tileSize;
            this._requestTile(coords, tile, function () {
                done(null, tile);
            });
            return tile;
        },

        clearTiles: function clearTiles() {
            var tileSize = this.options.tileSize;
            _.forIn(this._tiles, function (tile) {
                var ctx = tile.el.getContext('2d');
                ctx.clearRect(0, 0, tileSize, tileSize);
            });
        },

        onMouseMove: function onMouseMove() {
            // override
        },

        onClick: function onClick() {
            // override
        }

    });

    module.exports = Canvas;
})();

},{"./DOM":102}],102:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Base = require('../../layer/core/Base');

    var DOM = Base.extend({

        onAdd: function onAdd(map) {
            L.GridLayer.prototype.onAdd.call(this, map);
            map.on('zoomstart', this.clearExtrema, this);
            this.on('tileunload', this.onTileUnload, this);
            this.on('cacheload', this.onCacheLoad, this);
            this.on('cachehit', this.onCacheHit, this);
            this.on('cacheunload', this.onCacheUnload, this);
            this.on('extremachange', this.onExtremaChange, this);
        },

        onRemove: function onRemove(map) {
            L.GridLayer.prototype.onRemove.call(this, map);
            map.off('zoomstart', this.clearExtrema, this);
            this.off('tileunload', this.onTileUnload, this);
            this.off('cacheload', this.onCacheLoad, this);
            this.off('cachehit', this.onCacheHit, this);
            this.off('cacheunload', this.onCacheUnload, this);
            this.off('extremachange', this.onExtremaChange, this);
        },

        onCacheHit: function onCacheHit(event) {
            var cached = event.entry;
            var tile = event.tile;
            var coords = event.coords;
            // data exists, render only this tile
            if (cached.data) {
                this.renderTile(tile, cached.data, coords);
            }
        },

        onCacheLoad: function onCacheLoad(event) {
            var _this = this;

            // same extrema, we are good to render the tiles. In
            // the case of a map with wraparound, we may have
            // multiple tiles dependent on the response, so iterate
            // over each tile and draw it.
            var cached = event.entry;
            var coords = event.coords;
            if (cached.data) {
                _.forIn(cached.tiles, function (tile) {
                    _this.renderTile(tile, cached.data, coords);
                });
            }
        },

        onExtremaChange: function onExtremaChange() {
            var _this2 = this;

            // redraw all tiles
            _.forIn(this._cache, function (cached) {
                _.forIn(cached.tiles, function (tile, key) {
                    if (cached.data) {
                        _this2.renderTile(tile, cached.data, _this2.coordFromCacheKey(key));
                    }
                });
            });
        },

        onCacheUnload: function onCacheUnload() {
            // override
        },

        createTile: function createTile() {
            // override
        },

        renderTile: function renderTile() {
            // override
        }
    });

    module.exports = DOM;
})();

},{"../../layer/core/Base":70}],103:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DOM = require('./DOM');

    var HTML = DOM.extend({

        onAdd: function onAdd(map) {
            var _this = this;

            DOM.prototype.onAdd.call(this, map);
            // handlers
            map.on('click', this.onClick, this);
            $(this._container).on('mousemove', function (event) {
                _this.onMouseMove(event);
            });
            $(this._container).on('mouseover', function (event) {
                _this.onMouseOver(event);
            });
            $(this._container).on('mouseout', function (event) {
                _this.onMouseOut(event);
            });
        },

        onRemove: function onRemove(map) {
            // handlers
            map.off('click', this.onClick, this);
            $(this._container).off('mousemove');
            $(this._container).off('mouseover');
            $(this._container).off('mouseout');
            DOM.prototype.onRemove.call(this, map);
        },

        createTile: function createTile(coords, done) {
            var tile = L.DomUtil.create('div', 'leaflet-tile leaflet-html-tile');
            tile.width = this.options.tileSize;
            tile.height = this.options.tileSize;
            this._requestTile(coords, tile, function () {
                done(null, tile);
            });
            return tile;
        },

        onMouseMove: function onMouseMove() {
            // override
        },

        onMouseOver: function onMouseOver() {
            // override
        },

        onMouseOut: function onMouseOut() {
            // override
        },

        onClick: function onClick() {
            // override
        }

    });

    module.exports = HTML;
})();

},{"./DOM":102}],104:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Base = require('../../layer/core/Base');

    var NO_OP = function NO_OP() {};

    var Overlay = Base.extend({

        options: {
            zIndex: 1
        },

        onAdd: function onAdd(map) {
            this.on('tileunload', this.onTileUnload, this);
            this.on('cacheload', this.onCacheLoad, this);
            this.on('cachehit', this.onCacheHit, this);
            this.on('cacheunload', this.onCacheUnload, this);
            this.on('extremachange', this.onExtremaChange, this);
            this._tiles = {};
            this._initContainer();
            // add event handlers
            map.on('click', this.onClick, this);
            map.on('mousemove', this.onMouseMove, this);
            this._resetView();
            this._update();
        },

        onRemove: function onRemove(map) {
            // remove layer
            this._removeAllTiles();
            L.DomUtil.remove(this._container);
            map._removeZoomLimit(this);
            this._tileZoom = null;
            // remove handlers
            this.off('tileunload', this.onTileUnload, this);
            this.off('cacheload', this.onCacheLoad, this);
            this.off('cachehit', this.onCacheHit, this);
            this.off('cacheunload', this.onCacheUnload, this);
            this.off('extremachange', this.onExtremaChange, this);
            map.off('click', this.onClick, this);
            map.off('mousemove', this.onMouseMove, this);
        },

        // No-op these functions
        _updateOpacity: NO_OP,
        _initTile: NO_OP,
        _updateLevels: NO_OP,
        _removeTilesAtZoom: NO_OP,
        _setZoomTransforms: NO_OP,

        _initContainer: function _initContainer() {
            if (!this._container) {
                this._container = document.createElement('canvas');
                this._container.className += 'leaflet-layer leaflet-zoom-animated';
            }
            this._updateZIndex();
            this.getPane().appendChild(this._container);
        },

        _pruneTiles: function _pruneTiles() {
            var _this = this;

            if (!this._map) {
                return;
            }
            var zoom = this._map.getZoom();
            if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
                this._removeAllTiles();
                return;
            }
            _.forIn(this._tiles, function (tile) {
                tile.retain = tile.current;
            });
            _.forIn(this._tiles, function (tile) {
                if (tile.current && !tile.active) {
                    var coords = tile.coords;
                    if (!_this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                        _this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
                    }
                }
            });
            _.forIn(this._tiles, function (tile, key) {
                if (!tile.retain) {
                    _this._removeTile(key);
                }
            });
        },

        _removeAllTiles: function _removeAllTiles() {
            var _this2 = this;

            _.forIn(this._tiles, function (tile, key) {
                _this2._removeTile(key);
            });
        },

        _invalidateAll: function _invalidateAll() {
            this._removeAllTiles();
            this._tileZoom = null;
        },

        _setView: function _setView(center, zoom, noPrune, noUpdate) {
            var tileZoom = Math.round(zoom);
            if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {
                tileZoom = undefined;
            }
            var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
            if (!noUpdate || tileZoomChanged) {
                this._tileZoom = tileZoom;
                if (this._abortLoading) {
                    this._abortLoading();
                }
                this._resetGrid();
                if (tileZoom !== undefined) {
                    this._update(center);
                }
                if (!noPrune) {
                    this._pruneTiles();
                }
            }
            this._setZoomTransform(center, zoom);
        },

        _setZoomTransform: function _setZoomTransform(center, zoom) {
            var currentCenter = this._map.getCenter();
            var currentZoom = this._map.getZoom();
            var scale = this._map.getZoomScale(zoom, currentZoom);
            var position = L.DomUtil.getPosition(this._container);
            var viewHalf = this._map.getSize().multiplyBy(0.5);
            var currentCenterPoint = this._map.project(currentCenter, zoom);
            var destCenterPoint = this._map.project(center, zoom);
            var centerOffset = destCenterPoint.subtract(currentCenterPoint);
            var topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);
            if (L.Browser.any3d) {
                L.DomUtil.setTransform(this._container, topLeftOffset, scale);
            } else {
                L.DomUtil.setPosition(this._container, topLeftOffset);
            }
        },

        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function _update(center) {
            var map = this._map;
            if (!map) {
                return;
            }
            var zoom = map.getZoom();
            if (center === undefined) {
                center = map.getCenter();
            }
            if (this._tileZoom === undefined) {
                // if out of minzoom/maxzoom
                return;
            }
            var pixelBounds = this._getTiledPixelBounds(center),
                tileRange = this._pxBoundsToTileRange(pixelBounds),
                tileCenter = tileRange.getCenter(),
                queue = [];

            _.forIn(this._tiles, function (tile) {
                tile.current = false;
            });
            // _update just loads more tiles. If the tile zoom level differs too much
            // from the map's, let _setView reset levels and prune old tiles.
            if (Math.abs(zoom - this._tileZoom) > 1) {
                this._setView(center, zoom);
                return;
            }
            // create a queue of coordinates to load tiles from
            var i = void 0,
                j = void 0;
            for (j = tileRange.min.y; j <= tileRange.max.y; j++) {
                for (i = tileRange.min.x; i <= tileRange.max.x; i++) {
                    var coords = new L.Point(i, j);
                    coords.z = this._tileZoom;

                    if (!this._isValidTile(coords)) {
                        continue;
                    }

                    var tile = this._tiles[this._tileCoordsToKey(coords)];
                    if (tile) {
                        tile.current = true;
                    } else {
                        queue.push(coords);
                    }
                }
            }
            // sort tile queue to load tiles in order of their distance to center
            queue.sort(function (a, b) {
                return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
            });
            if (queue.length !== 0) {
                // if its the first batch of tiles to load
                if (!this._loading) {
                    this._loading = true;
                    // @event loading: Event
                    // Fired when the grid layer starts loading tiles
                    this.fire('loading');
                }
                for (i = 0; i < queue.length; i++) {
                    this._addTile(queue[i]);
                }
            }
        },

        _removeTile: function _removeTile(key) {
            var tile = this._tiles[key];
            if (!tile) {
                return;
            }
            delete this._tiles[key];
            // @event tileunload: TileEvent
            // Fired when a tile is removed (e.g. when a tile goes off the screen).
            this.fire('tileunload', {
                coords: this._keyToTileCoords(key)
            });
        },

        createTile: function createTile(coords, done) {
            var tile = {
                coords: coords,
                current: true
            };
            this._requestTile(coords, tile, function () {
                done(null, tile);
            });
            return tile;
        },

        _addTile: function _addTile(coords) {

            var tile = this.createTile(coords, L.bind(this._tileReady, this, coords));
            var key = this._tileCoordsToKey(coords);
            this._tiles[key] = tile;

            // @event tileloadstart: TileEvent
            // Fired when a tile is requested and starts loading.
            this.fire('tileloadstart', {
                coords: coords
            });
        },

        _tileReady: function _tileReady(coords, err, tile) {
            if (!this._map) {
                return;
            }
            if (err) {
                // @event tileerror: TileErrorEvent
                // Fired when there is an error loading a tile.
                this.fire('tileerror', {
                    error: err,
                    tile: tile,
                    coords: coords
                });
            }
            // tile loaded
            tile.loaded = +new Date();
            tile.active = true;
            this._pruneTiles();

            // @event tileload: TileEvent
            // Fired when a tile loads.
            this.fire('tileload', {
                coords: coords,
                tile: tile
            });

            if (this._noTilesToLoad()) {
                this._loading = false;
                // @event load: Event
                // Fired when the grid layer loaded all visible tiles.
                this.fire('load');
                if (L.Browser.ielt9 || !this._map._fadeAnimated) {
                    L.Util.requestAnimFrame(this._pruneTiles, this);
                } else {
                    // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
                    // to trigger a pruning.
                    setTimeout(L.bind(this._pruneTiles, this), 250);
                }
            }
        },

        onCacheHit: function onCacheHit() {
            // override
        },

        onCacheLoad: function onCacheLoad() {
            // override
        },

        onExtremaChange: function onExtremaChange() {
            // override
        },

        onCacheUnload: function onCacheUnload() {
            // override
        },

        onMouseMove: function onMouseMove() {
            // override
        },

        onClick: function onClick() {
            // override
        }

    });

    module.exports = Overlay;
})();

},{"../../layer/core/Base":70}],105:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var esper = require('esper');
    var Overlay = require('./Overlay');

    var WebGL = Overlay.extend({

        onAdd: function onAdd(map) {
            Overlay.prototype.onAdd.call(this, map);
            map.on('zoomstart', this.onZoomStart, this);
            map.on('zoomend', this.onZoomEnd, this);
        },

        onRemove: function onRemove(map) {
            Overlay.prototype.onRemove.call(this, map);
            map.off('zoomstart', this.onZoomStart, this);
            map.off('zoomend', this.onZoomEnd, this);
        },

        onZoomStart: function onZoomStart() {
            this._isZooming = true;
        },

        onZoomEnd: function onZoomEnd() {
            this._isZooming = false;
            if (this._initialized) {
                var gl = this._gl;
                gl.clear(gl.COLOR_BUFFER_BIT);
                this.renderFrame();
            }
        },

        _initContainer: function _initContainer() {
            Overlay.prototype._initContainer.call(this);
            if (!this._gl) {
                this._initGL();
            } else {
                this._draw();
            }
            this._isZooming = false;
        },

        onWebGLInit: function onWebGLInit(done) {
            done(null);
        },

        _initGL: function _initGL() {
            var _this = this;

            var gl = this._gl = esper.WebGLContext.get(this._container);
            // handle missing context
            if (!gl) {
                throw 'Unable to acquire a WebGL context';
            }
            // init the webgl state
            gl.clearColor(0, 0, 0, 0);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            gl.disable(gl.DEPTH_TEST);
            // get map size
            var size = this._map.getSize();
            var devicePixelRatio = window.devicePixelRatio;
            // set viewport size
            this._viewport = new esper.Viewport({
                width: size.x * devicePixelRatio,
                height: size.y * devicePixelRatio
            });
            // set canvas size
            this._gl.canvas.style.width = size.x + 'px';
            this._gl.canvas.style.height = size.y + 'px';
            // webgl init callback
            this.onWebGLInit(function (err) {
                if (err) {
                    console.error(err);
                    return;
                }
                // flag as ready
                _this._initialized = true;
                // start draw loop
                _this._draw();
            });
        },

        getTranslationMatrix: function getTranslationMatrix(x, y, z) {
            var mat = new Float32Array(16);
            mat[0] = 1;
            mat[1] = 0;
            mat[2] = 0;
            mat[3] = 0;
            mat[4] = 0;
            mat[5] = 1;
            mat[6] = 0;
            mat[7] = 0;
            mat[8] = 0;
            mat[9] = 0;
            mat[10] = 1;
            mat[11] = 0;
            mat[12] = x;
            mat[13] = y;
            mat[14] = z;
            mat[15] = 1;
            return mat;
        },

        getOrthoMatrix: function getOrthoMatrix(left, right, bottom, top, near, far) {
            var mat = new Float32Array(16);
            mat[0] = 2 / (right - left);
            mat[1] = 0;
            mat[2] = 0;
            mat[3] = 0;
            mat[4] = 0;
            mat[5] = 2 / (top - bottom);
            mat[6] = 0;
            mat[7] = 0;
            mat[8] = 0;
            mat[9] = 0;
            mat[10] = -2 / (far - near);
            mat[11] = 0;
            mat[12] = -((right + left) / (right - left));
            mat[13] = -((top + bottom) / (top - bottom));
            mat[14] = -((far + near) / (far - near));
            mat[15] = 1;
            return mat;
        },

        _positionContainer: function _positionContainer() {
            var size = this._map.getSize();
            var devicePixelRatio = window.devicePixelRatio;
            // set viewport size
            this._viewport.resize(size.x * devicePixelRatio, size.y * devicePixelRatio);
            // set canvas size
            this._gl.canvas.style.width = size.x + 'px';
            this._gl.canvas.style.height = size.y + 'px';
            // re-position container
            var topLeft = this._map.containerPointToLayerPoint([0, 0]);
            L.DomUtil.setPosition(this._container, topLeft);
        },

        _draw: function _draw() {
            if (this._map && this._initialized) {
                if (!this.isHidden()) {
                    // re-position canvas
                    if (!this._isZooming) {
                        // position the container and resize viewport
                        this._positionContainer();
                        // clear buffer
                        var gl = this._gl;
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        // draw the frame
                        this.renderFrame();
                    }
                }
                requestAnimationFrame(this._draw.bind(this));
            }
        },

        renderFrame: function renderFrame() {
            // implement this
        }

    });

    module.exports = WebGL;
})();

},{"./Overlay":104,"esper":50}],106:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Core = {
        HTML: require('./core/HTML'),
        WebGL: require('./core/WebGL'),
        Canvas: require('./core/Canvas')
    };

    // canvas renderers
    var Canvas = {
        Heatmap: require('./type/canvas/Heatmap'),
        TopTrails: require('./type/canvas/TopTrails'),
        Preview: require('./type/canvas/Preview')
    };

    // html renderers
    var HTML = {
        Empty: require('./type/html/Empty'),
        Heatmap: require('./type/html/Heatmap'),
        Ring: require('./type/html/Ring'),
        WordCloud: require('./type/html/WordCloud'),
        WordHistogram: require('./type/html/WordHistogram'),
        Community: require('./type/html/Community'),
        CommunityLabel: require('./type/html/CommunityLabel')
    };

    // webgl renderers
    var WebGL = {
        Heatmap: require('./type/webgl/Heatmap'),
        Point: require('./type/webgl/Point')
    };

    // pending layer renderers
    var Pending = {
        DelayedBlink: require('./type/pending/DelayedBlink'),
        DelayedSpin: require('./type/pending/DelayedSpin'),
        Blink: require('./type/pending/Blink'),
        Spin: require('./type/pending/Spin'),
        BlinkSpin: require('./type/pending/BlinkSpin')
    };

    // pending layer renderers
    var Debug = {
        Coord: require('./type/debug/Coord')
    };

    module.exports = {
        Core: Core,
        HTML: HTML,
        Canvas: Canvas,
        WebGL: WebGL,
        Debug: Debug,
        Pending: Pending
    };
})();

},{"./core/Canvas":101,"./core/HTML":103,"./core/WebGL":105,"./type/canvas/Heatmap":111,"./type/canvas/Preview":112,"./type/canvas/TopTrails":113,"./type/debug/Coord":114,"./type/html/Community":115,"./type/html/CommunityLabel":116,"./type/html/Empty":117,"./type/html/Heatmap":118,"./type/html/Ring":119,"./type/html/WordCloud":120,"./type/html/WordHistogram":121,"./type/pending/Blink":122,"./type/pending/BlinkSpin":123,"./type/pending/DelayedBlink":124,"./type/pending/DelayedSpin":125,"./type/pending/Spin":126,"./type/webgl/Heatmap":127,"./type/webgl/Point":128}],107:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var NUM_GRADIENT_STEPS = 100;

    function rgb2lab(rgb) {
        var r = rgb[0] > 0.04045 ? Math.pow((rgb[0] + 0.055) / 1.055, 2.4) : rgb[0] / 12.92;
        var g = rgb[1] > 0.04045 ? Math.pow((rgb[1] + 0.055) / 1.055, 2.4) : rgb[1] / 12.92;
        var b = rgb[2] > 0.04045 ? Math.pow((rgb[2] + 0.055) / 1.055, 2.4) : rgb[2] / 12.92;
        //Observer. = 2°, Illuminant = D65
        var x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;
        var y = r * 0.2126729 + g * 0.7151522 + b * 0.0721750;
        var z = r * 0.0193339 + g * 0.1191920 + b * 0.9503041;
        x = x / 0.95047; // Observer= 2°, Illuminant= D65
        y = y / 1.00000;
        z = z / 1.08883;
        x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 16 / 116;
        y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787037 * y + 16 / 116;
        z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787037 * z + 16 / 116;
        return [116 * y - 16, 500 * (x - y), 200 * (y - z), rgb[3]];
    }

    function lab2rgb(lab) {
        var y = (lab[0] + 16) / 116;
        var x = y + lab[1] / 500;
        var z = y - lab[2] / 200;
        x = x > 0.206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
        y = y > 0.206893034 ? y * y * y : (y - 4 / 29) / 7.787037;
        z = z > 0.206893034 ? z * z * z : (z - 4 / 29) / 7.787037;
        x = x * 0.95047; // Observer= 2°, Illuminant= D65
        y = y * 1.00000;
        z = z * 1.08883;
        var r = x * 3.2404542 + y * -1.5371385 + z * -0.4985314;
        var g = x * -0.9692660 + y * 1.8760108 + z * 0.0415560;
        var b = x * 0.0556434 + y * -0.2040259 + z * 1.0572252;
        r = r > 0.00304 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : 12.92 * r;
        g = g > 0.00304 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : 12.92 * g;
        b = b > 0.00304 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : 12.92 * b;
        return [Math.max(Math.min(r, 1), 0), Math.max(Math.min(g, 1), 0), Math.max(Math.min(b, 1), 0), lab[3]];
    }

    function distance(c1, c2) {
        return Math.sqrt((c1[0] - c2[0]) * (c1[0] - c2[0]) + (c1[1] - c2[1]) * (c1[1] - c2[1]) + (c1[2] - c2[2]) * (c1[2] - c2[2]) + (c1[3] - c2[3]) * (c1[3] - c2[3]));
    }

    var buildFlatLookupTable = function buildFlatLookupTable(color) {
        var output = [];
        for (var i = 0; i < NUM_GRADIENT_STEPS; i++) {
            output.push(color[0]);
            output.push(color[1]);
            output.push(color[2]);
            output.push(color[3]);
        }
        return output;
    };

    // Interpolate between a set of colors using even perceptual distance and interpolation in CIE L*a*b* space
    var buildPerceptualLookupTable = function buildPerceptualLookupTable(baseColors) {
        var buffer = new ArrayBuffer(NUM_GRADIENT_STEPS * 4 * 4);
        var outputGradient = new Float32Array(buffer);
        // Calculate perceptual spread in L*a*b* space
        var labs = _.map(baseColors, function (color) {
            return rgb2lab([color[0] / 255, color[1] / 255, color[2] / 255, color[3] / 255]);
        });
        var distances = _.map(labs, function (color, index, colors) {
            return index > 0 ? distance(color, colors[index - 1]) : 0;
        });
        // Calculate cumulative distances in [0,1]
        var totalDistance = _.reduce(distances, function (a, b) {
            return a + b;
        }, 0);
        distances = _.map(distances, function (d) {
            return d / totalDistance;
        });
        var distanceTraversed = 0;
        var key = 0;
        var progress = void 0;
        var stepProgress = void 0;
        var rgb = void 0;
        for (var i = 0; i < NUM_GRADIENT_STEPS; i++) {
            progress = i / (NUM_GRADIENT_STEPS - 1);
            if (progress > distanceTraversed + distances[key + 1] && key + 1 < labs.length - 1) {
                key += 1;
                distanceTraversed += distances[key];
            }
            stepProgress = (progress - distanceTraversed) / distances[key + 1];
            rgb = lab2rgb([labs[key][0] + (labs[key + 1][0] - labs[key][0]) * stepProgress, labs[key][1] + (labs[key + 1][1] - labs[key][1]) * stepProgress, labs[key][2] + (labs[key + 1][2] - labs[key][2]) * stepProgress, labs[key][3] + (labs[key + 1][3] - labs[key][3]) * stepProgress]);
            outputGradient[i * 4] = rgb[0];
            outputGradient[i * 4 + 1] = rgb[1];
            outputGradient[i * 4 + 2] = rgb[2];
            outputGradient[i * 4 + 3] = rgb[3];
        }
        return outputGradient;
    };

    var COOL = buildPerceptualLookupTable([[0x04, 0x20, 0x40, 0x50], [0x08, 0x40, 0x81, 0x7f], [0x08, 0x68, 0xac, 0xff], [0x2b, 0x8c, 0xbe, 0xff], [0x4e, 0xb3, 0xd3, 0xff], [0x7b, 0xcc, 0xc4, 0xff], [0xa8, 0xdd, 0xb5, 0xff], [0xcc, 0xeb, 0xc5, 0xff], [0xe0, 0xf3, 0xdb, 0xff], [0xf7, 0xfc, 0xf0, 0xff]]);

    var HOT = buildPerceptualLookupTable([[0x40, 0x00, 0x13, 0x50], [0x80, 0x00, 0x26, 0x7f], [0xbd, 0x00, 0x26, 0xff], [0xe3, 0x1a, 0x1c, 0xff], [0xfc, 0x4e, 0x2a, 0xff], [0xfd, 0x8d, 0x3c, 0xff], [0xfe, 0xb2, 0x4c, 0xff], [0xfe, 0xd9, 0x76, 0xff], [0xff, 0xed, 0xa0, 0xff]]);

    var VERDANT = buildPerceptualLookupTable([[0x00, 0x40, 0x26, 0x50], [0x00, 0x5a, 0x32, 0x7f], [0x23, 0x84, 0x43, 0xff], [0x41, 0xab, 0x5d, 0xff], [0x78, 0xc6, 0x79, 0xff], [0xad, 0xdd, 0x8e, 0xff], [0xd9, 0xf0, 0xa3, 0xff], [0xf7, 0xfc, 0xb9, 0xff], [0xff, 0xff, 0xe5, 0xff]]);

    var SPECTRAL = buildPerceptualLookupTable([[0x26, 0x1a, 0x40, 0x50], [0x44, 0x2f, 0x72, 0x7f], [0xe1, 0x2b, 0x02, 0xff], [0x02, 0xdc, 0x01, 0xff], [0xff, 0xd2, 0x02, 0xff], [0xff, 0xff, 0xff, 0xff]]);

    var TEMPERATURE = buildPerceptualLookupTable([[0x00, 0x16, 0x40, 0x50], [0x00, 0x39, 0x66, 0x7f], [0x31, 0x3d, 0x66, 0xff], [0xe1, 0x2b, 0x02, 0xff], [0xff, 0xd2, 0x02, 0xff], [0xff, 0xff, 0xff, 0xff]]);

    var GREYSCALE = buildPerceptualLookupTable([[0x00, 0x00, 0x00, 0x7f], [0x40, 0x40, 0x40, 0xff], [0xff, 0xff, 0xff, 0xff]]);

    var POLAR_HOT = buildPerceptualLookupTable([[0xff, 0x44, 0x00, 0xff], [0xbd, 0xbd, 0xbd, 0xb0]]);

    var POLAR_COLD = buildPerceptualLookupTable([[0xbd, 0xbd, 0xbd, 0xb0], [0x32, 0xa5, 0xf9, 0xff]]);

    var FIRE = buildPerceptualLookupTable([[0x96, 0x00, 0x00, 0x96], [0xff, 0xff, 0x32, 0xff]]);

    var FLAT = buildFlatLookupTable([0xff, 0xff, 0xff, 0xff]);

    var buildLookupFunction = function buildLookupFunction(RAMP) {
        return function (scaledValue, inColor) {
            var index = Math.floor(scaledValue * (NUM_GRADIENT_STEPS - 1));
            inColor[0] = RAMP[index * 4];
            inColor[1] = RAMP[index * 4 + 1];
            inColor[2] = RAMP[index * 4 + 2];
            inColor[3] = RAMP[index * 4 + 3];
            return inColor;
        };
    };

    var concat = function concat(a, b) {
        var combined = new Float32Array(a.length + b.length);
        combined.set(a, 0);
        combined.set(b, a.length);
        return combined;
    };

    var ColorTables = {
        cool: COOL,
        hot: HOT,
        verdant: VERDANT,
        spectral: SPECTRAL,
        temperature: TEMPERATURE,
        grey: GREYSCALE,
        polar: concat(POLAR_HOT, POLAR_COLD),
        flat: FLAT
    };

    var ColorRamp = {
        cool: buildLookupFunction(COOL),
        hot: buildLookupFunction(HOT),
        verdant: buildLookupFunction(VERDANT),
        spectral: buildLookupFunction(SPECTRAL),
        temperature: buildLookupFunction(TEMPERATURE),
        grey: buildLookupFunction(GREYSCALE),
        fire: buildLookupFunction(FIRE),
        polar: buildLookupFunction(concat(POLAR_HOT, POLAR_COLD)),
        flat: buildLookupFunction(FLAT)
    };

    var setColorRamp = function setColorRamp(type, baseColors) {
        var func = ColorRamp[type.toLowerCase()];
        if (func) {
            this._colorRamp = func;
        } else if (baseColors) {
            ColorRamp[type.toLowerCase()] = buildLookupFunction(buildPerceptualLookupTable(baseColors));
            this._colorRamp = ColorRamp[type.toLowerCase()];
        }
        this._colorRampType = type.toLowerCase();
        return this;
    };

    var getColorRamp = function getColorRamp(type) {
        return this._colorRamp || ColorRamp[type.toLowerCase()];
    };

    var getColorRampTable = function getColorRampTable() {
        return ColorTables[this._colorRampType];
    };

    var initialize = function initialize() {
        this._colorRamp = ColorRamp.verdant;
        this._colorRampType = 'verdant';
    };

    module.exports = {
        initialize: initialize,
        setColorRamp: setColorRamp,
        getColorRamp: getColorRamp,
        getColorRampTable: getColorRampTable,
        NUM_GRADIENT_STEPS: NUM_GRADIENT_STEPS
    };
})();

},{}],108:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var TILE_SIZE = 256;

    function fract(f) {
        return f % 1;
    }

    function mod(n, m) {
        return (n % m + m) % m;
    }

    function getHash(lx, ly, radius) {
        var diameter = radius * 2;
        var xHash = Math.floor(lx / diameter);
        var yHash = Math.floor(ly / diameter);
        return xHash + ':' + yHash;
    }

    function getHashes(lx, ly, radius, zoom) {
        var diameter = radius * 2;
        var numCells = Math.ceil(Math.pow(2, zoom) * TILE_SIZE / diameter);
        var x = lx / diameter;
        var y = ly / diameter;
        var fx = fract(x);
        var fy = fract(y);
        var px = fx > 0.5;
        var nx = fx < 0.5;
        var py = fy > 0.5;
        var ny = fy < 0.5;
        var cx = Math.floor(x);
        var cy = Math.floor(y);
        var cells = [[cx, cy]];
        if (px) {
            cells.push([cx + 1, cy]);
        }
        if (py) {
            cells.push([cx, cy + 1]);
        }
        if (nx) {
            cells.push([cx - 1, cy]);
        }
        if (ny) {
            cells.push([cx, cy - 1]);
        }
        if (nx && ny) {
            cells.push([cx - 1, cy - 1]);
        }
        if (px && py) {
            cells.push([cx + 1, cy + 1]);
        }
        if (nx && py) {
            cells.push([cx - 1, cy + 1]);
        }
        if (px && ny) {
            cells.push([cx + 1, cy - 1]);
        }
        // return hashes
        return cells.map(function (cell) {
            // mod the cell coords if they overflow
            cell[0] = mod(cell[0], numCells);
            cell[1] = mod(cell[1], numCells);
            // hash
            return cell[0] + ':' + cell[1];
        });
    }

    function circleCollision(point, origin, radius, zoom) {
        var dim = Math.pow(2, zoom) * TILE_SIZE;
        var p = void 0,
            o = void 0;
        // check cases where the point is near the opposing horizontal extrema
        // of the map and ensure that the distance calculated is the shortest
        if (point.x < radius && dim - origin.x < radius) {
            p = point;
            o = {
                x: origin.x - dim,
                y: origin.y
            };
        } else if (dim - point.x < radius && origin.x < radius) {
            p = {
                x: point.x - dim,
                y: point.y
            };
            o = origin;
        } else {
            p = point;
            o = origin;
        }
        var dx = p.x - o.x;
        var dy = p.y - o.y;
        var distSqr = dx * dx + dy * dy;
        if (distSqr < radius * radius) {
            return true;
        }
        return false;
    }

    function initialize() {
        this.clearHash();
    }

    function clearHash() {
        this._spatialHash = {};
    }

    function addPoint(point, radius, zoom) {
        // spatial hash key
        var x = point.x;
        var y = point.y;
        var hashes = getHashes(x, y, radius, zoom);
        // add pixel to hash
        var i = void 0;
        for (i = 0; i < hashes.length; i++) {
            var hash = hashes[i];
            this._spatialHash[hash] = this._spatialHash[hash] || [];
            this._spatialHash[hash].push(point);
        }
    }

    function removePoint(point, radius, zoom) {
        // spatial hash key
        var hashes = getHashes(point.x, point.y, radius, zoom);
        // add pixel to hash
        var i = void 0;
        for (i = 0; i < hashes.length; i++) {
            var hash = hashes[i];
            var points = this._spatialHash[hash];
            if (points) {
                var index = points.indexOf(point);
                if (index >= 0) {
                    points.splice(index, 1);
                }
            }
        }
    }

    function pick(point, radius, zoom) {
        var hash = getHash(point.x, point.y, radius);
        // get points in bin
        var points = this._spatialHash[hash];
        if (points) {
            // find first intersecting point in the bin
            var p = void 0,
                i = void 0;
            for (i = 0; i < points.length; i++) {
                p = points[i];
                // check for collision
                if (circleCollision(point, p, radius, zoom)) {
                    // return first point
                    return p;
                }
            }
        }
    }

    module.exports = {
        initialize: initialize,
        clearHash: clearHash,
        addPoint: addPoint,
        removePoint: removePoint,
        pick: pick
    };
})();

},{}],109:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var SIGMOID_SCALE = 0.15;

    // log10

    function log10Transform(val, min, max) {
        var logMin = Math.log10(min || 1);
        var logMax = Math.log10(max || 1);
        var logVal = Math.log10(val || 1);
        return (logVal - logMin) / (logMax - logMin || 1);
    }

    function inverseLog10Transform(nval, min, max) {
        var logMin = Math.log10(min || 1);
        var logMax = Math.log10(max || 1);
        return Math.pow(10, nval * logMax - nval * logMin + logMin);
    }

    // sigmoid

    function sigmoidTransform(val, min, max) {
        var absMin = Math.abs(min);
        var absMax = Math.abs(max);
        var distance = Math.max(absMin, absMax);
        var scaledVal = val / (SIGMOID_SCALE * distance);
        return 1 / (1 + Math.exp(-scaledVal));
    }

    function inverseSigmoidTransform(nval, min, max) {
        var absMin = Math.abs(min);
        var absMax = Math.abs(max);
        var distance = Math.max(absMin, absMax);
        if (nval === 0) {
            return -distance;
        }
        if (nval === 1) {
            return distance;
        }
        return Math.log(1 / nval - 1) * -(SIGMOID_SCALE * distance);
    }

    // linear

    function linearTransform(val, min, max) {
        var range = max - min;
        if (range === 0) {
            return 1;
        }
        return (val - min) / range;
    }

    function inverseLinearTransform(nval, min, max) {
        var range = max - min;
        if (range === 0) {
            return 1;
        }
        return min + nval * range;
    }

    var Transform = {
        linear: linearTransform,
        log10: log10Transform,
        sigmoid: sigmoidTransform
    };

    var Inverse = {
        linear: inverseLinearTransform,
        log10: inverseLog10Transform,
        sigmoid: inverseSigmoidTransform
    };

    var initialize = function initialize() {
        this._range = {
            min: 0,
            max: 1
        };
        this._transformFunc = log10Transform;
        this._inverseFunc = inverseLog10Transform;
    };

    var setTransformFunc = function setTransformFunc(type) {
        var func = type.toLowerCase();
        this._transformFunc = Transform[func];
        this._transformType = type;
        this._inverseFunc = Inverse[func];
    };

    var setValueRange = function setValueRange(range) {
        this._range.min = range.min;
        this._range.max = range.max;
    };

    var getValueRange = function getValueRange() {
        return this._range;
    };

    var getTransformEnum = function getTransformEnum() {
        if (this._transformType === 'linear') {
            return 1;
        } else if (this._transformType === 'sigmoid') {
            return 2;
        }
        return 0;
    };

    var interpolateToRange = function interpolateToRange(nval) {
        // interpolate between the filter range
        var rMin = this._range.min;
        var rMax = this._range.max;
        var rval = (nval - rMin) / (rMax - rMin);
        // ensure output is [0:1]
        return Math.max(0, Math.min(1, rval));
    };

    var transformValue = function transformValue(val) {
        // clamp the value between the extreme (shouldn't be necessary)
        var min = this._extrema.min;
        var max = this._extrema.max;
        var clamped = Math.max(Math.min(val, max), min);
        // normalize the value
        if (min !== max) {
            return this._transformFunc(clamped, min, max);
        }
        // if min === max, always return 1
        return 1;
    };

    var untransformValue = function untransformValue(nval) {
        var min = this._extrema.min;
        var max = this._extrema.max;
        // clamp the value between the extreme (shouldn't be necessary)
        var clamped = Math.max(Math.min(nval, 1), 0);
        // unnormalize the value
        if (min !== max) {
            return this._inverseFunc(clamped, min, max);
        }
        // if min === max, always return 1
        return 1;
    };

    module.exports = {
        initialize: initialize,
        setTransformFunc: setTransformFunc,
        setValueRange: setValueRange,
        getValueRange: getValueRange,
        getTransformEnum: getTransformEnum,
        transformValue: transformValue,
        untransformValue: untransformValue,
        interpolateToRange: interpolateToRange
    };
})();

},{}],110:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var POSITIVE = '1';
    var NEUTRAL = '0';
    var NEGATIVE = '-1';

    function getClassFunc(min, max) {
        min = min !== undefined ? min : -1;
        max = max !== undefined ? max : 1;
        var positive = [0.25 * max, 0.5 * max, 0.75 * max];
        var negative = [-0.25 * min, -0.5 * min, -0.75 * min];
        return function (sentiment) {
            var prefix = void 0;
            var range = void 0;
            if (sentiment < 0) {
                prefix = 'neg-';
                range = negative;
            } else {
                prefix = 'pos-';
                range = positive;
            }
            var abs = Math.abs(sentiment);
            if (abs > range[2]) {
                return prefix + '4';
            } else if (abs > range[1]) {
                return prefix + '3';
            } else if (abs > range[0]) {
                return prefix + '2';
            }
            return prefix + '1';
        };
    }

    function getTotal(count) {
        if (!count) {
            return 0;
        }
        var pos = count[POSITIVE] ? count[POSITIVE] : 0;
        var neu = count[NEUTRAL] ? count[NEUTRAL] : 0;
        var neg = count[NEGATIVE] ? count[NEGATIVE] : 0;
        return pos + neu + neg;
    }

    function getAvg(count) {
        if (!count) {
            return 0;
        }
        var pos = count[POSITIVE] ? count[POSITIVE] : 0;
        var neu = count[NEUTRAL] ? count[NEUTRAL] : 0;
        var neg = count[NEGATIVE] ? count[NEGATIVE] : 0;
        var total = pos + neu + neg;
        return total !== 0 ? (pos - neg) / total : 0;
    }

    module.exports = {
        getClassFunc: getClassFunc,
        getTotal: getTotal,
        getAvg: getAvg
    };
})();

},{}],111:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Canvas = require('../../core/Canvas');
    var ColorRamp = require('../../mixin/ColorRamp');
    var ValueTransform = require('../../mixin/ValueTransform');

    var Heatmap = Canvas.extend({

        includes: [
        // mixins
        ColorRamp, ValueTransform],

        initialize: function initialize() {
            ColorRamp.initialize.apply(this, arguments);
            ValueTransform.initialize.apply(this, arguments);
        },

        renderCanvas: function renderCanvas(bins, resolution, ramp) {
            var canvas = document.createElement('canvas');
            canvas.height = resolution;
            canvas.width = resolution;
            var ctx = canvas.getContext('2d');
            var imageData = ctx.getImageData(0, 0, resolution, resolution);
            var data = imageData.data;
            var color = [0, 0, 0, 0];
            var nval = void 0,
                rval = void 0,
                bin = void 0,
                i = void 0;
            for (i = 0; i < bins.length; i++) {
                bin = bins[i];
                if (bin === 0) {
                    color[0] = 0;
                    color[1] = 0;
                    color[2] = 0;
                    color[3] = 0;
                } else {
                    nval = this.transformValue(bin);
                    rval = this.interpolateToRange(nval);
                    ramp(rval, color);
                }
                data[i * 4] = Math.round(color[0] * 255);
                data[i * 4 + 1] = Math.round(color[1] * 255);
                data[i * 4 + 2] = Math.round(color[2] * 255);
                data[i * 4 + 3] = Math.round(color[3] * 255);
            }
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        },

        renderTile: function renderTile(canvas, data) {
            if (!data) {
                return;
            }
            var bins = new Float64Array(data);
            var resolution = Math.sqrt(bins.length);
            var ramp = this.getColorRamp();
            var tileCanvas = this.renderCanvas(bins, resolution, ramp);
            var ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(tileCanvas, 0, 0, resolution, resolution, 0, 0, canvas.width, canvas.height);
        }

    });

    module.exports = Heatmap;
})();

},{"../../core/Canvas":101,"../../mixin/ColorRamp":107,"../../mixin/ValueTransform":109}],112:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function () {

    'use strict';

    var Canvas = require('../../core/Canvas');

    var Preview = Canvas.extend({

        options: {
            lineWidth: 1,
            lineColor: '#fff'
        },

        highlighted: false,

        _drawHighlight: function _drawHighlight(canvas, x, y, size) {
            var ctx = canvas.getContext('2d');
            ctx.beginPath();
            ctx.fillStyle = this.options.fillColor;
            ctx.rect(x * size, y * size, size, size);
            ctx.lineWidth = this.options.lineWidth;
            ctx.strokeStyle = this.options.lineColor;
            ctx.stroke();
        },

        onMouseMove: function onMouseMove(e) {
            var _this = this;

            var target = e.originalEvent.target;
            if (this.highlighted) {
                // clear existing highlight
                this.clearTiles();
            }
            // get layer coord
            var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
            // get tile coord
            var coord = this.getTileCoordFromLayerPoint(layerPoint);
            // get cache key
            var nkey = this.cacheKeyFromCoord(coord, true);
            // get cache entry
            var cached = this._cache[nkey];
            if (cached && cached.data) {
                var _ret = function () {
                    // get bin coordinate
                    var bin = _this.getBinCoordFromLayerPoint(layerPoint);
                    // get bin data entry
                    var data = cached.data[bin.index];
                    if (data) {
                        // for each tile relying on that data
                        _.forIn(cached.tiles, function (tile) {
                            _this._drawHighlight(tile, bin.x, bin.y, bin.size);
                        });
                        var collision = {
                            value: data,
                            x: coord.x,
                            y: coord.z,
                            z: coord.z,
                            bx: bin.x,
                            by: bin.y,
                            type: 'preview',
                            layer: _this
                        };
                        if (!_this.highlighted) {
                            // execute callback
                            _this.fire('mouseover', {
                                elem: target,
                                value: collision
                            });
                        }
                        // flag as highlighted
                        _this.highlighted = collision;
                        // set cursor
                        $(_this._map._container).css('cursor', 'pointer');
                        return {
                            v: void 0
                        };
                    }
                }();

                if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
            }
            // mouse out
            if (this.highlighted) {
                this.fire('mouseout', {
                    elem: target,
                    value: this.highlighted
                });
            }
            // clear highlighted flag
            this.highlighted = null;
        }

    });

    module.exports = Preview;
})();

},{"../../core/Canvas":101}],113:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Canvas = require('../../core/Canvas');
    var ColorRamp = require('../../mixin/ColorRamp');
    var ValueTransform = require('../../mixin/ValueTransform');

    var TopTrails = Canvas.extend({

        includes: [
        // mixins
        ColorRamp, ValueTransform],

        options: {
            selectedColor: [255, 100, 255, 255],
            highlightedColor: [200, 0, 255, 255],
            downSampleFactor: 8
        },

        highlighted: null,

        selected: null,

        initialize: function initialize() {
            ColorRamp.initialize.apply(this, arguments);
            ValueTransform.initialize.apply(this, arguments);
        },

        clearHighlight: function clearHighlight() {
            if (this.highlighted) {
                this.highlighted = null;
                this.clearTiles();
            }
        },

        clearSelection: function clearSelection() {
            if (this.selected) {
                this.selected = null;
                this.clearTiles();
            }
        },

        setSelection: function setSelection(value) {
            this.clearSelection();
            this.selected = value;
        },

        setHighlight: function setHighlight(value) {
            this.clearHighlight();
            this.highlighted = value;
        },

        onClick: function onClick(e) {
            var target = e.originalEvent.target;
            var bin = this._getBinData(e);
            if (bin) {
                // execute callback
                this.fire('click', {
                    elem: target,
                    value: bin
                });
                // flag as selected
                this.setSelection(bin);
                this._highlightTrails();
                return;
            }
            // clear selected flag
            this.clearSelection();
            this._highlightTrails();
        },

        onMouseMove: function onMouseMove(e) {
            var target = e.originalEvent.target;
            var bin = this._getBinData(e);
            if (bin) {
                // execute callback
                if (!this.highlighted) {
                    this.fire('mouseover', {
                        elem: target,
                        value: bin
                    });
                }
                // flag as highlighted
                this.setHighlight(bin);
                this._highlightTrails();
                // set cursor
                $(this._map._container).css('cursor', 'pointer');
                // exit early
                return;
            }
            // mouse out
            if (this.highlighted) {
                this.fire('mouseout', {
                    elem: target,
                    value: this.highlighted
                });
            }
            this.clearHighlight();
            this._highlightTrails();
        },

        _getBinData: function _getBinData(e) {
            // get layer coord
            var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
            // get tile coord
            var coord = this.getTileCoordFromLayerPoint(layerPoint);
            // get cache key
            var nkey = this.cacheKeyFromCoord(coord, true);
            // get cache entry
            var cached = this._cache[nkey];
            if (cached && cached.pixels) {
                // get bin coordinate
                var bin = this.getBinCoordFromLayerPoint(layerPoint);
                // downsample the bin res
                var x = Math.floor(bin.x / this.options.downSampleFactor);
                var y = Math.floor(bin.y / this.options.downSampleFactor);
                // if hits a pixel
                if (cached.pixels[x] && cached.pixels[x][y]) {
                    var ids = Object.keys(cached.pixels[x][y]);
                    // take first entry
                    var id = ids[0];
                    // create collision object
                    var collision = {
                        value: id,
                        x: coord.x,
                        y: coord.z,
                        z: coord.z,
                        bx: bin.x,
                        by: bin.y,
                        type: 'top-trails',
                        layer: this
                    };
                    return collision;
                }
            }
            return null;
        },

        _highlightTrailsForData: function _highlightTrailsForData(cached) {
            var _this = this;

            var selected = this.selected;
            var highlighted = this.highlighted;
            if (cached.data) {
                (function () {
                    var trail = void 0;
                    if (selected) {
                        trail = cached.trails[selected.value];
                        if (trail) {
                            // for each tile relying on that data
                            _.forIn(cached.tiles, function (tile) {
                                _this._renderTrail(tile, trail, _this.options.selectedColor);
                            });
                        }
                    }
                    if (highlighted) {
                        trail = cached.trails[highlighted.value];
                        if (trail) {
                            _.forIn(cached.tiles, function (tile) {
                                _this._renderTrail(tile, trail, _this.options.highlightedColor);
                            });
                        }
                    }
                })();
            }
        },

        _highlightTrails: function _highlightTrails() {
            var _this2 = this;

            _.forIn(this._cache, function (cached) {
                _this2._highlightTrailsForData(cached);
            });
        },

        _renderTrail: function _renderTrail(canvas, pixels, color) {
            var resolution = this.getResolution();
            var highlight = document.createElement('canvas');
            highlight.height = resolution;
            highlight.width = resolution;
            var highlightCtx = highlight.getContext('2d');
            var imageData = highlightCtx.getImageData(0, 0, resolution, resolution);
            var data = imageData.data;
            var pixel = void 0,
                x = void 0,
                y = void 0,
                i = void 0,
                j = void 0;
            for (i = 0; i < pixels.length; i++) {
                pixel = pixels[i];
                x = pixel[0];
                y = pixel[1];
                j = x + resolution * y;
                data[j * 4] = color[0];
                data[j * 4 + 1] = color[1];
                data[j * 4 + 2] = color[2];
                data[j * 4 + 3] = color[3];
            }
            highlightCtx.putImageData(imageData, 0, 0);
            // draw to tile
            var ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(highlight, 0, 0, resolution, resolution, 0, 0, canvas.width, canvas.height);
        },

        renderTile: function renderTile(container, data, coord) {
            if (!data) {
                return;
            }
            // modify cache entry
            var nkey = this.cacheKeyFromCoord(coord, true);
            var cached = this._cache[nkey];
            if (cached.trails) {
                // trails already added, exit early
                return;
            }
            var trails = cached.trails = {};
            var pixels = cached.pixels = {};
            var ids = Object.keys(data);
            var bins = void 0,
                bin = void 0;
            var id = void 0,
                i = void 0,
                j = void 0;
            var rx = void 0,
                ry = void 0,
                x = void 0,
                y = void 0;
            for (i = 0; i < ids.length; i++) {
                id = ids[i];
                bins = data[id];
                for (j = 0; j < bins.length; j++) {
                    bin = bins[j];
                    // down sample the pixel to make interaction easier
                    rx = Math.floor(bin[0] / this.options.downSampleFactor);
                    ry = Math.floor(bin[1] / this.options.downSampleFactor);
                    pixels[rx] = pixels[rx] || {};
                    pixels[rx][ry] = pixels[rx][ry] || {};
                    pixels[rx][ry][id] = true;
                    // add pixel under the trail at correct resolution
                    x = bin[0];
                    y = bin[1];
                    trails[id] = trails[id] || [];
                    trails[id].push([x, y]);
                }
            }
            // make sure to highlight selected trails in the tile
            this._highlightTrailsForData(cached);
        }

    });

    module.exports = TopTrails;
})();

},{"../../core/Canvas":101,"../../mixin/ColorRamp":107,"../../mixin/ValueTransform":109}],114:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    module.exports = {

        renderTile: function renderTile(elem, coord) {
            $(elem).empty();
            $(elem).append('<div style="top:0; left:0;">' + coord.z + ', ' + coord.x + ', ' + coord.y + '</div>');
        }

    };
})();

},{}],115:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');

    var Community = HTML.extend({

        _getBinCoordFromCartesian: function _getBinCoordFromCartesian(px, py, zoom) {
            // Coords are named lon/lat, but are actually in the range [0, 255].
            // The Leaflet map is setup to use a custom projection to reflect this on
            // creation.
            var layerPt = this._getLayerPointFromLonLat({
                'lon': px,
                'lat': py
            }, zoom);
            var res = this.getBinCoordFromLayerPoint(layerPt, 256);
            return res;
        },

        // render community rings
        renderTile: function renderTile(container, data, coord) {
            var _this = this;

            if (!data) {
                return;
            }
            var dataView = new DataView(data);
            var decoder = new TextDecoder('utf-8');
            var decodedString = decoder.decode(dataView);
            var jsonObj = JSON.parse(decodedString);

            var divs = $();
            _.forEach(jsonObj.communities, function (community) {
                if (community.numNodes > 1) {
                    var div = _this._createRingDiv(community.radius, community.coords, coord.z, 'community-ring');
                    div.data('name', community.metadata);
                    div.data('count', community.numNodes);
                    divs = divs.add(div);
                }
            });
            $(container).append(divs);
        },

        // forward community metadata string to app level mousemove handler when pointer is
        // over a community ring
        onMouseOver: function onMouseOver(e) {
            var target = $(e.originalEvent.target);
            var value = { name: target.data('name'), count: target.data('count') };
            if (!value) {
                value = {};
            }
            this.fire('mouseover', {
                elem: e.originalEvent.target,
                value: value,
                type: 'community',
                layer: this
            });
        },

        // forward cleared string to app level mousemove handler when pointer moves off
        // a community ring
        onMouseOut: function onMouseOut(e) {
            this.fire('mouseout', {
                elem: e.originalEvent.target,
                type: 'community',
                layer: this
            });
        },

        _createRingDiv: function _createRingDiv(communityRadius, communityCoords, zoomLevel, className) {
            var radius = Math.max(4, communityRadius * Math.pow(2, zoomLevel));
            var offset = radius / 2;
            var binCoord = this._getBinCoordFromCartesian(communityCoords[0], communityCoords[1], zoomLevel);
            var left = binCoord.x;
            var top = binCoord.y;

            return $('\n                <div class="' + className + '" style="\n                    left: ' + (left - offset) + 'px;\n                    top: ' + (top - offset) + 'px;\n                    width: ' + radius + 'px;\n                    height: ' + radius + 'px;">\n                </div>\n                ');
        }
    });

    module.exports = Community;
})();

},{"../../core/HTML":103}],116:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');

    var CommunityLabel = HTML.extend({

        options: {
            labelScale: 1.0,
            labelMaxLength: 200,
            labelThreshold: [[0, 5000], [10, 100], [14, 10], [16, 0]]
        },

        initialize: function initialize() {
            var _this = this;

            // expand thresholds for lookups during rendering
            this.labelThreshold = [];
            if (this.options.labelThreshold.length === 1) {
                this.labelThreshold = this.options.labelThreshold;
            } else {
                _.forEach(_.dropRight(this.options.labelThreshold, 1), function (v, i) {
                    var next = _this.options.labelThreshold[i + 1];
                    var step = next[0] - v[0];
                    _this.labelThreshold = _this.labelThreshold.concat(_.zip(_.range(v[0], next[0]), _.fill(Array(step), v[1])));
                });
                this.labelThreshold.push(_.last(this.options.labelThreshold));
            }
        },

        // render community rings
        renderTile: function renderTile(container, data, coord) {
            var _this2 = this;

            if (!data) {
                return;
            }
            var dataView = new DataView(data);
            var decoder = new TextDecoder('utf-8');
            var decodedString = decoder.decode(dataView);
            var jsonObj = JSON.parse(decodedString);

            var divs = $();
            _.forEach(jsonObj.communities, function (community) {
                var idx = _.clamp(coord.z, 0, _this2.labelThreshold.length - 1);
                if (community.numNodes > _this2.labelThreshold[idx][1]) {
                    var div = _this2._createLabelDiv(community.coords, community.radius, coord.z, community.metadata, 'community-label');
                    div.data('name', community.metadata);
                    div.data('count', community.numNodes);
                    divs = divs.add(div);
                }
            });
            $(container).append(divs);
        },

        // forward community metadata string to app level mousemove handler when pointer is
        // over a community ring
        onMouseOver: function onMouseOver(e) {
            var target = $(e.originalEvent.target);
            var value = { name: target.data('name'), count: target.data('count') };
            if (!value) {
                value = {};
            }
            this.fire('mouseover', {
                elem: e.originalEvent.target,
                value: value,
                type: 'community-labels',
                layer: this
            });
        },

        // forward cleared string to app level mousemove handler when pointer moves off
        // a community ring
        onMouseOut: function onMouseOut(e) {
            this.fire('mouseout', {
                elem: e.originalEvent.target,
                type: 'community-labels',
                layer: this
            });
        },

        _getBinCoordFromCartesian: function _getBinCoordFromCartesian(px, py, zoom) {
            // Coords are named lon/lat, but are actually in the range [0, 255].
            // The Leaflet map is setup to use a custom projection to reflect this on
            // creation.
            var layerPt = this._getLayerPointFromLonLat({
                'lon': px,
                'lat': py
            }, zoom);
            var res = this.getBinCoordFromLayerPoint(layerPt, 256);
            return res;
        },

        _createLabelDiv: function _createLabelDiv(communityCoords, communityRadius, zoomLevel, label, className) {
            var radius = Math.max(16, communityRadius * Math.pow(2, zoomLevel));
            var binCoord = this._getBinCoordFromCartesian(communityCoords[0], communityCoords[1], zoomLevel);
            var left = binCoord.x - this.options.labelMaxLength / 2;
            var top = binCoord.y - radius / 2;
            return $('\n                <div class="' + className + ' ' + radius + '" style="\n                    left: ' + left + 'px;\n                    top: ' + top + 'px;\n                    line-height: ' + radius + 'px;">' + label + '</div>\n                ');
        }
    });

    module.exports = CommunityLabel;
})();

},{"../../core/HTML":103}],117:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');

    var Empty = HTML.extend({});

    module.exports = Empty;
})();

},{"../../core/HTML":103}],118:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');
    var ColorRamp = require('../../mixin/ColorRamp');
    var ValueTransform = require('../../mixin/ValueTransform');

    var Heatmap = HTML.extend({

        includes: [
        // mixins
        ColorRamp, ValueTransform],

        initialize: function initialize() {
            ColorRamp.initialize.apply(this, arguments);
            ValueTransform.initialize.apply(this, arguments);
        },

        onMouseOver: function onMouseOver(e) {
            var target = $(e.originalEvent.target);
            var value = target.attr('data-value');
            if (value) {
                var $parent = target.parents('.leaflet-html-tile');
                this.fire('mouseover', {
                    elem: e.originalEvent.target,
                    value: parseInt(value, 10),
                    x: parseInt($parent.attr('data-x'), 10),
                    y: parseInt($parent.attr('data-y'), 10),
                    z: this._map.getZoom(),
                    bx: parseInt(target.attr('data-bx'), 10),
                    by: parseInt(target.attr('data-by'), 10),
                    type: 'heatmap',
                    layer: this
                });
            }
        },

        onMouseOut: function onMouseOut(e) {
            var target = $(e.originalEvent.target);
            var value = target.attr('data-value');
            if (value) {
                var $parent = target.parents('.leaflet-html-tile');
                this.fire('mouseout', {
                    elem: e.originalEvent.target,
                    value: parseInt(value, 10),
                    x: parseInt($parent.attr('data-x'), 10),
                    y: parseInt($parent.attr('data-y'), 10),
                    z: this._map.getZoom(),
                    bx: parseInt(target.attr('data-bx'), 10),
                    by: parseInt(target.attr('data-by'), 10),
                    type: 'heatmap',
                    layer: this
                });
            }
        },

        onClick: function onClick(e) {
            // un-select any prev selected pixel
            $('.heatmap-pixel').removeClass('highlight');
            // get target
            var target = $(e.originalEvent.target);
            if (!this.isTargetLayer(e.originalEvent.target)) {
                // this layer is not the target
                return;
            }
            if (target.hasClass('heatmap-pixel')) {
                target.addClass('highlight');
            }
            var value = target.attr('data-value');
            if (value) {
                var $parent = target.parents('.leaflet-html-tile');
                this.fire('click', {
                    elem: e.originalEvent.target,
                    value: parseInt(value, 10),
                    x: parseInt($parent.attr('data-x'), 10),
                    y: parseInt($parent.attr('data-y'), 10),
                    z: this._map.getZoom(),
                    bx: parseInt(target.attr('data-bx'), 10),
                    by: parseInt(target.attr('data-by'), 10),
                    type: 'heatmap',
                    layer: this
                });
            }
        },

        renderTile: function renderTile(container, data) {
            if (!data) {
                return;
            }
            var bins = new Float64Array(data);
            var resolution = Math.sqrt(bins.length);
            var ramp = this.getColorRamp();
            var pixelSize = this.options.tileSize / resolution;
            var color = [0, 0, 0, 0];
            var html = '';
            var nval = void 0,
                rval = void 0,
                bin = void 0;
            var left = void 0,
                top = void 0;
            var i = void 0;
            for (i = 0; i < bins.length; i++) {
                bin = bins[i];
                if (bin === 0) {
                    continue;
                } else {
                    left = i % resolution;
                    top = Math.floor(i / resolution);
                    nval = this.transformValue(bin);
                    rval = this.interpolateToRange(nval);
                    ramp(rval, color);
                }
                var r = Math.round(color[0] * 255);
                var g = Math.round(color[1] * 255);
                var b = Math.round(color[2] * 255);
                var a = color[3];
                var rgba = 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';
                html += '\n                    <div class="heatmap-pixel"\n                        data-value="' + bin + '"\n                        data-bx="' + left + '"\n                        data-by="' + top + '"\n                        style="\n                            height: ' + pixelSize + 'px;\n                            width: ' + pixelSize + 'px;\n                            left: ' + left * pixelSize + 'px;\n                            top: ' + top * pixelSize + 'px;\n                            background-color: ' + rgba + ';">\n                    </div>\n                    ';
            }
            container.innerHTML = html;
        }

    });

    module.exports = Heatmap;
})();

},{"../../core/HTML":103,"../../mixin/ColorRamp":107,"../../mixin/ValueTransform":109}],119:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');
    var ValueTransform = require('../../mixin/ValueTransform');

    var Heatmap = HTML.extend({

        includes: [
        // mixins
        ValueTransform],

        initialize: function initialize() {
            ValueTransform.initialize.apply(this, arguments);
        },

        onClick: function onClick(e) {
            var target = $(e.originalEvent.target);
            $('.heatmap-ring').removeClass('highlight');
            if (!this.isTargetLayer(e.originalEvent.target)) {
                // this layer is not the target
                return;
            }
            if (target.hasClass('heatmap-ring')) {
                target.addClass('highlight');
            }
        },

        renderTile: function renderTile(container, data) {
            var _this = this;

            if (!data) {
                return;
            }
            var bins = new Float64Array(data);
            var resolution = Math.sqrt(bins.length);
            var binSize = this.options.tileSize / resolution;
            var html = '';
            bins.forEach(function (bin, index) {
                if (!bin) {
                    return;
                }
                var percent = _this.transformValue(bin);
                var radius = percent * binSize;
                var offset = (binSize - radius) / 2;
                var left = index % resolution * binSize;
                var top = Math.floor(index / resolution) * binSize;
                html += '\n                    <div class="heatmap-ring" style="\n                        left: ' + (left + offset) + 'px;\n                        top: ' + (top + offset) + 'px;\n                        width: ' + radius + 'px;\n                        height: ' + radius + 'px;">\n                    </div>\n                    ';
            });
            container.innerHTML = html;
        }

    });

    module.exports = Heatmap;
})();

},{"../../core/HTML":103,"../../mixin/ValueTransform":109}],120:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');
    var ValueTransform = require('../../mixin/ValueTransform');
    var sentiment = require('../../sentiment/Sentiment');
    var sentimentFunc = sentiment.getClassFunc(-1, 1);

    var VERTICAL_OFFSET = 24;
    var HORIZONTAL_OFFSET = 10;
    var NUM_ATTEMPTS = 1;

    /**
     * Given an initial position, return a new position, incrementally spiralled
     * outwards.
     */
    var spiralPosition = function spiralPosition(pos) {
        var pi2 = 2 * Math.PI;
        var circ = pi2 * pos.radius;
        var inc = pos.arcLength > circ / 10 ? circ / 10 : pos.arcLength;
        var da = inc / pos.radius;
        var nt = pos.t + da;
        if (nt > pi2) {
            nt = nt % pi2;
            pos.radius = pos.radius + pos.radiusInc;
        }
        pos.t = nt;
        pos.x = pos.radius * Math.cos(nt);
        pos.y = pos.radius * Math.sin(nt);
        return pos;
    };

    /**
     *  Returns true if bounding box a intersects bounding box b
     */
    var intersectTest = function intersectTest(a, b) {
        return Math.abs(a.x - b.x) * 2 < a.width + b.width && Math.abs(a.y - b.y) * 2 < a.height + b.height;
    };

    /**
     *  Returns true if bounding box a is not fully contained inside bounding box b
     */
    var overlapTest = function overlapTest(a, b) {
        return a.x + a.width / 2 > b.x + b.width / 2 || a.x - a.width / 2 < b.x - b.width / 2 || a.y + a.height / 2 > b.y + b.height / 2 || a.y - a.height / 2 < b.y - b.height / 2;
    };

    /**
     * Check if a word intersects another word, or is not fully contained in the
     * tile bounding box
     */
    var intersectWord = function intersectWord(position, word, cloud, bb) {
        var box = {
            x: position.x,
            y: position.y,
            height: word.height,
            width: word.width
        };
        var i = void 0;
        for (i = 0; i < cloud.length; i++) {
            if (intersectTest(box, cloud[i])) {
                return true;
            }
        }
        // make sure it doesn't intersect the border;
        if (overlapTest(box, bb)) {
            // if it hits a border, increment collision count
            // and extend arc length
            position.collisions++;
            position.arcLength = position.radius;
            return true;
        }
        return false;
    };

    var WordCloud = HTML.extend({

        includes: [
        // mixins
        ValueTransform],

        options: {
            maxNumWords: 15,
            minFontSize: 10,
            maxFontSize: 20
        },

        initialize: function initialize() {
            ValueTransform.initialize.apply(this, arguments);
        },

        clearSelection: function clearSelection() {
            $(this._container).removeClass('highlight');
            this.highlight = null;
        },

        setHighlight: function setHighlight(word) {
            this.clearSelection();
            // Highlight selected word
            $(this._container).addClass('highlight');
            $('.word-cloud-label[data-word="' + word + '"]').addClass('highlight');
            this.highlight = word;
        },

        onMouseOver: function onMouseOver(e) {
            var target = $(e.originalEvent.target);
            $('.word-cloud-label').removeClass('hover');
            var word = target.attr('data-word');
            if (word) {
                // highlight all instances of the word
                $('.word-cloud-label[data-word="' + word + '"]').addClass('hover');
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('mouseover', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-cloud',
                        layer: this
                    });
                }
            }
        },

        onMouseOut: function onMouseOut(e) {
            var target = $(e.originalEvent.target);
            $('.word-cloud-label').removeClass('hover');
            var word = target.attr('data-word');
            if (word) {
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('mouseout', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-cloud',
                        layer: this
                    });
                }
            }
        },

        onClick: function onClick(e) {
            // un-select any prev selected words
            $('.word-cloud-label').removeClass('highlight');
            $(this._container).removeClass('highlight');
            // get target
            var target = $(e.originalEvent.target);
            if (!this.isTargetLayer(e.originalEvent.target)) {
                // this layer is not the target
                return;
            }
            var word = target.attr('data-word');
            if (word) {
                this.setHighlight(word);
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('click', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-cloud',
                        layer: this
                    });
                }
            } else {
                this.clearSelection();
            }
        },

        _measureWords: function _measureWords(wordCounts) {
            var _this = this;

            // sort words by frequency
            wordCounts = wordCounts.sort(function (a, b) {
                return b.count - a.count;
            }).slice(0, this.options.maxNumWords);
            // build measurement html
            var $html = $('<div style="height:256px; width:256px;"></div>');
            var minFontSize = this.options.minFontSize;
            var maxFontSize = this.options.maxFontSize;
            wordCounts.forEach(function (word) {
                word.percent = _this.transformValue(word.count);
                word.fontSize = minFontSize + word.percent * (maxFontSize - minFontSize);
                $html.append('\n                    <div class="word-cloud-label" style="\n                        visibility:hidden;\n                        font-size: ' + word.fontSize + 'px;">' + word.text + '</div>;\n                    ');
            });
            // append measurements
            $('body').append($html);
            $html.children().each(function (index, elem) {
                wordCounts[index].width = elem.offsetWidth;
                wordCounts[index].height = elem.offsetHeight;
            });
            $html.remove();
            return wordCounts;
        },

        _createWordCloud: function _createWordCloud(wordCounts) {
            var tileSize = this.options.tileSize;
            var boundingBox = {
                width: tileSize - HORIZONTAL_OFFSET * 2,
                height: tileSize - VERTICAL_OFFSET * 2,
                x: 0,
                y: 0
            };
            var cloud = [];
            // sort words by frequency
            wordCounts = this._measureWords(wordCounts);
            // assemble word cloud
            wordCounts.forEach(function (wordCount) {
                // starting spiral position
                var pos = {
                    radius: 1,
                    radiusInc: 5,
                    arcLength: 10,
                    x: 0,
                    y: 0,
                    t: 0,
                    collisions: 0
                };
                // spiral outwards to find position
                while (pos.collisions < NUM_ATTEMPTS) {
                    // increment position in a spiral
                    pos = spiralPosition(pos);
                    // test for intersection
                    if (!intersectWord(pos, wordCount, cloud, boundingBox)) {
                        cloud.push({
                            key: wordCount.key,
                            text: wordCount.text,
                            fontSize: wordCount.fontSize,
                            percent: Math.round(wordCount.percent * 100 / 10) * 10, // round to nearest 10
                            x: pos.x,
                            y: pos.y,
                            width: wordCount.width,
                            height: wordCount.height,
                            sentiment: wordCount.sentiment,
                            avg: wordCount.avg
                        });
                        break;
                    }
                }
            });
            return cloud;
        },

        extractExtrema: function extractExtrema(data) {
            var sums = _.map(data, function (count) {
                count = count.counts || count;
                if (_.isNumber(count)) {
                    return count;
                }
                return sentiment.getTotal(count);
            });
            return {
                min: _.min(sums),
                max: _.max(sums)
            };
        },

        getText: function getText(keyData, key) {
            return key;
        },

        renderTile: function renderTile(container, data) {
            var _this2 = this;

            if (!data || _.isEmpty(data)) {
                return;
            }
            var highlight = this.highlight;
            var wordCounts = _.map(data, function (keyData, key) {
                var count = keyData.counts || keyData;
                var text = _this2.getText(keyData, key);
                if (_.isNumber(count)) {
                    return {
                        key: key,
                        text: text,
                        count: count
                    };
                }
                var total = sentiment.getTotal(count);
                var avg = sentiment.getAvg(count);
                return {
                    key: key,
                    text: text,
                    count: total,
                    avg: avg,
                    sentiment: sentimentFunc(avg)
                };
            });
            // exit early if no words
            if (wordCounts.length === 0) {
                return;
            }
            // genereate the cloud
            var cloud = this._createWordCloud(wordCounts);
            // build html elements
            var halfSize = this.options.tileSize / 2;
            var html = '';
            cloud.forEach(function (word) {
                // create classes
                var classNames = ['word-cloud-label', 'word-cloud-label-' + word.percent, word.text === highlight ? 'highlight' : '', word.sentiment ? word.sentiment : ''].join(' ');
                // create styles
                var styles = ['font-size: ' + word.fontSize + 'px', 'left: ' + (halfSize + word.x - word.width / 2) + 'px', 'top: ' + (halfSize + word.y - word.height / 2) + 'px', 'width: ' + word.width + 'px', 'height: ' + word.height + 'px'].join(';');
                // create html for entry
                html += '\n                    <div class="' + classNames + '"\n                        style="' + styles + '"\n                        data-sentiment="' + word.avg + '"\n                        data-word="' + word.key + '">' + word.text + '</div>\n                    ';
            });
            container.innerHTML = html;
        }

    });

    module.exports = WordCloud;
})();

},{"../../core/HTML":103,"../../mixin/ValueTransform":109,"../../sentiment/Sentiment":110}],121:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var _this = this;

    var HTML = require('../../core/HTML');
    var ValueTransform = require('../../mixin/ValueTransform');
    var sentiment = require('../../sentiment/Sentiment');
    var sentimentFunc = sentiment.getClassFunc(-1, 1);

    var isSingleValue = function isSingleValue(count) {
        // single values are never null, and always numbers
        return count !== null && _.isNumber(count);
    };

    var extractCount = function extractCount(count) {
        if (isSingleValue(count)) {
            return count;
        }
        return sentiment.getTotal(count);
    };

    var extractSentimentClass = function extractSentimentClass(avg) {
        if (avg !== undefined) {
            return sentimentFunc(avg);
        }
        return '';
    };

    var extractFrequency = function extractFrequency(count) {
        count = count.counts || count;
        if (isSingleValue(count)) {
            return {
                count: count
            };
        }
        return {
            count: sentiment.getTotal(count),
            avg: sentiment.getAvg(count)
        };
    };

    var extractAvg = function extractAvg(frequencies) {
        if (frequencies[0].avg === undefined) {
            return;
        }
        var sum = _.sumBy(frequencies, function (frequency) {
            return frequency.avg;
        });
        return sum / frequencies.length;
    };

    var WordHistogram = HTML.extend({

        includes: [
        // mixins
        ValueTransform],

        options: {
            maxNumWords: 8,
            minFontSize: 16,
            maxFontSize: 22
        },

        initialize: function initialize() {
            ValueTransform.initialize.apply(this, arguments);
        },

        clearSelection: function clearSelection() {
            $(this._container).removeClass('highlight');
            this.highlight = null;
        },

        setHighlight: function setHighlight(word) {
            this.clearSelection();
            // Highlight selected word
            $(this._container).addClass('highlight');
            $('.word-histogram-entry[data-word="' + word + '"]').addClass('highlight');
            this.highlight = word;
        },

        onMouseOver: function onMouseOver(e) {
            var target = $(e.originalEvent.target);
            $('.word-histogram-entry').removeClass('hover');
            var word = target.attr('data-word');
            if (word) {
                $('.word-histogram-entry[data-word="' + word + '"]').addClass('hover');
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('mouseover', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-histogram',
                        layer: this
                    });
                }
            }
        },

        onMouseOut: function onMouseOut(e) {
            var target = $(e.originalEvent.target);
            $('.word-histogram-entry').removeClass('hover');
            var word = target.attr('data-word');
            if (word) {
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('mouseout', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-histogram',
                        layer: this
                    });
                }
            }
        },

        onClick: function onClick(e) {
            // un-select and prev selected histogram
            $('.word-histogram-entry').removeClass('highlight');
            $(this._container).removeClass('highlight');
            // get target
            var target = $(e.originalEvent.target);
            if (!this.isTargetLayer(e.originalEvent.target)) {
                // this layer is not the target
                return;
            }
            var word = target.attr('data-word');
            if (word) {
                this.setHighlight(word);
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('mouseover', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-histogram',
                        layer: this
                    });
                }
            } else {
                this.clearSelection();
            }
        },

        extractExtrema: function extractExtrema(data) {
            var sums = _.map(data, function (counts) {
                return _.sumBy(counts, extractCount);
            });
            return {
                min: _.min(sums),
                max: _.max(sums)
            };
        },

        getText: function getText(keyData, key) {
            return key;
        },

        extractValues: function extractValues(data, key) {
            var frequencies = _.map(data, extractFrequency);
            var avg = extractAvg(frequencies);
            var max = _.maxBy(frequencies, function (val) {
                return val.count;
            }).count;
            var total = _.sumBy(frequencies, function (val) {
                return val.count;
            });
            return {
                key: key,
                topic: _this.getText(data, key),
                frequencies: frequencies,
                max: max,
                total: total,
                avg: avg
            };
        },

        renderTile: function renderTile(container, data) {
            var _this2 = this;

            if (!data || _.isEmpty(data)) {
                return;
            }
            var highlight = this.highlight;
            // convert object to array
            var values = _.map(data, this.extractValues).sort(function (a, b) {
                return b.total - a.total;
            });
            // get number of entries
            var numEntries = Math.min(values.length, this.options.maxNumWords);
            var $html = $('<div class="word-histograms" style="display:inline-block;"></div>');
            var totalHeight = 0;
            var minFontSize = this.options.minFontSize;
            var maxFontSize = this.options.maxFontSize;
            values.slice(0, numEntries).forEach(function (value) {
                var key = value.key;
                var topic = value.topic;
                var frequencies = value.frequencies;
                var max = value.max;
                var total = value.total;
                var avg = value.avg;
                var sentimentClass = extractSentimentClass(avg);
                var highlightClass = key === highlight ? 'highlight' : '';
                // scale the height based on level min / max
                var percent = _this2.transformValue(total);
                var percentLabel = Math.round(percent * 100 / 10) * 10;
                var height = minFontSize + percent * (maxFontSize - minFontSize);
                totalHeight += height;
                // create container 'entry' for chart and hashtag
                var $entry = $('\n                    <div class="word-histogram-entry ' + highlightClass + '"\n                        data-sentiment="' + avg + '"\n                        data-word="' + key + '"\n                        style="height:' + height + 'px;">\n                    </div>\n                    ');
                // create chart
                var $chart = $('\n                    <div class="word-histogram-left"\n                        data-sentiment="' + avg + '"\n                        data-word="' + key + '">\n                    </div>\n                    ');
                var barWidth = 'calc(' + 100 / frequencies.length + '%)';
                // create bars
                frequencies.forEach(function (frequency) {
                    var count = frequency.count;
                    var avg = frequency.avg;
                    var sentimentClass = extractSentimentClass(avg);
                    // get the percent relative to the highest count in the tile
                    var relativePercent = max !== 0 ? count / max * 100 : 0;
                    // make invisible if zero count
                    var visibility = relativePercent === 0 ? 'hidden' : '';
                    // Get the style class of the bar
                    var percentLabel = Math.round(relativePercent / 10) * 10;
                    var barClasses = ['word-histogram-bar', 'word-histogram-bar-' + percentLabel, sentimentClass + '-fill'].join(' ');
                    var barHeight = void 0;
                    var barTop = void 0;
                    // ensure there is at least a single pixel of color
                    if (relativePercent / 100 * height < 3) {
                        barHeight = '3px';
                        barTop = 'calc(100% - 3px)';
                    } else {
                        barHeight = relativePercent + '%';
                        barTop = '(100 - relativePercent)%';
                    }
                    // create bar
                    $chart.append('\n                        <div class="' + barClasses + '"\n                            data-word="' + key + '"\n                            style="\n                            visibility: ' + visibility + ';\n                            width: ' + barWidth + ';\n                            height: ' + barHeight + ';\n                            top: ' + barTop + ';">\n                        </div>\n                        ');
                });
                $entry.append($chart);
                var topicClasses = ['word-histogram-label', 'word-histogram-label-' + percentLabel, sentimentClass].join(' ');
                // create tag label
                var $topic = $('\n                    <div class="word-histogram-right">\n                        <div class="' + topicClasses + '"\n                            data-sentiment="' + avg + '"\n                            data-word="' + key + '"\n                        style="\n                            font-size: ' + height + 'px;\n                            line-height: ' + height + 'px;\n                            height: ' + height + 'px;">' + topic + '</div>\n                    </div>\n                    ');
                $entry.append($topic);
                $html.append($entry);
            });
            $html.css('top', this.options.tileSize / 2 - totalHeight / 2);
            container.innerHTML = $html[0].outerHTML;
        }
    });

    module.exports = WordHistogram;
})();

},{"../../core/HTML":103,"../../mixin/ValueTransform":109,"../../sentiment/Sentiment":110}],122:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DELAY = 1200;

    module.exports = {

        renderTile: function renderTile(elem) {
            var delay = -(Math.random() * DELAY);
            elem.innerHTML = '<div class="blinking blinking-tile" style="animation-delay:' + delay + 'ms"></div>';
        }

    };
})();

},{}],123:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DELAY = 1200;

    module.exports = {

        renderTile: function renderTile(elem) {
            var delay = -(Math.random() * DELAY);
            elem.innerHTML = '\n                <div class="vertical-centered-box blinking" style="animation-delay: ' + delay + 'ms">\n                    <div class="content">\n                        <div class="loader-circle"></div>\n                        <div class="loader-line-mask" style="animation-delay: ' + delay + 'ms">\n                            <div class="loader-line"></div>\n                        </div>\n                    </div>\n                </div>\n                ';
        }

    };
})();

},{}],124:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DELAY = 1200;

    module.exports = {

        renderTile: function renderTile(elem) {
            setTimeout(function () {
                var delay = -(Math.random() * DELAY);
                if ($(elem).hasClass('pending')) {
                    elem.innerHTML = '<div class="blinking blinking-tile" style="animation-delay: ' + delay + 'ms"></div>';
                }
            }, DELAY);
        }

    };
})();

},{}],125:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DELAY = 1200;

    module.exports = {

        renderTile: function renderTile(elem) {
            setTimeout(function () {
                var delay = -(Math.random() * DELAY);
                if ($(elem).hasClass('pending')) {
                    elem.innerHTML = '\n                        <div class="vertical-centered-box" style="animation-delay: ' + delay + 'ms">\n                            <div class="content">\n                                <div class="loader-circle"></div>\n                                <div class="loader-line-mask" style="animation-delay: ' + delay + 'ms">\n                                    <div class="loader-line"></div>\n                                </div>\n                            </div>\n                        </div>\n                        ';
                }
            }, DELAY);
        }

    };
})();

},{}],126:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DELAY = 1200;

    module.exports = {

        renderTile: function renderTile(elem) {
            var delay = -(Math.random() * DELAY);
            elem.innerHTML = '\n                <div class="vertical-centered-box" style="animation-delay: ' + delay + 'ms">\n                    <div class="content">\n                        <div class="loader-circle"></div>\n                        <div class="loader-line-mask" style="animation-delay: ' + delay + 'ms">\n                            <div class="loader-line"></div>\n                        </div>\n                    </div>\n                </div>\n                ';
        }

    };
})();

},{}],127:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var esper = require('esper');
    var WebGL = require('../../core/WebGL');
    var ColorRamp = require('../../mixin/ColorRamp');
    var ValueTransform = require('../../mixin/ValueTransform');
    var Shaders = require('./Shaders');

    var TILE_SIZE = 256;

    function encode(enc, val) {
        enc[0] = val / 16777216.0 & 0xFF;
        enc[1] = val / 65536.0 & 0xFF;
        enc[2] = val / 256.0 & 0xFF;
        enc[3] = val & 0xFF;
        return enc;
    }

    var Heatmap = WebGL.extend({

        includes: [
        // mixins
        ColorRamp, ValueTransform],

        onWebGLInit: function onWebGLInit(done) {
            // ensure we use the correct context
            esper.WebGLContext.bind(this._container);
            // quad vertices
            var vertices = new Float32Array([
            // positions
            0, -TILE_SIZE, TILE_SIZE, -TILE_SIZE, TILE_SIZE, 0, 0, -TILE_SIZE, TILE_SIZE, 0, 0, 0,
            // uvs
            0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1]);
            // quad buffer
            this._quadBuffer = new esper.VertexBuffer(vertices, {
                0: {
                    size: 2,
                    type: 'FLOAT',
                    byteOffset: 0
                },
                1: {
                    size: 2,
                    type: 'FLOAT',
                    byteOffset: 2 * 6 * 4
                }
            }, {
                count: 6
            });
            // load shader
            this._shader = new esper.Shader({
                vert: Shaders.heatmap.vert,
                frag: Shaders.heatmap.frag
            }, function (err) {
                if (err) {
                    done(err);
                }
                done(null);
            });
        },

        initialize: function initialize() {
            ColorRamp.initialize.apply(this, arguments);
            ValueTransform.initialize.apply(this, arguments);
        },

        onCacheLoad: function onCacheLoad(event) {
            var cached = event.entry;
            var coords = event.coords;
            if (cached.data && cached.data.byteLength > 0) {
                this.bufferTileTexture(cached, coords);
            }
        },

        onExtremaChange: function onExtremaChange() {
            var _this = this;

            _.forIn(this._cache, function (cached) {
                if (cached.data && cached.data.byteLength > 0) {
                    _this.bufferTileTexture(cached);
                }
            });
        },

        bufferTileTexture: function bufferTileTexture(cached) {
            var data = new Float64Array(cached.data);
            var resolution = Math.sqrt(data.length);
            var bins = new Uint8Array(data.length * 4);
            var enc = [0, 0, 0, 0];
            var bin = void 0,
                i = void 0;
            var sum = 0;
            for (i = 0; i < data.length; i++) {
                bin = data[i];
                sum += bin;
                encode(enc, bin);
                bins[i * 4] = enc[0];
                bins[i * 4 + 1] = enc[1];
                bins[i * 4 + 2] = enc[2];
                bins[i * 4 + 3] = enc[3];
            }
            if (sum > 0) {
                // ensure we use the correct context
                esper.WebGLContext.bind(this._container);
                // create the texture
                cached.texture = new esper.Texture2D({
                    height: resolution,
                    width: resolution,
                    src: bins,
                    format: 'RGBA',
                    type: 'UNSIGNED_BYTE',
                    wrap: 'CLAMP_TO_EDGE',
                    filter: 'NEAREST',
                    invertY: true
                });
            }
        },

        getProjectionMatrix: function getProjectionMatrix() {
            var bounds = this._map.getPixelBounds();
            var dim = Math.pow(2, this._map.getZoom()) * TILE_SIZE;
            return this.getOrthoMatrix(bounds.min.x, bounds.max.x, dim - bounds.max.y, dim - bounds.min.y, -1, 1);
        },

        renderTiles: function renderTiles() {
            var _this2 = this;

            var buffer = this._quadBuffer;
            var shader = this._shader;
            var zoom = this._map.getZoom();
            var dim = Math.pow(2, zoom) * TILE_SIZE;
            // bind buffer
            buffer.bind();
            // for each tile
            _.forIn(this._cache, function (cached) {
                if (!cached.texture) {
                    return;
                }
                // bind tile texture to texture unit 0
                cached.texture.bind(0);
                _.forIn(cached.tiles, function (tile, key) {
                    // find the tiles position from its key
                    var coords = _this2.coordFromCacheKey(key);
                    // NOTE: we have to check here if the tiles are stale or not
                    if (coords.z !== zoom) {
                        return;
                    }
                    var x = TILE_SIZE * coords.x;
                    var y = _this2.options.tms ? TILE_SIZE * (coords.y + 1) : dim - TILE_SIZE * coords.y;
                    // create model matrix
                    var model = _this2.getTranslationMatrix(x, y, 0);
                    shader.setUniform('uModelMatrix', model);
                    // draw the tile
                    buffer.draw();
                });
                // unbind texture
                cached.texture.unbind();
            });
            // unbind buffer
            buffer.unbind();
        },

        renderFrame: function renderFrame() {
            // setup
            this._viewport.push();
            this._shader.use();
            // set uniforms
            this._shader.setUniform('uProjectionMatrix', this.getProjectionMatrix());
            this._shader.setUniform('uOpacity', this.getOpacity());
            this._shader.setUniform('uRangeMin', this.getValueRange().min);
            this._shader.setUniform('uRangeMax', this.getValueRange().max);
            this._shader.setUniform('uMin', this.getExtrema().min);
            this._shader.setUniform('uMax', this.getExtrema().max);
            this._shader.setUniform('uTransformType', this.getTransformEnum());
            this._shader.setUniform('uTextureSampler', 0);
            this._shader.setUniform('uRamp', this.getColorRampTable());
            // draw
            this.renderTiles();
            // teardown
            this._viewport.pop();
        }

    });

    module.exports = Heatmap;
})();

},{"../../core/WebGL":105,"../../mixin/ColorRamp":107,"../../mixin/ValueTransform":109,"./Shaders":129,"esper":50}],128:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var esper = require('esper');
    var parallel = require('async/parallel');
    var WebGL = require('../../core/WebGL');
    var SpatialHash = require('../../mixin/SpatialHash');
    var Shaders = require('./Shaders');

    var TILE_SIZE = 256;
    var COMPONENT_BYTE_SIZE = 2;
    var COMPONENTS_PER_POINT = 4; // encoding two uint32's across xy/zw
    var MAX_TILES = 128;
    var MAX_POINTS_PER_TILE = 256 * 256;
    var MAX_TILE_BYTE_SIZE = MAX_POINTS_PER_TILE * COMPONENTS_PER_POINT * COMPONENT_BYTE_SIZE;
    var MAX_BUFFER_BYTE_SIZE = MAX_TILES * MAX_TILE_BYTE_SIZE;

    var NUM_SLICES = 64;
    var POINT_RADIUS = 8;
    var POINT_RADIUS_INC = 2;

    var POSITIONS_INDEX = 0;
    var OFFSETS_INDEX = 1;

    function encodePoint(arraybuffer, index, x, y) {
        arraybuffer[index] = x >> 16;
        arraybuffer[index + 1] = x & 0x0000FFFF;
        arraybuffer[index + 2] = y >> 16;
        arraybuffer[index + 3] = y & 0x0000FFFF;
    }

    function applyJitter(point, maxDist) {
        var angle = Math.random() * (Math.PI * 2);
        var dist = Math.random() * maxDist;
        point.x += Math.Floor(Math.cos(angle) * dist);
        point.y += Math.Floor(Math.sin(angle) * dist);
    }

    function createCircleOutlineBuffer(numSegments) {
        var theta = 2 * Math.PI / numSegments;
        var radius = 1.0;
        // precalculate sine and cosine
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        var t = void 0;
        // start at angle = 0
        var x = radius;
        var y = 0;
        var positions = new Float32Array(numSegments * 2);
        for (var i = 0; i < numSegments; i++) {
            positions[i * 2] = x;
            positions[i * 2 + 1] = y;
            // apply the rotation
            t = x;
            x = c * x - s * y;
            y = s * t + c * y;
        }
        var pointers = {};
        pointers[POSITIONS_INDEX] = {
            size: 2,
            type: 'FLOAT'
        };
        var options = {
            mode: 'LINE_LOOP',
            count: positions.length / 2
        };
        return new esper.VertexBuffer(positions, pointers, options);
    }

    function createCircleFillBuffer(numSegments) {
        var theta = 2 * Math.PI / numSegments;
        var radius = 1.0;
        // precalculate sine and cosine
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        var t = void 0;
        // start at angle = 0
        var x = radius;
        var y = 0;
        var positions = new Float32Array((numSegments + 2) * 2);
        positions[0] = 0;
        positions[1] = 0;
        positions[positions.length - 2] = radius;
        positions[positions.length - 1] = 0;
        for (var i = 0; i < numSegments; i++) {
            positions[(i + 1) * 2] = x;
            positions[(i + 1) * 2 + 1] = y;
            // apply the rotation
            t = x;
            x = c * x - s * y;
            y = s * t + c * y;
        }

        var pointers = {};
        pointers[POSITIONS_INDEX] = {
            size: 2,
            type: 'FLOAT'
        };
        var options = {
            mode: 'TRIANGLE_FAN',
            count: positions.length / 2
        };
        return new esper.VertexBuffer(positions, pointers, options);
    }

    var Point = WebGL.extend({

        includes: [
        // mixins
        SpatialHash],

        options: {
            pointOutline: 1,
            pointOutlineColor: [0.0, 0.0, 0.0, 1.0],
            pointFillColor: [0.2, 0.15, 0.4, 0.5],
            pointRadius: POINT_RADIUS,
            selectedOutlineColor: [0.0, 0.0, 0.0, 1.0],
            selectedFillColor: [0.8, 0.4, 0.2, 0.5],
            selectedRadius: POINT_RADIUS + POINT_RADIUS_INC,
            highlightedOutlineColor: [0.0, 0.0, 0.0, 1.0],
            highlightedFillColor: [0.3, 0.25, 0.5, 0.5],
            highlightedRadius: POINT_RADIUS + POINT_RADIUS_INC,
            blending: true,
            jitter: true,
            jitterDistance: 10
        },

        initialize: function initialize() {
            SpatialHash.initialize.apply(this, arguments);
        },

        onWebGLInit: function onWebGLInit(done) {
            var _this = this;

            // ensure we use the correct context
            esper.WebGLContext.bind(this._container);
            // create the circle vertexbuffer
            this._circleFillBuffer = createCircleFillBuffer(NUM_SLICES);
            this._circleOutlineBuffer = createCircleOutlineBuffer(NUM_SLICES);
            // create the root offset buffer
            this._offsetBuffer = new esper.VertexBuffer(MAX_BUFFER_BYTE_SIZE);
            // get the extension for hardware instancing
            this._ext = esper.WebGLContext.getExtension('ANGLE_instanced_arrays');
            if (!this._ext) {
                throw 'ANGLE_instanced_arrays WebGL extension is not supported';
            }
            // clear the chunks
            this.initChunks();
            // load shaders
            parallel({
                instanced: function instanced(done) {
                    var shader = new esper.Shader({
                        vert: Shaders.instancedPoint.vert,
                        frag: Shaders.instancedPoint.frag
                    }, function (err) {
                        if (err) {
                            done(err, null);
                        }
                        done(null, shader);
                    });
                },
                individual: function individual(done) {
                    var shader = new esper.Shader({
                        vert: Shaders.point.vert,
                        frag: Shaders.point.frag
                    }, function (err) {
                        if (err) {
                            done(err, null);
                        }
                        done(null, shader);
                    });
                }
            }, function (err, shaders) {
                if (err) {
                    done(err);
                }
                _this._instancedShader = shaders.instanced;
                _this._individualShader = shaders.individual;
                done(null);
            });
        },

        getCollisionRadius: function getCollisionRadius() {
            return this.options.pointRadius + this.options.pointOutline;
        },

        onAdd: function onAdd(map) {
            WebGL.prototype.onAdd.call(this, map);
            map.on('zoomend', this.onZoomEnd, this);
        },

        onRemove: function onRemove(map) {
            WebGL.prototype.onRemove.call(this, map);
            map.off('zoomend', this.onZoomEnd, this);
        },

        onZoomStart: function onZoomStart() {
            this.clearHash();
            WebGL.prototype.onZoomStart.apply(this, arguments);
        },

        initChunks: function initChunks() {
            // ensure we use the correct context
            esper.WebGLContext.bind(this._container);
            // allocate available chunks
            this._availableChunks = new Array(MAX_TILES);
            for (var i = 0; i < MAX_TILES; i++) {
                var byteOffset = i * MAX_TILE_BYTE_SIZE;
                this._availableChunks[i] = {
                    byteOffset: byteOffset,
                    count: 0,
                    vertexBuffer: new esper.VertexBuffer(this._offsetBuffer.buffer, {
                        1: {
                            size: 4,
                            type: 'UNSIGNED_SHORT',
                            byteOffset: byteOffset
                        }
                    }, {
                        mode: 'POINTS',
                        byteLength: MAX_BUFFER_BYTE_SIZE
                    })
                };
            }
            this._usedChunks = {};
        },

        onMouseMove: function onMouseMove(e) {
            var target = e.originalEvent.target;
            var layerPixel = this.getLayerPointFromEvent(e.originalEvent);
            var radius = this.getCollisionRadius();
            var zoom = this._map.getZoom();
            var collision = this.pick(layerPixel, radius, zoom);
            var size = Math.pow(2, zoom);
            if (collision) {
                // mimic mouseover / mouseout events
                if (this.highlighted) {
                    if (this.highlighted.value !== collision) {
                        // new collision
                        // execute mouseout for old
                        this.fire('mouseout', {
                            elem: target,
                            value: this.highlighted.value
                        });
                        // execute mouseover for new
                        this.fire('mouseover', {
                            elem: target,
                            value: collision
                        });
                    }
                } else {
                    // no previous collision, execute mouseover
                    this.fire('mouseover', {
                        elem: target,
                        value: collision
                    });
                }
                // use collision point to find tile
                var coord = this.getTileCoordFromLayerPoint(collision);
                var hash = this.cacheKeyFromCoord(coord);
                // flag as highlighted
                this.highlighted = {
                    tiles: this._cache[hash].tiles,
                    value: collision,
                    point: [collision.x, size * TILE_SIZE - collision.y]
                };
                // set cursor
                $(this._map._container).css('cursor', 'pointer');
                return;
            }
            // mouse out
            if (this.highlighted) {
                this.fire('mouseout', {
                    elem: target,
                    value: this.highlighted.value
                });
            }
            // clear highlighted flag
            this.highlighted = null;
        },

        onClick: function onClick(e) {
            var target = e.originalEvent.target;
            var layerPixel = this.getLayerPointFromEvent(e.originalEvent);
            var radius = this.getCollisionRadius();
            var zoom = this._map.getZoom();
            var size = Math.pow(2, zoom);
            var collision = this.pick(layerPixel, radius, zoom);
            if (collision) {
                // use collision point to find tile
                var coord = this.getTileCoordFromLayerPoint(collision);
                var hash = this.cacheKeyFromCoord(coord);
                // flag as selected
                this.selected = {
                    tiles: this._cache[hash].tiles,
                    value: collision,
                    point: [collision.x, size * TILE_SIZE - collision.y]
                };
                this.fire('click', {
                    elem: target,
                    value: collision
                });
            } else {
                this.selected = null;
            }
        },

        addTileToBuffer: function addTileToBuffer(coords, data, count) {
            if (this._availableChunks.length === 0) {
                console.warn('No available chunks remaining to buffer data');
                return;
            }
            // get an available chunk
            var chunk = this._availableChunks.pop();
            // set count
            chunk.count = count;
            // buffer the data into the physical chunk
            this._offsetBuffer.bufferSubData(data, chunk.byteOffset);
            // flag as used
            var ncoords = this.getNormalizedCoords(coords);
            var hash = this.cacheKeyFromCoord(ncoords);
            this._usedChunks[hash] = chunk;
        },

        removeTileFromBuffer: function removeTileFromBuffer(coords) {
            var ncoords = this.getNormalizedCoords(coords);
            var hash = this.cacheKeyFromCoord(ncoords);
            var chunk = this._usedChunks[hash];
            // clear the count
            chunk.count = 0;
            delete this._usedChunks[hash];
            // add as a new available chunk
            this._availableChunks.push(chunk);
            // no need to actually unbuffer the data
        },

        onCacheLoad: function onCacheLoad(event) {
            var cached = event.entry;
            var coords = event.coords;
            if (cached.data && cached.data.length > 0) {
                // convert x / y to tile pixels
                var data = cached.data;
                var xField = this.getXField();
                var yField = this.getYField();
                var zoom = coords.z;
                var size = Math.pow(2, zoom);
                var radius = this.getCollisionRadius();
                var numBytes = data.length * COMPONENT_BYTE_SIZE * COMPONENTS_PER_POINT;
                var buffer = new ArrayBuffer(Math.min(numBytes, MAX_TILE_BYTE_SIZE));
                var positions = new Uint16Array(buffer);
                var count = 0;
                var numDatum = Math.min(data.length, MAX_POINTS_PER_TILE);
                var points = [];
                var collisions = {};
                var i = void 0;
                // calc pixel locations
                for (i = 0; i < numDatum; i++) {
                    var hit = data[i];
                    var x = _.get(hit, xField);
                    var y = _.get(hit, yField);
                    if (x !== undefined && y !== undefined) {
                        // get position in layer
                        var layerPoint = this.getLayerPointFromDataPoint(x, y, zoom);
                        // create pixel
                        var point = {
                            x: layerPoint.x,
                            y: layerPoint.y,
                            data: hit
                        };
                        var hash = point.x + ':' + point.y;
                        if (this.options.jitter) {
                            if (collisions[hash]) {
                                applyJitter(point, this.options.jitterDistance);
                            }
                            collisions[hash] = true;
                        }
                        // store point
                        points.push(point);

                        // encode the point into the buffer
                        encodePoint(positions, i * 4, point.x, size * TILE_SIZE - point.y);

                        // add point to spatial hash
                        this.addPoint(point, radius, zoom);
                        // increment count
                        count++;
                    }
                }
                if (count > 0) {
                    // store points in the cache
                    cached.points = points;
                    // buffer the data
                    this.addTileToBuffer(coords, positions, count);
                }
            }
        },

        onCacheUnload: function onCacheUnload(event) {
            var _this2 = this;

            var cached = event.entry;
            var coords = event.coords;
            if (cached.points) {
                (function () {
                    //cached.data && cached.data.length > 0) {
                    _this2.removeTileFromBuffer(coords);
                    var radius = _this2.getCollisionRadius();
                    cached.points.forEach(function (point) {
                        _this2.removePoint(point, radius, coords.z);
                    });
                    cached.points = null;
                })();
            }
        },

        getWrapAroundOffset: function getWrapAroundOffset(coords) {
            var size = Math.pow(2, this._map.getZoom());
            // create model matrix
            var xWrap = Math.floor(coords.x / size);
            var yWrap = Math.floor(coords.y / size);
            return [size * TILE_SIZE * xWrap, size * TILE_SIZE * yWrap];
        },

        getProjectionMatrix: function getProjectionMatrix() {
            var size = this._map.getSize();
            return this.getOrthoMatrix(0, size.x, 0, size.y, -1, 1);
        },

        getViewOffset: function getViewOffset() {
            var bounds = this._map.getPixelBounds();
            var dim = Math.pow(2, this._map.getZoom()) * TILE_SIZE;
            return [bounds.min.x, dim - bounds.max.y];
        },

        drawInstanced: function drawInstanced(buffer, color, radius) {
            var _this3 = this;

            var gl = this._gl;
            var ext = this._ext;
            var shader = this._instancedShader;
            var cache = this._cache;
            var zoom = this._map.getZoom();
            if (this.options.blending) {
                // enable blending
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            }
            // use shader
            shader.use();
            // set uniforms
            shader.setUniform('uColor', color);
            shader.setUniform('uProjectionMatrix', this.getProjectionMatrix());
            shader.setUniform('uOpacity', this.getOpacity());
            shader.setUniform('uScale', radius);
            // calc view offset
            var viewOffset = this.getViewOffset();
            // binds the buffer to instance
            buffer.bind();
            // enable instancing
            ext.vertexAttribDivisorANGLE(OFFSETS_INDEX, 1);
            // for each allocated chunk
            _.forIn(this._usedChunks, function (chunk, hash) {
                // for each tile referring to the data
                var cached = cache[hash];
                if (cached) {
                    // bind the chunk's buffer
                    chunk.vertexBuffer.bind();
                    // render for each tile
                    _.keys(cached.tiles).forEach(function (hash) {
                        var coords = _this3.coordFromCacheKey(hash);
                        if (coords.z !== zoom) {
                            // NOTE: we have to check here if the tiles are stale or not
                            return;
                        }
                        // upload view offset
                        var offset = _this3.getWrapAroundOffset(coords);
                        var totalOffset = [viewOffset[0] - offset[0], viewOffset[1] - offset[1]];
                        shader.setUniform('uViewOffset', totalOffset);
                        // draw the istances
                        ext.drawArraysInstancedANGLE(gl[buffer.mode], 0, buffer.count, chunk.count);
                    });
                    // unbind
                    chunk.vertexBuffer.unbind();
                }
            });
            // disable instancing
            ext.vertexAttribDivisorANGLE(OFFSETS_INDEX, 0);
            // unbind buffer
            buffer.unbind();
        },

        drawIndividual: function drawIndividual(buffer, color, radius, tiles, point) {
            var _this4 = this;

            // draw selected points
            var gl = this._gl;
            var shader = this._individualShader;
            var zoom = this._map.getZoom();
            // bind the buffer
            buffer.bind();
            // disable blending
            gl.disable(gl.BLEND);
            // use shader
            shader.use();
            // use uniform for offset
            shader.setUniform('uProjectionMatrix', this.getProjectionMatrix());
            shader.setUniform('uOpacity', this.getOpacity());
            shader.setUniform('uScale', radius);
            // view offset
            var viewOffset = this.getViewOffset();
            _.forIn(tiles, function (tile) {
                if (tile.coords.z !== zoom) {
                    // NOTE: we have to check here if the tiles are stale or not
                    return;
                }
                // upload view offset
                var offset = _this4.getWrapAroundOffset(tile.coords);
                var totalOffset = [viewOffset[0] - offset[0], viewOffset[1] - offset[1]];
                shader.setUniform('uViewOffset', totalOffset);
                shader.setUniform('uOffset', point);
                shader.setUniform('uColor', color);
                buffer.draw();
            });
            // unbind the buffer
            buffer.unbind();
        },

        renderFrame: function renderFrame() {
            // setup
            var gl = this._gl;
            var viewport = this._viewport;
            viewport.push();

            // draw instanced points

            // draw instanced fill
            this.drawInstanced(this._circleFillBuffer, this.options.pointFillColor, this.options.pointRadius);
            // draw instanced outlines
            gl.lineWidth(this.options.pointOutline);
            this.drawInstanced(this._circleOutlineBuffer, this.options.pointOutlineColor, this.options.pointRadius);

            // draw individual points

            if (this.highlighted) {
                // draw individual fill
                this.drawIndividual(this._circleFillBuffer, this.options.highlightedFillColor, this.options.highlightedRadius, this.highlighted.tiles, this.highlighted.point);
                // draw individual outline
                gl.lineWidth(this.options.pointOutline);
                this.drawIndividual(this._circleOutlineBuffer, this.options.highlightedOutlineColor, this.options.highlightedRadius, this.highlighted.tiles, this.highlighted.point);
            }

            if (this.selected) {
                // draw individual fill
                this.drawIndividual(this._circleFillBuffer, this.options.selectedFillColor, this.options.selectedRadius, this.selected.tiles, this.selected.point);
                // draw individual outline
                gl.lineWidth(this.options.pointOutline);
                this.drawIndividual(this._circleOutlineBuffer, this.options.selectedOutlineColor, this.options.selectedRadius, this.selected.tiles, this.selected.point);
            }

            // teardown
            viewport.pop();
        }

    });

    module.exports = Point;
})();

},{"../../core/WebGL":105,"../../mixin/SpatialHash":108,"./Shaders":129,"async/parallel":36,"esper":50}],129:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var ColorRamp = require('../../mixin/ColorRamp');

    /**
     * precision
     */
    var precision = '\n        precision highp float;\n        precision highp int;\n        ';

    /**
     * decode float
     */
    var decodeRGBAToFloat = '\n        float decodeRGBAToFloat(vec4 v) {\n            return (v.x * 255.0 * 16777216.0) +\n                (v.y * 255.0 * 65536.0) +\n                (v.z * 255.0 * 256.0) +\n                v.w * 255.0;\n        }\n        ';

    var decodeUint16ToUint32 = '\n        int decodeUint16ToUint32(float a, float b) {\n            return int(a * 65536.0) + int(b);\n        }\n        ';

    /**
     * transforms
     */

    // log10
    var log10Transform = '\n        float log10(float val) {\n            return log(val) / log(10.0);\n        }\n        float log10Transform(float val, float minVal, float maxVal) {\n            if (minVal < 1.0) { minVal = 1.0; }\n            if (maxVal < 1.0) { maxVal = 1.0; }\n            if (val < 1.0) { val = 1.0; }\n            float logMin = log10(minVal);\n            float logMax = log10(maxVal);\n            float logVal = log10(val);\n            float range = logMax - logMin;\n            if (range == 0.0) { range = 1.0; }\n            return (logVal - logMin) / range;\n        }\n        ';

    // sigmoid
    var sigmoidTransform = '\n        float sigmoidTransform(float val, float minVal, float maxVal) {\n            minVal = abs(minVal);\n            maxVal = abs(maxVal);\n            float dist = max(minVal, maxVal);\n            float SIGMOID_SCALE = 0.15;\n            float scaledVal = val / (SIGMOID_SCALE * dist);\n            return 1.0 / (1.0 + exp(-scaledVal));\n        }\n        ';

    // linear
    var linearTransform = '\n        float linearTransform(float val, float minVal, float maxVal) {\n            float range = maxVal - minVal;\n            if (range == 0.0) { range = 1.0; }\n            return (val - minVal) / range;\n        }\n        ';

    var transform = log10Transform + sigmoidTransform + linearTransform + '\n        #define LOG_TRANSFORM 0\n        #define LINEAR_TRANSFORM 1\n        #define SIGMOID_TRANSFORM 2\n        uniform int uTransformType;\n        uniform float uMin;\n        uniform float uMax;\n        float transform(float val) {\n            if (val < uMin) { val = uMin; }\n            if (val > uMax) { val = uMax; }\n            if (uTransformType == LINEAR_TRANSFORM) {\n                return linearTransform(val, uMin, uMax);\n            } else if (uTransformType == SIGMOID_TRANSFORM) {\n                return sigmoidTransform(val, uMin, uMax);\n            }\n            return log10Transform(val, uMin, uMax);\n        }\n        ';

    /**
     * Color ramp
     */
    var colorRamp = '\n        #define RAMP_VALUES ' + ColorRamp.NUM_GRADIENT_STEPS + '\n        uniform vec4 uRamp[RAMP_VALUES];\n        vec4 colorRamp(float value) {\n            float maxIndex = float(RAMP_VALUES - 1);\n            int index = int(value * maxIndex);\n            // NOTE: I REALLY don\'t like this, but it seems to be the only way\n            // to index the uRamp array\n            for (int i=0; i<RAMP_VALUES; i++) {\n                if (i == index) {\n                    return uRamp[i];\n                }\n            }\n            return vec4(1.0, 0.0, 1.0, 1.0);\n        }\n        ';

    /**
     * Value Range
     */
    var valueRange = '\n        uniform float uRangeMin;\n        uniform float uRangeMax;\n        float interpolateToRange(float nval) {\n            float rval = (nval - uRangeMin) / (uRangeMax - uRangeMin);\n            if (rval > 1.0) {\n                rval = 1.0;\n            } else if (rval < 0.0) {\n                rval = 0.0;\n            }\n            return rval;\n        }\n        ';

    /**
     * heatmap shader
     */
    var heatmap = {
        vert: precision + '\n            attribute vec2 aPosition;\n            attribute vec2 aTextureCoord;\n            uniform mat4 uProjectionMatrix;\n            uniform mat4 uModelMatrix;\n            varying vec2 vTextureCoord;\n            void main() {\n                vTextureCoord = aTextureCoord;\n                gl_Position = uProjectionMatrix * uModelMatrix * vec4(aPosition, 0.0, 1.0);\n            }\n            ',
        frag: precision + decodeRGBAToFloat + transform + colorRamp + valueRange + '\n            uniform sampler2D uTextureSampler;\n            uniform float uOpacity;\n            varying vec2 vTextureCoord;\n            void main() {\n                vec4 enc = texture2D(uTextureSampler, vTextureCoord);\n                float count = decodeRGBAToFloat(enc);\n                if (count == 0.0) {\n                    discard;\n                }\n                float nval = transform(count);\n                float rval = interpolateToRange(nval);\n                vec4 color = colorRamp(rval);\n                gl_FragColor = vec4(color.rgb, color.a * uOpacity);\n            }\n            '
    };

    /**
     * instanced point shader
     */
    var instancedPoint = {
        vert: precision + decodeUint16ToUint32 + '\n            attribute vec2 aPosition;\n            attribute vec4 aOffset;\n            uniform ivec2 uViewOffset;\n            uniform float uScale;\n            uniform mat4 uProjectionMatrix;\n            void main() {\n                ivec2 iOffset = ivec2(\n                    decodeUint16ToUint32(aOffset.x, aOffset.y),\n                    decodeUint16ToUint32(aOffset.z, aOffset.w));\n                vec2 mPosition = uScale * aPosition + vec2(iOffset - uViewOffset);\n                gl_Position = uProjectionMatrix * vec4(mPosition, 0.0, 1.0);\n            }\n            ',
        frag: precision + '\n            uniform float uOpacity;\n            uniform vec4 uColor;\n            void main() {\n                gl_FragColor = vec4(uColor.rgb, uColor.a * uOpacity);\n            }\n            '
    };

    var point = {
        vert: precision + '\n            attribute vec2 aPosition;\n            uniform ivec2 uOffset;\n            uniform ivec2 uViewOffset;\n            uniform float uScale;\n            uniform mat4 uProjectionMatrix;\n            void main() {\n                vec2 mPosition = uScale * aPosition + vec2(uOffset - uViewOffset);\n                gl_Position = uProjectionMatrix * vec4(mPosition, 0.0, 1.0);\n            }\n            ',
        frag: precision + '\n            uniform float uOpacity;\n            uniform vec4 uColor;\n            void main() {\n                gl_FragColor = vec4(uColor.rgb, uColor.a * uOpacity);\n            }\n            '
    };

    module.exports = {

        /**
         * heatmap shader
         */
        heatmap: heatmap,

        /**
         * instanced point shader
         */
        instancedPoint: instancedPoint,

        /**
         * point shader
         */
        point: point

    };
})();

},{"../../mixin/ColorRamp":107}],130:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

(function () {

    'use strict';

    var Requestor = require('./Requestor');

    var MetaRequestor = function (_Requestor) {
        _inherits(MetaRequestor, _Requestor);

        function MetaRequestor(url, callback) {
            _classCallCheck(this, MetaRequestor);

            return _possibleConstructorReturn(this, (MetaRequestor.__proto__ || Object.getPrototypeOf(MetaRequestor)).call(this, url, callback));
        }

        _createClass(MetaRequestor, [{
            key: 'getHash',
            value: function getHash(req) {
                return req.type + '-' + req.index + '-' + req.store;
            }
        }, {
            key: 'getURL',
            value: function getURL(res) {
                return 'meta/' + res.type + '/' + res.endpoint + '/' + res.index + '/' + res.store;
            }
        }]);

        return MetaRequestor;
    }(Requestor);

    module.exports = MetaRequestor;
})();

},{"./Requestor":131}],131:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function () {

    'use strict';

    var RETRY_INTERVAL = 5000;

    function getHost() {
        var loc = window.location;
        var new_uri = void 0;
        if (loc.protocol === 'https:') {
            new_uri = 'wss:';
        } else {
            new_uri = 'ws:';
        }
        return new_uri + '//' + loc.host + loc.pathname;
    }

    function establishConnection(requestor, callback) {
        requestor.socket = new WebSocket(getHost() + requestor.url);
        // on open
        requestor.socket.onopen = function () {
            requestor.isOpen = true;
            console.log('Websocket connection established');
            callback.apply(this, arguments);
        };
        // on message
        requestor.socket.onmessage = function (event) {
            var res = JSON.parse(event.data);
            var hash = requestor.getHash(res);
            var request = requestor.requests[hash];
            delete requestor.requests[hash];
            if (res.success) {
                request.resolve(requestor.getURL(res), res);
            } else {
                request.reject(res);
            }
        };
        // on close
        requestor.socket.onclose = function () {
            // log close only if connection was ever open
            if (requestor.isOpen) {
                console.warn('Websocket connection closed, attempting to re-connect in', RETRY_INTERVAL);
            }
            requestor.socket = null;
            requestor.isOpen = false;
            // reject all pending requests
            Object.keys(requestor.requests).forEach(function (key) {
                requestor.requests[key].reject();
            });
            // clear request map
            requestor.requests = {};
            // attempt to re-establish connection
            setTimeout(function () {
                establishConnection(requestor, function () {
                    // once connection is re-established, send pending requests
                    requestor.pending.forEach(function (req) {
                        requestor.get(req);
                    });
                    requestor.pending = [];
                });
            }, RETRY_INTERVAL);
        };
    }

    var Requestor = function () {
        function Requestor(url, callback) {
            _classCallCheck(this, Requestor);

            this.url = url;
            this.requests = {};
            this.pending = [];
            this.isOpen = false;
            establishConnection(this, callback);
        }

        _createClass(Requestor, [{
            key: 'getHash',
            value: function getHash() {
                // override
            }
        }, {
            key: 'getURL',
            value: function getURL() {
                // override
            }
        }, {
            key: 'get',
            value: function get(req) {
                if (!this.isOpen) {
                    // if no connection, add request to pending queue
                    this.pending.push(req);
                    return;
                }
                var hash = this.getHash(req);
                var request = this.requests[hash];
                if (request) {
                    return request.promise();
                }
                request = this.requests[hash] = $.Deferred();
                this.socket.send(JSON.stringify(req));
                return request.promise();
            }
        }, {
            key: 'close',
            value: function close() {
                this.socket.onclose = null;
                this.socket.close();
                this.socket = null;
            }
        }]);

        return Requestor;
    }();

    module.exports = Requestor;
})();

},{}],132:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

(function () {

    'use strict';

    var stringify = require('json-stable-stringify');
    var Requestor = require('./Requestor');

    function pruneEmpty(obj) {
        return function prune(current) {
            _.forOwn(current, function (value, key) {
                if (_.isUndefined(value) || _.isNull(value) || _.isNaN(value) || _.isString(value) && _.isEmpty(value) || _.isObject(value) && _.isEmpty(prune(value))) {
                    delete current[key];
                }
            });
            // remove any leftover undefined values from the delete
            // operation on an array
            if (_.isArray(current)) {
                _.pull(current, undefined);
            }
            return current;
        }(_.cloneDeep(obj)); // do not modify the original object, create a clone instead
    }

    var TileRequestor = function (_Requestor) {
        _inherits(TileRequestor, _Requestor);

        function TileRequestor(url, callback) {
            _classCallCheck(this, TileRequestor);

            return _possibleConstructorReturn(this, (TileRequestor.__proto__ || Object.getPrototypeOf(TileRequestor)).call(this, url, callback));
        }

        _createClass(TileRequestor, [{
            key: 'getHash',
            value: function getHash(req) {
                var coord = req.coord;
                var hash = stringify(pruneEmpty(req.params));
                return req.type + '-' + req.index + '-' + req.store + '-' + coord.z + '-' + coord.x + '-' + coord.y + '-' + hash;
            }
        }, {
            key: 'getURL',
            value: function getURL(res) {
                var coord = res.coord;
                return 'tile/' + res.type + '/' + res.index + '/' + res.store + '/' + coord.z + '/' + coord.x + '/' + coord.y;
            }
        }]);

        return TileRequestor;
    }(Requestor);

    module.exports = TileRequestor;
})();

},{"./Requestor":131,"json-stable-stringify":55}]},{},[62])(62)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvZWFjaE9mLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL2VhY2hPZkxpbWl0LmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL2RvTGltaXQuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvZWFjaE9mTGltaXQuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvZ2V0SXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvb25jZS5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9vbmx5T25jZS5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9wYXJhbGxlbC5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9ub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZXN0LmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9ub2RlX21vZHVsZXMvbG9kYXNoL2JlZm9yZS5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJub2RlX21vZHVsZXMvYXN5bmMvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9ub2RlX21vZHVsZXMvbG9kYXNoL25vb3AuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvbm9kZV9tb2R1bGVzL2xvZGFzaC9vbmNlLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL25vZGVfbW9kdWxlcy9sb2Rhc2gvcmVzdC5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9ub2RlX21vZHVsZXMvbG9kYXNoL3RvRmluaXRlLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9JbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9OdW1iZXIuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvcGFyYWxsZWwuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvQ29sb3JUZXh0dXJlMkQuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvRGVwdGhUZXh0dXJlMkQuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvSW5kZXhCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvUmVuZGVyVGFyZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2VzcGVyL3NyYy9jb3JlL1JlbmRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvU2hhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2VzcGVyL3NyYy9jb3JlL1NoYWRlclBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9lc3Blci9zcmMvY29yZS9UZXh0dXJlMkQuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvVGV4dHVyZUN1YmVNYXAuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvVmVydGV4QnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2VzcGVyL3NyYy9jb3JlL1ZlcnRleFBhY2thZ2UuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvVmlld3BvcnQuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvV2ViR0xDb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL2VzcGVyL3NyYy9leHBvcnRzLmpzIiwibm9kZV9tb2R1bGVzL2VzcGVyL3NyYy91dGlsL0FzeW5jLmpzIiwibm9kZV9tb2R1bGVzL2VzcGVyL3NyYy91dGlsL0ltYWdlTG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL2VzcGVyL3NyYy91dGlsL1V0aWwuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL3V0aWwvWEhSTG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzb24tc3RhYmxlLXN0cmluZ2lmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzb25pZnkvbGliL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL2pzb25pZnkvbGliL3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwic2NyaXB0cy9DUlMvR3JhcGguanMiLCJzY3JpcHRzL0NSUy9leHBvcnRzLmpzIiwic2NyaXB0cy9leHBvcnRzLmpzIiwic2NyaXB0cy9sYXllci9hZ2cvRGF0ZUhpc3RvZ3JhbS5qcyIsInNjcmlwdHMvbGF5ZXIvYWdnL0hpc3RvZ3JhbS5qcyIsInNjcmlwdHMvbGF5ZXIvYWdnL01ldHJpYy5qcyIsInNjcmlwdHMvbGF5ZXIvYWdnL1Rlcm1zLmpzIiwic2NyaXB0cy9sYXllci9hZ2cvVGVybXNGaWx0ZXIuanMiLCJzY3JpcHRzL2xheWVyL2FnZy9Ub3BIaXRzLmpzIiwic2NyaXB0cy9sYXllci9hZ2cvVG9wVGVybXMuanMiLCJzY3JpcHRzL2xheWVyL2NvcmUvQmFzZS5qcyIsInNjcmlwdHMvbGF5ZXIvY29yZS9Db21wb3NpdGUuanMiLCJzY3JpcHRzL2xheWVyL2NvcmUvRGVidWcuanMiLCJzY3JpcHRzL2xheWVyL2NvcmUvSW1hZ2UuanMiLCJzY3JpcHRzL2xheWVyL2NvcmUvTGl2ZS5qcyIsInNjcmlwdHMvbGF5ZXIvY29yZS9QZW5kaW5nLmpzIiwic2NyaXB0cy9sYXllci9leHBvcnRzLmpzIiwic2NyaXB0cy9sYXllci9wYXJhbS9CaW5uaW5nLmpzIiwic2NyaXB0cy9sYXllci9wYXJhbS9FbGFzdGljLmpzIiwic2NyaXB0cy9sYXllci9wYXJhbS9UaWxpbmcuanMiLCJzY3JpcHRzL2xheWVyL3F1ZXJ5L0Jvb2wuanMiLCJzY3JpcHRzL2xheWVyL3F1ZXJ5L0V4aXN0cy5qcyIsInNjcmlwdHMvbGF5ZXIvcXVlcnkvTWF0Y2guanMiLCJzY3JpcHRzL2xheWVyL3F1ZXJ5L1ByZWZpeC5qcyIsInNjcmlwdHMvbGF5ZXIvcXVlcnkvUXVlcnlTdHJpbmcuanMiLCJzY3JpcHRzL2xheWVyL3F1ZXJ5L1JhbmdlLmpzIiwic2NyaXB0cy9sYXllci9xdWVyeS9UZXJtcy5qcyIsInNjcmlwdHMvbGF5ZXIvdHlwZS9Db21tdW5pdHkuanMiLCJzY3JpcHRzL2xheWVyL3R5cGUvQ291bnQuanMiLCJzY3JpcHRzL2xheWVyL3R5cGUvSGVhdG1hcC5qcyIsInNjcmlwdHMvbGF5ZXIvdHlwZS9NYWNyby5qcyIsInNjcmlwdHMvbGF5ZXIvdHlwZS9NaWNyby5qcyIsInNjcmlwdHMvbGF5ZXIvdHlwZS9QcmV2aWV3LmpzIiwic2NyaXB0cy9sYXllci90eXBlL1RvcENvdW50LmpzIiwic2NyaXB0cy9sYXllci90eXBlL1RvcEZyZXF1ZW5jeS5qcyIsInNjcmlwdHMvbGF5ZXIvdHlwZS9Ub3BUcmFpbHMuanMiLCJzY3JpcHRzL2xheWVyL3R5cGUvVG9waWNDb3VudC5qcyIsInNjcmlwdHMvbGF5ZXIvdHlwZS9Ub3BpY0ZyZXF1ZW5jeS5qcyIsInNjcmlwdHMvbWFwL01hcC5qcyIsInNjcmlwdHMvcHJvamVjdGlvbi9HcmFwaC5qcyIsInNjcmlwdHMvcmVuZGVyZXIvY29yZS9DYW52YXMuanMiLCJzY3JpcHRzL3JlbmRlcmVyL2NvcmUvRE9NLmpzIiwic2NyaXB0cy9yZW5kZXJlci9jb3JlL0hUTUwuanMiLCJzY3JpcHRzL3JlbmRlcmVyL2NvcmUvT3ZlcmxheS5qcyIsInNjcmlwdHMvcmVuZGVyZXIvY29yZS9XZWJHTC5qcyIsInNjcmlwdHMvcmVuZGVyZXIvZXhwb3J0cy5qcyIsInNjcmlwdHMvcmVuZGVyZXIvbWl4aW4vQ29sb3JSYW1wLmpzIiwic2NyaXB0cy9yZW5kZXJlci9taXhpbi9TcGF0aWFsSGFzaC5qcyIsInNjcmlwdHMvcmVuZGVyZXIvbWl4aW4vVmFsdWVUcmFuc2Zvcm0uanMiLCJzY3JpcHRzL3JlbmRlcmVyL3NlbnRpbWVudC9TZW50aW1lbnQuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvY2FudmFzL0hlYXRtYXAuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvY2FudmFzL1ByZXZpZXcuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvY2FudmFzL1RvcFRyYWlscy5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS9kZWJ1Zy9Db29yZC5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS9odG1sL0NvbW11bml0eS5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS9odG1sL0NvbW11bml0eUxhYmVsLmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL2h0bWwvRW1wdHkuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvaHRtbC9IZWF0bWFwLmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL2h0bWwvUmluZy5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS9odG1sL1dvcmRDbG91ZC5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS9odG1sL1dvcmRIaXN0b2dyYW0uanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvcGVuZGluZy9CbGluay5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS9wZW5kaW5nL0JsaW5rU3Bpbi5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS9wZW5kaW5nL0RlbGF5ZWRCbGluay5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS9wZW5kaW5nL0RlbGF5ZWRTcGluLmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL3BlbmRpbmcvU3Bpbi5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS93ZWJnbC9IZWF0bWFwLmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL3dlYmdsL1BvaW50LmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL3dlYmdsL1NoYWRlcnMuanMiLCJzY3JpcHRzL3JlcXVlc3QvTWV0YVJlcXVlc3Rvci5qcyIsInNjcmlwdHMvcmVxdWVzdC9SZXF1ZXN0b3IuanMiLCJzY3JpcHRzL3JlcXVlc3QvVGlsZVJlcXVlc3Rvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9VQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNILFNBZE0sQ0FjTCxFQUFFLFNBQUYsQ0FBWSxHQUFaLENBZEssQ0FBUCxDQURxQixDQWVBO0FBQ3hCOztBQXZCTyxRQXlCRixhQXpCRTtBQUFBOztBQTBCSiwrQkFBWSxHQUFaLEVBQWlCLFFBQWpCLEVBQTJCO0FBQUE7O0FBQUEsaUlBQ2pCLEdBRGlCLEVBQ1osUUFEWTtBQUUxQjs7QUE1Qkc7QUFBQTtBQUFBLG9DQTZCSSxHQTdCSixFQTZCUztBQUNULG9CQUFJLFFBQVEsSUFBSSxLQUFoQjtBQUNBLG9CQUFJLE9BQU8sVUFBVSxXQUFXLElBQUksTUFBZixDQUFWLENBQVg7QUFDQSx1QkFBVSxJQUFJLElBQWQsU0FBc0IsSUFBSSxLQUExQixTQUFtQyxJQUFJLEtBQXZDLFNBQWdELE1BQU0sQ0FBdEQsU0FBMkQsTUFBTSxDQUFqRSxTQUFzRSxNQUFNLENBQTVFLFNBQWlGLElBQWpGO0FBQ0g7QUFqQ0c7QUFBQTtBQUFBLG1DQWtDRyxHQWxDSCxFQWtDUTtBQUNSLG9CQUFJLFFBQVEsSUFBSSxLQUFoQjtBQUNBLGlDQUFlLElBQUksSUFBbkIsU0FBMkIsSUFBSSxLQUEvQixTQUF3QyxJQUFJLEtBQTVDLFNBQXFELE1BQU0sQ0FBM0QsU0FBZ0UsTUFBTSxDQUF0RSxTQUEyRSxNQUFNLENBQWpGO0FBQ0g7QUFyQ0c7O0FBQUE7QUFBQSxNQXlCb0IsU0F6QnBCOztBQXdDUixXQUFPLE9BQVAsR0FBaUIsYUFBakI7QUFFSCxDQTFDQSxHQUFEIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGVhY2hPZkltcGxlbWVudGF0aW9uID0gKDAsIF9pc0FycmF5TGlrZTIuZGVmYXVsdCkoY29sbCkgPyBlYWNoT2ZBcnJheUxpa2UgOiBlYWNoT2ZHZW5lcmljO1xuICAgIGVhY2hPZkltcGxlbWVudGF0aW9uKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjayk7XG59O1xuXG52YXIgX2lzQXJyYXlMaWtlID0gcmVxdWlyZSgnbG9kYXNoL2lzQXJyYXlMaWtlJyk7XG5cbnZhciBfaXNBcnJheUxpa2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNBcnJheUxpa2UpO1xuXG52YXIgX2VhY2hPZkxpbWl0ID0gcmVxdWlyZSgnLi9lYWNoT2ZMaW1pdCcpO1xuXG52YXIgX2VhY2hPZkxpbWl0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2hPZkxpbWl0KTtcblxudmFyIF9kb0xpbWl0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9kb0xpbWl0Jyk7XG5cbnZhciBfZG9MaW1pdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kb0xpbWl0KTtcblxudmFyIF9ub29wID0gcmVxdWlyZSgnbG9kYXNoL25vb3AnKTtcblxudmFyIF9ub29wMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX25vb3ApO1xuXG52YXIgX29uY2UgPSByZXF1aXJlKCdsb2Rhc2gvb25jZScpO1xuXG52YXIgX29uY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb25jZSk7XG5cbnZhciBfb25seU9uY2UgPSByZXF1aXJlKCcuL2ludGVybmFsL29ubHlPbmNlJyk7XG5cbnZhciBfb25seU9uY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb25seU9uY2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBlYWNoT2YgaW1wbGVtZW50YXRpb24gb3B0aW1pemVkIGZvciBhcnJheS1saWtlc1xuZnVuY3Rpb24gZWFjaE9mQXJyYXlMaWtlKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gKDAsIF9vbmNlMi5kZWZhdWx0KShjYWxsYmFjayB8fCBfbm9vcDIuZGVmYXVsdCk7XG4gICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgY29tcGxldGVkID0gMCxcbiAgICAgICAgbGVuZ3RoID0gY29sbC5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdGVyYXRvckNhbGxiYWNrKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKCsrY29tcGxldGVkID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKGNvbGxbaW5kZXhdLCBpbmRleCwgKDAsIF9vbmx5T25jZTIuZGVmYXVsdCkoaXRlcmF0b3JDYWxsYmFjaykpO1xuICAgIH1cbn1cblxuLy8gYSBnZW5lcmljIHZlcnNpb24gb2YgZWFjaE9mIHdoaWNoIGNhbiBoYW5kbGUgYXJyYXksIG9iamVjdCwgYW5kIGl0ZXJhdG9yIGNhc2VzLlxudmFyIGVhY2hPZkdlbmVyaWMgPSAoMCwgX2RvTGltaXQyLmRlZmF1bHQpKF9lYWNoT2ZMaW1pdDIuZGVmYXVsdCwgSW5maW5pdHkpO1xuXG4vKipcbiAqIExpa2UgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9LCBleGNlcHQgdGhhdCBpdCBwYXNzZXMgdGhlIGtleSAob3IgaW5kZXgpIGFzIHRoZSBzZWNvbmQgYXJndW1lbnRcbiAqIHRvIHRoZSBpdGVyYXRlZS5cbiAqXG4gKiBAbmFtZSBlYWNoT2ZcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyBmb3JFYWNoT2ZcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH1cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoXG4gKiBpdGVtIGluIGBjb2xsYC4gVGhlIGBrZXlgIGlzIHRoZSBpdGVtJ3Mga2V5LCBvciBpbmRleCBpbiB0aGUgY2FzZSBvZiBhblxuICogYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyKWAgd2hpY2ggbXVzdCBiZSBjYWxsZWQgb25jZSBpdFxuICogaGFzIGNvbXBsZXRlZC4gSWYgbm8gZXJyb3IgaGFzIG9jY3VycmVkLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGJlIHJ1biB3aXRob3V0XG4gKiBhcmd1bWVudHMgb3Igd2l0aCBhbiBleHBsaWNpdCBgbnVsbGAgYXJndW1lbnQuIEludm9rZWQgd2l0aFxuICogKGl0ZW0sIGtleSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iaiA9IHtkZXY6IFwiL2Rldi5qc29uXCIsIHRlc3Q6IFwiL3Rlc3QuanNvblwiLCBwcm9kOiBcIi9wcm9kLmpzb25cIn07XG4gKiB2YXIgY29uZmlncyA9IHt9O1xuICpcbiAqIGFzeW5jLmZvckVhY2hPZihvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBjYWxsYmFjaykge1xuICogICAgIGZzLnJlYWRGaWxlKF9fZGlybmFtZSArIHZhbHVlLCBcInV0ZjhcIiwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICogICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAqICAgICAgICAgdHJ5IHtcbiAqICAgICAgICAgICAgIGNvbmZpZ3Nba2V5XSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gKiAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAqICAgICAgICAgfVxuICogICAgICAgICBjYWxsYmFjaygpO1xuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGlmIChlcnIpIGNvbnNvbGUuZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICogICAgIC8vIGNvbmZpZ3MgaXMgbm93IGEgbWFwIG9mIEpTT04gZGF0YVxuICogICAgIGRvU29tZXRoaW5nV2l0aChjb25maWdzKTtcbiAqIH0pO1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBlYWNoT2ZMaW1pdDtcblxudmFyIF9lYWNoT2ZMaW1pdDIgPSByZXF1aXJlKCcuL2ludGVybmFsL2VhY2hPZkxpbWl0Jyk7XG5cbnZhciBfZWFjaE9mTGltaXQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFjaE9mTGltaXQyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGVhY2hPZmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYVxuICogdGltZS5cbiAqXG4gKiBAbmFtZSBlYWNoT2ZMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZWFjaE9mXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfVxuICogQGFsaWFzIGZvckVhY2hPZkxpbWl0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2hcbiAqIGl0ZW0gaW4gYGNvbGxgLiBUaGUgYGtleWAgaXMgdGhlIGl0ZW0ncyBrZXksIG9yIGluZGV4IGluIHRoZSBjYXNlIG9mIGFuXG4gKiBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIpYCB3aGljaCBtdXN0IGJlIGNhbGxlZCBvbmNlIGl0XG4gKiBoYXMgY29tcGxldGVkLiBJZiBubyBlcnJvciBoYXMgb2NjdXJyZWQsIHRoZSBjYWxsYmFjayBzaG91bGQgYmUgcnVuIHdpdGhvdXRcbiAqIGFyZ3VtZW50cyBvciB3aXRoIGFuIGV4cGxpY2l0IGBudWxsYCBhcmd1bWVudC4gSW52b2tlZCB3aXRoXG4gKiAoaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICovXG5mdW5jdGlvbiBlYWNoT2ZMaW1pdChjb2xsLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICgwLCBfZWFjaE9mTGltaXQzLmRlZmF1bHQpKGxpbWl0KShjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRvTGltaXQ7XG5mdW5jdGlvbiBkb0xpbWl0KGZuLCBsaW1pdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZm4oaXRlcmFibGUsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spO1xuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9lYWNoT2ZMaW1pdDtcblxudmFyIF9ub29wID0gcmVxdWlyZSgnbG9kYXNoL25vb3AnKTtcblxudmFyIF9ub29wMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX25vb3ApO1xuXG52YXIgX29uY2UgPSByZXF1aXJlKCcuL29uY2UnKTtcblxudmFyIF9vbmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29uY2UpO1xuXG52YXIgX2l0ZXJhdG9yID0gcmVxdWlyZSgnLi9pdGVyYXRvcicpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxudmFyIF9vbmx5T25jZSA9IHJlcXVpcmUoJy4vb25seU9uY2UnKTtcblxudmFyIF9vbmx5T25jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vbmx5T25jZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9lYWNoT2ZMaW1pdChsaW1pdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSAoMCwgX29uY2UyLmRlZmF1bHQpKGNhbGxiYWNrIHx8IF9ub29wMi5kZWZhdWx0KTtcbiAgICAgICAgaWYgKGxpbWl0IDw9IDAgfHwgIW9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0RWxlbSA9ICgwLCBfaXRlcmF0b3IyLmRlZmF1bHQpKG9iaik7XG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgIHZhciBydW5uaW5nID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlZUNhbGxiYWNrKGVycikge1xuICAgICAgICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRvbmUgJiYgcnVubmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXBsZW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxlbmlzaCgpIHtcbiAgICAgICAgICAgIHdoaWxlIChydW5uaW5nIDwgbGltaXQgJiYgIWRvbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IG5leHRFbGVtKCk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydW5uaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xuICAgICAgICAgICAgICAgIGl0ZXJhdGVlKGVsZW0udmFsdWUsIGVsZW0ua2V5LCAoMCwgX29ubHlPbmNlMi5kZWZhdWx0KShpdGVyYXRlZUNhbGxiYWNrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXBsZW5pc2goKTtcbiAgICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjb2xsKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yU3ltYm9sICYmIGNvbGxbaXRlcmF0b3JTeW1ib2xdICYmIGNvbGxbaXRlcmF0b3JTeW1ib2xdKCk7XG59O1xuXG52YXIgaXRlcmF0b3JTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpdGVyYXRvcjtcblxudmFyIF9pc0FycmF5TGlrZSA9IHJlcXVpcmUoJ2xvZGFzaC9pc0FycmF5TGlrZScpO1xuXG52YXIgX2lzQXJyYXlMaWtlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQXJyYXlMaWtlKTtcblxudmFyIF9nZXRJdGVyYXRvciA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3InKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcik7XG5cbnZhciBfa2V5cyA9IHJlcXVpcmUoJ2xvZGFzaC9rZXlzJyk7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlJdGVyYXRvcihjb2xsKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gY29sbC5sZW5ndGg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHJldHVybiArK2kgPCBsZW4gPyB7IHZhbHVlOiBjb2xsW2ldLCBrZXk6IGkgfSA6IG51bGw7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZW0uZG9uZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGkrKztcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0ZW0udmFsdWUsIGtleTogaSB9O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdEl0ZXJhdG9yKG9iaikge1xuICAgIHZhciBva2V5cyA9ICgwLCBfa2V5czIuZGVmYXVsdCkob2JqKTtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHZhciBsZW4gPSBva2V5cy5sZW5ndGg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBrZXkgPSBva2V5c1srK2ldO1xuICAgICAgICByZXR1cm4gaSA8IGxlbiA/IHsgdmFsdWU6IG9ialtrZXldLCBrZXk6IGtleSB9IDogbnVsbDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpdGVyYXRvcihjb2xsKSB7XG4gICAgaWYgKCgwLCBfaXNBcnJheUxpa2UyLmRlZmF1bHQpKGNvbGwpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVBcnJheUl0ZXJhdG9yKGNvbGwpO1xuICAgIH1cblxuICAgIHZhciBpdGVyYXRvciA9ICgwLCBfZ2V0SXRlcmF0b3IyLmRlZmF1bHQpKGNvbGwpO1xuICAgIHJldHVybiBpdGVyYXRvciA/IGNyZWF0ZUVTMjAxNUl0ZXJhdG9yKGl0ZXJhdG9yKSA6IGNyZWF0ZU9iamVjdEl0ZXJhdG9yKGNvbGwpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG9uY2U7XG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGZuID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIHZhciBjYWxsRm4gPSBmbjtcbiAgICAgICAgZm4gPSBudWxsO1xuICAgICAgICBjYWxsRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG9ubHlPbmNlO1xuZnVuY3Rpb24gb25seU9uY2UoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZm4gPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC5cIik7XG4gICAgICAgIHZhciBjYWxsRm4gPSBmbjtcbiAgICAgICAgZm4gPSBudWxsO1xuICAgICAgICBjYWxsRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBfcGFyYWxsZWw7XG5cbnZhciBfbm9vcCA9IHJlcXVpcmUoJ2xvZGFzaC9ub29wJyk7XG5cbnZhciBfbm9vcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub29wKTtcblxudmFyIF9pc0FycmF5TGlrZSA9IHJlcXVpcmUoJ2xvZGFzaC9pc0FycmF5TGlrZScpO1xuXG52YXIgX2lzQXJyYXlMaWtlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQXJyYXlMaWtlKTtcblxudmFyIF9yZXN0ID0gcmVxdWlyZSgnbG9kYXNoL3Jlc3QnKTtcblxudmFyIF9yZXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Jlc3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfcGFyYWxsZWwoZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IF9ub29wMi5kZWZhdWx0O1xuICAgIHZhciByZXN1bHRzID0gKDAsIF9pc0FycmF5TGlrZTIuZGVmYXVsdCkodGFza3MpID8gW10gOiB7fTtcblxuICAgIGVhY2hmbih0YXNrcywgZnVuY3Rpb24gKHRhc2ssIGtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGFzaygoMCwgX3Jlc3QyLmRlZmF1bHQpKGZ1bmN0aW9uIChlcnIsIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzW2tleV0gPSBhcmdzO1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSkpO1xuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIC8vIFNhZmFyaSA5IG1ha2VzIGBhcmd1bWVudHMubGVuZ3RoYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcbiAgICA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZylcbiAgICA6IFtdO1xuXG4gIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IGFycmF5O1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpO1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50c1xuICogb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoaWxlIGl0J3MgY2FsbGVkIGxlc3MgdGhhbiBgbmAgdGltZXMuIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBhdCB3aGljaCBgZnVuY2AgaXMgbm8gbG9uZ2VyIGludm9rZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmJlZm9yZSg1LCBhZGRDb250YWN0VG9MaXN0KSk7XG4gKiAvLyA9PiBBbGxvd3MgYWRkaW5nIHVwIHRvIDQgY29udGFjdHMgdG8gdGhlIGxpc3QuXG4gKi9cbmZ1bmN0aW9uIGJlZm9yZShuLCBmdW5jKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIG4gPSB0b0ludGVnZXIobik7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoLS1uID4gMCkge1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpZiAobiA8PSAxKSB7XG4gICAgICBmdW5jID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJlZm9yZTtcbiIsInZhciBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbm9vcDtcbiIsInZhciBiZWZvcmUgPSByZXF1aXJlKCcuL2JlZm9yZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gaW52b2tpbmcgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxsc1xuICogdG8gdGhlIGZ1bmN0aW9uIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGludm9jYXRpb24uIFRoZSBgZnVuY2AgaXNcbiAqIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICogaW5pdGlhbGl6ZSgpO1xuICogaW5pdGlhbGl6ZSgpO1xuICogLy8gPT4gYGNyZWF0ZUFwcGxpY2F0aW9uYCBpcyBpbnZva2VkIG9uY2VcbiAqL1xuZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gIHJldHVybiBiZWZvcmUoMiwgZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb25jZTtcbiIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXNcbiAqIGFuIGFycmF5LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAqIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9tZG4uaW8vcmVzdF9wYXJhbWV0ZXJzKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHNheSA9IF8ucmVzdChmdW5jdGlvbih3aGF0LCBuYW1lcykge1xuICogICByZXR1cm4gd2hhdCArICcgJyArIF8uaW5pdGlhbChuYW1lcykuam9pbignLCAnKSArXG4gKiAgICAgKF8uc2l6ZShuYW1lcykgPiAxID8gJywgJiAnIDogJycpICsgXy5sYXN0KG5hbWVzKTtcbiAqIH0pO1xuICpcbiAqIHNheSgnaGVsbG8nLCAnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcycpO1xuICogLy8gPT4gJ2hlbGxvIGZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICovXG5mdW5jdGlvbiByZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHN0YXJ0ID0gc3RhcnQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXN0O1xuIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcbiIsInZhciB0b0Zpbml0ZSA9IHJlcXVpcmUoJy4vdG9GaW5pdGUnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0ludGVnZXI7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHBhcmFsbGVsTGltaXQ7XG5cbnZhciBfZWFjaE9mID0gcmVxdWlyZSgnLi9lYWNoT2YnKTtcblxudmFyIF9lYWNoT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFjaE9mKTtcblxudmFyIF9wYXJhbGxlbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvcGFyYWxsZWwnKTtcblxudmFyIF9wYXJhbGxlbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJhbGxlbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogUnVuIHRoZSBgdGFza3NgIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIGluIHBhcmFsbGVsLCB3aXRob3V0IHdhaXRpbmcgdW50aWxcbiAqIHRoZSBwcmV2aW91cyBmdW5jdGlvbiBoYXMgY29tcGxldGVkLiBJZiBhbnkgb2YgdGhlIGZ1bmN0aW9ucyBwYXNzIGFuIGVycm9yIHRvXG4gKiBpdHMgY2FsbGJhY2ssIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIHZhbHVlIG9mIHRoZVxuICogZXJyb3IuIE9uY2UgdGhlIGB0YXNrc2AgaGF2ZSBjb21wbGV0ZWQsIHRoZSByZXN1bHRzIGFyZSBwYXNzZWQgdG8gdGhlIGZpbmFsXG4gKiBgY2FsbGJhY2tgIGFzIGFuIGFycmF5LlxuICpcbiAqICoqTm90ZToqKiBgcGFyYWxsZWxgIGlzIGFib3V0IGtpY2tpbmctb2ZmIEkvTyB0YXNrcyBpbiBwYXJhbGxlbCwgbm90IGFib3V0XG4gKiBwYXJhbGxlbCBleGVjdXRpb24gb2YgY29kZS4gIElmIHlvdXIgdGFza3MgZG8gbm90IHVzZSBhbnkgdGltZXJzIG9yIHBlcmZvcm1cbiAqIGFueSBJL08sIHRoZXkgd2lsbCBhY3R1YWxseSBiZSBleGVjdXRlZCBpbiBzZXJpZXMuICBBbnkgc3luY2hyb25vdXMgc2V0dXBcbiAqIHNlY3Rpb25zIGZvciBlYWNoIHRhc2sgd2lsbCBoYXBwZW4gb25lIGFmdGVyIHRoZSBvdGhlci4gIEphdmFTY3JpcHQgcmVtYWluc1xuICogc2luZ2xlLXRocmVhZGVkLlxuICpcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gdXNlIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5LiBFYWNoIHByb3BlcnR5IHdpbGxcbiAqIGJlIHJ1biBhcyBhIGZ1bmN0aW9uIGFuZCB0aGUgcmVzdWx0cyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZmluYWwgYGNhbGxiYWNrYFxuICogYXMgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIFRoaXMgY2FuIGJlIGEgbW9yZSByZWFkYWJsZSB3YXkgb2YgaGFuZGxpbmdcbiAqIHJlc3VsdHMgZnJvbSB7QGxpbmsgYXN5bmMucGFyYWxsZWx9LlxuICpcbiAqIEBuYW1lIHBhcmFsbGVsXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gY29udGFpbmluZyBmdW5jdGlvbnMgdG8gcnVuLlxuICogRWFjaCBmdW5jdGlvbiBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCByZXN1bHQpYCB3aGljaCBpdCBtdXN0IGNhbGwgb25cbiAqIGNvbXBsZXRpb24gd2l0aCBhbiBlcnJvciBgZXJyYCAod2hpY2ggY2FuIGJlIGBudWxsYCkgYW5kIGFuIG9wdGlvbmFsIGByZXN1bHRgXG4gKiB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlXG4gKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5XG4gKiAob3Igb2JqZWN0KSBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHRhc2sgY2FsbGJhY2tzLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQGV4YW1wbGVcbiAqIGFzeW5jLnBhcmFsbGVsKFtcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiBdLFxuICogLy8gb3B0aW9uYWwgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHRoZSByZXN1bHRzIGFycmF5IHdpbGwgZXF1YWwgWydvbmUnLCd0d28nXSBldmVuIHRob3VnaFxuICogICAgIC8vIHRoZSBzZWNvbmQgZnVuY3Rpb24gaGFkIGEgc2hvcnRlciB0aW1lb3V0LlxuICogfSk7XG4gKlxuICogLy8gYW4gZXhhbXBsZSB1c2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheVxuICogYXN5bmMucGFyYWxsZWwoe1xuICogICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDEpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgdHdvOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgZXF1YWxzIHRvOiB7b25lOiAxLCB0d286IDJ9XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcGFyYWxsZWxMaW1pdCh0YXNrcywgY2FsbGJhY2spIHtcbiAgKDAsIF9wYXJhbGxlbDIuZGVmYXVsdCkoX2VhY2hPZjIuZGVmYXVsdCwgdGFza3MsIGNhbGxiYWNrKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIihmdW5jdGlvbiAoKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgVGV4dHVyZTJEID0gcmVxdWlyZSgnLi9UZXh0dXJlMkQnKTtcbiAgICBsZXQgSW1hZ2VMb2FkZXIgPSByZXF1aXJlKCcuLi91dGlsL0ltYWdlTG9hZGVyJyk7XG4gICAgbGV0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcblxuICAgIGxldCBNQUdfRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgTUlOX0ZJTFRFUlMgPSB7XG4gICAgICAgIE5FQVJFU1Q6IHRydWUsXG4gICAgICAgIExJTkVBUjogdHJ1ZSxcbiAgICAgICAgTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSX01JUE1BUF9ORUFSRVNUOiB0cnVlLFxuICAgICAgICBORUFSRVNUX01JUE1BUF9MSU5FQVI6IHRydWUsXG4gICAgICAgIExJTkVBUl9NSVBNQVBfTElORUFSOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgV1JBUF9NT0RFUyA9IHtcbiAgICAgICAgUkVQRUFUOiB0cnVlLFxuICAgICAgICBNSVJST1JFRF9SRVBFQVQ6IHRydWUsXG4gICAgICAgIENMQU1QX1RPX0VER0U6IHRydWVcbiAgICB9O1xuICAgIGxldCBUWVBFUyA9IHtcbiAgICAgICAgVU5TSUdORURfQllURTogdHJ1ZSxcbiAgICAgICAgRkxPQVQ6IHRydWVcbiAgICB9O1xuICAgIGxldCBGT1JNQVRTID0ge1xuICAgICAgICBSR0I6IHRydWUsXG4gICAgICAgIFJHQkE6IHRydWVcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgdHlwZSBmb3IgY29sb3IgdGV4dHVyZXMuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfVFlQRSA9ICdVTlNJR05FRF9CWVRFJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZvcm1hdCBmb3IgY29sb3IgdGV4dHVyZXMuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfRk9STUFUID0gJ1JHQkEnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgd3JhcCBtb2RlIGZvciBjb2xvciB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9XUkFQID0gJ1JFUEVBVCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBtaW4gLyBtYWcgZmlsdGVyIGZvciBjb2xvciB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9GSUxURVIgPSAnTElORUFSJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZvciB3aGV0aGVyIGFscGhhIHByZW11bHRpcGx5aW5nIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfUFJFTVVMVElQTFlfQUxQSEEgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZm9yIHdoZXRoZXIgbWlwbWFwcGluZyBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX01JUE1BUCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3Igd2hldGhlciBpbnZlcnQteSBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX0lOVkVSVF9ZID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBDb2xvclRleHR1cmUyRFxuICAgICAqIEBjbGFzc2Rlc2MgQSB0ZXh0dXJlIGNsYXNzIHRvIHJlcHJlc2VudCBhIDJEIGNvbG9yIHRleHR1cmUuXG4gICAgICogQGF1Z21lbnRzIFRleHR1cmUyRFxuICAgICAqL1xuICAgIGNsYXNzIENvbG9yVGV4dHVyZTJEIGV4dGVuZHMgVGV4dHVyZTJEIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFudGlhdGVzIGEgQ29sb3JUZXh0dXJlMkQgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlYyAtIFRoZSBzcGVjaWZpY2F0aW9uIGFyZ3VtZW50cy5cbiAgICAgICAgICogQHBhcmFtIHtJbWFnZURhdGF8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBzcGVjLmltYWdlIC0gVGhlIEhUTUxJbWFnZUVsZW1lbnQgdG8gYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy51cmwgLSBUaGUgSFRNTEltYWdlRWxlbWVudCBVUkwgdG8gbG9hZCBhbmQgYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl8RmxvYXQzMkFycmF5fSBzcGVjLnNyYyAtIFRoZSBkYXRhIHRvIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWMud2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHRleHR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcGVjLmhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIHRleHR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLndyYXAgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIGJvdGggUyBhbmQgVCBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLndyYXBTIC0gVGhlIHdyYXBwaW5nIHR5cGUgb3ZlciB0aGUgUyBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLndyYXBUIC0gVGhlIHdyYXBwaW5nIHR5cGUgb3ZlciB0aGUgVCBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLmZpbHRlciAtIFRoZSBtaW4gLyBtYWcgZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLm1pbkZpbHRlciAtIFRoZSBtaW5pZmljYXRpb24gZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLm1hZ0ZpbHRlciAtIFRoZSBtYWduaWZpY2F0aW9uIGZpbHRlciB1c2VkIGR1cmluZyBzY2FsaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2x9IHNwZWMubWlwTWFwIC0gV2hldGhlciBvciBub3QgbWlwLW1hcHBpbmcgaXMgZW5hYmxlZC5cbiAgICAgICAgICogQHBhcmFtIHtib29sfSBzcGVjLmludmVydFkgLSBXaGV0aGVyIG9yIG5vdCBpbnZlcnQteSBpcyBlbmFibGVkLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2x9IHNwZWMucHJlTXVsdGlwbHlBbHBoYSAtIFdoZXRoZXIgb3Igbm90IGFscGhhIHByZW11bHRpcGx5aW5nIGlzIGVuYWJsZWQuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLmZvcm1hdCAtIFRoZSB0ZXh0dXJlIHBpeGVsIGZvcm1hdC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMudHlwZSAtIFRoZSB0ZXh0dXJlIHBpeGVsIGNvbXBvbmVudCB0eXBlLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayB0byBiZSBleGVjdXRlZCBpZiB0aGUgZGF0YSBpcyBsb2FkZWQgYXN5bmNocm9ub3VzbHkgdmlhIGEgVVJMLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3Ioc3BlYyA9IHt9LCBjYWxsYmFjayA9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGdldCBzcGVjaWZpYyBwYXJhbXNcbiAgICAgICAgICAgIHNwZWMud3JhcFMgPSBzcGVjLndyYXBTIHx8IHNwZWMud3JhcDtcbiAgICAgICAgICAgIHNwZWMud3JhcFQgPSBzcGVjLndyYXBUIHx8IHNwZWMud3JhcDtcbiAgICAgICAgICAgIHNwZWMubWluRmlsdGVyID0gc3BlYy5taW5GaWx0ZXIgfHwgc3BlYy5maWx0ZXI7XG4gICAgICAgICAgICBzcGVjLm1hZ0ZpbHRlciA9IHNwZWMubWFnRmlsdGVyIHx8IHNwZWMuZmlsdGVyO1xuICAgICAgICAgICAgLy8gc2V0IHRleHR1cmUgcGFyYW1zXG4gICAgICAgICAgICBzcGVjLndyYXBTID0gV1JBUF9NT0RFU1tzcGVjLndyYXBTXSA/IHNwZWMud3JhcFMgOiBERUZBVUxUX1dSQVA7XG4gICAgICAgICAgICBzcGVjLndyYXBUID0gV1JBUF9NT0RFU1tzcGVjLndyYXBUXSA/IHNwZWMud3JhcFQgOiBERUZBVUxUX1dSQVA7XG4gICAgICAgICAgICBzcGVjLm1pbkZpbHRlciA9IE1JTl9GSUxURVJTW3NwZWMubWluRmlsdGVyXSA/IHNwZWMubWluRmlsdGVyIDogREVGQVVMVF9GSUxURVI7XG4gICAgICAgICAgICBzcGVjLm1hZ0ZpbHRlciA9IE1BR19GSUxURVJTW3NwZWMubWFnRmlsdGVyXSA/IHNwZWMubWFnRmlsdGVyIDogREVGQVVMVF9GSUxURVI7XG4gICAgICAgICAgICAvLyBzZXQgb3RoZXIgcHJvcGVydGllc1xuICAgICAgICAgICAgc3BlYy5taXBNYXAgPSBzcGVjLm1pcE1hcCAhPT0gdW5kZWZpbmVkID8gc3BlYy5taXBNYXAgOiBERUZBVUxUX01JUE1BUDtcbiAgICAgICAgICAgIHNwZWMuaW52ZXJ0WSA9IHNwZWMuaW52ZXJ0WSAhPT0gdW5kZWZpbmVkID8gc3BlYy5pbnZlcnRZIDogREVGQVVMVF9JTlZFUlRfWTtcbiAgICAgICAgICAgIHNwZWMucHJlTXVsdGlwbHlBbHBoYSA9IHNwZWMucHJlTXVsdGlwbHlBbHBoYSAhPT0gdW5kZWZpbmVkID8gc3BlYy5wcmVNdWx0aXBseUFscGhhIDogREVGQVVMVF9QUkVNVUxUSVBMWV9BTFBIQTtcbiAgICAgICAgICAgIC8vIHNldCBmb3JtYXRcbiAgICAgICAgICAgIHNwZWMuZm9ybWF0ID0gRk9STUFUU1tzcGVjLmZvcm1hdF0gPyBzcGVjLmZvcm1hdCA6IERFRkFVTFRfRk9STUFUO1xuICAgICAgICAgICAgLy8gYnVmZmVyIHRoZSB0ZXh0dXJlIGJhc2VkIG9uIGFyZ3VtZW50IHR5cGVcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BlYy5zcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdCBzb3VyY2UgZnJvbSB1cmxcbiAgICAgICAgICAgICAgICBzcGVjLnR5cGUgPSAnVU5TSUdORURfQllURSc7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCBiYXNlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgc3VwZXIoc3BlYyk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcHV0IGV4dGVuc2lvbiBoYW5kbGluZyBmb3IgYXJyYXlidWZmZXIgLyBpbWFnZSAvIHZpZGVvIGRpZmZlcmVudGlhdGlvblxuICAgICAgICAgICAgICAgIEltYWdlTG9hZGVyLmxvYWQoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IHNwZWMuc3JjLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBpbWFnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdG8gdW5zaWduZWQgYnl0ZSB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IFV0aWwucmVzaXplQ2FudmFzKHNwZWMsIGltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdyBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyRGF0YShpbWFnZSwgc3BlYy53aWR0aCwgc3BlYy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhlY3V0ZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChVdGlsLmlzQ2FudmFzVHlwZShzcGVjLnNyYykpIHtcbiAgICAgICAgICAgICAgICAvLyBpcyBpbWFnZSAvIGNhbnZhcyAvIHZpZGVvIHR5cGVcbiAgICAgICAgICAgICAgICAvLyBzZXQgdG8gdW5zaWduZWQgYnl0ZSB0eXBlXG4gICAgICAgICAgICAgICAgc3BlYy50eXBlID0gJ1VOU0lHTkVEX0JZVEUnO1xuICAgICAgICAgICAgICAgIHNwZWMuc3JjID0gVXRpbC5yZXNpemVDYW52YXMoc3BlYywgc3BlYy5zcmMpO1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgYmFzZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIHN1cGVyKHNwZWMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhcnJheSwgYXJyYXlidWZmZXIsIG9yIG51bGxcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5zcmMgPT09IHVuZGVmaW5lZCB8fCBzcGVjLnNyYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBkYXRhIGlzIHByb3ZpZGVkLCBhc3N1bWUgdGhpcyB0ZXh0dXJlIHdpbGwgYmUgcmVuZGVyZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8uIEluIHRoaXMgY2FzZSBkaXNhYmxlIG1pcG1hcHBpbmcsIHRoZXJlIGlzIG5vIG5lZWQgYW5kIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgb25seSBpbnRyb2R1Y2UgdmVyeSBwZWN1bGlhciBhbmQgZGlmZmljdWx0IHRvIGRpc2Nlcm5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nIHBoZW5vbWVuYSBpbiB3aGljaCB0aGUgdGV4dHVyZSAndHJhbnNmb3JtcycgYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBhbmdsZXMgLyBkaXN0YW5jZXMgdG8gdGhlIG1pcG1hcHBlZCAoZW1wdHkpIHBvcnRpb25zLlxuICAgICAgICAgICAgICAgICAgICBzcGVjLm1pcE1hcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBidWZmZXIgZnJvbSBhcmdcbiAgICAgICAgICAgICAgICBzcGVjLnR5cGUgPSBUWVBFU1tzcGVjLnR5cGVdID8gc3BlYy50eXBlIDogREVGQVVMVF9UWVBFO1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgYmFzZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIHN1cGVyKHNwZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb2xvclRleHR1cmUyRDtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgVGV4dHVyZTJEID0gcmVxdWlyZSgnLi9UZXh0dXJlMkQnKTtcblxuICAgIGxldCBNQUdfRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgTUlOX0ZJTFRFUlMgPSB7XG4gICAgICAgIE5FQVJFU1Q6IHRydWUsXG4gICAgICAgIExJTkVBUjogdHJ1ZVxuICAgIH07XG4gICAgbGV0IFdSQVBfTU9ERVMgPSB7XG4gICAgICAgIFJFUEVBVDogdHJ1ZSxcbiAgICAgICAgQ0xBTVBfVE9fRURHRTogdHJ1ZSxcbiAgICAgICAgTUlSUk9SRURfUkVQRUFUOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgREVQVEhfVFlQRVMgPSB7XG4gICAgICAgIFVOU0lHTkVEX0JZVEU6IHRydWUsXG4gICAgICAgIFVOU0lHTkVEX1NIT1JUOiB0cnVlLFxuICAgICAgICBVTlNJR05FRF9JTlQ6IHRydWVcbiAgICB9O1xuICAgIGxldCBGT1JNQVRTID0ge1xuICAgICAgICBERVBUSF9DT01QT05FTlQ6IHRydWUsXG4gICAgICAgIERFUFRIX1NURU5DSUw6IHRydWVcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgdHlwZSBmb3IgZGVwdGggdGV4dHVyZXMuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfVFlQRSA9ICdVTlNJR05FRF9JTlQnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZm9ybWF0IGZvciBkZXB0aCB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9GT1JNQVQgPSAnREVQVEhfQ09NUE9ORU5UJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHdyYXAgbW9kZSBmb3IgZGVwdGggdGV4dHVyZXMuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfV1JBUCA9ICdDTEFNUF9UT19FREdFJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IG1pbiAvIG1hZyBmaWx0ZXIgZm9yIGRlcHRoIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX0ZJTFRFUiA9ICdMSU5FQVInO1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIERlcHRoVGV4dHVyZTJEXG4gICAgICogQGNsYXNzZGVzYyBBIHRleHR1cmUgY2xhc3MgdG8gcmVwcmVzZW50IGEgMkQgZGVwdGggdGV4dHVyZS5cbiAgICAgKiBAYXVnbWVudHMgVGV4dHVyZTJEXG4gICAgICovXG4gICAgY2xhc3MgRGVwdGhUZXh0dXJlMkQgZXh0ZW5kcyBUZXh0dXJlMkQge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYSBEZXB0aFRleHR1cmUyRCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIC0gVGhlIHNwZWNpZmljYXRpb24gYXJndW1lbnRzLlxuICAgICAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl8VWludDE2QXJyYXl8VWludDMyQXJyYXl9IHNwZWMuc3JjIC0gVGhlIGRhdGEgdG8gYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3BlYy53aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWMuaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgYm90aCBTIGFuZCBUIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcFMgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIHRoZSBTIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcFQgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIHRoZSBUIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMuZmlsdGVyIC0gVGhlIG1pbiAvIG1hZyBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMubWluRmlsdGVyIC0gVGhlIG1pbmlmaWNhdGlvbiBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMubWFnRmlsdGVyIC0gVGhlIG1hZ25pZmljYXRpb24gZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLmZvcm1hdCAtIFRoZSB0ZXh0dXJlIHBpeGVsIGZvcm1hdC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMudHlwZSAtIFRoZSB0ZXh0dXJlIHBpeGVsIGNvbXBvbmVudCB0eXBlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3Ioc3BlYyA9IHt9KSB7XG4gICAgICAgICAgICAvLyBnZXQgc3BlY2lmaWMgcGFyYW1zXG4gICAgICAgICAgICBzcGVjLndyYXBTID0gc3BlYy53cmFwUyB8fCBzcGVjLndyYXA7XG4gICAgICAgICAgICBzcGVjLndyYXBUID0gc3BlYy53cmFwVCB8fCBzcGVjLndyYXA7XG4gICAgICAgICAgICBzcGVjLm1pbkZpbHRlciA9IHNwZWMubWluRmlsdGVyIHx8IHNwZWMuZmlsdGVyO1xuICAgICAgICAgICAgc3BlYy5tYWdGaWx0ZXIgPSBzcGVjLm1hZ0ZpbHRlciB8fCBzcGVjLmZpbHRlcjtcbiAgICAgICAgICAgIC8vIHNldCB0ZXh0dXJlIHBhcmFtc1xuICAgICAgICAgICAgc3BlYy53cmFwUyA9IFdSQVBfTU9ERVNbc3BlYy53cmFwU10gPyBzcGVjLndyYXBTIDogREVGQVVMVF9XUkFQO1xuICAgICAgICAgICAgc3BlYy53cmFwVCA9IFdSQVBfTU9ERVNbc3BlYy53cmFwVF0gPyBzcGVjLndyYXBUIDogREVGQVVMVF9XUkFQO1xuICAgICAgICAgICAgc3BlYy5taW5GaWx0ZXIgPSBNSU5fRklMVEVSU1tzcGVjLm1pbkZpbHRlcl0gPyBzcGVjLm1pbkZpbHRlciA6IERFRkFVTFRfRklMVEVSO1xuICAgICAgICAgICAgc3BlYy5tYWdGaWx0ZXIgPSBNQUdfRklMVEVSU1tzcGVjLm1hZ0ZpbHRlcl0gPyBzcGVjLm1hZ0ZpbHRlciA6IERFRkFVTFRfRklMVEVSO1xuICAgICAgICAgICAgLy8gc2V0IG1pcC1tYXBwaW5nIGFuZCBmb3JtYXRcbiAgICAgICAgICAgIHNwZWMubWlwTWFwID0gZmFsc2U7IC8vIGRpc2FibGUgbWlwLW1hcHBpbmdcbiAgICAgICAgICAgIHNwZWMuaW52ZXJ0WSA9IGZhbHNlOyAvLyBubyBuZWVkIHRvIGludmVydC15XG4gICAgICAgICAgICBzcGVjLnByZU11bHRpcGx5QWxwaGEgPSBmYWxzZTsgLy8gbm8gYWxwaGEgdG8gcHJlLW11bHRpcGx5XG4gICAgICAgICAgICBzcGVjLmZvcm1hdCA9IEZPUk1BVFNbc3BlYy5mb3JtYXRdID8gc3BlYy5mb3JtYXQgOiBERUZBVUxUX0ZPUk1BVDtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHN0ZW5jaWwtZGVwdGgsIG9yIGp1c3QgZGVwdGhcbiAgICAgICAgICAgIGlmIChzcGVjLmZvcm1hdCA9PT0gJ0RFUFRIX1NURU5DSUwnKSB7XG4gICAgICAgICAgICAgICAgc3BlYy50eXBlID0gJ1VOU0lHTkVEX0lOVF8yNF84X1dFQkdMJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3BlYy50eXBlID0gREVQVEhfVFlQRVNbc3BlYy50eXBlXSA/IHNwZWMudHlwZSA6IERFRkFVTFRfVFlQRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhbGwgYmFzZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgc3VwZXIoc3BlYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IERlcHRoVGV4dHVyZTJEO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBXZWJHTENvbnRleHQgPSByZXF1aXJlKCcuL1dlYkdMQ29udGV4dCcpO1xuXG4gICAgbGV0IFRZUEVTID0ge1xuICAgICAgICBVTlNJR05FRF9CWVRFOiB0cnVlLFxuICAgICAgICBVTlNJR05FRF9TSE9SVDogdHJ1ZSxcbiAgICAgICAgVU5TSUdORURfSU5UOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgTU9ERVMgPSB7XG4gICAgICAgIFBPSU5UUzogdHJ1ZSxcbiAgICAgICAgTElORVM6IHRydWUsXG4gICAgICAgIExJTkVfU1RSSVA6IHRydWUsXG4gICAgICAgIExJTkVfTE9PUDogdHJ1ZSxcbiAgICAgICAgVFJJQU5HTEVTOiB0cnVlLFxuICAgICAgICBUUklBTkdMRV9TVFJJUDogdHJ1ZSxcbiAgICAgICAgVFJJQU5HTEVfRkFOOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgQllURVNfUEVSX1RZUEUgPSB7XG4gICAgICAgIFVOU0lHTkVEX0JZVEU6IDEsXG4gICAgICAgIFVOU0lHTkVEX1NIT1JUOiAyLFxuICAgICAgICBVTlNJR05FRF9JTlQ6IDRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgY29tcG9uZW50IHR5cGUuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfVFlQRSA9ICdVTlNJR05FRF9TSE9SVCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCByZW5kZXIgbW9kZSAocHJpbWl0aXZlIHR5cGUpLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX01PREUgPSAnVFJJQU5HTEVTJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGJ5dGUgb2Zmc2V0IHRvIHJlbmRlciBmcm9tLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX0JZVEVfT0ZGU0VUID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGNvdW50IG9mIGluZGljZXMgdG8gcmVuZGVyLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX0NPVU5UID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBJbmRleEJ1ZmZlclxuICAgICAqIEBjbGFzc2Rlc2MgQW4gaW5kZXggYnVmZmVyIGNsYXNzIHRvIGhvbGUgaW5kZXhpbmcgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgY2xhc3MgSW5kZXhCdWZmZXIge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYW4gSW5kZXhCdWZmZXIgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1dlYkdMQnVmZmVyfFVpbnQ4QXJyYXl8VWludDE2QXJyYXl8VWluMzJBcnJheXxBcnJheXxOdW1iZXJ9IGFyZyAtIFRoZSBpbmRleCBkYXRhIHRvIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcmVuZGVyaW5nIG9wdGlvbnMuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLm1vZGUgLSBUaGUgZHJhdyBtb2RlIC8gcHJpbWl0aXZlIHR5cGUuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmJ5dGVPZmZzZXQgLSBUaGUgYnl0ZSBvZmZzZXQgaW50byB0aGUgZHJhd24gYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5jb3VudCAtIFRoZSBudW1iZXIgb2YgdmVydGljZXMgdG8gZHJhdy5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKGFyZywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gV2ViR0xDb250ZXh0LmdldCgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gVFlQRVNbb3B0aW9ucy50eXBlXSA/IG9wdGlvbnMudHlwZSA6IERFRkFVTFRfVFlQRTtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IE1PREVTW29wdGlvbnMubW9kZV0gPyBvcHRpb25zLm1vZGUgOiBERUZBVUxUX01PREU7XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gKG9wdGlvbnMuY291bnQgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmNvdW50IDogREVGQVVMVF9DT1VOVDtcbiAgICAgICAgICAgIHRoaXMuYnl0ZU9mZnNldCA9IChvcHRpb25zLmJ5dGVPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmJ5dGVPZmZzZXQgOiBERUZBVUxUX0JZVEVfT0ZGU0VUO1xuICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgV2ViR0xCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2ViR0xCdWZmZXIgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnQXJndW1lbnQgb2YgdHlwZSBXZWJHTEJ1ZmZlcmAgbXVzdCBiZSBjb21wbGltZW50ZWQgd2l0aCBhIGNvcnJlc3BvbmRpbmcgYG9wdGlvbnMuYnl0ZUxlbmd0aGAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IG9wdGlvbnMuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBhcmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGFyZykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnl0ZSBsZW5ndGggYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnQXJndW1lbnQgb2YgdHlwZSBgbnVtYmVyYCBtdXN0IGJlIGNvbXBsaW1lbnRlZCB3aXRoIGEgY29ycmVzcG9uZGluZyBgb3B0aW9ucy50eXBlYCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJEYXRhKGFyZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcnJheUJ1ZmZlciBhcmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnQXJndW1lbnQgb2YgdHlwZSBgQXJyYXlCdWZmZXJgIG11c3QgYmUgY29tcGxpbWVudGVkIHdpdGggYSBjb3JyZXNwb25kaW5nIGBvcHRpb25zLnR5cGVgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlckRhdGEoYXJnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcnJheSBvciBBcnJheUJ1ZmZlclZpZXcgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJEYXRhKGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0VtcHR5IGJ1ZmZlciBtdXN0IGJlIGNvbXBsaW1lbnRlZCB3aXRoIGEgY29ycmVzcG9uZGluZyBgb3B0aW9ucy50eXBlYCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwbG9hZCBpbmRleCBkYXRhIHRvIHRoZSBHUFUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fG51bWJlcn0gYXJnIC0gVGhlIGFycmF5IG9mIGRhdGEgdG8gYnVmZmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtJbmRleEJ1ZmZlcn0gVGhlIGluZGV4IGJ1ZmZlciBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGJ1ZmZlckRhdGEoYXJnKSB7XG4gICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgLy8gY2FzdCBhcnJheSB0byBBcnJheUJ1ZmZlclZpZXcgYmFzZWQgb24gcHJvdmlkZWQgdHlwZVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciB0eXBlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ1VOU0lHTkVEX0lOVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnVmZmVyIHRvIHVpbnQzMlxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBuZXcgVWludDMyQXJyYXkoYXJnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ1VOU0lHTkVEX1NIT1JUJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBidWZmZXIgdG8gdWludDE2XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IG5ldyBVaW50MTZBcnJheShhcmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciB0byB1aW50OFxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBuZXcgVWludDhBcnJheShhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IGVuc3VyZSB0eXBlIGNvcnJlc3BvbmRzIHRvIGRhdGFcbiAgICAgICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ1VOU0lHTkVEX0lOVCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnVU5TSUdORURfU0hPUlQnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnVU5TSUdORURfQllURSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIShhcmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgJiZcbiAgICAgICAgICAgICAgICAgICAgIShOdW1iZXIuaXNJbnRlZ2VyKGFyZykpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnQXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGBBcnJheWAsIGBBcnJheUJ1ZmZlcmAsIGBBcnJheUJ1ZmZlclZpZXdgLCBvciBgbnVtYmVyYCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgdGhhdCB0aGUgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgZXh0ZW5zaW9uXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnVU5TSUdORURfSU5UJyAmJlxuICAgICAgICAgICAgICAgICFXZWJHTENvbnRleHQuY2hlY2tFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdDYW5ub3QgY3JlYXRlIEluZGV4QnVmZmVyIG9mIHR5cGUgYFVOU0lHTkVEX0lOVGAgYXMgZXh0ZW5zaW9uIGBPRVNfZWxlbWVudF9pbmRleF91aW50YCBpcyBub3Qgc3VwcG9ydGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IG92ZXJ3cml0ZSB0aGUgY291bnQgaWYgaXQgaXMgYWxyZWFkeSBzZXRcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50ID09PSBERUZBVUxUX0NPVU5UKSB7XG4gICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gKGFyZyAvIEJZVEVTX1BFUl9UWVBFW3RoaXMudHlwZV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSBhcmcubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBieXRlIGxlbmd0aFxuICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoYXJnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGFyZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gYXJnLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjcmVhdGUgYnVmZmVyIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBidWZmZXIgdGhlIGRhdGFcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGFyZywgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBsb2FkIHBhcnRpYWwgaW5kZXggZGF0YSB0byB0aGUgR1BVLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld30gYXJyYXkgLSBUaGUgYXJyYXkgb2YgZGF0YSB0byBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBieXRlT2Zmc2V0IC0gVGhlIGJ5dGUgb2Zmc2V0IGF0IHdoaWNoIHRvIGJ1ZmZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7SW5kZXhCdWZmZXJ9IFRoZSBpbmRleCBidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBidWZmZXJTdWJEYXRhKGFycmF5LCBieXRlT2Zmc2V0ID0gREVGQVVMVF9CWVRFX09GRlNFVCkge1xuICAgICAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGlmICghdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQnVmZmVyIGhhcyBub3QgeWV0IGJlZW4gYWxsb2NhdGVkLCBhbGxvY2F0ZSB3aXRoIGBidWZmZXJEYXRhYCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjYXN0IGFycmF5IHRvIEFycmF5QnVmZmVyVmlldyBiYXNlZCBvbiBwcm92aWRlZCB0eXBlXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgdHlwZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdVTlNJR05FRF9JTlQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciB0byB1aW50MzJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkoYXJyYXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSAnVU5TSUdORURfU0hPUlQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciB0byB1aW50MTZcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkgPSBuZXcgVWludDE2QXJyYXkoYXJyYXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciB0byB1aW50OFxuICAgICAgICAgICAgICAgICAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICEoYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSAmJlxuICAgICAgICAgICAgICAgICEoYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkgJiZcbiAgICAgICAgICAgICAgICAhKGFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkpICYmXG4gICAgICAgICAgICAgICAgIShhcnJheSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdBcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgYEFycmF5YCwgYEFycmF5QnVmZmVyYCwgb3IgYEFycmF5QnVmZmVyVmlld2AnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgdGhhdCB3ZSBhcmVuJ3Qgb3ZlcmZsb3dpbmcgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgaWYgKGJ5dGVPZmZzZXQgKyBhcnJheS5ieXRlTGVuZ3RoID4gdGhpcy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYEFyZ3VtZW50IG9mIGxlbmd0aCAke2FycmF5LmJ5dGVMZW5ndGh9IGJ5dGVzIHdpdGggYCArXG4gICAgICAgICAgICAgICAgICAgIGBvZmZzZXQgb2YgJHtieXRlT2Zmc2V0fSBieXRlcyBvdmVyZmxvd3MgdGhlIGJ1ZmZlciBgICtcbiAgICAgICAgICAgICAgICAgICAgYGxlbmd0aCBvZiAke3RoaXMuYnl0ZUxlbmd0aH0gYnl0ZXNgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYnl0ZU9mZnNldCwgYXJyYXkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhlY3V0ZSB0aGUgZHJhdyBjb21tYW5kIGZvciB0aGUgYm91bmQgYnVmZmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gJ2RyYXdFbGVtZW50cycuIE9wdGlvbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5tb2RlIC0gVGhlIGRyYXcgbW9kZSAvIHByaW1pdGl2ZSB0eXBlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5ieXRlT2Zmc2V0IC0gVGhlIGJ5dGVPZmZzZXQgaW50byB0aGUgZHJhd24gYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5jb3VudCAtIFRoZSBudW1iZXIgb2YgdmVydGljZXMgdG8gZHJhdy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7SW5kZXhCdWZmZXJ9IFRoZSBpbmRleCBidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBkcmF3KG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGxldCBtb2RlID0gZ2xbb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZV07XG4gICAgICAgICAgICBsZXQgdHlwZSA9IGdsW3RoaXMudHlwZV07XG4gICAgICAgICAgICBsZXQgYnl0ZU9mZnNldCA9IChvcHRpb25zLmJ5dGVPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmJ5dGVPZmZzZXQgOiB0aGlzLmJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAob3B0aW9ucy5jb3VudCAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuY291bnQgOiB0aGlzLmNvdW50O1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0F0dGVtcHRpbmcgdG8gZHJhdyB3aXRoIGEgY291bnQgb2YgMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiaW5kIGJ1ZmZlclxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgLy8gZHJhdyBlbGVtZW50c1xuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKG1vZGUsIGNvdW50LCB0eXBlLCBieXRlT2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gdW5iaW5kXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gSW5kZXhCdWZmZXI7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IFdlYkdMQ29udGV4dCA9IHJlcXVpcmUoJy4vV2ViR0xDb250ZXh0Jyk7XG5cbiAgICBsZXQgVEVYVFVSRV9UQVJHRVRTID0ge1xuICAgICAgICBURVhUVVJFXzJEOiB0cnVlLFxuICAgICAgICBURVhUVVJFX0NVQkVfTUFQOiB0cnVlXG4gICAgfTtcblxuICAgIGxldCBERVBUSF9GT1JNQVRTID0ge1xuICAgICAgICBERVBUSF9DT01QT05FTlQ6IHRydWUsXG4gICAgICAgIERFUFRIX1NURU5DSUw6IHRydWVcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFJlbmRlclRhcmdldFxuICAgICAqIEBjbGFzc2Rlc2MgQSByZW5kZXJUYXJnZXQgY2xhc3MgdG8gYWxsb3cgcmVuZGVyaW5nIHRvIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGNsYXNzIFJlbmRlclRhcmdldCB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3RhbnRpYXRlcyBhIFJlbmRlclRhcmdldCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gV2ViR0xDb250ZXh0LmdldCgpO1xuICAgICAgICAgICAgdGhpcy5mcmFtZWJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kcyB0aGUgcmVuZGVyVGFyZ2V0IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7UmVuZGVyVGFyZ2V0fSBUaGUgcmVuZGVyVGFyZ2V0IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgYmluZCgpIHtcbiAgICAgICAgICAgIC8vIGJpbmQgZnJhbWVidWZmZXJcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5iaW5kcyB0aGUgcmVuZGVyVGFyZ2V0IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7UmVuZGVyVGFyZ2V0fSBUaGUgcmVuZGVyVGFyZ2V0IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdW5iaW5kKCkge1xuICAgICAgICAgICAgLy8gdW5iaW5kIGZyYW1lYnVmZmVyXG4gICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dGFjaGVzIHRoZSBwcm92aWRlZCB0ZXh0dXJlIHRvIHRoZSBwcm92aWRlZCBhdHRhY2htZW50IGxvY2F0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1RleHR1cmUyRH0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlIHRvIGF0dGFjaC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGF0dGFjaG1lbnQgaW5kZXguIChvcHRpb25hbClcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldCAtIFRoZSB0ZXh0dXJlIHRhcmdldCB0eXBlLiAob3B0aW9uYWwpXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1JlbmRlclRhcmdldH0gVGhlIHJlbmRlclRhcmdldCBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHNldENvbG9yVGFyZ2V0KHRleHR1cmUsIGluZGV4LCB0YXJnZXQpIHtcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICBpZiAoIXRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVGV4dHVyZSBhcmd1bWVudCBpcyBtaXNzaW5nJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChURVhUVVJFX1RBUkdFVFNbaW5kZXhdICYmIHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGluZGV4KSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVGV4dHVyZSBjb2xvciBhdHRhY2htZW50IGluZGV4IGlzIGludmFsaWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldCAmJiAhVEVYVFVSRV9UQVJHRVRTW3RhcmdldF0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVGV4dHVyZSB0YXJnZXQgaXMgaW52YWxpZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVzWydjb2xvcicgKyBpbmRleF0gPSB0ZXh0dXJlO1xuICAgICAgICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgICAgICAgICBnbC5GUkFNRUJVRkZFUixcbiAgICAgICAgICAgICAgICBnbFsnQ09MT1JfQVRUQUNITUVOVCcgKyBpbmRleF0sXG4gICAgICAgICAgICAgICAgZ2xbdGFyZ2V0IHx8ICdURVhUVVJFXzJEJ10sXG4gICAgICAgICAgICAgICAgdGV4dHVyZS50ZXh0dXJlLFxuICAgICAgICAgICAgICAgIDApO1xuICAgICAgICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dGFjaGVzIHRoZSBwcm92aWRlZCB0ZXh0dXJlIHRvIHRoZSBwcm92aWRlZCBhdHRhY2htZW50IGxvY2F0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1RleHR1cmUyRH0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlIHRvIGF0dGFjaC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7UmVuZGVyVGFyZ2V0fSBUaGUgcmVuZGVyVGFyZ2V0IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RGVwdGhUYXJnZXQodGV4dHVyZSkge1xuICAgICAgICAgICAgaWYgKCF0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1RleHR1cmUgYXJndW1lbnQgaXMgbWlzc2luZyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIURFUFRIX0ZPUk1BVFNbdGV4dHVyZS5mb3JtYXRdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1Byb3ZpZGVkIHRleHR1cmUgaXMgbm90IG9mIGZvcm1hdCBgREVQVEhfQ09NUE9ORU5UYCBvciBgREVQVEhfU1RFTkNJTGAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZXMuZGVwdGggPSB0ZXh0dXJlO1xuICAgICAgICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgICAgICAgICBnbC5GUkFNRUJVRkZFUixcbiAgICAgICAgICAgICAgICBnbC5ERVBUSF9BVFRBQ0hNRU5ULFxuICAgICAgICAgICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgICAgICAgICAgdGV4dHVyZS50ZXh0dXJlLFxuICAgICAgICAgICAgICAgIDApO1xuICAgICAgICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZXMgdGhlIHJlbmRlclRhcmdldCBhbmQgYWxsIGF0dGFjaGVkIHRleHR1cmVzIGJ5IHRoZSBwcm92aWRlZCBoZWlnaHQgYW5kIHdpZHRoLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgbmV3IHdpZHRoIG9mIHRoZSByZW5kZXJUYXJnZXQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgbmV3IGhlaWdodCBvZiB0aGUgcmVuZGVyVGFyZ2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtSZW5kZXJUYXJnZXR9IFRoZSByZW5kZXJUYXJnZXQgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ251bWJlcicgfHwgKHdpZHRoIDw9IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIFxcYHdpZHRoXFxgIG9mICR7d2lkdGh9IGlzIGludmFsaWRgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICdudW1iZXInIHx8IChoZWlnaHQgPD0gMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgUHJvdmlkZWQgXFxgaGVpZ2h0XFxgIG9mICR7aGVpZ2h0fSBpcyBpbnZhbGlkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0ZXh0dXJlcyA9IHRoaXMudGV4dHVyZXM7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0ZXh0dXJlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIHRleHR1cmVzW2tleV0ucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gUmVuZGVyVGFyZ2V0O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBWZXJ0ZXhQYWNrYWdlID0gcmVxdWlyZSgnLi4vY29yZS9WZXJ0ZXhQYWNrYWdlJyk7XG4gICAgbGV0IFZlcnRleEJ1ZmZlciA9IHJlcXVpcmUoJy4uL2NvcmUvVmVydGV4QnVmZmVyJyk7XG4gICAgbGV0IEluZGV4QnVmZmVyID0gcmVxdWlyZSgnLi4vY29yZS9JbmRleEJ1ZmZlcicpO1xuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhbGwgdmVydGV4IGJ1ZmZlcnMgYW5kIHRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIGNvdW50c1xuICAgICAqIGFyZSBub3QgZXF1YWwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZlcnRleEJ1ZmZlcnMgLSBUaGUgYXJyYXkgb2YgdmVydGV4QnVmZmVycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja1ZlcnRleEJ1ZmZlckNvdW50cyh2ZXJ0ZXhCdWZmZXJzKSB7XG4gICAgICAgIGxldCBjb3VudCA9IG51bGw7XG4gICAgICAgIHZlcnRleEJ1ZmZlcnMuZm9yRWFjaChidWZmZXIgPT4ge1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY291bnQgPSBidWZmZXIuY291bnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCAhPT0gYnVmZmVyLmNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGBWZXJ0ZXhCdWZmZXJzIG11c3QgYWxsIGhhdmUgdGhlIHNhbWUgY291bnQgdG8gYmUgcmVuZGVyZWQgd2l0aG91dCBhbiBJbmRleEJ1ZmZlciwgbWlzbWF0Y2ggb2YgJHtjb3VudH0gYW5kICR7YnVmZmVyLmNvdW50fSBmb3VuZGA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2NvdW50ICcgKyBjb3VudCArICcgPT09ICcgKyBidWZmZXIuY291bnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhbGwgYXR0cmlidXRlIHBvaW50ZXJzIGFuZCB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmIGFuIGluZGV4XG4gICAgICogb2NjdXJzIG1vcmUgdGhhbiBvbmNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2ZXJ0ZXhCdWZmZXJzIC0gVGhlIGFycmF5IG9mIHZlcnRleEJ1ZmZlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tJbmRleENvbGxpc2lvbnModmVydGV4QnVmZmVycykge1xuICAgICAgICBsZXQgaW5kaWNlcyA9IHt9O1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJzLmZvckVhY2goYnVmZmVyID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGJ1ZmZlci5wb2ludGVycykuZm9yRWFjaChpbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgaW5kaWNlc1tpbmRleF0gPSBpbmRpY2VzW2luZGV4XSB8fCAwO1xuICAgICAgICAgICAgICAgIGluZGljZXNbaW5kZXhdKys7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKGluZGljZXMpLmZvckVhY2goaW5kZXggPT4ge1xuICAgICAgICAgICAgaWYgKGluZGljZXNbaW5kZXhdID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IGBNb3JlIHRoYW4gb25lIGF0dHJpYnV0ZSBwb2ludGVyIGV4aXN0cyBmb3IgaW5kZXggXFxgJHtpbmRleH1cXGBgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgUmVuZGVyYWJsZVxuICAgICAqIEBjbGFzc2Rlc2MgQSBjb250YWluZXIgZm9yIG9uZSBvciBtb3JlIFZlcnRleEJ1ZmZlcnMgYW5kIGFuIG9wdGlvbmFsIEluZGV4QnVmZmVyLlxuICAgICAqL1xuICAgIGNsYXNzIFJlbmRlcmFibGUge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYW4gUmVuZGVyYWJsZSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIC0gVGhlIHJlbmRlcmFibGUgc3BlY2lmaWNhdGlvbiBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl8RmxvYXQzMkFycmF5fSBzcGVjLnZlcnRpY2VzIC0gVGhlIHZlcnRpY2VzIHRvIGludGVybGVhdmUgYW5kIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtWZXJ0ZXhCdWZmZXJ9IHNwZWMudmVydGV4QnVmZmVyIC0gQW4gZXhpc3RpbmcgdmVydGV4IGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtWZXJ0ZXhCdWZmZXJbXX0gc3BlYy52ZXJ0ZXhCdWZmZXJzIC0gTXVsdGlwbGUgZXhpc3RpbmcgdmVydGV4IGJ1ZmZlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl8VWludDE2QXJyYXl8VWludDMyQXJyYXl9IHNwZWMuaW5kaWNlcyAtIFRoZSBpbmRpY2VzIHRvIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtJbmRleEJ1ZmZlcn0gc3BlYy5pbmRleGJ1ZmZlciAtIEFuIGV4aXN0aW5nIGluZGV4IGJ1ZmZlci5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHNwZWMgPSB7fSkge1xuICAgICAgICAgICAgaWYgKHNwZWMudmVydGV4QnVmZmVyIHx8IHNwZWMudmVydGV4QnVmZmVycykge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBleGlzdGluZyB2ZXJ0ZXggYnVmZmVyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJzID0gc3BlYy52ZXJ0ZXhCdWZmZXJzIHx8IFtzcGVjLnZlcnRleEJ1ZmZlcl07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNwZWMudmVydGljZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdmVydGV4IHBhY2thZ2VcbiAgICAgICAgICAgICAgICBsZXQgdmVydGV4UGFja2FnZSA9IG5ldyBWZXJ0ZXhQYWNrYWdlKHNwZWMudmVydGljZXMpO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB2ZXJ0ZXggYnVmZmVyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJzID0gW25ldyBWZXJ0ZXhCdWZmZXIodmVydGV4UGFja2FnZSldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGVjLmluZGV4QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIGV4aXN0aW5nIGluZGV4IGJ1ZmZlclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBzcGVjLmluZGV4QnVmZmVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzcGVjLmluZGljZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgaW5kZXggYnVmZmVyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IG5ldyBJbmRleEJ1ZmZlcihzcGVjLmluZGljZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGluZGV4IGJ1ZmZlciwgY2hlY2sgdGhhdCB2ZXJ0ZXggYnVmZmVycyBhbGwgaGF2ZVxuICAgICAgICAgICAgLy8gdGhlIHNhbWUgY291bnRcbiAgICAgICAgICAgIGlmICghdGhpcy5pbmRleEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGNoZWNrVmVydGV4QnVmZmVyQ291bnRzKHRoaXMudmVydGV4QnVmZmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayB0aGF0IG5vIGF0dHJpYnV0ZSBpbmRpY2VzIGNsYXNoXG4gICAgICAgICAgICBjaGVja0luZGV4Q29sbGlzaW9ucyh0aGlzLnZlcnRleEJ1ZmZlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4ZWN1dGUgdGhlIGRyYXcgY29tbWFuZCBmb3IgdGhlIHVuZGVybHlpbmcgYnVmZmVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvICdkcmF3RWxlbWVudHMnLiBPcHRpb25hbC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubW9kZSAtIFRoZSBkcmF3IG1vZGUgLyBwcmltaXRpdmUgdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYnl0ZU9mZnNldCAtIFRoZSBieXRlT2Zmc2V0IGludG8gdGhlIGRyYXduIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuaW5kZXhPZmZzZXQgLSBUaGUgaW5kZXhPZmZzZXQgaW50byB0aGUgZHJhd24gYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5jb3VudCAtIFRoZSBudW1iZXIgb2YgdmVydGljZXMgdG8gZHJhdy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7UmVuZGVyYWJsZX0gLSBUaGUgcmVuZGVyYWJsZSBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGRyYXcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAvLyBkcmF3IHRoZSByZW5kZXJhYmxlXG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBpbmRleCBidWZmZXIgdG8gZHJhdyBlbGVtZW50c1xuICAgICAgICAgICAgICAgIC8vIGJpbmQgdmVydGV4IGJ1ZmZlcnMgYW5kIGVuYWJsZSBhdHRyaWJ1dGUgcG9pbnRlcnNcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlcnMuZm9yRWFjaCh2ZXJ0ZXhCdWZmZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXIuYmluZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGRyYXcgcHJpbWl0aXZlcyB1c2luZyBpbmRleCBidWZmZXJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4QnVmZmVyLmRyYXcob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgLy8gZGlzYWJsZSBhdHRyaWJ1dGUgcG9pbnRlcnNcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlcnMuZm9yRWFjaCh2ZXJ0ZXhCdWZmZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXIudW5iaW5kKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gbm8gYWR2YW50YWdlIHRvIHVuYmluZGluZyBhcyB0aGVyZSBpcyBubyBzdGFjayB1c2VkXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vIGluZGV4IGJ1ZmZlciwgdXNlIGRyYXcgYXJyYXlzXG4gICAgICAgICAgICAgICAgLy8gc2V0IGFsbCBhdHRyaWJ1dGUgcG9pbnRlcnNcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlcnMuZm9yRWFjaCh2ZXJ0ZXhCdWZmZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXIuYmluZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcnRleEJ1ZmZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJzWzBdLmRyYXcob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgYWxsIGF0dHJpYnV0ZSBwb2ludGVyc1xuICAgICAgICAgICAgICAgIHRoaXMudmVydGV4QnVmZmVycy5mb3JFYWNoKHZlcnRleEJ1ZmZlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlci51bmJpbmQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJhYmxlO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBXZWJHTENvbnRleHQgPSByZXF1aXJlKCcuL1dlYkdMQ29udGV4dCcpO1xuICAgIGxldCBTaGFkZXJQYXJzZXIgPSByZXF1aXJlKCcuL1NoYWRlclBhcnNlcicpO1xuICAgIGxldCBBc3luYyA9IHJlcXVpcmUoJy4uL3V0aWwvQXN5bmMnKTtcbiAgICBsZXQgWEhSTG9hZGVyID0gcmVxdWlyZSgnLi4vdXRpbC9YSFJMb2FkZXInKTtcblxuICAgIGxldCBVTklGT1JNX0ZVTkNUSU9OUyA9IHtcbiAgICAgICAgJ2Jvb2wnOiAndW5pZm9ybTFpJyxcbiAgICAgICAgJ2Jvb2xbXSc6ICd1bmlmb3JtMWl2JyxcbiAgICAgICAgJ2Zsb2F0JzogJ3VuaWZvcm0xZicsXG4gICAgICAgICdmbG9hdFtdJzogJ3VuaWZvcm0xZnYnLFxuICAgICAgICAnaW50JzogJ3VuaWZvcm0xaScsXG4gICAgICAgICdpbnRbXSc6ICd1bmlmb3JtMWl2JyxcbiAgICAgICAgJ3VpbnQnOiAndW5pZm9ybTFpJyxcbiAgICAgICAgJ3VpbnRbXSc6ICd1bmlmb3JtMWl2JyxcbiAgICAgICAgJ3ZlYzInOiAndW5pZm9ybTJmdicsXG4gICAgICAgICd2ZWMyW10nOiAndW5pZm9ybTJmdicsXG4gICAgICAgICdpdmVjMic6ICd1bmlmb3JtMml2JyxcbiAgICAgICAgJ2l2ZWMyW10nOiAndW5pZm9ybTJpdicsXG4gICAgICAgICd2ZWMzJzogJ3VuaWZvcm0zZnYnLFxuICAgICAgICAndmVjM1tdJzogJ3VuaWZvcm0zZnYnLFxuICAgICAgICAnaXZlYzMnOiAndW5pZm9ybTNpdicsXG4gICAgICAgICdpdmVjM1tdJzogJ3VuaWZvcm0zaXYnLFxuICAgICAgICAndmVjNCc6ICd1bmlmb3JtNGZ2JyxcbiAgICAgICAgJ3ZlYzRbXSc6ICd1bmlmb3JtNGZ2JyxcbiAgICAgICAgJ2l2ZWM0JzogJ3VuaWZvcm00aXYnLFxuICAgICAgICAnaXZlYzRbXSc6ICd1bmlmb3JtNGl2JyxcbiAgICAgICAgJ21hdDInOiAndW5pZm9ybU1hdHJpeDJmdicsXG4gICAgICAgICdtYXQyW10nOiAndW5pZm9ybU1hdHJpeDJmdicsXG4gICAgICAgICdtYXQzJzogJ3VuaWZvcm1NYXRyaXgzZnYnLFxuICAgICAgICAnbWF0M1tdJzogJ3VuaWZvcm1NYXRyaXgzZnYnLFxuICAgICAgICAnbWF0NCc6ICd1bmlmb3JtTWF0cml4NGZ2JyxcbiAgICAgICAgJ21hdDRbXSc6ICd1bmlmb3JtTWF0cml4NGZ2JyxcbiAgICAgICAgJ3NhbXBsZXIyRCc6ICd1bmlmb3JtMWknLFxuICAgICAgICAnc2FtcGxlckN1YmUnOiAndW5pZm9ybTFpJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIG1hcCBvZiBleGlzdGluZyBhdHRyaWJ1dGVzLCBmaW5kIHRoZSBsb3dlc3QgaW5kZXggdGhhdCBpcyBub3RcbiAgICAgKiBhbHJlYWR5IHVzZWQuIElmIHRoZSBhdHRyaWJ1dGUgb3JkZXJpbmcgd2FzIGFscmVhZHkgcHJvdmlkZWQsIHVzZSB0aGF0XG4gICAgICogaW5zdGVhZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBUaGUgZXhpc3RpbmcgYXR0cmlidXRlcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlY2xhcmF0aW9uIC0gVGhlIGF0dHJpYnV0ZSBkZWNsYXJhdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhdHRyaWJ1dGUgaW5kZXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlSW5kZXgoYXR0cmlidXRlcywgZGVjbGFyYXRpb24pIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgYXR0cmlidXRlIGlzIGFscmVhZHkgZGVjbGFyZWQsIGlmIHNvLCB1c2UgdGhhdCBpbmRleFxuICAgICAgICBpZiAoYXR0cmlidXRlc1tkZWNsYXJhdGlvbi5uYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXNbZGVjbGFyYXRpb24ubmFtZV0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIG5leHQgYXZhaWxhYmxlIGluZGV4XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXIgc291cmNlLCBwYXJzZXMgdGhlIGRlY2xhcmF0aW9ucyBhbmQgYXBwZW5kcyBpbmZvcm1hdGlvbiBwZXJ0YWluaW5nIHRvIHRoZSB1bmlmb3JtcyBhbmQgYXR0cmlidHVlcyBkZWNsYXJlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTaGFkZXJ9IHNoYWRlciAtIFRoZSBzaGFkZXIgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2ZXJ0U291cmNlIC0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmcmFnU291cmNlIC0gVGhlIGZyYWdtZW50IHNoYWRlciBzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBhdHRyaWJ1dGUgYW5kIHVuaWZvcm0gaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0QXR0cmlidXRlc0FuZFVuaWZvcm1zKHNoYWRlciwgdmVydFNvdXJjZSwgZnJhZ1NvdXJjZSkge1xuICAgICAgICBsZXQgZGVjbGFyYXRpb25zID0gU2hhZGVyUGFyc2VyLnBhcnNlRGVjbGFyYXRpb25zKFxuICAgICAgICAgICAgW3ZlcnRTb3VyY2UsIGZyYWdTb3VyY2VdLFxuICAgICAgICAgICAgWyd1bmlmb3JtJywgJ2F0dHJpYnV0ZSddKTtcbiAgICAgICAgLy8gZm9yIGVhY2ggZGVjbGFyYXRpb24gaW4gdGhlIHNoYWRlclxuICAgICAgICBkZWNsYXJhdGlvbnMuZm9yRWFjaChkZWNsYXJhdGlvbiA9PiB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBpdHMgYW4gYXR0cmlidXRlIG9yIHVuaWZvcm1cbiAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbi5xdWFsaWZpZXIgPT09ICdhdHRyaWJ1dGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgYXR0cmlidXRlLCBzdG9yZSB0eXBlIGFuZCBpbmRleFxuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGdldEF0dHJpYnV0ZUluZGV4KHNoYWRlci5hdHRyaWJ1dGVzLCBkZWNsYXJhdGlvbik7XG4gICAgICAgICAgICAgICAgc2hhZGVyLmF0dHJpYnV0ZXNbZGVjbGFyYXRpb24ubmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGRlY2xhcmF0aW9uLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBpZiAoZGVjbGFyYXRpb24ucXVhbGlmaWVyID09PSAndW5pZm9ybScpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB1bmlmb3JtLCBzdG9yZSB0eXBlIGFuZCBidWZmZXIgZnVuY3Rpb24gbmFtZVxuICAgICAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtc1tkZWNsYXJhdGlvbi5uYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZGVjbGFyYXRpb24udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuYzogVU5JRk9STV9GVU5DVElPTlNbZGVjbGFyYXRpb24udHlwZSArIChkZWNsYXJhdGlvbi5jb3VudCA+IDEgPyAnW10nIDogJycpXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc2hhZGVyIHNvdXJjZSBzdHJpbmcgYW5kIHNoYWRlciB0eXBlLCBjb21waWxlcyB0aGUgc2hhZGVyIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgV2ViR0xTaGFkZXIgb2JqZWN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgd2ViZ2wgcmVuZGVyaW5nIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNoYWRlclNvdXJjZSAtIFRoZSBzaGFkZXIgc291cmNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHNoYWRlciB0eXBlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7V2ViR0xTaGFkZXJ9IFRoZSBjb21waWxlZCBzaGFkZXIgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBpbGVTaGFkZXIoZ2wsIHNoYWRlclNvdXJjZSwgdHlwZSkge1xuICAgICAgICBsZXQgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsW3R5cGVdKTtcbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgICAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgICAgICAgdGhyb3cgJ0FuIGVycm9yIG9jY3VycmVkIGNvbXBpbGluZyB0aGUgc2hhZGVyczpcXG4nICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZHMgdGhlIGF0dHJpYnV0ZSBsb2NhdGlvbnMgZm9yIHRoZSBTaGFkZXIgb2JqZWN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NoYWRlcn0gc2hhZGVyIC0gVGhlIFNoYWRlciBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZEF0dHJpYnV0ZUxvY2F0aW9ucyhzaGFkZXIpIHtcbiAgICAgICAgbGV0IGdsID0gc2hhZGVyLmdsO1xuICAgICAgICBsZXQgYXR0cmlidXRlcyA9IHNoYWRlci5hdHRyaWJ1dGVzO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAvLyBiaW5kIHRoZSBhdHRyaWJ1dGUgbG9jYXRpb25cbiAgICAgICAgICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbihcbiAgICAgICAgICAgICAgICBzaGFkZXIucHJvZ3JhbSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0uaW5kZXgsXG4gICAgICAgICAgICAgICAga2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVlcmllcyB0aGUgd2ViZ2wgcmVuZGVyaW5nIGNvbnRleHQgZm9yIHRoZSB1bmlmb3JtIGxvY2F0aW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTaGFkZXJ9IHNoYWRlciAtIFRoZSBTaGFkZXIgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFVuaWZvcm1Mb2NhdGlvbnMoc2hhZGVyKSB7XG4gICAgICAgIGxldCBnbCA9IHNoYWRlci5nbDtcbiAgICAgICAgbGV0IHVuaWZvcm1zID0gc2hhZGVyLnVuaWZvcm1zO1xuICAgICAgICBPYmplY3Qua2V5cyh1bmlmb3JtcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSB1bmlmb3JtIGxvY2F0aW9uXG4gICAgICAgICAgICBsZXQgbG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyLnByb2dyYW0sIGtleSk7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBudWxsLCBwYXJzZSBtYXkgZGV0ZWN0IHVuaWZvcm0gdGhhdCBpcyBjb21waWxlZCBvdXRcbiAgICAgICAgICAgIC8vIGR1ZSB0byBhIHByZXByb2Nlc3NvciBldmFsdWF0aW9uLlxuICAgICAgICAgICAgLy8gVE9ETzogZml4IHBhcnNlciBzbyB0aGF0IGl0IGV2YWx1YXRlcyB0aGVzZSBjb3JyZWN0bHkuXG4gICAgICAgICAgICBpZiAobG9jYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdW5pZm9ybXNba2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybXNba2V5XS5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gbG9hZCBzaGFkZXIgc291cmNlIGZyb20gYSB1cmwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBUaGUgdXJsIHRvIGxvYWQgdGhlIHJlc291cmNlIGZyb20uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGZ1bmN0aW9uIHRvIGxvYWQgdGhlIHNoYWRlciBzb3VyY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9hZFNoYWRlclNvdXJjZSh1cmwpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIFhIUkxvYWRlci5sb2FkKHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZShudWxsLCByZXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkb25lKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHBhc3MgdGhyb3VnaCB0aGUgc2hhZGVyIHNvdXJjZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2YgdGhlIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgZnVuY3Rpb24gdG8gcGFzcyB0aHJvdWdoIHRoZSBzaGFkZXIgc291cmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhc3NUaHJvdWdoU291cmNlKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgZG9uZShudWxsLCBzb3VyY2UpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIGFycmF5IG9mIEdMU0wgc291cmNlIHN0cmluZ3MgYW5kIFVSTHMsIGFuZCByZXNvbHZlcyB0aGVtIGludG8gYW5kIGFycmF5IG9mIEdMU0wgc291cmNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VzIC0gVGhlIHNoYWRlciBzb3VyY2VzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgc2hhZGVyIHNvdXJjZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZXMoc291cmNlcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgbGV0IHRhc2tzID0gW107XG4gICAgICAgICAgICBzb3VyY2VzID0gc291cmNlcyB8fCBbXTtcbiAgICAgICAgICAgIHNvdXJjZXMgPSAhQXJyYXkuaXNBcnJheShzb3VyY2VzKSA/IFtzb3VyY2VzXSA6IHNvdXJjZXM7XG4gICAgICAgICAgICBzb3VyY2VzLmZvckVhY2goc291cmNlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoU2hhZGVyUGFyc2VyLmlzR0xTTChzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzLnB1c2gocGFzc1Rocm91Z2hTb3VyY2Uoc291cmNlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaChsb2FkU2hhZGVyU291cmNlKHNvdXJjZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgQXN5bmMucGFyYWxsZWwodGFza3MsIGRvbmUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHNoYWRlciBwcm9ncmFtIG9iamVjdCBmcm9tIHNvdXJjZSBzdHJpbmdzLiBUaGlzIGluY2x1ZGVzOlxuICAgICAqICAgIDEpIENvbXBpbGluZyBhbmQgbGlua2luZyB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAgICogICAgMikgUGFyc2luZyBzaGFkZXIgc291cmNlIGZvciBhdHRyaWJ1dGUgYW5kIHVuaWZvcm0gaW5mb3JtYXRpb24uXG4gICAgICogICAgMykgQmluZGluZyBhdHRyaWJ1dGUgbG9jYXRpb25zLCBieSBvcmRlciBvZiBkZWxjYXJhdGlvbi5cbiAgICAgKiAgICA0KSBRdWVyeWluZyBhbmQgc3RvcmluZyB1bmlmb3JtIGxvY2F0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NoYWRlcn0gc2hhZGVyIC0gVGhlIFNoYWRlciBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZXMgLSBBIG1hcCBjb250YWluaW5nIHNvdXJjZXMgdW5kZXIgJ3ZlcnQnIGFuZCAnZnJhZycgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NoYWRlcn0gVGhlIHNoYWRlciBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9ncmFtKHNoYWRlciwgc291cmNlcykge1xuICAgICAgICBsZXQgZ2wgPSBzaGFkZXIuZ2w7XG4gICAgICAgIGxldCBjb21tb24gPSBzb3VyY2VzLmNvbW1vbi5qb2luKCcnKTtcbiAgICAgICAgbGV0IHZlcnQgPSBzb3VyY2VzLnZlcnQuam9pbignJyk7XG4gICAgICAgIGxldCBmcmFnID0gc291cmNlcy5mcmFnLmpvaW4oJycpO1xuICAgICAgICAvLyBjb21waWxlIHNoYWRlcnNcbiAgICAgICAgbGV0IHZlcnRleFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGNvbW1vbiArIHZlcnQsICdWRVJURVhfU0hBREVSJyk7XG4gICAgICAgIGxldCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGNvbW1vbiArIGZyYWcsICdGUkFHTUVOVF9TSEFERVInKTtcbiAgICAgICAgLy8gcGFyc2Ugc291cmNlIGZvciBhdHRyaWJ1dGUgYW5kIHVuaWZvcm1zXG4gICAgICAgIHNldEF0dHJpYnV0ZXNBbmRVbmlmb3JtcyhzaGFkZXIsIHZlcnQsIGZyYWcpO1xuICAgICAgICAvLyBjcmVhdGUgdGhlIHNoYWRlciBwcm9ncmFtXG4gICAgICAgIHNoYWRlci5wcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgICAgICAvLyBhdHRhY2ggdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihzaGFkZXIucHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHNoYWRlci5wcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgICAgIC8vIGJpbmQgdmVydGV4IGF0dHJpYnV0ZSBsb2NhdGlvbnMgQkVGT1JFIGxpbmtpbmdcbiAgICAgICAgYmluZEF0dHJpYnV0ZUxvY2F0aW9ucyhzaGFkZXIpO1xuICAgICAgICAvLyBsaW5rIHNoYWRlclxuICAgICAgICBnbC5saW5rUHJvZ3JhbShzaGFkZXIucHJvZ3JhbSk7XG4gICAgICAgIC8vIElmIGNyZWF0aW5nIHRoZSBzaGFkZXIgcHJvZ3JhbSBmYWlsZWQsIGFsZXJ0XG4gICAgICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihzaGFkZXIucHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICAgICAgICB0aHJvdyAnQW4gZXJyb3Igb2NjdXJlZCBsaW5raW5nIHRoZSBzaGFkZXI6XFxuJyArIGdsLmdldFByb2dyYW1JbmZvTG9nKHNoYWRlci5wcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgc2hhZGVyIHVuaWZvcm0gbG9jYXRpb25zXG4gICAgICAgIGdldFVuaWZvcm1Mb2NhdGlvbnMoc2hhZGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgU2hhZGVyXG4gICAgICogQGNsYXNzZGVzYyBBIHNoYWRlciBjbGFzcyB0byBhc3Npc3QgaW4gY29tcGlsaW5nIGFuZCBsaW5raW5nIHdlYmdsIHNoYWRlcnMsIHN0b3JpbmcgYXR0cmlidXRlIGFuZCB1bmlmb3JtIGxvY2F0aW9ucywgYW5kIGJ1ZmZlcmluZyB1bmlmb3Jtcy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaGFkZXIge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYSBTaGFkZXIgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlYyAtIFRoZSBzaGFkZXIgc3BlY2lmaWNhdGlvbiBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfE9iamVjdH0gc3BlYy5jb21tb24gLSBTb3VyY2VzIC8gVVJMcyB0byBiZSBzaGFyZWQgYnkgYm90aCB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfE9iamVjdH0gc3BlYy52ZXJ0IC0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlcyAvIFVSTHMuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfE9iamVjdH0gc3BlYy5mcmFnIC0gVGhlIGZyYWdtZW50IHNoYWRlciBzb3VyY2VzIC8gVVJMcy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gc3BlYy5hdHRyaWJ1dGVzIC0gVGhlIGF0dHJpYnV0ZSBpbmRleCBvcmRlcmluZ3MuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgc2hhZGVyIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBjb21waWxlZCBhbmQgbGlua2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3Ioc3BlYyA9IHt9LCBjYWxsYmFjayA9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHNvdXJjZSBhcmd1bWVudHNcbiAgICAgICAgICAgIGlmICghc3BlYy52ZXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1ZlcnRleCBzaGFkZXIgYXJndW1lbnQgYHZlcnRgIGhhcyBub3QgYmVlbiBwcm92aWRlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNwZWMuZnJhZykge1xuICAgICAgICAgICAgICAgIHRocm93ICdGcmFnbWVudCBzaGFkZXIgYXJndW1lbnQgYGZyYWdgIGhhcyBub3QgYmVlbiBwcm92aWRlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0gPSAwO1xuICAgICAgICAgICAgdGhpcy5nbCA9IFdlYkdMQ29udGV4dC5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbiA9IHNwZWMudmVyc2lvbiB8fCAnMS4wMCc7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMgPSB7fTtcbiAgICAgICAgICAgIC8vIGlmIGF0dHJpYnV0ZSBvcmRlcmluZyBpcyBwcm92aWRlZCwgdXNlIHRob3NlIGluZGljZXNcbiAgICAgICAgICAgIGlmIChzcGVjLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBzcGVjLmF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0ciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHNoYWRlclxuICAgICAgICAgICAgQXN5bmMucGFyYWxsZWwoe1xuICAgICAgICAgICAgICAgIGNvbW1vbjogcmVzb2x2ZVNvdXJjZXMoc3BlYy5jb21tb24pLFxuICAgICAgICAgICAgICAgIHZlcnQ6IHJlc29sdmVTb3VyY2VzKHNwZWMudmVydCksXG4gICAgICAgICAgICAgICAgZnJhZzogcmVzb2x2ZVNvdXJjZXMoc3BlYy5mcmFnKSxcbiAgICAgICAgICAgIH0sIChlcnIsIHNvdXJjZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb25jZSBhbGwgc2hhZGVyIHNvdXJjZXMgYXJlIGxvYWRlZFxuICAgICAgICAgICAgICAgIGNyZWF0ZVByb2dyYW0odGhpcywgc291cmNlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmRzIHRoZSBzaGFkZXIgcHJvZ3JhbSBmb3IgdXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTaGFkZXJ9IFRoZSBzaGFkZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICB1c2UoKSB7XG4gICAgICAgICAgICAvLyB1c2UgdGhlIHNoYWRlclxuICAgICAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWZmZXIgYSB1bmlmb3JtIHZhbHVlIGJ5IG5hbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIHVuaWZvcm0gbmFtZSBpbiB0aGUgc2hhZGVyIHNvdXJjZS5cbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB1bmlmb3JtIHZhbHVlIHRvIGJ1ZmZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7U2hhZGVyfSAtIFRoZSBzaGFkZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRVbmlmb3JtKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbbmFtZV07XG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgdW5pZm9ybSBzcGVjIGV4aXN0cyBmb3IgdGhlIG5hbWVcbiAgICAgICAgICAgIGlmICghdW5pZm9ybSkge1xuICAgICAgICAgICAgICAgIHRocm93IGBObyB1bmlmb3JtIGZvdW5kIHVuZGVyIG5hbWUgXFxgJHtuYW1lfVxcYGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayB2YWx1ZVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgdW5pZm9ybSBhcmd1bWVudCBpcyBkZWZpbmVkXG4gICAgICAgICAgICAgICAgdGhyb3cgYFZhbHVlIHBhc3NlZCBmb3IgdW5pZm9ybSBcXGAke25hbWV9XFxgIGlzIHVuZGVmaW5lZCBvciBudWxsYDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGJvb2xlYW4ncyB0byAwIG9yIDFcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwYXNzIHRoZSBhcmd1bWVudHMgZGVwZW5kaW5nIG9uIHRoZSB0eXBlXG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgc3RyaW5nIGNvbXBhcmlvbnMgZnJvbSBoZXJlLi4uXG4gICAgICAgICAgICBpZiAodW5pZm9ybS50eXBlID09PSAnbWF0MicgfHwgdW5pZm9ybS50eXBlID09PSAnbWF0MycgfHwgdW5pZm9ybS50eXBlID09PSAnbWF0NCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdsW3VuaWZvcm0uZnVuY10odW5pZm9ybS5sb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nbFt1bmlmb3JtLmZ1bmNdKHVuaWZvcm0ubG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1ZmZlciBhIG1hcCBvZiB1bmlmb3JtIHZhbHVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1zIC0gVGhlIG1hcCBvZiB1bmlmb3JtcyBrZXllZCBieSBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTaGFkZXJ9IFRoZSBzaGFkZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRVbmlmb3JtcyhhcmdzKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhcmdzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VW5pZm9ybShuYW1lLCBhcmdzW25hbWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNoYWRlcjtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgQ09NTUVOVFNfUkVHRVhQID0gLyhcXC9cXCooW1xcc1xcU10qPylcXCpcXC8pfChcXC9cXC8oLiopJCkvZ207XG4gICAgbGV0IEVORExJTkVfUkVHRVhQID0gLyhcXHJcXG58XFxufFxccikvZ207XG4gICAgbGV0IFdISVRFU1BBQ0VfUkVHRVhQID0gL1xcc3syLH0vZztcbiAgICBsZXQgQlJBQ0tFVF9XSElURVNQQUNFX1JFR0VYUCA9IC8oXFxzKikoXFxbKShcXHMqKShcXGQrKShcXHMqKShcXF0pKFxccyopL2c7XG4gICAgbGV0IE5BTUVfQ09VTlRfUkVHRVhQID0gLyhbYS16QS1aX11bYS16QS1aMC05X10qKSg/OlxcWyhcXGQrKVxcXSk/LztcbiAgICBsZXQgUFJFQ0lTSU9OX1JFR0VYID0gL1xcYnByZWNpc2lvblxccytcXHcrXFxzK1xcdys7L2c7XG4gICAgbGV0IElOTElORV9QUkVDSVNJT05fUkVHRVggPSAvXFxiKGhpZ2hwfG1lZGl1bXB8bG93cClcXHMrL2c7XG4gICAgbGV0IEdMU0xfUkVHRVhQID0gL3ZvaWRcXHMrbWFpblxccypcXChcXHMqKHZvaWQpKlxccypcXClcXHMqL21pO1xuICAgIGxldCBQUkVQX1JFR0VYUCA9IC8jKFtcXFdcXHdcXHNcXGRdKSg/Oi4qXFxcXHI/XFxuKSouKiQvZ207XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHN0YW5kYXJkIGNvbW1lbnRzIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gc3RyaXAgY29tbWVudHMgZnJvbS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGNvbW1lbnRsZXNzIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpcENvbW1lbnRzKHN0cikge1xuICAgICAgICAvLyByZWdleCBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb2Fncml1cy9zdHJpcGNvbW1lbnRzXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShDT01NRU5UU19SRUdFWFAsICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIHByZWNpc2lvbiBzdGF0ZW1lbnRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIHVucHJvY2Vzc2VkIHNvdXJjZSBjb2RlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcHJvY2Vzc2VkIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmlwUHJlY2lzaW9uKHNvdXJjZSkge1xuICAgICAgICAvLyByZW1vdmUgZ2xvYmFsIHByZWNpc2lvbiBkZWNsYXJhdGlvbnNcbiAgICAgICAgc291cmNlID0gc291cmNlLnJlcGxhY2UoUFJFQ0lTSU9OX1JFR0VYLCAnJyk7XG4gICAgICAgIC8vIHJlbW92ZSBpbmxpbmUgcHJlY2lzaW9uIGRlY2xhcmF0aW9uc1xuICAgICAgICByZXR1cm4gc291cmNlLnJlcGxhY2UoSU5MSU5FX1BSRUNJU0lPTl9SRUdFWCwgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCB3aGl0ZXNwYWNlIGludG8gYSBzaW5nbGUgJyAnIHNwYWNlIGNoYXJhY3Rlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gbm9ybWFsaXplIHdoaXRlc3BhY2UgZnJvbS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIG5vcm1hbGl6ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVdoaXRlc3BhY2Uoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShFTkRMSU5FX1JFR0VYUCwgJyAnKSAvLyByZW1vdmUgbGluZSBlbmRpbmdzXG4gICAgICAgICAgICAucmVwbGFjZShXSElURVNQQUNFX1JFR0VYUCwgJyAnKSAvLyBub3JtYWxpemUgd2hpdGVzcGFjZSB0byBzaW5nbGUgJyAnXG4gICAgICAgICAgICAucmVwbGFjZShCUkFDS0VUX1dISVRFU1BBQ0VfUkVHRVhQLCAnJDIkNCQ2Jyk7IC8vIHJlbW92ZSB3aGl0ZXNwYWNlIGluIGJyYWNrZXRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBuYW1lIGFuZCBjb3VudCBvdXQgb2YgYSBuYW1lIHN0YXRlbWVudCwgcmV0dXJuaW5nIHRoZSBkZWNsYXJhdGlvbiBvYmplY3QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBxdWFsaWZpZXIgLSBUaGUgcXVhbGlmaWVyIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW50cnkgLSBUaGUgdmFyaWFibGUgZGVjbGFyYXRpb24gc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVjbGFyYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlTmFtZUFuZENvdW50KHF1YWxpZmllciwgdHlwZSwgZW50cnkpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIG5hbWUgYW5kIHNpemUgb2YgdmFyaWFibGVcbiAgICAgICAgbGV0IG1hdGNoZXMgPSBlbnRyeS5tYXRjaChOQU1FX0NPVU5UX1JFR0VYUCk7XG4gICAgICAgIGxldCBuYW1lID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgbGV0IGNvdW50ID0gKG1hdGNoZXNbMl0gPT09IHVuZGVmaW5lZCkgPyAxIDogcGFyc2VJbnQobWF0Y2hlc1syXSwgMTApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcXVhbGlmaWVyOiBxdWFsaWZpZXIsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGNvdW50OiBjb3VudFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHNpbmdsZSAnc3RhdGVtZW50Jy4gQSAnc3RhdGVtZW50JyBpcyBjb25zaWRlcmVkIGFueSBzZXF1ZW5jZSBvZlxuICAgICAqIGNoYXJhY3RlcnMgZm9sbG93ZWQgYnkgYSBzZW1pLWNvbG9uLiBUaGVyZWZvcmUsIGEgc2luZ2xlICdzdGF0ZW1lbnQnIGluXG4gICAgICogdGhpcyBzZW5zZSBjb3VsZCBjb250YWluIHNldmVyYWwgY29tbWEgc2VwYXJhdGVkIGRlY2xhcmF0aW9ucy4gUmV0dXJuc1xuICAgICAqIGFsbCByZXN1bHRpbmcgZGVjbGFyYXRpb25zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RhdGVtZW50IC0gVGhlIHN0YXRlbWVudCB0byBwYXJzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgYXJyYXkgb2YgcGFyc2VkIGRlY2xhcmF0aW9uIG9iamVjdHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnQoc3RhdGVtZW50KSB7XG4gICAgICAgIC8vIHNwbGl0IHN0YXRlbWVudCBvbiBjb21tYXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gWyd1bmlmb3JtIG1hdDQgQVsxMF0nLCAnQicsICdDWzJdJ11cbiAgICAgICAgLy9cbiAgICAgICAgbGV0IHNwbGl0ID0gc3RhdGVtZW50LnNwbGl0KCcsJykubWFwKGVsZW0gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0udHJpbSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzcGxpdCBkZWNsYXJhdGlvbiBoZWFkZXIgZnJvbSBzdGF0ZW1lbnRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gWyd1bmlmb3JtJywgJ21hdDQnLCAnQVsxMF0nXVxuICAgICAgICAvL1xuICAgICAgICBsZXQgaGVhZGVyID0gc3BsaXQuc2hpZnQoKS5zcGxpdCgnICcpO1xuXG4gICAgICAgIC8vIHF1YWxpZmllciBpcyBhbHdheXMgZmlyc3QgZWxlbWVudFxuICAgICAgICAvL1xuICAgICAgICAvLyAndW5pZm9ybSdcbiAgICAgICAgLy9cbiAgICAgICAgbGV0IHF1YWxpZmllciA9IGhlYWRlci5zaGlmdCgpO1xuXG4gICAgICAgIC8vIHR5cGUgd2lsbCBiZSB0aGUgc2Vjb25kIGVsZW1lbnRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gJ21hdDQnXG4gICAgICAgIC8vXG4gICAgICAgIGxldCB0eXBlID0gaGVhZGVyLnNoaWZ0KCk7XG5cbiAgICAgICAgLy8gbGFzdCBwYXJ0IG9mIGhlYWRlciB3aWxsIGJlIHRoZSBmaXJzdCwgYW5kIHBvc3NpYmxlIG9ubHkgdmFyaWFibGUgbmFtZVxuICAgICAgICAvL1xuICAgICAgICAvLyBbJ0FbMTBdJywgJ0InLCAnQ1syXSddXG4gICAgICAgIC8vXG4gICAgICAgIGxldCBuYW1lcyA9IGhlYWRlci5jb25jYXQoc3BsaXQpO1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBvdGhlciBuYW1lcyBhZnRlciBhICcsJyBhZGQgdGhlbSBhcyB3ZWxsXG4gICAgICAgIHJldHVybiBuYW1lcy5tYXAobmFtZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOYW1lQW5kQ291bnQocXVhbGlmaWVyLCB0eXBlLCBuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIHRoZSBzb3VyY2Ugc3RyaW5nIGJ5IHNlbWktY29sb25zIGFuZCBjb25zdHJ1Y3RzIGFuIGFycmF5IG9mXG4gICAgICogZGVjbGFyYXRpb24gb2JqZWN0cyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgcXVhbGlmaWVyIGtleXdvcmRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIHNoYWRlciBzb3VyY2Ugc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBrZXl3b3JkcyAtIFRoZSBxdWFsaWZpZXIgZGVjbGFyYXRpb24ga2V5d29yZHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGFycmF5IG9mIHF1YWxpZmllciBkZWNsYXJhdGlvbiBvYmplY3RzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlU291cmNlKHNvdXJjZSwga2V5d29yZHMpIHtcbiAgICAgICAgLy8gZ2V0IGluZGl2aWR1YWwgc3RhdGVtZW50cyAoYW55IHNlcXVlbmNlIGVuZGluZyBpbiA7KVxuICAgICAgICBsZXQgc3RhdGVtZW50cyA9IHNvdXJjZS5zcGxpdCgnOycpO1xuICAgICAgICAvLyBidWlsZCByZWdleCBmb3IgcGFyc2luZyBzdGF0ZW1lbnRzIHdpdGggdGFyZ2V0dGVkIGtleXdvcmRzXG4gICAgICAgIGxldCBrZXl3b3JkU3RyID0ga2V5d29yZHMuam9pbignfCcpO1xuICAgICAgICBsZXQga2V5d29yZFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXFxcXGIoJyArIGtleXdvcmRTdHIgKyAnKVxcXFxiLionKTtcbiAgICAgICAgLy8gcGFyc2UgYW5kIHN0b3JlIGdsb2JhbCBwcmVjaXNpb24gc3RhdGVtZW50cyBhbmQgYW55IGRlY2xhcmF0aW9uc1xuICAgICAgICBsZXQgbWF0Y2hlZCA9IFtdO1xuICAgICAgICAvLyBmb3IgZWFjaCBzdGF0ZW1lbnRcbiAgICAgICAgc3RhdGVtZW50cy5mb3JFYWNoKHN0YXRlbWVudCA9PiB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3Iga2V5d29yZHNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBbJ3VuaWZvcm0gZmxvYXQgdVRpbWUnXVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGxldCBrbWF0Y2ggPSBzdGF0ZW1lbnQubWF0Y2goa2V5d29yZFJlZ2V4KTtcbiAgICAgICAgICAgIGlmIChrbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSBzdGF0ZW1lbnQgYW5kIGFkZCB0byBhcnJheVxuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBtYXRjaGVkLmNvbmNhdChwYXJzZVN0YXRlbWVudChrbWF0Y2hbMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbHRlcnMgb3V0IGR1cGxpY2F0ZSBkZWNsYXJhdGlvbnMgcHJlc2VudCBiZXR3ZWVuIHNoYWRlcnMuIEN1cnJlbnRseVxuICAgICAqIGp1c3QgcmVtb3ZlcyBhbGwgIyBzdGF0ZW1lbnRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkZWNsYXJhdGlvbnMgLSBUaGUgYXJyYXkgb2YgZGVjbGFyYXRpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBmaWx0ZXJlZCBhcnJheSBvZiBkZWNsYXJhdGlvbnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyRHVwbGljYXRlc0J5TmFtZShkZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgLy8gaW4gY2FzZXMgd2hlcmUgdGhlIHNhbWUgZGVjbGFyYXRpb25zIGFyZSBwcmVzZW50IGluIG11bHRpcGxlXG4gICAgICAgIC8vIHNvdXJjZXMsIHRoaXMgZnVuY3Rpb24gd2lsbCByZW1vdmUgZHVwbGljYXRlcyBmcm9tIHRoZSByZXN1bHRzXG4gICAgICAgIGxldCBzZWVuID0ge307XG4gICAgICAgIHJldHVybiBkZWNsYXJhdGlvbnMuZmlsdGVyKGRlY2xhcmF0aW9uID0+IHtcbiAgICAgICAgICAgIGlmIChzZWVuW2RlY2xhcmF0aW9uLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VlbltkZWNsYXJhdGlvbi5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgcHJlcHJvY2Vzc29yIG9uIHRoZSBnbHNsIGNvZGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgLSBUaGUgdW5wcm9jZXNzZWQgc291cmNlIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBwcm9jZXNzZWQgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJlcHJvY2Vzcyhzb3VyY2UpIHtcbiAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHRoaXMgY29ycmVjdGx5Li4uXG4gICAgICAgIHJldHVybiBzb3VyY2UucmVwbGFjZShQUkVQX1JFR0VYUCwgJycpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgdGhlIHByb3ZpZGVkIEdMU0wgc291cmNlLCBhbmQgcmV0dXJucyBhbGwgZGVjbGFyYXRpb24gc3RhdGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlIHByb3ZpZGVkIHF1YWxpZmllciB0eXBlLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGV4dHJhY3QgYWxsIGF0dHJpYnV0ZXMgYW5kIHVuaWZvcm0gbmFtZXMgYW5kIHR5cGVzIGZyb20gYSBzaGFkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBleGFtcGxlLCB3aGVuIHByb3ZpZGVkIGEgJ3VuaWZvcm0nIHF1YWxpZmllcnMsIHRoZSBkZWNsYXJhdGlvbjpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICd1bmlmb3JtIGhpZ2hwIHZlYzMgdVNwZWN1bGFyQ29sb3I7J1xuICAgICAgICAgKlxuICAgICAgICAgKiBXb3VsZCBiZSBwYXJzZWQgdG86XG4gICAgICAgICAqICAgICB7XG4gICAgICAgICAqICAgICAgICAgcXVhbGlmaWVyOiAndW5pZm9ybScsXG4gICAgICAgICAqICAgICAgICAgdHlwZTogJ3ZlYzMnLFxuICAgICAgICAgKiAgICAgICAgIG5hbWU6ICd1U3BlY3VsYXJDb2xvcicsXG4gICAgICAgICAqICAgICAgICAgY291bnQ6IDFcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlcyAtIFRoZSBzaGFkZXIgc291cmNlcy5cbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gcXVhbGlmaWVycyAtIFRoZSBxdWFsaWZpZXJzIHRvIGV4dHJhY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgYXJyYXkgb2YgcXVhbGlmaWVyIGRlY2xhcmF0aW9uIHN0YXRlbWVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBwYXJzZURlY2xhcmF0aW9uczogZnVuY3Rpb24oc291cmNlcyA9IFtdLCBxdWFsaWZpZXJzID0gW10pIHtcbiAgICAgICAgICAgIC8vIGlmIG5vIHNvdXJjZXMgb3IgcXVhbGlmaWVycyBhcmUgcHJvdmlkZWQsIHJldHVybiBlbXB0eSBhcnJheVxuICAgICAgICAgICAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAwIHx8IHF1YWxpZmllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlcyA9IEFycmF5LmlzQXJyYXkoc291cmNlcykgPyBzb3VyY2VzIDogW3NvdXJjZXNdO1xuICAgICAgICAgICAgcXVhbGlmaWVycyA9IEFycmF5LmlzQXJyYXkocXVhbGlmaWVycykgPyBxdWFsaWZpZXJzIDogW3F1YWxpZmllcnNdO1xuICAgICAgICAgICAgLy8gcGFyc2Ugb3V0IHRhcmdldHRlZCBkZWNsYXJhdGlvbnNcbiAgICAgICAgICAgIGxldCBkZWNsYXJhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHNvdXJjZXMuZm9yRWFjaChzb3VyY2UgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHJ1biBwcmVwcm9jZXNzb3JcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBwcmVwcm9jZXNzKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHByZWNpc2lvbiBzdGF0ZW1lbnRzXG4gICAgICAgICAgICAgICAgc291cmNlID0gc3RyaXBQcmVjaXNpb24oc291cmNlKTtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgY29tbWVudHNcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBzdHJpcENvbW1lbnRzKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgLy8gZmluYWxseSwgbm9ybWFsaXplIHRoZSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgc291cmNlID0gbm9ybWFsaXplV2hpdGVzcGFjZShzb3VyY2UpO1xuICAgICAgICAgICAgICAgIC8vIHBhcnNlIG91dCBkZWNsYXJhdGlvbnNcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnMgPSBkZWNsYXJhdGlvbnMuY29uY2F0KHBhcnNlU291cmNlKHNvdXJjZSwgcXVhbGlmaWVycykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgZHVwbGljYXRlcyBhbmQgcmV0dXJuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyRHVwbGljYXRlc0J5TmFtZShkZWNsYXJhdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlY3RzIGJhc2VkIG9uIHRoZSBleGlzdGVuY2Ugb2YgYSAndm9pZCBtYWluKCkgeycgc3RhdGVtZW50LCBpZiB0aGUgc3RyaW5nIGlzIGdsc2wgc291cmNlIGNvZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBUaGUgaW5wdXQgc3RyaW5nIHRvIHRlc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBzdHJpbmcgaXMgZ2xzbCBjb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNHTFNMOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBHTFNMX1JFR0VYUC50ZXN0KHN0cik7XG4gICAgICAgIH1cblxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IFdlYkdMQ29udGV4dCA9IHJlcXVpcmUoJy4vV2ViR0xDb250ZXh0Jyk7XG4gICAgbGV0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcblxuICAgIGxldCBNQUdfRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgTUlOX0ZJTFRFUlMgPSB7XG4gICAgICAgIE5FQVJFU1Q6IHRydWUsXG4gICAgICAgIExJTkVBUjogdHJ1ZSxcbiAgICAgICAgTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSX01JUE1BUF9ORUFSRVNUOiB0cnVlLFxuICAgICAgICBORUFSRVNUX01JUE1BUF9MSU5FQVI6IHRydWUsXG4gICAgICAgIExJTkVBUl9NSVBNQVBfTElORUFSOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgTk9OX01JUE1BUF9NSU5fRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSOiB0cnVlLFxuICAgIH07XG4gICAgbGV0IE1JUE1BUF9NSU5fRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSX01JUE1BUF9ORUFSRVNUOiB0cnVlLFxuICAgICAgICBORUFSRVNUX01JUE1BUF9MSU5FQVI6IHRydWUsXG4gICAgICAgIExJTkVBUl9NSVBNQVBfTElORUFSOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgV1JBUF9NT0RFUyA9IHtcbiAgICAgICAgUkVQRUFUOiB0cnVlLFxuICAgICAgICBNSVJST1JFRF9SRVBFQVQ6IHRydWUsXG4gICAgICAgIENMQU1QX1RPX0VER0U6IHRydWVcbiAgICB9O1xuICAgIGxldCBERVBUSF9UWVBFUyA9IHtcbiAgICAgICAgREVQVEhfQ09NUE9ORU5UOiB0cnVlLFxuICAgICAgICBERVBUSF9TVEVOQ0lMOiB0cnVlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHR5cGUgZm9yIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX1RZUEUgPSAnVU5TSUdORURfQllURSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3JtYXQgZm9yIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX0ZPUk1BVCA9ICdSR0JBJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHdyYXAgbW9kZSBmb3IgdGV4dHVyZXMuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfV1JBUCA9ICdSRVBFQVQnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgbWluIC8gbWFnIGZpbHRlciBmb3IgdGV4dHVyZXMuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfRklMVEVSID0gJ0xJTkVBUic7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3Igd2hldGhlciBhbHBoYSBwcmVtdWx0aXBseWluZyBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX1BSRU1VTFRJUExZX0FMUEhBID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZvciB3aGV0aGVyIG1pcG1hcHBpbmcgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9NSVBNQVAgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZm9yIHdoZXRoZXIgaW52ZXJ0LXkgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9JTlZFUlRfWSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBtaXAtbWFwcGluZyBmaWx0ZXIgc3VmZml4LlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX01JUE1BUF9NSU5fRklMVEVSX1NVRkZJWCA9ICdfTUlQTUFQX0xJTkVBUic7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgVGV4dHVyZTJEXG4gICAgICogQGNsYXNzZGVzYyBBIHRleHR1cmUgY2xhc3MgdG8gcmVwcmVzZW50IGEgMkQgdGV4dHVyZS5cbiAgICAgKi9cbiAgICBjbGFzcyBUZXh0dXJlMkQge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYSBUZXh0dXJlMkQgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl8VWludDE2QXJyYXl8VWludDMyQXJyYXl8RmxvYXQzMkFycmF5fEltYWdlRGF0YXxIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IHNwZWMuc3JjIC0gVGhlIGRhdGEgdG8gYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3BlYy53aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWMuaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgYm90aCBTIGFuZCBUIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcFMgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIHRoZSBTIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcFQgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIHRoZSBUIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMuZmlsdGVyIC0gVGhlIG1pbiAvIG1hZyBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMubWluRmlsdGVyIC0gVGhlIG1pbmlmaWNhdGlvbiBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMubWFnRmlsdGVyIC0gVGhlIG1hZ25pZmljYXRpb24gZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gc3BlYy5taXBNYXAgLSBXaGV0aGVyIG9yIG5vdCBtaXAtbWFwcGluZyBpcyBlbmFibGVkLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2x9IHNwZWMuaW52ZXJ0WSAtIFdoZXRoZXIgb3Igbm90IGludmVydC15IGlzIGVuYWJsZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gc3BlYy5wcmVNdWx0aXBseUFscGhhIC0gV2hldGhlciBvciBub3QgYWxwaGEgcHJlbXVsdGlwbHlpbmcgaXMgZW5hYmxlZC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMuZm9ybWF0IC0gVGhlIHRleHR1cmUgcGl4ZWwgZm9ybWF0LlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy50eXBlIC0gVGhlIHRleHR1cmUgcGl4ZWwgY29tcG9uZW50IHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihzcGVjID0ge30pIHtcbiAgICAgICAgICAgIC8vIGdldCBzcGVjaWZpYyBwYXJhbXNcbiAgICAgICAgICAgIHNwZWMud3JhcFMgPSBzcGVjLndyYXBTIHx8IHNwZWMud3JhcDtcbiAgICAgICAgICAgIHNwZWMud3JhcFQgPSBzcGVjLndyYXBUIHx8IHNwZWMud3JhcDtcbiAgICAgICAgICAgIHNwZWMubWluRmlsdGVyID0gc3BlYy5taW5GaWx0ZXIgfHwgc3BlYy5maWx0ZXI7XG4gICAgICAgICAgICBzcGVjLm1hZ0ZpbHRlciA9IHNwZWMubWFnRmlsdGVyIHx8IHNwZWMuZmlsdGVyO1xuICAgICAgICAgICAgLy8gc2V0IGNvbnRleHRcbiAgICAgICAgICAgIHRoaXMuZ2wgPSBXZWJHTENvbnRleHQuZ2V0KCk7XG4gICAgICAgICAgICAvLyBlbXB0eSB0ZXh0dXJlXG4gICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgICAgICAgICAgLy8gc2V0IHRleHR1cmUgcGFyYW1zXG4gICAgICAgICAgICB0aGlzLndyYXBTID0gc3BlYy53cmFwUyB8fCBERUZBVUxUX1dSQVA7XG4gICAgICAgICAgICB0aGlzLndyYXBUID0gc3BlYy53cmFwVCB8fCBERUZBVUxUX1dSQVA7XG4gICAgICAgICAgICB0aGlzLm1pbkZpbHRlciA9IHNwZWMubWluRmlsdGVyIHx8IERFRkFVTFRfRklMVEVSO1xuICAgICAgICAgICAgdGhpcy5tYWdGaWx0ZXIgPSBzcGVjLm1hZ0ZpbHRlciB8fCBERUZBVUxUX0ZJTFRFUjtcbiAgICAgICAgICAgIC8vIHNldCBvdGhlciBwcm9wZXJ0aWVzXG4gICAgICAgICAgICB0aGlzLm1pcE1hcCA9IHNwZWMubWlwTWFwICE9PSB1bmRlZmluZWQgPyBzcGVjLm1pcE1hcCA6IERFRkFVTFRfTUlQTUFQO1xuICAgICAgICAgICAgdGhpcy5pbnZlcnRZID0gc3BlYy5pbnZlcnRZICE9PSB1bmRlZmluZWQgPyBzcGVjLmludmVydFkgOiBERUZBVUxUX0lOVkVSVF9ZO1xuICAgICAgICAgICAgdGhpcy5wcmVNdWx0aXBseUFscGhhID0gc3BlYy5wcmVNdWx0aXBseUFscGhhICE9PSB1bmRlZmluZWQgPyBzcGVjLnByZU11bHRpcGx5QWxwaGEgOiBERUZBVUxUX1BSRU1VTFRJUExZX0FMUEhBO1xuICAgICAgICAgICAgLy8gc2V0IGZvcm1hdFxuICAgICAgICAgICAgdGhpcy5mb3JtYXQgPSBzcGVjLmZvcm1hdCB8fCBERUZBVUxUX0ZPUk1BVDtcbiAgICAgICAgICAgIGlmIChERVBUSF9UWVBFU1t0aGlzLmZvcm1hdF0gJiYgIVdlYkdMQ29udGV4dC5jaGVja0V4dGVuc2lvbignV0VCR0xfZGVwdGhfdGV4dHVyZScpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYENhbm5vdCBjcmVhdGUgVGV4dHVyZTJEIG9mIGZvcm1hdCBcXGAke3RoaXMuZm9ybWF0fVxcYCBhcyBcXGBXRUJHTF9kZXB0aF90ZXh0dXJlXFxgIGV4dGVuc2lvbiBpcyB1bnN1cHBvcnRlZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgdHlwZVxuICAgICAgICAgICAgdGhpcy50eXBlID0gc3BlYy50eXBlIHx8IERFRkFVTFRfVFlQRTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdGTE9BVCcgJiYgIVdlYkdMQ29udGV4dC5jaGVja0V4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGBDYW5ub3QgY3JlYXRlIFRleHR1cmUyRCBvZiB0eXBlIFxcYEZMT0FUXFxgIGFzIFxcYE9FU190ZXh0dXJlX2Zsb2F0XFxgIGV4dGVuc2lvbiBpcyB1bnN1cHBvcnRlZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1cmwgd2lsbCBub3QgYmUgcmVzb2x2ZWQgeWV0LCBzbyBkb24ndCBidWZmZXIgaW4gdGhhdCBjYXNlXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMuc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHNpemVcbiAgICAgICAgICAgICAgICBpZiAoIVV0aWwuaXNDYW52YXNUeXBlKHNwZWMuc3JjKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgYSBjYW52YXMgdHlwZSwgZGltZW5zaW9ucyBNVVNUIGJlIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMud2lkdGggIT09ICdudW1iZXInIHx8IHNwZWMud2lkdGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ2B3aWR0aGAgYXJndW1lbnQgaXMgbWlzc2luZyBvciBpbnZhbGlkJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMuaGVpZ2h0ICE9PSAnbnVtYmVyJyB8fCBzcGVjLmhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnYGhlaWdodGAgYXJndW1lbnQgaXMgbWlzc2luZyBvciBpbnZhbGlkJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbC5tdXN0QmVQb3dlck9mVHdvKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVV0aWwuaXNQb3dlck9mVHdvKHNwZWMud2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgYFBhcmFtZXRlcnMgcmVxdWlyZSBhIHBvd2VyLW9mLXR3byB0ZXh0dXJlLCB5ZXQgcHJvdmlkZWQgd2lkdGggb2YgXFxgJHtzcGVjLndpZHRofVxcYCBpcyBub3QgYSBwb3dlciBvZiB0d29gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFVdGlsLmlzUG93ZXJPZlR3byhzcGVjLmhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBgUGFyYW1ldGVycyByZXF1aXJlIGEgcG93ZXItb2YtdHdvIHRleHR1cmUsIHlldCBwcm92aWRlZCBoZWlnaHQgb2YgXFxgJHtzcGVjLmhlaWdodH1cXGAgaXMgbm90IGEgcG93ZXIgb2YgdHdvYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBidWZmZXIgdGhlIGRhdGFcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlckRhdGEoc3BlYy5zcmMgfHwgbnVsbCwgc3BlYy53aWR0aCwgc3BlYy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVycyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kcyB0aGUgdGV4dHVyZSBvYmplY3QgdG8gdGhlIHByb3ZpZGVkIHRleHR1cmUgdW5pdCBsb2NhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGxvY2F0aW9uIC0gVGhlIHRleHR1cmUgdW5pdCBsb2NhdGlvbiBpbmRleC4gRGVmYXVsdHMgdG8gMC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VGV4dHVyZTJEfSBUaGUgdGV4dHVyZSBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGJpbmQobG9jYXRpb24gPSAwKSB7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobG9jYXRpb24pIHx8IGxvY2F0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IGBUZXh0dXJlIHVuaXQgbG9jYXRpb24gaXMgaW52YWxpZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsWydURVhUVVJFJyArIGxvY2F0aW9uXSk7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5iaW5kcyB0aGUgdGV4dHVyZSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1RleHR1cmUyRH0gVGhlIHRleHR1cmUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICB1bmJpbmQoKSB7XG4gICAgICAgICAgICAvLyB1bmJpbmQgdGV4dHVyZVxuICAgICAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQnVmZmVyIGRhdGEgaW50byB0aGUgdGV4dHVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlclZpZXd8bnVsbH0gZGF0YSAtIFRoZSBkYXRhIGFycmF5IHRvIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VGV4dHVyZTJEfSBUaGUgdGV4dHVyZSBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGJ1ZmZlckRhdGEoZGF0YSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0ZXh0dXJlIG9iamVjdCBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3RcbiAgICAgICAgICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmluZCB0ZXh0dXJlXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICAgICAgLy8gaW52ZXJ0IHkgaWYgc3BlY2lmaWVkXG4gICAgICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0aGlzLmludmVydFkpO1xuICAgICAgICAgICAgLy8gcHJlbXVsdGlwbHkgYWxwaGEgaWYgc3BlY2lmaWVkXG4gICAgICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRoaXMucHJlTXVsdGlwbHlBbHBoYSk7XG4gICAgICAgICAgICAvLyBjYXN0IGFycmF5IGFyZ1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnVU5TSUdORURfU0hPUlQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDE2QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdVTlNJR05FRF9JTlQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDMyQXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdGTE9BVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBlbnN1cmUgdHlwZSBjb3JyZXNwb25kcyB0byBkYXRhXG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnVU5TSUdORURfQllURSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdVTlNJR05FRF9TSE9SVCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50MzJBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdVTlNJR05FRF9JTlQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ0ZMT0FUJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSAmJiAhKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgJiYgIVV0aWwuaXNDYW52YXNUeXBlKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0FyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBgQXJyYXlgLCBgQXJyYXlCdWZmZXJgLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2BBcnJheUJ1ZmZlclZpZXdgLCBgSW1hZ2VEYXRhYCwgYEhUTUxJbWFnZUVsZW1lbnRgLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2BIVE1MQ2FudmFzRWxlbWVudGAsIGBIVE1MVmlkZW9FbGVtZW50YCwgb3IgbnVsbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVXRpbC5pc0NhbnZhc1R5cGUoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IGRhdGEud2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBkYXRhLmhlaWdodDtcbiAgICAgICAgICAgICAgICAvLyBidWZmZXIgdGhlIHRleHR1cmVcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICAgICAgICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICAgICAgICAgICAgICAwLCAvLyBtaXAtbWFwIGxldmVsLFxuICAgICAgICAgICAgICAgICAgICBnbFt0aGlzLmZvcm1hdF0sIC8vIHdlYmdsIHJlcXVpcmVzIGZvcm1hdCA9PT0gaW50ZXJuYWxGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy5mb3JtYXRdLFxuICAgICAgICAgICAgICAgICAgICBnbFt0aGlzLnR5cGVdLFxuICAgICAgICAgICAgICAgICAgICBkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCB0aGlzLndpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciB0aGUgdGV4dHVyZSBkYXRhXG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICAgICAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgICAgICAgICAgICAgMCwgLy8gbWlwLW1hcCBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBnbFt0aGlzLmZvcm1hdF0sIC8vIHdlYmdsIHJlcXVpcmVzIGZvcm1hdCA9PT0gaW50ZXJuYWxGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIDAsIC8vIGJvcmRlciwgbXVzdCBiZSAwXG4gICAgICAgICAgICAgICAgICAgIGdsW3RoaXMuZm9ybWF0XSxcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy50eXBlXSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBtaXAgbWFwc1xuICAgICAgICAgICAgaWYgKHRoaXMubWlwTWFwKSB7XG4gICAgICAgICAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1bmJpbmQgdGV4dHVyZVxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHRleHR1cmUgcGFyYW1ldGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGJ5IG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMud3JhcCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgYm90aCBTIGFuZCBUIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy53cmFwUyAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgdGhlIFMgZGltZW5zaW9uLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLndyYXBUIC0gVGhlIHdyYXBwaW5nIHR5cGUgb3ZlciB0aGUgVCBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuZmlsdGVyIC0gVGhlIG1pbiAvIG1hZyBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5taW5GaWx0ZXIgLSBUaGUgbWluaWZpY2F0aW9uIGZpbHRlciB1c2VkIGR1cmluZyBzY2FsaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm1hZ0ZpbHRlciAtIFRoZSBtYWduaWZpY2F0aW9uIGZpbHRlciB1c2VkIGR1cmluZyBzY2FsaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtUZXh0dXJlMkR9IFRoZSB0ZXh0dXJlIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICAvLyBiaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgICAvLyBzZXQgd3JhcCBTIHBhcmFtZXRlclxuICAgICAgICAgICAgbGV0IHBhcmFtID0gcGFyYW1zLndyYXBTIHx8IHBhcmFtcy53cmFwO1xuICAgICAgICAgICAgaWYgKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKFdSQVBfTU9ERVNbcGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JhcFMgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2xbdGhpcy53cmFwU10pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGBUZXh0dXJlIHBhcmFtZXRlciBcXGAke3BhcmFtfVxcYCBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgXFxgVEVYVFVSRV9XUkFQX1NcXGBgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCB3cmFwIFQgcGFyYW1ldGVyXG4gICAgICAgICAgICBwYXJhbSA9IHBhcmFtcy53cmFwVCB8fCBwYXJhbXMud3JhcDtcbiAgICAgICAgICAgIGlmIChwYXJhbSkge1xuICAgICAgICAgICAgICAgIGlmIChXUkFQX01PREVTW3BhcmFtXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBUID0gcGFyYW07XG4gICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsW3RoaXMud3JhcFRdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIFxcYFRFWFRVUkVfV1JBUF9UXFxgYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgbWFnIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgICAgICAgIHBhcmFtID0gcGFyYW1zLm1hZ0ZpbHRlciB8fCBwYXJhbXMuZmlsdGVyO1xuICAgICAgICAgICAgaWYgKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1BR19GSUxURVJTW3BhcmFtXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hZ0ZpbHRlciA9IHBhcmFtO1xuICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2xbdGhpcy5tYWdGaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yICdURVhUVVJFX01BR19GSUxURVJcXGBgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBtaW4gZmlsdGVyIHBhcmFtZXRlclxuICAgICAgICAgICAgcGFyYW0gPSBwYXJhbXMubWluRmlsdGVyIHx8IHBhcmFtcy5maWx0ZXI7XG4gICAgICAgICAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taXBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE5PTl9NSVBNQVBfTUlOX0ZJTFRFUlNbcGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGdyYWRlIHRvIG1pcC1tYXAgbWluIGZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0gKz0gREVGQVVMVF9NSVBNQVBfTUlOX0ZJTFRFUl9TVUZGSVg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKE1JUE1BUF9NSU5fRklMVEVSU1twYXJhbV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluRmlsdGVyID0gcGFyYW07XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2xbdGhpcy5taW5GaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIFxcYFRFWFRVUkVfTUlOX0ZJTFRFUlxcYGA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTUlOX0ZJTFRFUlNbcGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbkZpbHRlciA9IHBhcmFtO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsW3RoaXMubWluRmlsdGVyXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIFxcYFRFWFRVUkVfTUlOX0ZJTFRFUlxcYGA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1bmJpbmQgdGV4dHVyZVxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZSB0aGUgdW5kZXJseWluZyB0ZXh0dXJlLiBUaGlzIGNsZWFycyB0aGUgdGV4dHVyZSBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgbmV3IHdpZHRoIG9mIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHRleHR1cmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1RleHR1cmUyRH0gVGhlIHRleHR1cmUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ251bWJlcicgfHwgKHdpZHRoIDw9IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIHdpZHRoIG9mIFxcYCR7d2lkdGh9XFxgIGlzIGludmFsaWRgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICdudW1iZXInIHx8IChoZWlnaHQgPD0gMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgUHJvdmlkZWQgaGVpZ2h0IG9mIFxcYCR7aGVpZ2h0fVxcYCBpcyBpbnZhbGlkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyRGF0YShudWxsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlMkQ7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IFdlYkdMQ29udGV4dCA9IHJlcXVpcmUoJy4vV2ViR0xDb250ZXh0Jyk7XG4gICAgbGV0IEFzeW5jID0gcmVxdWlyZSgnLi4vdXRpbC9Bc3luYycpO1xuICAgIGxldCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyk7XG4gICAgbGV0IEltYWdlTG9hZGVyID0gcmVxdWlyZSgnLi4vdXRpbC9JbWFnZUxvYWRlcicpO1xuXG4gICAgbGV0IEZBQ0VTID0gW1xuICAgICAgICAnLXgnLCAnK3gnLFxuICAgICAgICAnLXknLCAnK3knLFxuICAgICAgICAnLXonLCAnK3onXG4gICAgXTtcbiAgICBsZXQgRkFDRV9UQVJHRVRTID0ge1xuICAgICAgICAnK3onOiAnVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aJyxcbiAgICAgICAgJy16JzogJ1RFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWicsXG4gICAgICAgICcreCc6ICdURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gnLFxuICAgICAgICAnLXgnOiAnVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YJyxcbiAgICAgICAgJyt5JzogJ1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWScsXG4gICAgICAgICcteSc6ICdURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1knXG4gICAgfTtcbiAgICBsZXQgVEFSR0VUUyA9IHtcbiAgICAgICAgVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aOiB0cnVlLFxuICAgICAgICBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1o6IHRydWUsXG4gICAgICAgIFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWDogdHJ1ZSxcbiAgICAgICAgVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YOiB0cnVlLFxuICAgICAgICBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1k6IHRydWUsXG4gICAgICAgIFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWTogdHJ1ZVxuICAgIH07XG4gICAgbGV0IE1BR19GSUxURVJTID0ge1xuICAgICAgICBORUFSRVNUOiB0cnVlLFxuICAgICAgICBMSU5FQVI6IHRydWVcbiAgICB9O1xuICAgIGxldCBNSU5fRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSOiB0cnVlLFxuICAgICAgICBORUFSRVNUX01JUE1BUF9ORUFSRVNUOiB0cnVlLFxuICAgICAgICBMSU5FQVJfTUlQTUFQX05FQVJFU1Q6IHRydWUsXG4gICAgICAgIE5FQVJFU1RfTUlQTUFQX0xJTkVBUjogdHJ1ZSxcbiAgICAgICAgTElORUFSX01JUE1BUF9MSU5FQVI6IHRydWVcbiAgICB9O1xuICAgIGxldCBOT05fTUlQTUFQX01JTl9GSUxURVJTID0ge1xuICAgICAgICBORUFSRVNUOiB0cnVlLFxuICAgICAgICBMSU5FQVI6IHRydWUsXG4gICAgfTtcbiAgICBsZXQgTUlQTUFQX01JTl9GSUxURVJTID0ge1xuICAgICAgICBORUFSRVNUX01JUE1BUF9ORUFSRVNUOiB0cnVlLFxuICAgICAgICBMSU5FQVJfTUlQTUFQX05FQVJFU1Q6IHRydWUsXG4gICAgICAgIE5FQVJFU1RfTUlQTUFQX0xJTkVBUjogdHJ1ZSxcbiAgICAgICAgTElORUFSX01JUE1BUF9MSU5FQVI6IHRydWVcbiAgICB9O1xuICAgIGxldCBXUkFQX01PREVTID0ge1xuICAgICAgICBSRVBFQVQ6IHRydWUsXG4gICAgICAgIE1JUlJPUkVEX1JFUEVBVDogdHJ1ZSxcbiAgICAgICAgQ0xBTVBfVE9fRURHRTogdHJ1ZVxuICAgIH07XG4gICAgbGV0IEZPUk1BVFMgPSB7XG4gICAgICAgIFJHQjogdHJ1ZSxcbiAgICAgICAgUkdCQTogdHJ1ZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCB0eXBlIGZvciB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9UWVBFID0gJ1VOU0lHTkVEX0JZVEUnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZm9ybWF0IGZvciB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9GT1JNQVQgPSAnUkdCQSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCB3cmFwIG1vZGUgZm9yIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX1dSQVAgPSAnQ0xBTVBfVE9fRURHRSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBtaW4gLyBtYWcgZmlsdGVyIGZvciB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9GSUxURVIgPSAnTElORUFSJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZvciB3aGV0aGVyIGFscGhhIHByZW11bHRpcGx5aW5nIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfUFJFTVVMVElQTFlfQUxQSEEgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZm9yIHdoZXRoZXIgbWlwbWFwcGluZyBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX01JUE1BUCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3Igd2hldGhlciBpbnZlcnQteSBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX0lOVkVSVF9ZID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IG1pcC1tYXBwaW5nIGZpbHRlciBzdWZmaXguXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfTUlQTUFQX01JTl9GSUxURVJfU1VGRklYID0gJ19NSVBNQVBfTElORUFSJztcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY3ViZW1hcCBhbmQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZlxuICAgICAqIGl0IGRvZXMgbm90IG1lZXQgcmVxdWlyZW1lbnRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RleHR1cmVDdWJlTWFwfSBjdWJlTWFwIC0gVGhlIGN1YmUgbWFwIHRleHR1cmUgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrRGltZW5zaW9ucyhjdWJlTWFwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3ViZU1hcC53aWR0aCAhPT0gJ251bWJlcicgfHwgY3ViZU1hcC53aWR0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyAnYHdpZHRoYCBhcmd1bWVudCBpcyBtaXNzaW5nIG9yIGludmFsaWQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY3ViZU1hcC5oZWlnaHQgIT09ICdudW1iZXInIHx8IGN1YmVNYXAuaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93ICdgaGVpZ2h0YCBhcmd1bWVudCBpcyBtaXNzaW5nIG9yIGludmFsaWQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdWJlTWFwLndpZHRoICE9PSBjdWJlTWFwLmhlaWdodCkge1xuICAgICAgICAgICAgdGhyb3cgJ1Byb3ZpZGVkIGB3aWR0aGAgbXVzdCBiZSBlcXVhbCB0byBgaGVpZ2h0YCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWwubXVzdEJlUG93ZXJPZlR3byhjdWJlTWFwKSAmJiAhVXRpbC5pc1Bvd2VyT2ZUd28oY3ViZU1hcC53aWR0aCkpIHtcbiAgICAgICAgICAgIHRocm93IGBQYXJhbWV0ZXJzIHJlcXVpcmUgYSBwb3dlci1vZi10d28gdGV4dHVyZSwgeWV0IHByb3ZpZGVkIHNpemUgb2YgJHtjdWJlTWFwLndpZHRofSBpcyBub3QgYSBwb3dlciBvZiB0d29gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIGxvYWQgYSBmYWNlIGZyb20gYSB1cmwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VGV4dHVyZUN1YmVNYXB9IGN1YmVNYXAgLSBUaGUgY3ViZSBtYXAgdGV4dHVyZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldCAtIFRoZSB0ZXh0dXJlIHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gVGhlIHVybCB0byBsb2FkIHRoZSBmYWNlIGZyb20uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGxvYWRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkRmFjZVVSTChjdWJlTWFwLCB0YXJnZXQsIHVybCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgLy8gVE9ETzogcHV0IGV4dGVuc2lvbiBoYW5kbGluZyBmb3IgYXJyYXlidWZmZXIgLyBpbWFnZSAvIHZpZGVvIGRpZmZlcmVudGlhdGlvblxuICAgICAgICAgICAgSW1hZ2VMb2FkZXIubG9hZCh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogaW1hZ2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IFV0aWwucmVzaXplQ2FudmFzKGN1YmVNYXAsIGltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgY3ViZU1hcC5idWZmZXJEYXRhKHRhcmdldCwgaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICBkb25lKG51bGwpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gbG9hZCBhIGZhY2UgZnJvbSBhIGNhbnZhcyB0eXBlIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtUZXh0dXJlQ3ViZU1hcH0gY3ViZU1hcCAtIFRoZSBjdWJlIG1hcCB0ZXh0dXJlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0IC0gVGhlIHRleHR1cmUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gY2FudmFzIC0gVGhlIGNhbnZhcyB0eXBlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIFRoZSBsb2FkZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9hZEZhY2VDYW52YXMoY3ViZU1hcCwgdGFyZ2V0LCBjYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGNhbnZhcyA9IFV0aWwucmVzaXplQ2FudmFzKGN1YmVNYXAsIGNhbnZhcyk7XG4gICAgICAgICAgICBjdWJlTWFwLmJ1ZmZlckRhdGEodGFyZ2V0LCBjYW52YXMpO1xuICAgICAgICAgICAgZG9uZShudWxsKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gbG9hZCBhIGZhY2UgZnJvbSBhbiBhcnJheSB0eXBlIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtUZXh0dXJlQ3ViZU1hcH0gY3ViZU1hcCAtIFRoZSBjdWJlIG1hcCB0ZXh0dXJlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0IC0gVGhlIHRleHR1cmUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBhcnIgLSBUaGUgYXJyYXkgdHlwZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGxvYWRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkRmFjZUFycmF5KGN1YmVNYXAsIHRhcmdldCwgYXJyKSB7XG4gICAgICAgIGNoZWNrRGltZW5zaW9ucyhjdWJlTWFwKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGN1YmVNYXAuYnVmZmVyRGF0YSh0YXJnZXQsIGFycik7XG4gICAgICAgICAgICBkb25lKG51bGwpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBUZXh0dXJlQ3ViZU1hcFxuICAgICAqIEBjbGFzc2Rlc2MgQSB0ZXh0dXJlIGNsYXNzIHRvIHJlcHJlc2VudCBhIGN1YmUgbWFwIHRleHR1cmUuXG4gICAgICovXG4gICAgY2xhc3MgVGV4dHVyZUN1YmVNYXAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYSBUZXh0dXJlQ3ViZU1hcCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIC0gVGhlIHNwZWNpZmljYXRpb24gYXJndW1lbnRzXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjLmZhY2VzIC0gVGhlIGZhY2VzIHRvIGJ1ZmZlciwgdW5kZXIga2V5cyAnK3gnLCAnK3knLCAnK3onLCAnLXgnLCAnLXknLCBhbmQgJy16Jy5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWMud2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGZhY2VzLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3BlYy5oZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBmYWNlcy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgYm90aCBTIGFuZCBUIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcFMgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIHRoZSBTIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcFQgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIHRoZSBUIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMuZmlsdGVyIC0gVGhlIG1pbiAvIG1hZyBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMubWluRmlsdGVyIC0gVGhlIG1pbmlmaWNhdGlvbiBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMubWFnRmlsdGVyIC0gVGhlIG1hZ25pZmljYXRpb24gZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gc3BlYy5taXBNYXAgLSBXaGV0aGVyIG9yIG5vdCBtaXAtbWFwcGluZyBpcyBlbmFibGVkLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2x9IHNwZWMuaW52ZXJ0WSAtIFdoZXRoZXIgb3Igbm90IGludmVydC15IGlzIGVuYWJsZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gc3BlYy5wcmVNdWx0aXBseUFscGhhIC0gV2hldGhlciBvciBub3QgYWxwaGEgcHJlbXVsdGlwbHlpbmcgaXMgZW5hYmxlZC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMuZm9ybWF0IC0gVGhlIHRleHR1cmUgcGl4ZWwgZm9ybWF0LlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy50eXBlIC0gVGhlIHRleHR1cmUgcGl4ZWwgY29tcG9uZW50IHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihzcGVjID0ge30sIGNhbGxiYWNrID0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5nbCA9IFdlYkdMQ29udGV4dC5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBnZXQgc3BlY2lmaWMgcGFyYW1zXG4gICAgICAgICAgICBzcGVjLndyYXBTID0gc3BlYy53cmFwUyB8fCBzcGVjLndyYXA7XG4gICAgICAgICAgICBzcGVjLndyYXBUID0gc3BlYy53cmFwVCB8fCBzcGVjLndyYXA7XG4gICAgICAgICAgICBzcGVjLm1pbkZpbHRlciA9IHNwZWMubWluRmlsdGVyIHx8IHNwZWMuZmlsdGVyO1xuICAgICAgICAgICAgc3BlYy5tYWdGaWx0ZXIgPSBzcGVjLm1hZ0ZpbHRlciB8fCBzcGVjLmZpbHRlcjtcbiAgICAgICAgICAgIC8vIHNldCB0ZXh0dXJlIHBhcmFtc1xuICAgICAgICAgICAgdGhpcy53cmFwUyA9IFdSQVBfTU9ERVNbc3BlYy53cmFwU10gPyBzcGVjLndyYXBTIDogREVGQVVMVF9XUkFQO1xuICAgICAgICAgICAgdGhpcy53cmFwVCA9IFdSQVBfTU9ERVNbc3BlYy53cmFwVF0gPyBzcGVjLndyYXBUIDogREVGQVVMVF9XUkFQO1xuICAgICAgICAgICAgdGhpcy5taW5GaWx0ZXIgPSBNSU5fRklMVEVSU1tzcGVjLm1pbkZpbHRlcl0gPyBzcGVjLm1pbkZpbHRlciA6IERFRkFVTFRfRklMVEVSO1xuICAgICAgICAgICAgdGhpcy5tYWdGaWx0ZXIgPSBNQUdfRklMVEVSU1tzcGVjLm1hZ0ZpbHRlcl0gPyBzcGVjLm1hZ0ZpbHRlciA6IERFRkFVTFRfRklMVEVSO1xuICAgICAgICAgICAgLy8gc2V0IG90aGVyIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHRoaXMubWlwTWFwID0gc3BlYy5taXBNYXAgIT09IHVuZGVmaW5lZCA/IHNwZWMubWlwTWFwIDogREVGQVVMVF9NSVBNQVA7XG4gICAgICAgICAgICB0aGlzLmludmVydFkgPSBzcGVjLmludmVydFkgIT09IHVuZGVmaW5lZCA/IHNwZWMuaW52ZXJ0WSA6IERFRkFVTFRfSU5WRVJUX1k7XG4gICAgICAgICAgICB0aGlzLnByZU11bHRpcGx5QWxwaGEgPSBzcGVjLnByZU11bHRpcGx5QWxwaGEgIT09IHVuZGVmaW5lZCA/IHNwZWMucHJlTXVsdGlwbHlBbHBoYSA6IERFRkFVTFRfUFJFTVVMVElQTFlfQUxQSEE7XG4gICAgICAgICAgICAvLyBzZXQgZm9ybWF0IGFuZCB0eXBlXG4gICAgICAgICAgICB0aGlzLmZvcm1hdCA9IEZPUk1BVFNbc3BlYy5mb3JtYXRdID8gc3BlYy5mb3JtYXQgOiBERUZBVUxUX0ZPUk1BVDtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHNwZWMudHlwZSB8fCBERUZBVUxUX1RZUEU7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnRkxPQVQnICYmICFXZWJHTENvbnRleHQuY2hlY2tFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0JykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQ2Fubm90IGNyZWF0ZSBUZXh0dXJlMkQgb2YgdHlwZSBgRkxPQVRgIGFzIGBPRVNfdGV4dHVyZV9mbG9hdGAgZXh0ZW5zaW9uIGlzIHVuc3VwcG9ydGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBkaW1lbnNpb25zIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gc3BlYy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc3BlYy5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBzZXQgYnVmZmVyZWQgZmFjZXNcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyZWRGYWNlcyA9IFtdO1xuICAgICAgICAgICAgLy8gY3JlYXRlIGN1YmUgbWFwIGJhc2VkIG9uIGlucHV0XG4gICAgICAgICAgICBpZiAoc3BlYy5mYWNlcykge1xuICAgICAgICAgICAgICAgIGxldCB0YXNrcyA9IFtdO1xuICAgICAgICAgICAgICAgIEZBQ0VTLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmFjZSA9IHNwZWMuZmFjZXNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gRkFDRV9UQVJHRVRTW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9hZCBiYXNlZCBvbiB0eXBlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVybFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaChsb2FkRmFjZVVSTCh0aGlzLCB0YXJnZXQsIGZhY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChVdGlsLmlzQ2FudmFzVHlwZShmYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FudmFzXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKGxvYWRGYWNlQ2FudmFzKHRoaXMsIHRhcmdldCwgZmFjZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgLyBhcnJheWJ1ZmZlciBvciBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKGxvYWRGYWNlQXJyYXkodGhpcywgdGFyZ2V0LCBmYWNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBBc3luYy5wYXJhbGxlbCh0YXNrcywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbnVsbFxuICAgICAgICAgICAgICAgIGNoZWNrRGltZW5zaW9ucyh0aGlzKTtcbiAgICAgICAgICAgICAgICBGQUNFUy5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJEYXRhKEZBQ0VfVEFSR0VUU1tpZF0sIG51bGwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHNldCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmRzIHRoZSB0ZXh0dXJlIG9iamVjdCB0byB0aGUgcHJvdmlkZWQgdGV4dHVyZSB1bml0IGxvY2F0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbG9jYXRpb24gLSBUaGUgdGV4dHVyZSB1bml0IGxvY2F0aW9uIGluZGV4LiBEZWZhdWx0cyB0byAwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtUZXh0dXJlQ3ViZU1hcH0gVGhlIHRleHR1cmUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kKGxvY2F0aW9uID0gMCkge1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxvY2F0aW9uKSB8fCBsb2NhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVGV4dHVyZSB1bml0IGxvY2F0aW9uIGlzIGludmFsaWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmluZCBjdWJlIG1hcCB0ZXh0dXJlXG4gICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbFsnVEVYVFVSRScgKyBsb2NhdGlvbl0pO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuYmluZHMgdGhlIHRleHR1cmUgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtUZXh0dXJlQ3ViZU1hcH0gLSBUaGUgdGV4dHVyZSBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHVuYmluZCgpIHtcbiAgICAgICAgICAgIC8vIHVuYmluZCBjdWJlIG1hcCB0ZXh0dXJlXG4gICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWZmZXIgZGF0YSBpbnRvIHRoZSByZXNwZWN0aXZlIGN1YmUgbWFwIGZhY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXQgLSBUaGUgZmFjZSB0YXJnZXQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IGRhdGEgLSBUaGUgZmFjZSBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtUZXh0dXJlQ3ViZU1hcH0gVGhlIHRleHR1cmUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBidWZmZXJEYXRhKHRhcmdldCwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFUQVJHRVRTW3RhcmdldF0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgUHJvdmlkZWQgXFxgdGFyZ2V0XFxgIG9mICR7dGFyZ2V0fSAgaXMgaW52YWxpZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHRleHR1cmUgb2JqZWN0IGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxuICAgICAgICAgICAgaWYgKCF0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgICAvLyBpbnZlcnQgeSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRoaXMuaW52ZXJ0WSk7XG4gICAgICAgICAgICAvLyBwcmVtdWx0aXBseSBhbHBoYSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGhpcy5wcmVNdWx0aXBseUFscGhhKTtcbiAgICAgICAgICAgIC8vIGNhc3QgYXJyYXkgYXJnXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdVTlNJR05FRF9TSE9SVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50MTZBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ1VOU0lHTkVEX0lOVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50MzJBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ0ZMT0FUJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IGVuc3VyZSB0eXBlIGNvcnJlc3BvbmRzIHRvIGRhdGFcbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdVTlNJR05FRF9CWVRFJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ1VOU0lHTkVEX1NIT1JUJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ1VOU0lHTkVEX0lOVCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnRkxPQVQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhICYmICEoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSAmJiAhVXRpbC5pc0NhbnZhc1R5cGUoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGBBcnJheWAsIGBBcnJheUJ1ZmZlcmAsICcgK1xuICAgICAgICAgICAgICAgICAgICAnYEFycmF5QnVmZmVyVmlld2AsIGBJbWFnZURhdGFgLCBgSFRNTEltYWdlRWxlbWVudGAsICcgK1xuICAgICAgICAgICAgICAgICAgICAnYEhUTUxDYW52YXNFbGVtZW50YCwgYEhUTUxWaWRlb0VsZW1lbnRgLCBvciBudWxsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJ1ZmZlciB0aGUgZGF0YVxuICAgICAgICAgICAgaWYgKFV0aWwuaXNDYW52YXNUeXBlKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBkYXRhLndpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy8gYnVmZmVyIHRoZSB0ZXh0dXJlXG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGFyZ2V0XSxcbiAgICAgICAgICAgICAgICAgICAgMCwgLy8gbWlwLW1hcCBsZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy5mb3JtYXRdLCAvLyB3ZWJnbCByZXF1aXJlcyBmb3JtYXQgPT09IGludGVybmFsRm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIGdsW3RoaXMuZm9ybWF0XSxcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy50eXBlXSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciB0aGUgdGV4dHVyZSBkYXRhXG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGFyZ2V0XSxcbiAgICAgICAgICAgICAgICAgICAgMCwgLy8gbWlwLW1hcCBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBnbFt0aGlzLmZvcm1hdF0sIC8vIHdlYmdsIHJlcXVpcmVzIGZvcm1hdCA9PT0gaW50ZXJuYWxGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIDAsIC8vIGJvcmRlciwgbXVzdCBiZSAwXG4gICAgICAgICAgICAgICAgICAgIGdsW3RoaXMuZm9ybWF0XSxcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy50eXBlXSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cmFjayB0aGUgZmFjZSB0aGF0IHdhcyBidWZmZXJlZFxuICAgICAgICAgICAgaWYgKHRoaXMuYnVmZmVyZWRGYWNlcy5pbmRleE9mKHRhcmdldCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJlZEZhY2VzLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGFsbCBmYWNlcyBidWZmZXJlZCwgZ2VuZXJhdGUgbWlwbWFwc1xuICAgICAgICAgICAgaWYgKHRoaXMubWlwTWFwICYmIHRoaXMuYnVmZmVyZWRGYWNlcy5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGdlbmVyYXRlIG1pcG1hcHMgaWYgYWxsIGZhY2VzIGFyZSBidWZmZXJlZFxuICAgICAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfQ1VCRV9NQVApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdW5iaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSB0ZXh0dXJlIHBhcmFtZXRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBieSBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLndyYXAgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIGJvdGggUyBhbmQgVCBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMud3JhcFMgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIHRoZSBTIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy53cmFwVCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgdGhlIFQgZGltZW5zaW9uLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmZpbHRlciAtIFRoZSBtaW4gLyBtYWcgZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMubWluRmlsdGVyIC0gVGhlIG1pbmlmaWNhdGlvbiBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5tYWdGaWx0ZXIgLSBUaGUgbWFnbmlmaWNhdGlvbiBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VGV4dHVyZUN1YmVNYXB9IFRoZSB0ZXh0dXJlIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICAvLyBiaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgICAvLyBzZXQgd3JhcCBTIHBhcmFtZXRlclxuICAgICAgICAgICAgbGV0IHBhcmFtID0gcGFyYW1zLndyYXBTIHx8IHBhcmFtcy53cmFwO1xuICAgICAgICAgICAgaWYgKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKFdSQVBfTU9ERVNbcGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JhcFMgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfUywgZ2xbdGhpcy53cmFwU10pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGBUZXh0dXJlIHBhcmFtZXRlciBcXGAke3BhcmFtfVxcYCBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgXFxgVEVYVFVSRV9XUkFQX1NcXGBgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCB3cmFwIFQgcGFyYW1ldGVyXG4gICAgICAgICAgICBwYXJhbSA9IHBhcmFtcy53cmFwVCB8fCBwYXJhbXMud3JhcDtcbiAgICAgICAgICAgIGlmIChwYXJhbSkge1xuICAgICAgICAgICAgICAgIGlmIChXUkFQX01PREVTW3BhcmFtXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBUID0gcGFyYW07XG4gICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsW3RoaXMud3JhcFRdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIFxcYFRFWFRVUkVfV1JBUF9UXFxgYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgbWFnIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgICAgICAgIHBhcmFtID0gcGFyYW1zLm1hZ0ZpbHRlciB8fCBwYXJhbXMuZmlsdGVyO1xuICAgICAgICAgICAgaWYgKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1BR19GSUxURVJTW3BhcmFtXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hZ0ZpbHRlciA9IHBhcmFtO1xuICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2xbdGhpcy5tYWdGaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yICdURVhUVVJFX01BR19GSUxURVJcXGBgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBtaW4gZmlsdGVyIHBhcmFtZXRlclxuICAgICAgICAgICAgcGFyYW0gPSBwYXJhbXMubWluRmlsdGVyIHx8IHBhcmFtcy5maWx0ZXI7XG4gICAgICAgICAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taXBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE5PTl9NSVBNQVBfTUlOX0ZJTFRFUlNbcGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGdyYWRlIHRvIG1pcC1tYXAgbWluIGZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0gKz0gREVGQVVMVF9NSVBNQVBfTUlOX0ZJTFRFUl9TVUZGSVg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKE1JUE1BUF9NSU5fRklMVEVSU1twYXJhbV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluRmlsdGVyID0gcGFyYW07XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2xbdGhpcy5taW5GaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIFxcYFRFWFRVUkVfTUlOX0ZJTFRFUlxcYGA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTUlOX0ZJTFRFUlNbcGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbkZpbHRlciA9IHBhcmFtO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsW3RoaXMubWluRmlsdGVyXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIFxcYFRFWFRVUkVfTUlOX0ZJTFRFUlxcYGA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1bmJpbmQgdGV4dHVyZVxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gVGV4dHVyZUN1YmVNYXA7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IFdlYkdMQ29udGV4dCA9IHJlcXVpcmUoJy4vV2ViR0xDb250ZXh0Jyk7XG4gICAgbGV0IFZlcnRleFBhY2thZ2UgPSByZXF1aXJlKCcuL1ZlcnRleFBhY2thZ2UnKTtcblxuICAgIGxldCBNT0RFUyA9IHtcbiAgICAgICAgUE9JTlRTOiB0cnVlLFxuICAgICAgICBMSU5FUzogdHJ1ZSxcbiAgICAgICAgTElORV9TVFJJUDogdHJ1ZSxcbiAgICAgICAgTElORV9MT09QOiB0cnVlLFxuICAgICAgICBUUklBTkdMRVM6IHRydWUsXG4gICAgICAgIFRSSUFOR0xFX1NUUklQOiB0cnVlLFxuICAgICAgICBUUklBTkdMRV9GQU46IHRydWVcbiAgICB9O1xuICAgIGxldCBUWVBFUyA9IHtcbiAgICAgICAgQllURTogdHJ1ZSxcbiAgICAgICAgVU5TSUdORURfQllURTogdHJ1ZSxcbiAgICAgICAgU0hPUlQ6IHRydWUsXG4gICAgICAgIFVOU0lHTkVEX1NIT1JUOiB0cnVlLFxuICAgICAgICBGSVhFRDogdHJ1ZSxcbiAgICAgICAgRkxPQVQ6IHRydWVcbiAgICB9O1xuICAgIGxldCBCWVRFU19QRVJfVFlQRSA9IHtcbiAgICAgICAgQllURTogMSxcbiAgICAgICAgVU5TSUdORURfQllURTogMSxcbiAgICAgICAgU0hPUlQ6IDIsXG4gICAgICAgIFVOU0lHTkVEX1NIT1JUOiAyLFxuICAgICAgICBGSVhFRDogNCxcbiAgICAgICAgRkxPQVQ6IDRcbiAgICB9O1xuICAgIGxldCBTSVpFUyA9IHtcbiAgICAgICAgMTogdHJ1ZSxcbiAgICAgICAgMjogdHJ1ZSxcbiAgICAgICAgMzogdHJ1ZSxcbiAgICAgICAgNDogdHJ1ZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBhdHRyaWJ1dGUgcG9pbnQgYnl0ZSBvZmZzZXQuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfQllURV9PRkZTRVQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgcmVuZGVyIG1vZGUgKHByaW1pdGl2ZSB0eXBlKS5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9NT0RFID0gJ1RSSUFOR0xFUyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpbmRleCBvZmZzZXQgdG8gcmVuZGVyIGZyb20uXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfSU5ERVhfT0ZGU0VUID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGNvdW50IG9mIGluZGljZXMgdG8gcmVuZGVyLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX0NPVU5UID0gMDtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBhdHRyaWJ1dGUgcG9pbnRlcnMgYW5kIGRldGVybWluZSB0aGUgYnl0ZSBzdHJpZGUgb2YgdGhlIGJ1ZmZlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZVBvaW50ZXJzIC0gVGhlIGF0dHJpYnV0ZSBwb2ludGVyIG1hcC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGJ5dGUgc3RyaWRlIG9mIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U3RyaWRlKGF0dHJpYnV0ZVBvaW50ZXJzKSB7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIGF0dHJpYnV0ZSBwb2ludGVyIGFzc2lnbmVkIHRvIHRoaXMgYnVmZmVyLFxuICAgICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIGZvciBzdHJpZGUsIHNldCB0byBkZWZhdWx0IG9mIDBcbiAgICAgICAgbGV0IGluZGljZXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVQb2ludGVycyk7XG4gICAgICAgIGlmIChpbmRpY2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1heEJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgYnl0ZVNpemVTdW0gPSAwO1xuICAgICAgICBsZXQgYnl0ZVN0cmlkZSA9IDA7XG4gICAgICAgIGluZGljZXMuZm9yRWFjaChpbmRleCA9PiB7XG4gICAgICAgICAgICBsZXQgcG9pbnRlciA9IGF0dHJpYnV0ZVBvaW50ZXJzW2luZGV4XTtcbiAgICAgICAgICAgIGxldCBieXRlT2Zmc2V0ID0gcG9pbnRlci5ieXRlT2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwb2ludGVyLnNpemU7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHBvaW50ZXIudHlwZTtcbiAgICAgICAgICAgIC8vIHRyYWNrIHRoZSBzdW0gb2YgZWFjaCBhdHRyaWJ1dGUgc2l6ZVxuICAgICAgICAgICAgYnl0ZVNpemVTdW0gKz0gc2l6ZSAqIEJZVEVTX1BFUl9UWVBFW3R5cGVdO1xuICAgICAgICAgICAgLy8gdHJhY2sgdGhlIGxhcmdlc3Qgb2Zmc2V0IHRvIGRldGVybWluZSB0aGUgYnl0ZSBzdHJpZGUgb2YgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPiBtYXhCeXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgbWF4Qnl0ZU9mZnNldCA9IGJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnl0ZVN0cmlkZSA9IGJ5dGVPZmZzZXQgKyAoc2l6ZSAqIEJZVEVTX1BFUl9UWVBFW3R5cGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBtYXggYnl0ZSBvZmZzZXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB0aGUgc3VtIG9mXG4gICAgICAgIC8vIHRoZSBzaXplcy4gSWYgc28gdGhpcyBidWZmZXIgaXMgbm90IGludGVybGVhdmVkIGFuZCBkb2VzIG5vdCBuZWVkIGFcbiAgICAgICAgLy8gc3RyaWRlLlxuICAgICAgICBpZiAobWF4Qnl0ZU9mZnNldCA+PSBieXRlU2l6ZVN1bSkge1xuICAgICAgICAgICAgLy8gVE9ETzogdGVzdCB3aGF0IHN0cmlkZSA9PT0gMCBkb2VzIGZvciBhbiBpbnRlcmxlYXZlZCBidWZmZXIgb2ZcbiAgICAgICAgICAgIC8vIGxlbmd0aCA9PT0gMS5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlU3RyaWRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBhdHRyaWJ1dGUgcG9pbnRlcnMgdG8gZW5zdXJlIHRoZXkgYXJlIHZhbGlkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlUG9pbnRlcnMgLSBUaGUgYXR0cmlidXRlIHBvaW50ZXIgbWFwLlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgdmFsaWRhdGVkIGF0dHJpYnV0ZSBwb2ludGVyIG1hcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVQb2ludGVycyhhdHRyaWJ1dGVQb2ludGVycykge1xuICAgICAgICAvLyBwYXJzZSBwb2ludGVycyB0byBlbnN1cmUgdGhleSBhcmUgdmFsaWRcbiAgICAgICAgbGV0IHBvaW50ZXJzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZVBvaW50ZXJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBwYXJzZUludChrZXksIDEwKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQga2V5IGlzIGFuIHZhbGlkIGludGVnZXJcbiAgICAgICAgICAgIGlmIChpc05hTihpbmRleCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgQXR0cmlidXRlIGluZGV4IFxcYCR7a2V5fVxcYCBkb2VzIG5vdCByZXByZXNlbnQgYW4gaW50ZWdlcmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcG9pbnRlciA9IGF0dHJpYnV0ZVBvaW50ZXJzW2tleV07XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHBvaW50ZXIuc2l6ZTtcbiAgICAgICAgICAgIGxldCB0eXBlID0gcG9pbnRlci50eXBlO1xuICAgICAgICAgICAgbGV0IGJ5dGVPZmZzZXQgPSBwb2ludGVyLmJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICAvLyBjaGVjayBzaXplXG4gICAgICAgICAgICBpZiAoIVNJWkVTW3NpemVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0F0dHJpYnV0ZSBwb2ludGVyIGBzaXplYCBwYXJhbWV0ZXIgaXMgaW52YWxpZCwgbXVzdCBiZSBvbmUgb2YgJyArXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKFNJWkVTKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayB0eXBlXG4gICAgICAgICAgICBpZiAoIVRZUEVTW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0F0dHJpYnV0ZSBwb2ludGVyIGB0eXBlYCBwYXJhbWV0ZXIgaXMgaW52YWxpZCwgbXVzdCBiZSBvbmUgb2YgJyArXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKFRZUEVTKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVyc1tpbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IChieXRlT2Zmc2V0ICE9PSB1bmRlZmluZWQpID8gYnl0ZU9mZnNldCA6IERFRkFVTFRfQllURV9PRkZTRVRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcG9pbnRlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFZlcnRleEJ1ZmZlclxuICAgICAqIEBjbGFzc2Rlc2MgQSB2ZXJ0ZXggYnVmZmVyIG9iamVjdC5cbiAgICAgKi9cbiAgICBjbGFzcyBWZXJ0ZXhCdWZmZXIge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYW4gVmVydGV4QnVmZmVyIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtXZWJHTEJ1ZmZlcnxWZXJ0ZXhQYWNrYWdlfEZsb2F0MzJBcnJheXxBcnJheXxOdW1iZXJ9IGFyZyAtIFRoZSBidWZmZXIgb3IgbGVuZ3RoIG9mIHRoZSBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVQb2ludGVycyAtIFRoZSBhcnJheSBwb2ludGVyIG1hcCwgb3IgaW4gdGhlIGNhc2Ugb2YgYSB2ZXJ0ZXggcGFja2FnZSBhcmcsIHRoZSBvcHRpb25zLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSByZW5kZXJpbmcgb3B0aW9ucy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubW9kZSAtIFRoZSBkcmF3IG1vZGUgLyBwcmltaXRpdmUgdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuaW5kZXhPZmZzZXQgLSBUaGUgaW5kZXggb2Zmc2V0IGludG8gdGhlIGRyYXduIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuY291bnQgLSBUaGUgbnVtYmVyIG9mIGluZGljZXMgdG8gZHJhdy5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKGFyZywgYXR0cmlidXRlUG9pbnRlcnMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gV2ViR0xDb250ZXh0LmdldCgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gTU9ERVNbb3B0aW9ucy5tb2RlXSA/IG9wdGlvbnMubW9kZSA6IERFRkFVTFRfTU9ERTtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAob3B0aW9ucy5jb3VudCAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuY291bnQgOiBERUZBVUxUX0NPVU5UO1xuICAgICAgICAgICAgdGhpcy5pbmRleE9mZnNldCA9IChvcHRpb25zLmluZGV4T2Zmc2V0ICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5pbmRleE9mZnNldCA6IERFRkFVTFRfSU5ERVhfT0ZGU0VUO1xuICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIC8vIGZpcnN0LCBzZXQgdGhlIGF0dHJpYnV0ZSBwb2ludGVyc1xuICAgICAgICAgICAgaWYgKGFyZyAmJiBhcmcuYnVmZmVyICYmIGFyZy5wb2ludGVycykge1xuICAgICAgICAgICAgICAgIC8vIFZlcnRleFBhY2thZ2UgYXJndW1lbnQsIHVzZSBpdHMgYXR0cmlidXRlIHBvaW50ZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVycyA9IGFyZy5wb2ludGVycztcbiAgICAgICAgICAgICAgICAvLyBzaGlmdCBvcHRpb25zIGFyZyBzaW5jZSB0aGVyZSB3aWxsIGJlIG5vIGF0dHJpYiBwb2ludGVycyBhcmdcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXR0cmlidXRlUG9pbnRlcnM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlcnMgPSBnZXRBdHRyaWJ1dGVQb2ludGVycyhhdHRyaWJ1dGVQb2ludGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgdGhlIGJ5dGUgc3RyaWRlXG4gICAgICAgICAgICB0aGlzLmJ5dGVTdHJpZGUgPSBnZXRTdHJpZGUodGhpcy5wb2ludGVycyk7XG4gICAgICAgICAgICAvLyB0aGVuIGJ1ZmZlciB0aGUgZGF0YVxuICAgICAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBWZXJ0ZXhQYWNrYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcnRleFBhY2thZ2UgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJEYXRhKGFyZy5idWZmZXIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgV2ViR0xCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2ViR0xCdWZmZXIgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnQXJndW1lbnQgb2YgdHlwZSBgV2ViR0xCdWZmZXJgIG11c3QgYmUgY29tcGxpbWVudGVkIHdpdGggYSBjb3JyZXNwb25kaW5nIGBvcHRpb25zLmJ5dGVMZW5ndGhgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGFyZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gb3B0aW9ucy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFycmF5IG9yIEFycmF5QnVmZmVyIG9yIG51bWJlciBhcmd1bWVudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlckRhdGEoYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBsb2FkIHZlcnRleCBkYXRhIHRvIHRoZSBHUFUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fG51bWJlcn0gYXJnIC0gVGhlIGFycmF5IG9mIGRhdGEgdG8gYnVmZmVyLCBvciBzaXplIG9mIHRoZSBidWZmZXIgaW4gYnl0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlcnRleEJ1ZmZlcn0gVGhlIHZlcnRleCBidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBidWZmZXJEYXRhKGFyZykge1xuICAgICAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBhcmd1bWVudCBpcyB2YWxpZFxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgICAgIC8vIGNhc3QgYXJyYXkgaW50byBGbG9hdDMyQXJyYXlcbiAgICAgICAgICAgICAgICBhcmcgPSBuZXcgRmxvYXQzMkFycmF5KGFyZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICEoYXJnIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpICYmXG4gICAgICAgICAgICAgICAgIShBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKSkgJiZcbiAgICAgICAgICAgICAgICAhKE51bWJlci5pc0ludGVnZXIoYXJnKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgYXJyYXlidWZmZXIgb3IgYSBudW1lcmljIHNpemVcbiAgICAgICAgICAgICAgICB0aHJvdyAnQXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGBBcnJheWAsIGBBcnJheUJ1ZmZlcmAsIGBBcnJheUJ1ZmZlclZpZXdgLCBvciBgTnVtYmVyYCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgYnl0ZSBsZW5ndGhcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGFyZykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSBhcmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGFyZy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY3JlYXRlIGJ1ZmZlciBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHlcbiAgICAgICAgICAgIGlmICghdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYnVmZmVyIHRoZSBkYXRhXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGFyZywgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwbG9hZCBwYXJ0aWFsIHZlcnRleCBkYXRhIHRvIHRoZSBHUFUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBhcnJheSAtIFRoZSBhcnJheSBvZiBkYXRhIHRvIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVPZmZzZXQgLSBUaGUgYnl0ZSBvZmZzZXQgYXQgd2hpY2ggdG8gYnVmZmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZXJ0ZXhCdWZmZXJ9IFRoZSB2ZXJ0ZXggYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgYnVmZmVyU3ViRGF0YShhcnJheSwgYnl0ZU9mZnNldCA9IERFRkFVTFRfQllURV9PRkZTRVQpIHtcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhlIGJ1ZmZlciBleGlzdHNcbiAgICAgICAgICAgIGlmICghdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQnVmZmVyIGhhcyBub3QgeWV0IGJlZW4gYWxsb2NhdGVkLCBhbGxvY2F0ZSB3aXRoICcgK1xuICAgICAgICAgICAgICAgICAgICAnYGJ1ZmZlckRhdGFgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVuc3VyZSBhcmd1bWVudCBpcyB2YWxpZFxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgIShhcnJheSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSAmJlxuICAgICAgICAgICAgICAgICFBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYXkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0FyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBgQXJyYXlgLCBgQXJyYXlCdWZmZXJgLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ29yIGBBcnJheUJ1ZmZlclZpZXdgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgd2UgYXJlbid0IG92ZXJmbG93aW5nIHRoZSBidWZmZXJcbiAgICAgICAgICAgIGlmIChieXRlT2Zmc2V0ICsgYXJyYXkuYnl0ZUxlbmd0aCA+IHRoaXMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IGBBcmd1bWVudCBvZiBsZW5ndGggJHthcnJheS5ieXRlTGVuZ3RofSBieXRlcyB3aXRoIGAgK1xuICAgICAgICAgICAgICAgICAgICBgb2Zmc2V0IG9mICR7Ynl0ZU9mZnNldH0gYnl0ZXMgb3ZlcmZsb3dzIHRoZSBidWZmZXIgYCArXG4gICAgICAgICAgICAgICAgICAgIGBsZW5ndGggb2YgJHt0aGlzLmJ5dGVMZW5ndGh9IGJ5dGVzYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XG4gICAgICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYnl0ZU9mZnNldCwgYXJyYXkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQmluZHMgdGhlIHZlcnRleCBidWZmZXIgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZXJ0ZXhCdWZmZXJ9IC0gUmV0dXJucyB0aGUgdmVydGV4IGJ1ZmZlciBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgYmluZCgpIHtcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICAvLyBiaW5kIGJ1ZmZlclxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgIC8vIGZvciBlYWNoIGF0dHJpYnV0ZSBwb2ludGVyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnBvaW50ZXJzKS5mb3JFYWNoKGluZGV4ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IHRoaXMucG9pbnRlcnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIC8vIHNldCBhdHRyaWJ1dGUgcG9pbnRlclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLnNpemUsXG4gICAgICAgICAgICAgICAgICAgIGdsW3BvaW50ZXIudHlwZV0sXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ5dGVTdHJpZGUsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuYnl0ZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgLy8gZW5hYmxlIGF0dHJpYnV0ZSBpbmRleFxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5iaW5kcyB0aGUgdmVydGV4IGJ1ZmZlciBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlcnRleEJ1ZmZlcn0gVGhlIHZlcnRleCBidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICB1bmJpbmQoKSB7XG4gICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgLy8gdW5iaW5kIGJ1ZmZlclxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMucG9pbnRlcnMpLmZvckVhY2goaW5kZXggPT4ge1xuICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgYXR0cmlidXRlIGluZGV4XG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhlY3V0ZSB0aGUgZHJhdyBjb21tYW5kIGZvciB0aGUgYm91bmQgYnVmZmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gJ2RyYXdBcnJheXMnLiBPcHRpb25hbC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubW9kZSAtIFRoZSBkcmF3IG1vZGUgLyBwcmltaXRpdmUgdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuaW5kZXhPZmZzZXQgLSBUaGUgaW5kZXggb2Zmc2V0IGludG8gdGhlIGRyYXduIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuY291bnQgLSBUaGUgbnVtYmVyIG9mIGluZGljZXMgdG8gZHJhdy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VmVydGV4QnVmZmVyfSBUaGUgdmVydGV4IGJ1ZmZlciBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGRyYXcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgbGV0IG1vZGUgPSBnbFtvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlXTtcbiAgICAgICAgICAgIGxldCBpbmRleE9mZnNldCA9IChvcHRpb25zLmluZGV4T2Zmc2V0ICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5pbmRleE9mZnNldCA6IHRoaXMuaW5kZXhPZmZzZXQ7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAob3B0aW9ucy5jb3VudCAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuY291bnQgOiB0aGlzLmNvdW50O1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0F0dGVtcHRpbmcgdG8gZHJhdyB3aXRoIGEgY291bnQgb2YgMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkcmF3IGVsZW1lbnRzXG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzKG1vZGUsIGluZGV4T2Zmc2V0LCBjb3VudCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gVmVydGV4QnVmZmVyO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBDT01QT05FTlRfVFlQRSA9ICdGTE9BVCc7XG4gICAgbGV0IEJZVEVTX1BFUl9DT01QT05FTlQgPSA0O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBpbnZhbGlkIGF0dHJpYnV0ZSBhcmd1bWVudHMuIEEgdmFsaWQgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBsZW5ndGggPiAwIGtleSBieSBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gaW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyAtIFRoZSBtYXAgb2YgdmVydGV4IGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIHZhbGlkIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZU1hcChhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGxldCBnb29kQXR0cmlidXRlcyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBwYXJzZUZsb2F0KGtleSk7XG4gICAgICAgICAgICAvLyBjaGVjayB0aGF0IGtleSBpcyBhbiB2YWxpZCBpbnRlZ2VyXG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaW5kZXgpIHx8IGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IGBBdHRyaWJ1dGUgaW5kZXggXFxgJHtrZXl9XFxgIGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbGlkIGludGVnZXJgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZlcnRpY2VzID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgLy8gZW5zdXJlIGF0dHJpYnV0ZSBpcyB2YWxpZFxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmVydGljZXMpICYmIHZlcnRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgYXR0cmlidXRlIGRhdGEgYW5kIGluZGV4XG4gICAgICAgICAgICAgICAgZ29vZEF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdmVydGljZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYEVycm9yIHBhcnNpbmcgYXR0cmlidXRlIG9mIGluZGV4IFxcYCR7aW5kZXh9XFxgYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHNvcnQgYXR0cmlidXRlcyBhc2NlbmRpbmcgYnkgaW5kZXhcbiAgICAgICAgZ29vZEF0dHJpYnV0ZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdvb2RBdHRyaWJ1dGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb21wb25lbnQncyBieXRlIHNpemUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wb25lbnQgLSBUaGUgY29tcG9uZW50IHRvIG1lYXN1cmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBieXRlIHNpemUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnRTaXplKGNvbXBvbmVudCkge1xuICAgICAgICAvLyBjaGVjayBpZiBhcnJheVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb21wb25lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB2ZWN0b3JcbiAgICAgICAgaWYgKGNvbXBvbmVudC54ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIDEgY29tcG9uZW50IHZlY3RvclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC55ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyAyIGNvbXBvbmVudCB2ZWN0b3JcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LnogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAzIGNvbXBvbmVudCB2ZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC53ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQgY29tcG9uZW50IHZlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2luZ2xlIGNvbXBvbmVudFxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB0eXBlLCBzaXplLCBhbmQgb2Zmc2V0IGZvciBlYWNoIGF0dHJpYnV0ZSBpbiB0aGUgYXR0cmlidXRlIGFycmF5IGFsb25nIHdpdGggdGhlIGxlbmd0aCBhbmQgc3RyaWRlIG9mIHRoZSBwYWNrYWdlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1ZlcnRleFBhY2thZ2V9IHZlcnRleFBhY2thZ2UgLSBUaGUgVmVydGV4UGFja2FnZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXR0cmlidXRlcyBUaGUgYXJyYXkgb2YgdmVydGV4IGF0dHJpYnV0ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0UG9pbnRlcnNBbmRTdHJpZGUodmVydGV4UGFja2FnZSwgYXR0cmlidXRlcykge1xuICAgICAgICBsZXQgc2hvcnRlc3RBcnJheSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAvLyBjbGVhciBwb2ludGVyc1xuICAgICAgICB2ZXJ0ZXhQYWNrYWdlLnBvaW50ZXJzID0ge307XG4gICAgICAgIC8vIGZvciBlYWNoIGF0dHJpYnV0ZVxuICAgICAgICBhdHRyaWJ1dGVzLmZvckVhY2godmVydGljZXMgPT4ge1xuICAgICAgICAgICAgLy8gc2V0IHNpemUgdG8gbnVtYmVyIG9mIGNvbXBvbmVudHMgaW4gdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgbGV0IHNpemUgPSBnZXRDb21wb25lbnRTaXplKHZlcnRpY2VzLmRhdGFbMF0pO1xuICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIHRoZSBwYWNrYWdlIHdpbGwgYmUgdGhlIHNob3J0ZXN0IGF0dHJpYnV0ZSBhcnJheSBsZW5ndGhcbiAgICAgICAgICAgIHNob3J0ZXN0QXJyYXkgPSBNYXRoLm1pbihzaG9ydGVzdEFycmF5LCB2ZXJ0aWNlcy5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAvLyBzdG9yZSBwb2ludGVyIHVuZGVyIGluZGV4XG4gICAgICAgICAgICB2ZXJ0ZXhQYWNrYWdlLnBvaW50ZXJzW3ZlcnRpY2VzLmluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBDT01QT05FTlRfVFlQRSxcbiAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IG9mZnNldCAqIEJZVEVTX1BFUl9DT01QT05FTlRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBhY2N1bXVsYXRlIGF0dHJpYnV0ZSBvZmZzZXRcbiAgICAgICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gc2V0IHN0cmlkZSB0byB0b3RhbCBvZmZzZXRcbiAgICAgICAgdmVydGV4UGFja2FnZS5zdHJpZGUgPSBvZmZzZXQ7IC8vIG5vdCBpbiBieXRlc1xuICAgICAgICAvLyBzZXQgbGVuZ3RoIG9mIHBhY2thZ2UgdG8gdGhlIHNob3J0ZXN0IGF0dHJpYnV0ZSBhcnJheSBsZW5ndGhcbiAgICAgICAgdmVydGV4UGFja2FnZS5sZW5ndGggPSBzaG9ydGVzdEFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGwgdGhlIGFycmF5YnVmZmVyIHdpdGggYSBzaW5nbGUgY29tcG9uZW50IGF0dHJpYnV0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGJ1ZmZlciAtIFRoZSBhcnJheWJ1ZmZlciB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZlcnRpY2VzIC0gVGhlIHZlcnRleCBhdHRyaWJ1dGUgYXJyYXkgdG8gY29weSBmcm9tLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSBUaGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgdG8gY29weSBmcm9tLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHRvIHRoZSBhdHRyaWJ1dGUsIG5vdCBpbiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIC0gVGhlIHN0cmlkZSBvZiB0aGUgYnVmZmVyLCBub3QgaW4gYnl0ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0MUNvbXBvbmVudEF0dHIoYnVmZmVyLCB2ZXJ0aWNlcywgbGVuZ3RoLCBvZmZzZXQsIHN0cmlkZSkge1xuICAgICAgICBsZXQgdmVydGV4LCBpLCBqO1xuICAgICAgICBmb3IgKGk9MDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IGluIHRoZSBidWZmZXIgdG8gdGhlIHBhcnRpY3VsYXIgdmVydGV4XG4gICAgICAgICAgICBqID0gb2Zmc2V0ICsgKHN0cmlkZSAqIGkpO1xuICAgICAgICAgICAgaWYgKHZlcnRleC54ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJbal0gPSB2ZXJ0ZXgueDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmVydGV4WzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJbal0gPSB2ZXJ0ZXhbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqXSA9IHZlcnRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGwgdGhlIGFycmF5YnVmZmVyIHdpdGggYSBkb3VibGUgY29tcG9uZW50IGF0dHJpYnV0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGJ1ZmZlciAtIFRoZSBhcnJheWJ1ZmZlciB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZlcnRpY2VzIC0gVGhlIHZlcnRleCBhdHRyaWJ1dGUgYXJyYXkgdG8gY29weSBmcm9tLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSBUaGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgdG8gY29weSBmcm9tLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHRvIHRoZSBhdHRyaWJ1dGUsIG5vdCBpbiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIC0gVGhlIHN0cmlkZSBvZiB0aGUgYnVmZmVyLCBub3QgaW4gYnl0ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0MkNvbXBvbmVudEF0dHIoYnVmZmVyLCB2ZXJ0aWNlcywgbGVuZ3RoLCBvZmZzZXQsIHN0cmlkZSkge1xuICAgICAgICBsZXQgdmVydGV4LCBpLCBqO1xuICAgICAgICBmb3IgKGk9MDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IGluIHRoZSBidWZmZXIgdG8gdGhlIHBhcnRpY3VsYXIgdmVydGV4XG4gICAgICAgICAgICBqID0gb2Zmc2V0ICsgKHN0cmlkZSAqIGkpO1xuICAgICAgICAgICAgYnVmZmVyW2pdID0gKHZlcnRleC54ICE9PSB1bmRlZmluZWQpID8gdmVydGV4LnggOiB2ZXJ0ZXhbMF07XG4gICAgICAgICAgICBidWZmZXJbaisxXSA9ICh2ZXJ0ZXgueSAhPT0gdW5kZWZpbmVkKSA/IHZlcnRleC55IDogdmVydGV4WzFdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbCB0aGUgYXJyYXlidWZmZXIgd2l0aCBhIHRyaXBsZSBjb21wb25lbnQgYXR0cmlidXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYnVmZmVyIC0gVGhlIGFycmF5YnVmZmVyIHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmVydGljZXMgLSBUaGUgdmVydGV4IGF0dHJpYnV0ZSBhcnJheSB0byBjb3B5IGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIFRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlciB0byBjb3B5IGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgdG8gdGhlIGF0dHJpYnV0ZSwgbm90IGluIGJ5dGVzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgLSBUaGUgc3RyaWRlIG9mIHRoZSBidWZmZXIsIG5vdCBpbiBieXRlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQzQ29tcG9uZW50QXR0cihidWZmZXIsIHZlcnRpY2VzLCBsZW5ndGgsIG9mZnNldCwgc3RyaWRlKSB7XG4gICAgICAgIGxldCB2ZXJ0ZXgsIGksIGo7XG4gICAgICAgIGZvciAoaT0wOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgaW5kZXggaW4gdGhlIGJ1ZmZlciB0byB0aGUgcGFydGljdWxhciB2ZXJ0ZXhcbiAgICAgICAgICAgIGogPSBvZmZzZXQgKyAoc3RyaWRlICogaSk7XG4gICAgICAgICAgICBidWZmZXJbal0gPSAodmVydGV4LnggIT09IHVuZGVmaW5lZCkgPyB2ZXJ0ZXgueCA6IHZlcnRleFswXTtcbiAgICAgICAgICAgIGJ1ZmZlcltqKzFdID0gKHZlcnRleC55ICE9PSB1bmRlZmluZWQpID8gdmVydGV4LnkgOiB2ZXJ0ZXhbMV07XG4gICAgICAgICAgICBidWZmZXJbaisyXSA9ICh2ZXJ0ZXgueiAhPT0gdW5kZWZpbmVkKSA/IHZlcnRleC56IDogdmVydGV4WzJdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbCB0aGUgYXJyYXlidWZmZXIgd2l0aCBhIHF1YWRydXBsZSBjb21wb25lbnQgYXR0cmlidXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYnVmZmVyIC0gVGhlIGFycmF5YnVmZmVyIHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmVydGljZXMgLSBUaGUgdmVydGV4IGF0dHJpYnV0ZSBhcnJheSB0byBjb3B5IGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIFRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlciB0byBjb3B5IGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgdG8gdGhlIGF0dHJpYnV0ZSwgbm90IGluIGJ5dGVzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgLSBUaGUgc3RyaWRlIG9mIHRoZSBidWZmZXIsIG5vdCBpbiBieXRlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQ0Q29tcG9uZW50QXR0cihidWZmZXIsIHZlcnRpY2VzLCBsZW5ndGgsIG9mZnNldCwgc3RyaWRlKSB7XG4gICAgICAgIGxldCB2ZXJ0ZXgsIGksIGo7XG4gICAgICAgIGZvciAoaT0wOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgaW5kZXggaW4gdGhlIGJ1ZmZlciB0byB0aGUgcGFydGljdWxhciB2ZXJ0ZXhcbiAgICAgICAgICAgIGogPSBvZmZzZXQgKyAoc3RyaWRlICogaSk7XG4gICAgICAgICAgICBidWZmZXJbal0gPSAodmVydGV4LnggIT09IHVuZGVmaW5lZCkgPyB2ZXJ0ZXgueCA6IHZlcnRleFswXTtcbiAgICAgICAgICAgIGJ1ZmZlcltqKzFdID0gKHZlcnRleC55ICE9PSB1bmRlZmluZWQpID8gdmVydGV4LnkgOiB2ZXJ0ZXhbMV07XG4gICAgICAgICAgICBidWZmZXJbaisyXSA9ICh2ZXJ0ZXgueiAhPT0gdW5kZWZpbmVkKSA/IHZlcnRleC56IDogdmVydGV4WzJdO1xuICAgICAgICAgICAgYnVmZmVyW2orM10gPSAodmVydGV4LncgIT09IHVuZGVmaW5lZCkgPyB2ZXJ0ZXgudyA6IHZlcnRleFszXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBWZXJ0ZXhQYWNrYWdlXG4gICAgICogQGNsYXNzZGVzYyBBIHZlcnRleCBwYWNrYWdlIHRvIGFzc2lzdCBpbiBpbnRlcmxlYXZpbmcgdmVydGV4IGRhdGEgYW5kIGJ1aWxkaW5nIHRoZSBhc3NvY2lhdGVkIHZlcnRleCBhdHRyaWJ1dGUgcG9pbnRlcnMuXG4gICAgICovXG4gICAgY2xhc3MgVmVydGV4UGFja2FnZSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3RhbnRpYXRlcyBhIFZlcnRleFBhY2thZ2Ugb2JqZWN0LlxuICAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBUaGUgYXR0cmlidXRlcyB0byBpbnRlcmxlYXZlIGtleWVkIGJ5IGluZGV4LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVycyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgZGF0YSB0byBiZSBpbnRlcmxlYXZlZCBpbnNpZGUgdGhlIHBhY2thZ2UuIFRoaXMgY2xlYXJzIGFueSBwcmV2aW91c2x5IGV4aXN0aW5nIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gVGhlIGF0dHJpYnV0ZXMgdG8gaW50ZXJsZWF2ZWQsIGtleWVkIGJ5IGluZGV4LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZXJ0ZXhQYWNrYWdlfSBUaGUgdmVydGV4IHBhY2thZ2Ugb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGJhZCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBhdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVNYXAoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAvLyBzZXQgYXR0cmlidXRlIHBvaW50ZXJzIGFuZCBzdHJpZGVcbiAgICAgICAgICAgIHNldFBvaW50ZXJzQW5kU3RyaWRlKHRoaXMsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgLy8gc2V0IHNpemUgb2YgZGF0YSB2ZWN0b3JcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBzdHJpZGUgPSB0aGlzLnN0cmlkZTsgLy8gbm90IGluIGJ5dGVzXG4gICAgICAgICAgICBsZXQgcG9pbnRlcnMgPSB0aGlzLnBvaW50ZXJzO1xuICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IHRoaXMuYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGggKiBzdHJpZGUpO1xuICAgICAgICAgICAgLy8gZm9yIGVhY2ggdmVydGV4IGF0dHJpYnV0ZSBhcnJheVxuICAgICAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKHZlcnRpY2VzID0+IHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHBvaW50ZXJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IHBvaW50ZXJzW3ZlcnRpY2VzLmluZGV4XTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHBvaW50ZXJzIG9mZnNldFxuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBwb2ludGVyLmJ5dGVPZmZzZXQgLyBCWVRFU19QRVJfQ09NUE9ORU5UO1xuICAgICAgICAgICAgICAgIC8vIGNvcHkgdmVydGV4IGRhdGEgaW50byBhcnJheWJ1ZmZlclxuICAgICAgICAgICAgICAgIHN3aXRjaCAocG9pbnRlci5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldDJDb21wb25lbnRBdHRyKGJ1ZmZlciwgdmVydGljZXMuZGF0YSwgbGVuZ3RoLCBvZmZzZXQsIHN0cmlkZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0M0NvbXBvbmVudEF0dHIoYnVmZmVyLCB2ZXJ0aWNlcy5kYXRhLCBsZW5ndGgsIG9mZnNldCwgc3RyaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQ0Q29tcG9uZW50QXR0cihidWZmZXIsIHZlcnRpY2VzLmRhdGEsIGxlbmd0aCwgb2Zmc2V0LCBzdHJpZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQxQ29tcG9uZW50QXR0cihidWZmZXIsIHZlcnRpY2VzLmRhdGEsIGxlbmd0aCwgb2Zmc2V0LCBzdHJpZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gVmVydGV4UGFja2FnZTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBXZWJHTENvbnRleHQgPSByZXF1aXJlKCcuL1dlYkdMQ29udGV4dCcpO1xuXG4gICAgLyoqXG4gICAgICogQmluZCB0aGUgdmlld3BvcnQgdG8gdGhlIHJlbmRlcmluZyBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtWaWV3cG9ydH0gdmlld3BvcnQgLSBUaGUgdmlld3BvcnQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvdmVycmlkZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvdmVycmlkZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSBob3Jpem9udGFsIG9mZnNldCBvdmVycmlkZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSAtIFRoZSB2ZXJ0aWNhbCBvZmZzZXQgb3ZlcnJpZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KHZpZXdwb3J0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBnbCA9IHZpZXdwb3J0LmdsO1xuICAgICAgICB4ID0gKHggIT09IHVuZGVmaW5lZCkgPyB4IDogdmlld3BvcnQueDtcbiAgICAgICAgeSA9ICh5ICE9PSB1bmRlZmluZWQpID8geSA6IHZpZXdwb3J0Lnk7XG4gICAgICAgIHdpZHRoID0gKHdpZHRoICE9PSB1bmRlZmluZWQpID8gd2lkdGggOiB2aWV3cG9ydC53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gKGhlaWdodCAhPT0gdW5kZWZpbmVkKSA/IGhlaWdodCA6IHZpZXdwb3J0LmhlaWdodDtcbiAgICAgICAgZ2wudmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFZpZXdwb3J0XG4gICAgICogQGNsYXNzZGVzYyBBIHZpZXdwb3J0IGNsYXNzIGZvciBtYW5hZ2luZyBXZWJHTCB2aWV3cG9ydHMuXG4gICAgICovXG4gICAgY2xhc3MgVmlld3BvcnQge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYSBWaWV3cG9ydCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIC0gVGhlIHZpZXdwb3J0IHNwZWNpZmljYXRpb24gb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3BlYy53aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgdmlld3BvcnQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcGVjLmhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3Ioc3BlYyA9IHt9KSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gV2ViR0xDb250ZXh0LmdldCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAgICAgLy8gc2V0IHNpemVcbiAgICAgICAgICAgIHRoaXMucmVzaXplKFxuICAgICAgICAgICAgICAgIHNwZWMud2lkdGggfHwgdGhpcy5nbC5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgc3BlYy5oZWlnaHQgfHwgdGhpcy5nbC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSB2aWV3cG9ydHMgd2lkdGggYW5kIGhlaWdodC4gVGhpcyByZXNpemVzIHRoZSB1bmRlcmx5aW5nIGNhbnZhcyBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgdmlld3BvcnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZpZXdwb3J0fSBUaGUgdmlld3BvcnQgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemUod2lkdGggPSAwLCBoZWlnaHQgPSAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAnbnVtYmVyJyB8fCB3aWR0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIFxcYHdpZHRoXFxgIG9mIFxcYCR7d2lkdGh9XFxgIGlzIGludmFsaWRgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICdudW1iZXInIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIFxcYGhlaWdodFxcYCBvZiBcXGAke2hlaWdodH1cXGAgaXMgaW52YWxpZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZ2wuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmdsLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB2aWV3cG9ydCBkaW1lbnNpb25zIGFuZCBwb3NpdGlvbi4gVGhlIHVuZGVybHlpbmcgY2FudmFzIGVsZW1lbnQgaXMgbm90IGFmZmVjdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb3ZlcnJpZGUuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG92ZXJyaWRlLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSBob3Jpem9udGFsIG9mZnNldCBvdmVycmlkZS5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdmVydGljYWwgb2Zmc2V0IG92ZXJyaWRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtWaWV3cG9ydH0gLSBUaGUgdmlld3BvcnQgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBwdXNoKHggPSAwLCB5ID0gMCwgd2lkdGggPSB0aGlzLndpZHRoLCBoZWlnaHQgPSB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRocm93IGBQcm92aWRlZCBcXGB4XFxgIG9mIFxcYCR7eH1cXGAgaXMgaW52YWxpZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHkgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIFxcYHlcXGAgb2YgXFxgJHt5fVxcYCBpcyBpbnZhbGlkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICdudW1iZXInIHx8IHdpZHRoIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgUHJvdmlkZWQgXFxgd2lkdGhcXGAgb2YgXFxgJHt3aWR0aH1cXGAgaXMgaW52YWxpZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ251bWJlcicgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgUHJvdmlkZWQgXFxgaGVpZ2h0XFxgIG9mIFxcYCR7aGVpZ2h0fVxcYCBpcyBpbnZhbGlkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHB1c2ggb250byBzdGFja1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHNldCB2aWV3cG9ydFxuICAgICAgICAgICAgc2V0KHRoaXMsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUG9wcyBjdXJyZW50IHRoZSB2aWV3cG9ydCBvYmplY3QgYW5kIHNldHMgdGhlIHZpZXdwb3J0IGJlbmVhdGggaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZpZXdwb3J0fSBUaGUgdmlld3BvcnQgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBwb3AoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVmlld3BvcnQgc3RhY2sgaXMgZW1wdHknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHNldCh0aGlzLCB0b3AueCwgdG9wLnksIHRvcC53aWR0aCwgdG9wLmhlaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBWaWV3cG9ydDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBFWFRFTlNJT05TID0gW1xuICAgICAgICAvLyByYXRpZmllZFxuICAgICAgICAnT0VTX3RleHR1cmVfZmxvYXQnLFxuICAgICAgICAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcsXG4gICAgICAgICdXRUJHTF9sb3NlX2NvbnRleHQnLFxuICAgICAgICAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyxcbiAgICAgICAgJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JyxcbiAgICAgICAgJ1dFQkdMX2RlYnVnX3JlbmRlcmVyX2luZm8nLFxuICAgICAgICAnV0VCR0xfZGVidWdfc2hhZGVycycsXG4gICAgICAgICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycsXG4gICAgICAgICdXRUJHTF9kZXB0aF90ZXh0dXJlJyxcbiAgICAgICAgJ09FU19lbGVtZW50X2luZGV4X3VpbnQnLFxuICAgICAgICAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyxcbiAgICAgICAgJ0VYVF9mcmFnX2RlcHRoJyxcbiAgICAgICAgJ1dFQkdMX2RyYXdfYnVmZmVycycsXG4gICAgICAgICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyxcbiAgICAgICAgJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicsXG4gICAgICAgICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicsXG4gICAgICAgICdFWFRfYmxlbmRfbWlubWF4JyxcbiAgICAgICAgJ0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QnLFxuICAgICAgICAvLyBjb21tdW5pdHlcbiAgICAgICAgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hdGMnLFxuICAgICAgICAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyxcbiAgICAgICAgJ0VYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCcsXG4gICAgICAgICdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnLFxuICAgICAgICAnRVhUX3NSR0InLFxuICAgICAgICAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnLFxuICAgICAgICAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5JyxcbiAgICAgICAgJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnXG4gICAgXTtcblxuICAgIGxldCBfYm91bmRDb250ZXh0ID0gbnVsbDtcbiAgICBsZXQgX2NvbnRleHRzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIHJmYzQxMjIgdmVyc2lvbiA0IGNvbXBsaWFudCBVVUlELlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IC0gVGhlIFVVSUQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFVVSUQoKSB7XG4gICAgICAgIGxldCByZXBsYWNlID0gZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgbGV0IHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwO1xuICAgICAgICAgICAgbGV0IHYgPSAoYyA9PT0gJ3gnKSA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIHJlcGxhY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBIVE1MQ2FudmFzRWxlbWVudCBlbGVtZW50LiBJZiB0aGVyZSBpcyBubyBpZCwgaXQgZ2VuZXJhdGVzIG9uZSBhbmQgYXBwZW5kcyBpdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gVGhlIENhbnZhcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBDYW52YXMgaWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldElkKGNhbnZhcykge1xuICAgICAgICBpZiAoIWNhbnZhcy5pZCkge1xuICAgICAgICAgICAgY2FudmFzLmlkID0gZ2V0VVVJRCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW52YXMuaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENhbnZhcyBlbGVtZW50IG9iamVjdCBmcm9tIGVpdGhlciBhbiBleGlzdGluZyBvYmplY3QsIG9yIGlkZW50aWZpY2F0aW9uIHN0cmluZy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxTdHJpbmd9IGFyZyAtIFRoZSBDYW52YXMgb2JqZWN0IG9yIENhbnZhcyBpZCBvciBzZWxlY3RvciBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIENhbnZhcyBlbGVtZW50IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDYW52YXMoYXJnKSB7XG4gICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGFyZykgfHxcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gcmV0cmlldmUgYSB3cmFwcGVkIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIENhbnZhcyBlbGVtZW50IG9iamVjdCB0byBjcmVhdGUgdGhlIGNvbnRleHQgdW5kZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZXh0IHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dFdyYXBwZXIoYXJnKSB7XG4gICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKF9ib3VuZENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gbGFzdCBib3VuZCBjb250ZXh0XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ib3VuZENvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY2FudmFzID0gZ2V0Q2FudmFzKGFyZyk7XG4gICAgICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0c1tnZXRJZChjYW52YXMpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBubyBib3VuZCBjb250ZXh0IG9yIGFyZ3VtZW50XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGxvYWQgYWxsIGtub3duIGV4dGVuc2lvbnMgZm9yIGEgcHJvdmlkZWQgV2ViR0xSZW5kZXJpbmdDb250ZXh0LiBTdG9yZXMgdGhlIHJlc3VsdHMgaW4gdGhlIGNvbnRleHQgd3JhcHBlciBmb3IgbGF0ZXIgcXVlcmllcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRXcmFwcGVyIC0gVGhlIGNvbnRleHQgd3JhcHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkRXh0ZW5zaW9ucyhjb250ZXh0V3JhcHBlcikge1xuICAgICAgICBsZXQgZ2wgPSBjb250ZXh0V3JhcHBlci5nbDtcbiAgICAgICAgRVhURU5TSU9OUy5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgIGNvbnRleHRXcmFwcGVyLmV4dGVuc2lvbnNbaWRdID0gZ2wuZ2V0RXh0ZW5zaW9uKGlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gY3JlYXRlIGEgV2ViR0xSZW5kZXJpbmdDb250ZXh0IGFuZCBsb2FkIGFsbCBleHRlbnNpb25zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSAtIFRoZSBDYW52YXMgZWxlbWVudCBvYmplY3QgdG8gY3JlYXRlIHRoZSBjb250ZXh0IHVuZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fX0gb3B0aW9ucyAtIFBhcmFtZXRlcnMgdG8gdGhlIHdlYmdsIGNvbnRleHQsIG9ubHkgdXNlZCBkdXJpbmcgaW5zdGFudGlhdGlvbi4gT3B0aW9uYWwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZXh0IHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29udGV4dFdyYXBwZXIoY2FudmFzLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG9wdGlvbnMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBvcHRpb25zKTtcbiAgICAgICAgLy8gd3JhcCBjb250ZXh0XG4gICAgICAgIGxldCBjb250ZXh0V3JhcHBlciA9IHtcbiAgICAgICAgICAgIGlkOiBnZXRJZChjYW52YXMpLFxuICAgICAgICAgICAgZ2w6IGdsLFxuICAgICAgICAgICAgZXh0ZW5zaW9uczoge31cbiAgICAgICAgfTtcbiAgICAgICAgLy8gbG9hZCBXZWJHTCBleHRlbnNpb25zXG4gICAgICAgIGxvYWRFeHRlbnNpb25zKGNvbnRleHRXcmFwcGVyKTtcbiAgICAgICAgLy8gYWRkIGNvbnRleHQgd3JhcHBlciB0byBtYXBcbiAgICAgICAgX2NvbnRleHRzW2dldElkKGNhbnZhcyldID0gY29udGV4dFdyYXBwZXI7XG4gICAgICAgIC8vIGJpbmQgdGhlIGNvbnRleHRcbiAgICAgICAgX2JvdW5kQ29udGV4dCA9IGNvbnRleHRXcmFwcGVyO1xuICAgICAgICByZXR1cm4gY29udGV4dFdyYXBwZXI7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyBhbiBleGlzdGluZyBXZWJHTCBjb250ZXh0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnQgYW5kIGJpbmRzIGl0LiBXaGlsZSBib3VuZCwgdGhlIGFjdGl2ZSBjb250ZXh0IHdpbGwgYmUgdXNlZCBpbXBsaWNpdGx5IGJ5IGFueSBpbnN0YW50aWF0ZWQgYGVzcGVyYCBjb25zdHJ1Y3RzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fFN0cmluZ30gYXJnIC0gVGhlIENhbnZhcyBvYmplY3Qgb3IgQ2FudmFzIGlkZW50aWZpY2F0aW9uIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7V2ViR0xDb250ZXh0fSBUaGUgbmFtZXNwYWNlLCB1c2VkIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgbGV0IHdyYXBwZXIgPSBnZXRDb250ZXh0V3JhcHBlcihhcmcpO1xuICAgICAgICAgICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICBfYm91bmRDb250ZXh0ID0gd3JhcHBlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGBObyBjb250ZXh0IGV4aXN0cyBmb3IgcHJvdmlkZWQgYXJndW1lbnQgJyR7YXJnfSdgO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgYW4gZXhpc3RpbmcgV2ViR0wgY29udGV4dCBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50LiBJZiBubyBjb250ZXh0IGV4aXN0cywgb25lIGlzIGNyZWF0ZWQuXG4gICAgICAgICAqIER1cmluZyBjcmVhdGlvbiBhdHRlbXB0cyB0byBsb2FkIGFsbCBleHRlbnNpb25zIGZvdW5kIGF0OiBodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9leHRlbnNpb25zLy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxTdHJpbmd9IGFyZyAtIFRoZSBDYW52YXMgb2JqZWN0IG9yIENhbnZhcyBpZGVudGlmaWNhdGlvbiBzdHJpbmcuIE9wdGlvbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFBhcmFtZXRlcnMgdG8gdGhlIHdlYmdsIGNvbnRleHQsIG9ubHkgdXNlZCBkdXJpbmcgaW5zdGFudGlhdGlvbi4gT3B0aW9uYWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGFyZywgb3B0aW9ucykge1xuICAgICAgICAgICAgbGV0IHdyYXBwZXIgPSBnZXRDb250ZXh0V3JhcHBlcihhcmcpO1xuICAgICAgICAgICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgbmF0aXZlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIuZ2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZXQgY2FudmFzIGVsZW1lbnRcbiAgICAgICAgICAgIGxldCBjYW52YXMgPSBnZXRDYW52YXMoYXJnKTtcbiAgICAgICAgICAgIC8vIHRyeSB0byBmaW5kIG9yIGNyZWF0ZSBjb250ZXh0XG4gICAgICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgICAgICAgIHRocm93IGBObyBjb250ZXh0IGlzIGN1cnJlbnRseSBib3VuZCBvciBjb3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgYXJndW1lbnQgb2YgdHlwZSAke3R5cGVvZiBhcmd9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBjb250ZXh0XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29udGV4dFdyYXBwZXIoY2FudmFzLCBvcHRpb25zKS5nbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhbiBleGlzdGluZyBXZWJHTCBjb250ZXh0IG9iamVjdCBmb3IgdGhlIHByb3ZpZGVkIG9yIGN1cnJlbnRseSBib3VuZCBjb250ZXh0IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxTdHJpbmd9IGFyZyAtIFRoZSBDYW52YXMgb2JqZWN0IG9yIENhbnZhcyBpZGVudGlmaWNhdGlvbiBzdHJpbmcuIE9wdGlvbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH19IG9wdGlvbnMgLSBQYXJhbWV0ZXJzIHRvIHRoZSB3ZWJnbCBjb250ZXh0LCBvbmx5IHVzZWQgZHVyaW5nIGluc3RhbnRpYXRpb24uIE9wdGlvbmFsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGxldCB3cmFwcGVyID0gZ2V0Q29udGV4dFdyYXBwZXIoYXJnKTtcbiAgICAgICAgICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgZGVsZXRlIF9jb250ZXh0c1t3cmFwcGVyLmlkXTtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgaWYgY3VycmVudGx5IGJvdW5kXG4gICAgICAgICAgICAgICAgaWYgKHdyYXBwZXIgPT09IF9ib3VuZENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2JvdW5kQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgTm8gY29udGV4dCBpcyBjdXJyZW50bHkgYm91bmQgb3IgY291bGQgYmUgYXNzb2NpYXRlZCB3aXRoIHByb3ZpZGVkIGFyZ3VtZW50IG9mIHR5cGUgJHt0eXBlb2YgYXJnfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHN1cHBvcnRlZCBleHRlbnNpb25zIGZvciB0aGUgcHJvdmlkZWQgb3IgY3VycmVudGx5IGJvdW5kIGNvbnRleHQgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fFN0cmluZ30gYXJnIC0gVGhlIENhbnZhcyBvYmplY3Qgb3IgQ2FudmFzIGlkZW50aWZpY2F0aW9uIHN0cmluZy4gT3B0aW9uYWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBbGwgc3VwcG9ydGVkIGV4dGVuc2lvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBzdXBwb3J0ZWRFeHRlbnNpb25zOiBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGxldCB3cmFwcGVyID0gZ2V0Q29udGV4dFdyYXBwZXIoYXJnKTtcbiAgICAgICAgICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4dGVuc2lvbnMgPSB3cmFwcGVyLmV4dGVuc2lvbnM7XG4gICAgICAgICAgICAgICAgbGV0IHN1cHBvcnRlZCA9IFtdO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25zW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgYE5vIGNvbnRleHQgaXMgY3VycmVudGx5IGJvdW5kIG9yIGNvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aCBwcm92aWRlZCBhcmd1bWVudCBvZiB0eXBlICR7dHlwZW9mIGFyZ31gO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB1bnN1cHBvcnRlZCBleHRlbnNpb25zIGZvciB0aGUgcHJvdmlkZWQgb3IgY3VycmVudGx5IGJvdW5kIGNvbnRleHQgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fFN0cmluZ30gYXJnIC0gVGhlIENhbnZhcyBvYmplY3Qgb3IgQ2FudmFzIGlkZW50aWZpY2F0aW9uIHN0cmluZy4gT3B0aW9uYWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBbGwgdW5zdXBwb3J0ZWQgZXh0ZW5zaW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHVuc3VwcG9ydGVkRXh0ZW5zaW9uczogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICBsZXQgd3JhcHBlciA9IGdldENvbnRleHRXcmFwcGVyKGFyZyk7XG4gICAgICAgICAgICBpZiAod3JhcHBlcikge1xuICAgICAgICAgICAgICAgIGxldCBleHRlbnNpb25zID0gd3JhcHBlci5leHRlbnNpb25zO1xuICAgICAgICAgICAgICAgIGxldCB1bnN1cHBvcnRlZCA9IFtdO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXh0ZW5zaW9uc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5zdXBwb3J0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBgTm8gY29udGV4dCBpcyBjdXJyZW50bHkgYm91bmQgb3IgY291bGQgYmUgYXNzb2NpYXRlZCB3aXRoIHByb3ZpZGVkIGFyZ3VtZW50IG9mIHR5cGUgJHt0eXBlb2YgYXJnfWA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiBhbiBleHRlbnNpb24gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGxvYWRlZCBmb3IgdGhlIHByb3ZpZGVkIG9yIGN1cnJlbnRseSBib3VuZCBjb250ZXh0IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxTdHJpbmd9IGFyZyAtIFRoZSBDYW52YXMgb2JqZWN0IG9yIENhbnZhcyBpZGVudGlmaWNhdGlvbiBzdHJpbmcuIE9wdGlvbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXh0ZW5zaW9uIC0gVGhlIGV4dGVuc2lvbiBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgZXh0ZW5zaW9uIGhhcyBiZWVuIGxvYWRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICAgICAqL1xuICAgICAgICBjaGVja0V4dGVuc2lvbjogZnVuY3Rpb24oYXJnLCBleHRlbnNpb24pIHtcbiAgICAgICAgICAgIGlmICghZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hpZnQgcGFyYW1ldGVycyBpZiBubyBjYW52YXMgYXJnIGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gYXJnO1xuICAgICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB3cmFwcGVyID0gZ2V0Q29udGV4dFdyYXBwZXIoYXJnKTtcbiAgICAgICAgICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4dGVuc2lvbnMgPSB3cmFwcGVyLmV4dGVuc2lvbnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnNbZXh0ZW5zaW9uXSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGBObyBjb250ZXh0IGlzIGN1cnJlbnRseSBib3VuZCBvciBjb3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgYXJndW1lbnQgb2YgdHlwZSAke3R5cGVvZiBhcmd9YDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBleHRlbnNpb24gaWYgaXQgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGxvYWRlZCBmb3IgdGhlIHByb3ZpZGVkIG9yIGN1cnJlbnRseSBib3VuZCBjb250ZXh0IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxTdHJpbmd9IGFyZyAtIFRoZSBDYW52YXMgb2JqZWN0IG9yIENhbnZhcyBpZGVudGlmaWNhdGlvbiBzdHJpbmcuIE9wdGlvbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXh0ZW5zaW9uIC0gVGhlIGV4dGVuc2lvbiBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgZXh0ZW5zaW9uIGhhcyBiZWVuIGxvYWRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFeHRlbnNpb246IGZ1bmN0aW9uKGFyZywgZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBpZiAoIWV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIC8vIHNoaWZ0IHBhcmFtZXRlcnMgaWYgbm8gY2FudmFzIGFyZyBpcyBwcm92aWRlZFxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGFyZztcbiAgICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgd3JhcHBlciA9IGdldENvbnRleHRXcmFwcGVyKGFyZyk7XG4gICAgICAgICAgICBpZiAod3JhcHBlcikge1xuICAgICAgICAgICAgICAgIGxldCBleHRlbnNpb25zID0gd3JhcHBlci5leHRlbnNpb25zO1xuICAgICAgICAgICAgICAgIHJldHVybiBleHRlbnNpb25zW2V4dGVuc2lvbl0gfHwgbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGBObyBjb250ZXh0IGlzIGN1cnJlbnRseSBib3VuZCBvciBjb3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgYXJndW1lbnQgb2YgdHlwZSAke3R5cGVvZiBhcmd9YDtcbiAgICAgICAgfVxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICBJbmRleEJ1ZmZlcjogcmVxdWlyZSgnLi9jb3JlL0luZGV4QnVmZmVyJyksXHJcbiAgICAgICAgUmVuZGVyYWJsZTogcmVxdWlyZSgnLi9jb3JlL1JlbmRlcmFibGUnKSxcclxuICAgICAgICBSZW5kZXJUYXJnZXQ6IHJlcXVpcmUoJy4vY29yZS9SZW5kZXJUYXJnZXQnKSxcclxuICAgICAgICBTaGFkZXI6IHJlcXVpcmUoJy4vY29yZS9TaGFkZXInKSxcclxuICAgICAgICBUZXh0dXJlMkQ6IHJlcXVpcmUoJy4vY29yZS9UZXh0dXJlMkQnKSxcclxuICAgICAgICBDb2xvclRleHR1cmUyRDogcmVxdWlyZSgnLi9jb3JlL0NvbG9yVGV4dHVyZTJEJyksXHJcbiAgICAgICAgRGVwdGhUZXh0dXJlMkQ6IHJlcXVpcmUoJy4vY29yZS9EZXB0aFRleHR1cmUyRCcpLFxyXG4gICAgICAgIFRleHR1cmVDdWJlTWFwOiByZXF1aXJlKCcuL2NvcmUvVGV4dHVyZUN1YmVNYXAnKSxcclxuICAgICAgICBWZXJ0ZXhCdWZmZXI6IHJlcXVpcmUoJy4vY29yZS9WZXJ0ZXhCdWZmZXInKSxcclxuICAgICAgICBWZXJ0ZXhQYWNrYWdlOiByZXF1aXJlKCcuL2NvcmUvVmVydGV4UGFja2FnZScpLFxyXG4gICAgICAgIFZpZXdwb3J0OiByZXF1aXJlKCcuL2NvcmUvVmlld3BvcnQnKSxcclxuICAgICAgICBXZWJHTENvbnRleHQ6IHJlcXVpcmUoJy4vY29yZS9XZWJHTENvbnRleHQnKVxyXG4gICAgfTtcclxuXHJcbn0oKSk7XHJcbiIsIihmdW5jdGlvbiAoKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRvcihhcmcpIHtcbiAgICAgICAgbGV0IGkgPSAtMTtcbiAgICAgICAgbGV0IGxlbjtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgbGVuID0gYXJnLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyBpIDogbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xuICAgICAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyBrZXlzW2ldIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChmbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBmbiA9IG51bGw7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWFjaChvYmplY3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBsZXQgY29tcGxldGVkID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBkb25lKGVycikge1xuICAgICAgICAgICAgY29tcGxldGVkLS07XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBudWxsICYmIGNvbXBsZXRlZCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYga2V5IGlzIG51bGwgaW4gY2FzZSBpdGVyYXRvciBpc24ndCBleGhhdXN0ZWQgYW5kIGRvbmVcbiAgICAgICAgICAgICAgICAvLyB3YXMgcmVzb2x2ZWQgc3luY2hyb25vdXNseS5cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdGVyID0gZ2V0SXRlcmF0b3Iob2JqZWN0KTtcbiAgICAgICAgd2hpbGUgKChrZXkgPSBpdGVyKCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG9iamVjdFtrZXldLCBrZXksIGRvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wbGV0ZWQgPT09IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4ZWN1dGUgYSBzZXQgb2YgZnVuY3Rpb25zIGFzeW5jaHJvbm91c2x5LCBvbmNlIGFsbCBoYXZlIGJlZW5cbiAgICAgICAgICogY29tcGxldGVkLCBleGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbi4gSm9icyBtYXkgYmUgcGFzc2VkXG4gICAgICAgICAqIGFzIGFuIGFycmF5IG9yIG9iamVjdC4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIHRoZVxuICAgICAgICAgKiByZXN1bHRzIGluIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgdGFza3MuIEFsbCB0YXNrcyBtdXN0IGhhdmUgYWNjZXB0XG4gICAgICAgICAqIGFuZCBleGVjdXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdXBvbiBjb21wbGV0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gdGFza3MgLSBUaGUgc2V0IG9mIGZ1bmN0aW9ucyB0byBleGVjdXRlLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCB1cG9uIGNvbXBsZXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBwYXJhbGxlbDogZnVuY3Rpb24odGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0cyA9IEFycmF5LmlzQXJyYXkodGFza3MpID8gW10gOiB7fTtcbiAgICAgICAgICAgIGVhY2godGFza3MsIGZ1bmN0aW9uKHRhc2ssIGtleSwgZG9uZSkge1xuICAgICAgICAgICAgICAgIHRhc2soZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trZXldID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZHMgYW4gR0VUIHJlcXVlc3QgY3JlYXRlIGFuIEltYWdlIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgWEhSIG9wdGlvbnMuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnVybCAtIFRoZSBVUkwgZm9yIHRoZSByZXNvdXJjZS5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5zdWNjZXNzIC0gVGhlIHN1Y2Nlc3MgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuZXJyb3IgLSBUaGUgZXJyb3IgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBsb2FkOiBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBsZXQgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3VjY2VzcyhpbWFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltYWdlLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyID0gJ1VuYWJsZSB0byBsb2FkIGltYWdlIGZyb20gVVJMOiBgJyArIGV2ZW50LnBhdGhbMF0uY3VycmVudFNyYyArICdgJztcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWFnZS5zcmMgPSBvcHRpb25zLnVybDtcbiAgICAgICAgfVxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IFV0aWwgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgb25lIG9mIHRoZSBXZWJHTCBgdGV4SW1hZ2UyRGAgb3ZlcnJpZGRlblxuICAgICAqIGNhbnZhcyB0eXBlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gYXJnIC0gVGhlIGFyZ3VtZW50IHRvIHRlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sfSAtIFdoZXRoZXIgb3Igbm90IGl0IGlzIGEgY2FudmFzIHR5cGUuXG4gICAgICovXG4gICAgVXRpbC5pc0NhbnZhc1R5cGUgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIEltYWdlRGF0YSB8fFxuICAgICAgICAgICAgYXJnIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fFxuICAgICAgICAgICAgYXJnIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgfHxcbiAgICAgICAgICAgIGFyZyBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGV4dHVyZSBNVVNUIGJlIGEgcG93ZXItb2YtdHdvLiBPdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNwZWMgLSBUaGUgdGV4dHVyZSBzcGVjaWZpY2F0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2x9IC0gV2hldGhlciBvciBub3QgdGhlIHRleHR1cmUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3by5cbiAgICAgKi9cbiAgICBVdGlsLm11c3RCZVBvd2VyT2ZUd28gPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgIC8vIEFjY29yZGluZyB0bzpcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMX0FQSS9UdXRvcmlhbC9Vc2luZ190ZXh0dXJlc19pbl9XZWJHTCNOb25fcG93ZXItb2YtdHdvX3RleHR1cmVzXG4gICAgICAgIC8vIE4tUE9UIHRleHR1cmVzIGNhbm5vdCBiZSB1c2VkIHdpdGggbWlwbWFwcGluZyBhbmQgdGhleSBtdXN0IG5vdCBcIlJFUEVBVFwiXG4gICAgICAgIHJldHVybiBzcGVjLm1pcE1hcCB8fFxuICAgICAgICAgICAgc3BlYy53cmFwUyA9PT0gJ1JFUEVBVCcgfHxcbiAgICAgICAgICAgIHNwZWMud3JhcFMgPT09ICdNSVJST1JFRF9SRVBFQVQnIHx8XG4gICAgICAgICAgICBzcGVjLndyYXBUID09PSAnUkVQRUFUJyB8fFxuICAgICAgICAgICAgc3BlYy53cmFwVCA9PT0gJ01JUlJPUkVEX1JFUEVBVCc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgaW50ZWdlciBpcyBhIHBvd2VyIG9mIHR3by5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBudW0gLSBUaGUgbnVtYmVyIHRvIHRlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFdoZXRoZXIgb3Igbm90IHRoZSBudW1iZXIgaXMgYSBwb3dlciBvZiB0d28uXG4gICAgICovXG4gICAgVXRpbC5pc1Bvd2VyT2ZUd28gPSBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgcmV0dXJuIChudW0gIT09IDApID8gKG51bSAmIChudW0gLSAxKSkgPT09IDAgOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIHR3byBmb3IgYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBFeC5cbiAgICAgKlxuICAgICAqICAgICAyMDAgLT4gMjU2XG4gICAgICogICAgIDI1NiAtPiAyNTZcbiAgICAgKiAgICAgMjU3IC0+IDUxMlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG51bSAtIFRoZSBudW1iZXIgdG8gbW9kaWZ5LlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIE5leHQgaGlnaGVzdCBwb3dlciBvZiB0d28uXG4gICAgICovXG4gICAgVXRpbC5uZXh0SGlnaGVzdFBvd2VyT2ZUd28gPSBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGlmIChudW0gIT09IDApIHtcbiAgICAgICAgICAgIG51bSA9IG51bS0xO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaT0xOyBpPDMyOyBpPDw9MSkge1xuICAgICAgICAgICAgbnVtID0gbnVtIHwgbnVtID4+IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bSArIDE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSB0ZXh0dXJlIG11c3QgYmUgYSBQT1QsIHJlc2l6ZXMgYW5kIHJldHVybnMgdGhlIGltYWdlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlYyAtIFRoZSB0ZXh0dXJlIHNwZWNpZmljYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1nIC0gVGhlIGltYWdlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IC0gVGhlIG9yaWdpbmFsIGltYWdlLCBvciB0aGUgcmVzaXplZCBjYW52YXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICBVdGlsLnJlc2l6ZUNhbnZhcyA9IGZ1bmN0aW9uKHNwZWMsIGltZykge1xuICAgICAgICBpZiAoIVV0aWwubXVzdEJlUG93ZXJPZlR3byhzcGVjKSB8fFxuICAgICAgICAgICAgKFV0aWwuaXNQb3dlck9mVHdvKGltZy53aWR0aCkgJiYgVXRpbC5pc1Bvd2VyT2ZUd28oaW1nLmhlaWdodCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1nO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBjYW52YXMgZWxlbWVudFxuICAgICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IFV0aWwubmV4dEhpZ2hlc3RQb3dlck9mVHdvKGltZy53aWR0aCk7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBVdGlsLm5leHRIaWdoZXN0UG93ZXJPZlR3byhpbWcuaGVpZ2h0KTtcbiAgICAgICAgLy8gY29weSB0aGUgaW1hZ2UgY29udGVudHMgdG8gdGhlIGNhbnZhc1xuICAgICAgICBsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBpbWcud2lkdGgsIGltZy5oZWlnaHQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVXRpbDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kcyBhbiBYTUxIdHRwUmVxdWVzdCBHRVQgcmVxdWVzdCB0byB0aGUgc3VwcGxpZWQgdXJsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBYSFIgb3B0aW9ucy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudXJsIC0gVGhlIFVSTCBmb3IgdGhlIHJlc291cmNlLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnN1Y2Nlc3MgLSBUaGUgc3VjY2VzcyBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5lcnJvciAtIFRoZSBlcnJvciBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5yZXNwb25zZVR5cGUgLSBUaGUgcmVzcG9uc2VUeXBlIG9mIHRoZSBYSFIuXG4gICAgICAgICAqL1xuICAgICAgICBsb2FkOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgb3B0aW9ucy51cmwsIHRydWUpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IoJ0dFVCAnICsgcmVxdWVzdC5yZXNwb25zZVVSTCArICcgJyArIHJlcXVlc3Quc3RhdHVzICsgJyAoJyArIHJlcXVlc3Quc3RhdHVzVGV4dCArICcpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG59KCkpO1xuIiwidmFyIGpzb24gPSB0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcgPyBKU09OIDogcmVxdWlyZSgnanNvbmlmeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIG9wdHMgPSB7IGNtcDogb3B0cyB9O1xuICAgIHZhciBzcGFjZSA9IG9wdHMuc3BhY2UgfHwgJyc7XG4gICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHNwYWNlID0gQXJyYXkoc3BhY2UrMSkuam9pbignICcpO1xuICAgIHZhciBjeWNsZXMgPSAodHlwZW9mIG9wdHMuY3ljbGVzID09PSAnYm9vbGVhbicpID8gb3B0cy5jeWNsZXMgOiBmYWxzZTtcbiAgICB2YXIgcmVwbGFjZXIgPSBvcHRzLnJlcGxhY2VyIHx8IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gICAgdmFyIGNtcCA9IG9wdHMuY21wICYmIChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhb2JqID0geyBrZXk6IGEsIHZhbHVlOiBub2RlW2FdIH07XG4gICAgICAgICAgICAgICAgdmFyIGJvYmogPSB7IGtleTogYiwgdmFsdWU6IG5vZGVbYl0gfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZihhb2JqLCBib2JqKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSkob3B0cy5jbXApO1xuXG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIHN0cmluZ2lmeSAocGFyZW50LCBrZXksIG5vZGUsIGxldmVsKSB7XG4gICAgICAgIHZhciBpbmRlbnQgPSBzcGFjZSA/ICgnXFxuJyArIG5ldyBBcnJheShsZXZlbCArIDEpLmpvaW4oc3BhY2UpKSA6ICcnO1xuICAgICAgICB2YXIgY29sb25TZXBhcmF0b3IgPSBzcGFjZSA/ICc6ICcgOiAnOic7XG5cbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS50b0pTT04gJiYgdHlwZW9mIG5vZGUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS50b0pTT04oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSByZXBsYWNlci5jYWxsKHBhcmVudCwga2V5LCBub2RlKTtcblxuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCBub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4ganNvbi5zdHJpbmdpZnkobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RyaW5naWZ5KG5vZGUsIGksIG5vZGVbaV0sIGxldmVsKzEpIHx8IGpzb24uc3RyaW5naWZ5KG51bGwpO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGluZGVudCArIHNwYWNlICsgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgb3V0LmpvaW4oJywnKSArIGluZGVudCArICddJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN5Y2xlcykgcmV0dXJuIGpzb24uc3RyaW5naWZ5KCdfX2N5Y2xlX18nKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHNlZW4ucHVzaChub2RlKTtcblxuICAgICAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKG5vZGUpLnNvcnQoY21wICYmIGNtcChub2RlKSk7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHJpbmdpZnkobm9kZSwga2V5LCBub2RlW2tleV0sIGxldmVsKzEpO1xuXG4gICAgICAgICAgICAgICAgaWYoIXZhbHVlKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IGpzb24uc3RyaW5naWZ5KGtleSlcbiAgICAgICAgICAgICAgICAgICAgKyBjb2xvblNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICArIHZhbHVlO1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChpbmRlbnQgKyBzcGFjZSArIGtleVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW4uc3BsaWNlKHNlZW4uaW5kZXhPZihub2RlKSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gJ3snICsgb3V0LmpvaW4oJywnKSArIGluZGVudCArICd9JztcbiAgICAgICAgfVxuICAgIH0pKHsgJyc6IG9iaiB9LCAnJywgb2JqLCAwKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZSB9O1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59O1xuIiwiZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vbGliL3BhcnNlJyk7XG5leHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vbGliL3N0cmluZ2lmeScpO1xuIiwidmFyIGF0LCAvLyBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgY2gsIC8vIFRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgIGVzY2FwZWUgPSB7XG4gICAgICAgICdcIic6ICAnXCInLFxuICAgICAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAgICAgJy8nOiAgJy8nLFxuICAgICAgICBiOiAgICAnXFxiJyxcbiAgICAgICAgZjogICAgJ1xcZicsXG4gICAgICAgIG46ICAgICdcXG4nLFxuICAgICAgICByOiAgICAnXFxyJyxcbiAgICAgICAgdDogICAgJ1xcdCdcbiAgICB9LFxuICAgIHRleHQsXG5cbiAgICBlcnJvciA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIC8vIENhbGwgZXJyb3Igd2hlbiBzb21ldGhpbmcgaXMgd3JvbmcuXG4gICAgICAgIHRocm93IHtcbiAgICAgICAgICAgIG5hbWU6ICAgICdTeW50YXhFcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiBtLFxuICAgICAgICAgICAgYXQ6ICAgICAgYXQsXG4gICAgICAgICAgICB0ZXh0OiAgICB0ZXh0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBcbiAgICBuZXh0ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgLy8gSWYgYSBjIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgdmVyaWZ5IHRoYXQgaXQgbWF0Y2hlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuXG4gICAgICAgIGlmIChjICYmIGMgIT09IGNoKSB7XG4gICAgICAgICAgICBlcnJvcihcIkV4cGVjdGVkICdcIiArIGMgKyBcIicgaW5zdGVhZCBvZiAnXCIgKyBjaCArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGNoYXJhY3Rlci4gV2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzLFxuICAgICAgICAvLyByZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgICAgXG4gICAgICAgIGNoID0gdGV4dC5jaGFyQXQoYXQpO1xuICAgICAgICBhdCArPSAxO1xuICAgICAgICByZXR1cm4gY2g7XG4gICAgfSxcbiAgICBcbiAgICBudW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBhcnNlIGEgbnVtYmVyIHZhbHVlLlxuICAgICAgICB2YXIgbnVtYmVyLFxuICAgICAgICAgICAgc3RyaW5nID0gJyc7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgICAgc3RyaW5nID0gJy0nO1xuICAgICAgICAgICAgbmV4dCgnLScpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSAnLic7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCgpICYmIGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbnVtYmVyID0gK3N0cmluZztcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgICBlcnJvcihcIkJhZCBudW1iZXJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBhcnNlIGEgc3RyaW5nIHZhbHVlLlxuICAgICAgICB2YXIgaGV4LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHN0cmluZyA9ICcnLFxuICAgICAgICAgICAgdWZmZmY7XG4gICAgICAgIFxuICAgICAgICAvLyBXaGVuIHBhcnNpbmcgZm9yIHN0cmluZyB2YWx1ZXMsIHdlIG11c3QgbG9vayBmb3IgXCIgYW5kIFxcIGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgd2hpbGUgKG5leHQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZXggPSBwYXJzZUludChuZXh0KCksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGhleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gdWZmZmYgKiAxNiArIGhleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVmZmZmKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXNjYXBlZVtjaF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gZXNjYXBlZVtjaF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgc3RyaW5nXCIpO1xuICAgIH0sXG5cbiAgICB3aGl0ZSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gU2tpcCB3aGl0ZXNwYWNlLlxuXG4gICAgICAgIHdoaWxlIChjaCAmJiBjaCA8PSAnICcpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB3b3JkID0gZnVuY3Rpb24gKCkge1xuXG4vLyB0cnVlLCBmYWxzZSwgb3IgbnVsbC5cblxuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgbmV4dCgndCcpO1xuICAgICAgICAgICAgbmV4dCgncicpO1xuICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgbmV4dCgnZicpO1xuICAgICAgICAgICAgbmV4dCgnYScpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgbmV4dCgncycpO1xuICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIG5leHQoJ24nKTtcbiAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiVW5leHBlY3RlZCAnXCIgKyBjaCArIFwiJ1wiKTtcbiAgICB9LFxuXG4gICAgdmFsdWUsICAvLyBQbGFjZSBob2xkZXIgZm9yIHRoZSB2YWx1ZSBmdW5jdGlvbi5cblxuICAgIGFycmF5ID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhbiBhcnJheSB2YWx1ZS5cblxuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgICAgICBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICAgICAgbmV4dCgnWycpO1xuICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTsgICAvLyBlbXB0eSBhcnJheVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBhcnJheVwiKTtcbiAgICB9LFxuXG4gICAgb2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhbiBvYmplY3QgdmFsdWUuXG5cbiAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgIG9iamVjdCA9IHt9O1xuXG4gICAgICAgIGlmIChjaCA9PT0gJ3snKSB7XG4gICAgICAgICAgICBuZXh0KCd7Jyk7XG4gICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDsgICAvLyBlbXB0eSBvYmplY3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGtleSA9IHN0cmluZygpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgbmV4dCgnOicpO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0R1cGxpY2F0ZSBrZXkgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsdWUoKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgb2JqZWN0XCIpO1xuICAgIH07XG5cbnZhbHVlID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhIEpTT04gdmFsdWUuIEl0IGNvdWxkIGJlIGFuIG9iamVjdCwgYW4gYXJyYXksIGEgc3RyaW5nLCBhIG51bWJlcixcbi8vIG9yIGEgd29yZC5cblxuICAgIHdoaXRlKCk7XG4gICAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgJ3snOlxuICAgICAgICByZXR1cm4gb2JqZWN0KCk7XG4gICAgY2FzZSAnWyc6XG4gICAgICAgIHJldHVybiBhcnJheSgpO1xuICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgcmV0dXJuIHN0cmluZygpO1xuICAgIGNhc2UgJy0nOlxuICAgICAgICByZXR1cm4gbnVtYmVyKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGNoID49ICcwJyAmJiBjaCA8PSAnOScgPyBudW1iZXIoKSA6IHdvcmQoKTtcbiAgICB9XG59O1xuXG4vLyBSZXR1cm4gdGhlIGpzb25fcGFyc2UgZnVuY3Rpb24uIEl0IHdpbGwgaGF2ZSBhY2Nlc3MgdG8gYWxsIG9mIHRoZSBhYm92ZVxuLy8gZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNvdXJjZSwgcmV2aXZlcikge1xuICAgIHZhciByZXN1bHQ7XG4gICAgXG4gICAgdGV4dCA9IHNvdXJjZTtcbiAgICBhdCA9IDA7XG4gICAgY2ggPSAnICc7XG4gICAgcmVzdWx0ID0gdmFsdWUoKTtcbiAgICB3aGl0ZSgpO1xuICAgIGlmIChjaCkge1xuICAgICAgICBlcnJvcihcIlN5bnRheCBlcnJvclwiKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIG5ldyBzdHJ1Y3R1cmUsXG4gICAgLy8gcGFzc2luZyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byB0aGUgcmV2aXZlciBmdW5jdGlvbiBmb3IgcG9zc2libGVcbiAgICAvLyB0cmFuc2Zvcm1hdGlvbiwgc3RhcnRpbmcgd2l0aCBhIHRlbXBvcmFyeSByb290IG9iamVjdCB0aGF0IGhvbGRzIHRoZSByZXN1bHRcbiAgICAvLyBpbiBhbiBlbXB0eSBrZXkuIElmIHRoZXJlIGlzIG5vdCBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHNpbXBseSByZXR1cm4gdGhlXG4gICAgLy8gcmVzdWx0LlxuXG4gICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nID8gKGZ1bmN0aW9uIHdhbGsoaG9sZGVyLCBrZXkpIHtcbiAgICAgICAgdmFyIGssIHYsIHZhbHVlID0gaG9sZGVyW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICB2ID0gd2Fsayh2YWx1ZSwgayk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV2aXZlci5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgfSh7Jyc6IHJlc3VsdH0sICcnKSkgOiByZXN1bHQ7XG59O1xuIiwidmFyIGN4ID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICBnYXAsXG4gICAgaW5kZW50LFxuICAgIG1ldGEgPSB7ICAgIC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG4gICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgJ1wiJyA6ICdcXFxcXCInLFxuICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICB9LFxuICAgIHJlcDtcblxuZnVuY3Rpb24gcXVvdGUoc3RyaW5nKSB7XG4gICAgLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuICAgIC8vIGJhY2tzbGFzaCBjaGFyYWN0ZXJzLCB0aGVuIHdlIGNhbiBzYWZlbHkgc2xhcCBzb21lIHF1b3RlcyBhcm91bmQgaXQuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXG4gICAgLy8gc2VxdWVuY2VzLlxuICAgIFxuICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBlc2NhcGFibGUudGVzdChzdHJpbmcpID8gJ1wiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGMgPSBtZXRhW2FdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnID8gYyA6XG4gICAgICAgICAgICAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICB9KSArICdcIicgOiAnXCInICsgc3RyaW5nICsgJ1wiJztcbn1cblxuZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyKSB7XG4gICAgLy8gUHJvZHVjZSBhIHN0cmluZyBmcm9tIGhvbGRlcltrZXldLlxuICAgIHZhciBpLCAgICAgICAgICAvLyBUaGUgbG9vcCBjb3VudGVyLlxuICAgICAgICBrLCAgICAgICAgICAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgdiwgICAgICAgICAgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBtaW5kID0gZ2FwLFxuICAgICAgICBwYXJ0aWFsLFxuICAgICAgICB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgIFxuICAgIC8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xuICAgIC8vIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgIGlmICh0eXBlb2YgcmVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gcmVwLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuICAgICAgICBcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnbnVsbCc7XG4gICAgICAgIFxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4gICAgICAgICAgICAvLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlICdudWxsJy4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuICAgICAgICAgICAgLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQXJyYXkuaXNBcnJheVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCAnbnVsbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBlbGVtZW50cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB3cmFwIHRoZW0gaW4gYnJhY2tldHMuXG4gICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ1tdJyA6IGdhcCA/XG4gICAgICAgICAgICAgICAgICAgICdbXFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ10nIDpcbiAgICAgICAgICAgICAgICAgICAgJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgdGhlIHJlcGxhY2VyIGlzIGFuIGFycmF5LCB1c2UgaXQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlXG4gICAgICAgICAgICAvLyBzdHJpbmdpZmllZC5cbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSByZXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4gICAgICAgIC8vIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuXG4gICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICd7fScgOiBnYXAgP1xuICAgICAgICAgICAgJ3tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnfScgOlxuICAgICAgICAgICAgJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnfSc7XG4gICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIHZhciBpO1xuICAgIGdhcCA9ICcnO1xuICAgIGluZGVudCA9ICcnO1xuICAgIFxuICAgIC8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbiAgICAvLyBtYW55IHNwYWNlcy5cbiAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BhY2U7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5kZW50ICs9ICcgJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluZGVudCBzdHJpbmcuXG4gICAgZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbmRlbnQgPSBzcGFjZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4gICAgLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvci5cbiAgICByZXAgPSByZXBsYWNlcjtcbiAgICBpZiAocmVwbGFjZXIgJiYgdHlwZW9mIHJlcGxhY2VyICE9PSAnZnVuY3Rpb24nXG4gICAgJiYgKHR5cGVvZiByZXBsYWNlciAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gJ251bWJlcicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTi5zdHJpbmdpZnknKTtcbiAgICB9XG4gICAgXG4gICAgLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiAnJy5cbiAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuICAgIHJldHVybiBzdHIoJycsIHsnJzogdmFsdWV9KTtcbn07XG4iLCIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuMTQuMVxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gdXRpbHNfaG9va3NfX2hvb2tzICgpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkob2JqKSB7XG4gICAgICAgIHZhciBrO1xuICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAvLyBldmVuIGlmIGl0cyBub3Qgb3duIHByb3BlcnR5IEknZCBzdGlsbCBjYWxsIGl0IG5vbi1lbXB0eVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gW10sIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlX3V0Y19fY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWRUb2tlbnMgICAgOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyICAgOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdCAgIDogZmFsc2UsXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgcGFyc2VkRGF0ZVBhcnRzIDogW10sXG4gICAgICAgICAgICBtZXJpZGllbSAgICAgICAgOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICB2YXIgc29tZTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRfX2lzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgICAgICB2YXIgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IG0uX2lzVmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZF9fY3JlYXRlSW52YWxpZCAoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSB1dGlsc19ob29rc19faG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gbW9tZW50UHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgY29uc29sZSAhPT0gICd1bmRlZmluZWQnKSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgICAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcsICcpICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICBpZiAodXRpbHNfaG9va3NfX2hvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlX3NldF9fc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9vcmRpbmFsUGFyc2VMZW5pZW50LlxuICAgICAgICB0aGlzLl9vcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cCh0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlICsgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZV9jYWxlbmRhcl9fY2FsZW5kYXIgKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV0gfHwgdGhpcy5fY2FsZW5kYXJbJ3NhbWVFbHNlJ107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb25nRGF0ZUZvcm1hdCA9IHtcbiAgICAgICAgTFRTICA6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVCAgIDogJ2g6bW0gQScsXG4gICAgICAgIEwgICAgOiAnTU0vREQvWVlZWScsXG4gICAgICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcbiAgICAgICAgTExMICA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgTExMTCA6ICdkZGRkLCBNTU1NIEQsIFlZWVkgaDptbSBBJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdCAoa2V5KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxuICAgICAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwuc2xpY2UoMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuICAgIGZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludmFsaWREYXRlO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCc7XG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG4gICAgZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgICAgIHMgIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoICA6ICdhbiBob3VyJyxcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICBkICA6ICdhIGRheScsXG4gICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICBNICA6ICdhIG1vbnRoJyxcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeSAgOiAnYSB5ZWFyJyxcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlX19yZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgIHJldHVybiAoaXNGdW5jdGlvbihvdXRwdXQpKSA/XG4gICAgICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRBbGlhcyAodW5pdCwgc2hvcnRoYW5kKSB7XG4gICAgICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIHZhciBwcmlvcml0aWVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICAgICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICAgICAgdmFyIHVuaXRzID0gW107XG4gICAgICAgIGZvciAodmFyIHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgICAgIHVuaXRzLnB1c2goe3VuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdfSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ2V0X3NldF9fc2V0KHRoaXMsIHVuaXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldF9zZXRfX2dldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRfc2V0X19nZXQgKG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRfc2V0X19zZXQgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdHZXQgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gc3RyaW5nU2V0ICh1bml0cywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplT2JqZWN0VW5pdHModW5pdHMpO1xuICAgICAgICAgICAgdmFyIHByaW9yaXRpemVkID0gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW9yaXRpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGFycmF5W2ldIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGkgPSA1O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSAgICAgICAgID0gL1xcZC87ICAgICAgICAgICAgLy8gICAgICAgMCAtIDlcbiAgICB2YXIgbWF0Y2gyICAgICAgICAgPSAvXFxkXFxkLzsgICAgICAgICAgLy8gICAgICAwMCAtIDk5XG4gICAgdmFyIG1hdGNoMyAgICAgICAgID0gL1xcZHszfS87ICAgICAgICAgLy8gICAgIDAwMCAtIDk5OVxuICAgIHZhciBtYXRjaDQgICAgICAgICA9IC9cXGR7NH0vOyAgICAgICAgIC8vICAgIDAwMDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoNiAgICAgICAgID0gL1srLV0/XFxkezZ9LzsgICAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuICAgIHZhciBtYXRjaDF0bzIgICAgICA9IC9cXGRcXGQ/LzsgICAgICAgICAvLyAgICAgICAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzdG80ICAgICAgPSAvXFxkXFxkXFxkXFxkPy87ICAgICAvLyAgICAgOTk5IC0gOTk5OVxuICAgIHZhciBtYXRjaDV0bzYgICAgICA9IC9cXGRcXGRcXGRcXGRcXGRcXGQ/LzsgLy8gICA5OTk5OSAtIDk5OTk5OVxuICAgIHZhciBtYXRjaDF0bzMgICAgICA9IC9cXGR7MSwzfS87ICAgICAgIC8vICAgICAgIDAgLSA5OTlcbiAgICB2YXIgbWF0Y2gxdG80ICAgICAgPSAvXFxkezEsNH0vOyAgICAgICAvLyAgICAgICAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDF0bzYgICAgICA9IC9bKy1dP1xcZHsxLDZ9LzsgIC8vIC05OTk5OTkgLSA5OTk5OTlcblxuICAgIHZhciBtYXRjaFVuc2lnbmVkICA9IC9cXGQrLzsgICAgICAgICAgIC8vICAgICAgIDAgLSBpbmZcbiAgICB2YXIgbWF0Y2hTaWduZWQgICAgPSAvWystXT9cXGQrLzsgICAgICAvLyAgICAtaW5mIC0gaW5mXG5cbiAgICB2YXIgbWF0Y2hPZmZzZXQgICAgPSAvWnxbKy1dXFxkXFxkOj9cXGRcXGQvZ2k7IC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgIHZhciBtYXRjaFNob3J0T2Zmc2V0ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZ2k7IC8vICswMCAtMDAgKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG5cbiAgICB2YXIgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vOyAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuXG4gICAgLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4gICAgLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xuICAgIHZhciBtYXRjaFdvcmQgPSAvWzAtOV0qWydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK3xbXFx1MDYwMC1cXHUwNkZGXFwvXSsoXFxzKj9bXFx1MDYwMC1cXHUwNkZGXSspezEsMn0vaTtcblxuXG4gICAgdmFyIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcmVnZXhFc2NhcGUocy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgWUVBUiA9IDA7XG4gICAgdmFyIE1PTlRIID0gMTtcbiAgICB2YXIgREFURSA9IDI7XG4gICAgdmFyIEhPVVIgPSAzO1xuICAgIHZhciBNSU5VVEUgPSA0O1xuICAgIHZhciBTRUNPTkQgPSA1O1xuICAgIHZhciBNSUxMSVNFQ09ORCA9IDY7XG4gICAgdmFyIFdFRUsgPSA3O1xuICAgIHZhciBXRUVLREFZID0gODtcblxuICAgIHZhciBpbmRleE9mO1xuXG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleE9mID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIC8vIEkga25vd1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggKyAxLCAwKSkuZ2V0VVRDRGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMrKStNTU1NPy87XG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMgKG0sIGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzW20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzWyh0aGlzLl9tb250aHMuaXNGb3JtYXQgfHwgTU9OVEhTX0lOX0ZPUk1BVCkudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml0c19tb250aF9faGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuaXRzX21vbnRoX19oYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgICAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TW9udGggKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgICAgICByZXR1cm4geSA8PSA5OTk5ID8gJycgKyB5IDogJysnICsgeTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCAgIDRdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCAgNV0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3llYXInLCAxKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWScsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWScsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gaW5wdXQubGVuZ3RoID09PSAyID8gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbiAgICB9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gZ2V0SXNMZWFwWWVhciAoKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvL2Nhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxMzQ4L2luc3RhbnRpYXRpbmctYS1qYXZhc2NyaXB0LW9iamVjdC1ieS1jYWxsaW5nLXByb3RvdHlwZS1jb25zdHJ1Y3Rvci1hcHBseVxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgICAgICAvL3RoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG5cbiAgICAgICAgLy90aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG4gICAgZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICAgICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG4gICAgfVxuXG4gICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgICAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICAgICAgeWVhcjogcmVzWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrJywgJ3cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrJywgNSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd3JywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrZGF5JywgMTEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzW20uZGF5KCldIDpcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzW3RoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5X29mX3dlZWtfX2hhbmRsZVN0cmljdFBhcnNlKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGRheV9vZl93ZWVrX19oYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZGQnICYmIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGQnICYmIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGQnICYmIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNNaW5SZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5QaWVjZXMgPSBbXSwgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tLCBtaW5wLCBzaG9ydHAsIGxvbmdwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIG1pbnAgPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgc2hvcnRwID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgbG9uZ3AgPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpO1xuICAgICAgICAgICAgbWluUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgd2Vla2RheSAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIG1pblBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWluUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1lcmlkaWVtKCdhJywgdHJ1ZSk7XG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2hvdXInLCAxMyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBmdW5jdGlvbiBtYXRjaE1lcmlkaWVtIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdBJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRSZWdleFRva2VuKCdobW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbXNzJywgbWF0Y2g1dG82KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgICAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgaGUgd2FudHMuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIG9yZGluYWxQYXJzZTogZGVmYXVsdE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxuICAgIH07XG5cbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG4gICAgdmFyIGxvY2FsZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsO1xuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgICAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgZGVmaW5lTG9jYWxlIGN1cnJlbnRseSBhbHNvIHNldHMgdGhlIGdsb2JhbCBsb2NhbGUsIHdlXG4gICAgICAgICAgICAgICAgLy8gd2FudCB0byB1bmRvIHRoYXQgZm9yIGxhenkgbG9hZGVkIGxvY2FsZXNcbiAgICAgICAgICAgICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxvY2FsZSBrZXkuXG4gICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZSgnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kZWZpbmUtbG9jYWxlLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJlYXQgYXMgaWYgdGhlcmUgaXMgbm8gYmFzZSBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdwYXJlbnRMb2NhbGVVbmRlZmluZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzcGVjaWZpZWQgcGFyZW50TG9jYWxlIGlzIG5vdCBkZWZpbmVkIHlldC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvcGFyZW50LWxvY2FsZS8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpKTtcblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLCBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuICAgIGZ1bmN0aW9uIGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUgKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBpc28gODYwMSByZWdleFxuICAgIC8vIDAwMDAtMDAtMDAgMDAwMC1XMDAgb3IgMDAwMC1XMDAtMCArIFQgKyAwMCBvciAwMDowMCBvciAwMDowMDowMCBvciAwMDowMDowMC4wMDAgKyArMDA6MDAgb3IgKzAwMDAgb3IgKzAwKVxuICAgIHZhciBleHRlbmRlZElzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPy87XG4gICAgdmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPy87XG5cbiAgICB2YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcblxuICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuICAgIF07XG5cbiAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgdmFyIGlzb1RpbWVzID0gW1xuICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEgnLCAvXFxkXFxkL11cbiAgICBdO1xuXG4gICAgdmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBsLFxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgICAgIGFsbG93VGltZSwgZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgdHpGb3JtYXQ7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzJdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgIGlmICh0elJlZ2V4LmV4ZWMobWF0Y2hbNF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZS4gVGhpcyBpcyAnICtcbiAgICAgICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdXBjb21pbmcgbWFqb3IgJyArXG4gICAgICAgICdyZWxlYXNlLiBQbGVhc2UgcmVmZXIgdG8gJyArXG4gICAgICAgICdodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvIGZvciBtb3JlIGluZm8uJyxcbiAgICAgICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZSh1dGlsc19ob29rc19faG9va3Mubm93KCkpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0VVRDTW9udGgoKSwgbm93VmFsdWUuZ2V0VVRDRGF0ZSgpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4gICAgLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbiAgICAvLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbiAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgZGF0ZSwgaW5wdXQgPSBbXSwgY3VycmVudERhdGUsIHllYXJUb1VzZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgICAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhcik7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobG9jYWxfX2NyZWF0ZUxvY2FsKCksIGRvdywgZG95KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIDEpO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICAgICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Rva2VuJywgdG9rZW4sICdwYXJzZWRJbnB1dCcsIHBhcnNlZElucHV0LFxuICAgICAgICAgICAgLy8gICAgICAgICAncmVnZXgnLCBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChjb25maWcuX2xvY2FsZSwgY29uZmlnLl9hW0hPVVJdLCBjb25maWcuX21lcmlkaWVtKTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwIChsb2NhbGUsIGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgIHZhciBpc1BtO1xuXG4gICAgICAgIGlmIChtZXJpZGllbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxlLmlzUE0gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2tcbiAgICAgICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XG4gICAgICAgICAgICBpZiAoaXNQbSAmJiBob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1BtICYmIGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBhcnJheSBvZiBmb3JtYXQgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgICAgICBiZXN0TW9tZW50LFxuXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZF9faXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgICAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZF9fY3JlYXRlSW52YWxpZCh7bnVsbElucHV0OiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSAgZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdmFsaWRfX2lzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh1dGlsc19ob29rc19faG9va3Mubm93KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YobG9jYWxlKSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGlzT2JqZWN0KGlucHV0KSAmJiBpc09iamVjdEVtcHR5KGlucHV0KSkgfHxcbiAgICAgICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsX19jcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRfX2NyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB2YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRfX2NyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuICAgIC8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cbiAgICAvL1xuICAgIC8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2VcbiAgICAvLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxuICAgIGZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgICAgICB2YXIgcmVzLCBpO1xuICAgICAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xuICAgICAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRHVyYXRpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgMCxcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICAgICAgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKCk7XG5cbiAgICAgICAgdGhpcy5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBvZmZzZXQgKHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICAgICAgdmFyIHNpZ24gPSAnKyc7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaWduICsgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArIHNlcGFyYXRvciArIHplcm9GaWxsKH5+KG9mZnNldCkgJSA2MCwgMik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9mZnNldCgnWicsICc6Jyk7XG4gICAgb2Zmc2V0KCdaWicsICcnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1onLCAgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUmVnZXhUb2tlbignWlonLCBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gdGltZXpvbmUgY2h1bmtlclxuICAgIC8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuICAgIC8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxuICAgIHZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuICAgIGZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcobWF0Y2hlciwgc3RyaW5nKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gKChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpIHx8IFtdKTtcbiAgICAgICAgdmFyIGNodW5rICAgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgICAgIHZhciBwYXJ0cyAgID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgIHJldHVybiBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCBtb2RlbCkge1xuICAgICAgICB2YXIgcmVzLCBkaWZmO1xuICAgICAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAgICAgICAgZGlmZiA9IChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/IGlucHV0LnZhbHVlT2YoKSA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgY3JlYXRlX19jcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkICgpIHtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVfdXRjX19jcmVhdGVVVEMoYy5fYSkgOiBsb2NhbF9fY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgIHZhciBhc3BOZXRSZWdleCA9IC9eKFxcLSk/KD86KFxcZCopWy4gXSk/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspXFwuPyhcXGR7M30pP1xcZCopPyQvO1xuXG4gICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgIHZhciBpc29SZWdleCA9IC9eKC0pP1AoPzooLT9bMC05LC5dKilZKT8oPzooLT9bMC05LC5dKilNKT8oPzooLT9bMC05LC5dKilXKT8oPzooLT9bMC05LC5dKilEKT8oPzpUKD86KC0/WzAtOSwuXSopSCk/KD86KC0/WzAtOSwuXSopTSk/KD86KC0/WzAtOSwuXSopUyk/KT8kLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gaW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXMgOiB0b0ludChtYXRjaFtNSUxMSVNFQ09ORF0pICogc2lnblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UobG9jYWxfX2NyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLCBsb2NhbF9fY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pKTtcblxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XG4gICAgICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXMgPSB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0IChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBnZXRfc2V0X19zZXQobW9tLCAnRGF0ZScsIGdldF9zZXRfX2dldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0X3NldF9fZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZU9mZnNldCkge1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGRfc3VidHJhY3RfX2FkZCAgICAgID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpO1xuICAgIHZhciBhZGRfc3VidHJhY3RfX3N1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xuICAgICAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xuICAgICAgICByZXR1cm4gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfY2FsZW5kYXJfX2NhbGVuZGFyICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBsb2NhbF9fY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgZm9ybWF0ID0gdXRpbHNfaG9va3NfX2hvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJztcblxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0cyAmJiAoaXNGdW5jdGlvbihmb3JtYXRzW2Zvcm1hdF0pID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KSA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGxvY2FsX19jcmVhdGVMb2NhbChub3cpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxJbnB1dC52YWx1ZU9mKCkgPCB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgICAgIGluY2x1c2l2aXR5ID0gaW5jbHVzaXZpdHkgfHwgJygpJztcbiAgICAgICAgcmV0dXJuIChpbmNsdXNpdml0eVswXSA9PT0gJygnID8gdGhpcy5pc0FmdGVyKGZyb20sIHVuaXRzKSA6ICF0aGlzLmlzQmVmb3JlKGZyb20sIHVuaXRzKSkgJiZcbiAgICAgICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknID8gdGhpcy5pc0JlZm9yZSh0bywgdW5pdHMpIDogIXRoaXMuaXNBZnRlcih0bywgdW5pdHMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMgfHwgJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCx1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZiAoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgICAgIHZhciB0aGF0LFxuICAgICAgICAgICAgem9uZURlbHRhLFxuICAgICAgICAgICAgZGVsdGEsIG91dHB1dDtcblxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAneWVhcicgfHwgdW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpO1xuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0IC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWx0YSA9IHRoaXMgLSB0aGF0O1xuICAgICAgICAgICAgb3V0cHV0ID0gdW5pdHMgPT09ICdzZWNvbmQnID8gZGVsdGEgLyAxZTMgOiAvLyAxMDAwXG4gICAgICAgICAgICAgICAgdW5pdHMgPT09ICdtaW51dGUnID8gZGVsdGEgLyA2ZTQgOiAvLyAxMDAwICogNjBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2hvdXInID8gZGVsdGEgLyAzNmU1IDogLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2RheScgPyAoZGVsdGEgLSB6b25lRGVsdGEpIC8gODY0ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgdW5pdHMgPT09ICd3ZWVrJyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgICAgIGRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyKSArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgICAgIGFuY2hvcjIsIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgfVxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmcgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMuY2xvbmUoKS51dGMoKTtcbiAgICAgICAgaWYgKDAgPCBtLnllYXIoKSAmJiBtLnllYXIoKSA8PSA5OTk5KSB7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgICAgICBpZiAoIWlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKSA/IHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBsb2NhbF9fY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tKGxvY2FsX19jcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0byAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBsb2NhbF9fY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbiAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4gICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcbiAgICAgICAgLy8gdG8gdXRpbGl6ZSBmYWxsaW5nIHRocm91Z2ggdGhlIGNhc2VzLlxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRoaXMuaG91cnMoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGhpcy5taW51dGVzKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRzKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZHMoMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZWVrcyBhcmUgYSBzcGVjaWFsIGNhc2VcbiAgICAgICAgaWYgKHVuaXRzID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla2RheSgwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdHMgPT09ICdpc29XZWVrJykge1xuICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcXVhcnRlcnMgYXJlIGFsc28gc3BlY2lhbFxuICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgdGhpcy5tb250aChNYXRoLmZsb29yKHRoaXMubW9udGgoKSAvIDMpICogMyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRPZiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICdkYXRlJyBpcyBhbiBhbGlhcyBmb3IgJ2RheScsIHNvIGl0IHNob3VsZCBiZSBjb25zaWRlcmVkIGFzIHN1Y2guXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ2RhdGUnKSB7XG4gICAgICAgICAgICB1bml0cyA9ICdkYXknO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZih1bml0cykuYWRkKDEsICh1bml0cyA9PT0gJ2lzb1dlZWsnID8gJ3dlZWsnIDogdW5pdHMpKS5zdWJ0cmFjdCgxLCAnbXMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b190eXBlX192YWx1ZU9mICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfdmFsaWRfX2lzVmFsaWQgKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRfX2lzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0aW9uRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl9mLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgICAgICBzdHJpY3Q6IHRoaXMuX3N0cmljdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheSgpLFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdyxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgIGlucHV0LCB0aGlzLmlzb1dlZWsoKSwgdGhpcy5pc29XZWVrZGF5KCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtzVGFyZ2V0O1xuICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhckRhdGEgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgICAgICB0aGlzLm1vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSk7XG4gICAgICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdxdWFydGVyJywgNyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0UXVhcnRlciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuICAgIC8vIFBSSU9ST0lUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gbG9jYWxlLl9vcmRpbmFsUGFyc2UgOiBsb2NhbGUuX29yZGluYWxQYXJzZUxlbmllbnQ7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnRCcsICdERCddLCBEQVRFKTtcbiAgICBhZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdLCAxMCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdzZWNvbmQnLCAxNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbjtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIG1vbWVudFByb3RvdHlwZV9fcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xuXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZF9zdWJ0cmFjdF9fYWRkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2FsZW5kYXIgICAgICAgICAgPSBtb21lbnRfY2FsZW5kYXJfX2NhbGVuZGFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmVuZE9mICAgICAgICAgICAgID0gZW5kT2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZyb21Ob3cgICAgICAgICAgID0gZnJvbU5vdztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZ2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdHZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQmVmb3JlICAgICAgICAgID0gaXNCZWZvcmU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lT3JBZnRlciAgICAgPSBpc1NhbWVPckFmdGVyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVmFsaWQgICAgICAgICAgID0gbW9tZW50X3ZhbGlkX19pc1ZhbGlkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubGFuZyAgICAgICAgICAgICAgPSBsYW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgICAgICAgPSBsb2NhbGU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tYXggICAgICAgICAgICAgICA9IHByb3RvdHlwZU1heDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbiAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWluO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zZXQgICAgICAgICAgICAgICA9IHN0cmluZ1NldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN0YXJ0T2YgICAgICAgICAgID0gc3RhcnRPZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN1YnRyYWN0ICAgICAgICAgID0gYWRkX3N1YnRyYWN0X19zdWJ0cmFjdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0RhdGUgICAgICAgICAgICA9IHRvRGF0ZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvSVNPU3RyaW5nICAgICAgID0gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgICAgICA9IHRvSlNPTjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by52YWx1ZU9mICAgICAgICAgICA9IHRvX3R5cGVfX3ZhbHVlT2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcblxuICAgIC8vIFllYXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG5cbiAgICAvLyBXZWVrIFllYXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuXG4gICAgLy8gUXVhcnRlclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucXVhcnRlciA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuXG4gICAgLy8gTW9udGhcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuXG4gICAgLy8gV2Vla1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2VlayAgICAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuXG4gICAgLy8gRGF5XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheSAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG5cbiAgICAvLyBIb3VyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5ob3VyID0gbW9tZW50UHJvdG90eXBlX19wcm90by5ob3VycyA9IGdldFNldEhvdXI7XG5cbiAgICAvLyBNaW51dGVcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbnV0ZSA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcblxuICAgIC8vIFNlY29uZFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2Vjb25kID0gbW9tZW50UHJvdG90eXBlX19wcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xuXG4gICAgLy8gTWlsbGlzZWNvbmRcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kID0gbW9tZW50UHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcblxuICAgIC8vIE9mZnNldFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udXRjT2Zmc2V0ICAgICAgICAgICAgPSBnZXRTZXRPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucGFyc2Vab25lICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNMb2NhbCAgICAgICAgICAgICAgPSBpc0xvY2FsO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1VUQyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuXG4gICAgLy8gVGltZXpvbmVcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuXG4gICAgLy8gRGVwcmVjYXRpb25zXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsIGdldFNldFpvbmUpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKCdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJywgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKTtcblxuICAgIHZhciBtb21lbnRQcm90b3R5cGUgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvO1xuXG4gICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVVbml4IChpbnB1dCkge1xuICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVJblpvbmUgKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlX19wcm90byA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90b3R5cGVfX3Byb3RvLmNhbGVuZGFyICAgICAgICA9IGxvY2FsZV9jYWxlbmRhcl9fY2FsZW5kYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5sb25nRGF0ZUZvcm1hdCAgPSBsb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmludmFsaWREYXRlICAgICA9IGludmFsaWREYXRlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ub3JkaW5hbCAgICAgICAgID0gb3JkaW5hbDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnByZXBhcnNlICAgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnBvc3Rmb3JtYXQgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnJlbGF0aXZlVGltZSAgICA9IHJlbGF0aXZlX19yZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG90eXBlX19wcm90by5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uc2V0ICAgICAgICAgICAgID0gbG9jYWxlX3NldF9fc2V0O1xuXG4gICAgLy8gTW9udGhcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRocyAgICAgICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRocztcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1Nob3J0ICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzUGFyc2UgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzUGFyc2U7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNSZWdleCAgICAgICA9IG1vbnRoc1JlZ2V4O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzU2hvcnRSZWdleCAgPSBtb250aHNTaG9ydFJlZ2V4O1xuXG4gICAgLy8gV2Vla1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2VlayA9IGxvY2FsZVdlZWs7XG4gICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuICAgIC8vIERheSBvZiBXZWVrXG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzUmVnZXggICAgICAgPSAgICAgICAgd2Vla2RheXNSZWdleDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzU2hvcnRSZWdleCAgPSAgICAgICAgd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNNaW5SZWdleCAgICA9ICAgICAgICB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgLy8gSG91cnNcbiAgICBwcm90b3R5cGVfX3Byb3RvLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgIGZ1bmN0aW9uIGxpc3RzX19nZXQgKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoKTtcbiAgICAgICAgdmFyIHV0YyA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdHNfX2dldChmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gbGlzdHNfX2dldChmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8vICgpXG4gICAgLy8gKDUpXG4gICAgLy8gKGZtdCwgNSlcbiAgICAvLyAoZm10KVxuICAgIC8vICh0cnVlKVxuICAgIC8vICh0cnVlLCA1KVxuICAgIC8vICh0cnVlLCBmbXQsIDUpXG4gICAgLy8gKHRydWUsIGZtdClcbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpLFxuICAgICAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMDtcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RzX19nZXQoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gbGlzdHNfX2dldChmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RNb250aHNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5cyAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5c1Nob3J0IChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXNNaW4gKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicpO1xuICAgIH1cblxuICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUpO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUpO1xuXG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2Fic19fYWJzICgpIHtcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKGlucHV0LCB2YWx1ZSk7XG5cbiAgICAgICAgZHVyYXRpb24uX21pbGxpc2Vjb25kcyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbWlsbGlzZWNvbmRzO1xuICAgICAgICBkdXJhdGlvbi5fZGF5cyAgICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgICAgICBkdXJhdGlvbi5fbW9udGhzICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGQgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIHN1YnRyYWN0KDEsICdzJykgb3Igc3VidHJhY3QoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19zdWJ0cmFjdCAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0NlaWwgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSB0aGlzLl9kYXlzO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gdGhpcy5fbW9udGhzO1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgID0gdGhpcy5fZGF0YTtcbiAgICAgICAgdmFyIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycywgbW9udGhzRnJvbURheXM7XG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxuICAgICAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcbiAgICAgICAgaWYgKCEoKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKSkpIHtcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgbW9udGhzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICAgICAgc2Vjb25kcyAgICAgICAgICAgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgPSBzZWNvbmRzICUgNjA7XG5cbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgID0gaG91cnMgJSAyNDtcblxuICAgICAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICAgICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgICAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgZGF0YS5kYXlzICAgPSBkYXlzO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICAgICAgZGF0YS55ZWFycyAgPSB5ZWFycztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzVG9Nb250aHMgKGRheXMpIHtcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcbiAgICAgICAgcmV0dXJuIGRheXMgKiA0ODAwIC8gMTQ2MDk3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1RvRGF5cyAobW9udGhzKSB7XG4gICAgICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgICAgICByZXR1cm4gbW9udGhzICogMTQ2MDk3IC8gNDgwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcyAodW5pdHMpIHtcbiAgICAgICAgdmFyIGRheXM7XG4gICAgICAgIHZhciBtb250aHM7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIGRheXMgICA9IHRoaXMuX2RheXMgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICAgICAgcmV0dXJuIHVuaXRzID09PSAnbW9udGgnID8gbW9udGhzIDogbW9udGhzIC8gMTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnICAgOiByZXR1cm4gZGF5cyAvIDcgICAgICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RheScgICAgOiByZXR1cm4gZGF5cyAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZScgOiByZXR1cm4gZGF5cyAqIDE0NDAgICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCcgOiByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FzX192YWx1ZU9mICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzIChhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKTtcbiAgICB2YXIgYXNTZWNvbmRzICAgICAgPSBtYWtlQXMoJ3MnKTtcbiAgICB2YXIgYXNNaW51dGVzICAgICAgPSBtYWtlQXMoJ20nKTtcbiAgICB2YXIgYXNIb3VycyAgICAgICAgPSBtYWtlQXMoJ2gnKTtcbiAgICB2YXIgYXNEYXlzICAgICAgICAgPSBtYWtlQXMoJ2QnKTtcbiAgICB2YXIgYXNXZWVrcyAgICAgICAgPSBtYWtlQXMoJ3cnKTtcbiAgICB2YXIgYXNNb250aHMgICAgICAgPSBtYWtlQXMoJ00nKTtcbiAgICB2YXIgYXNZZWFycyAgICAgICAgPSBtYWtlQXMoJ3knKTtcblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2dldF9fZ2V0ICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHMgKyAncyddKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtuYW1lXTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XG4gICAgdmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbiAgICB2YXIgbWludXRlcyAgICAgID0gbWFrZUdldHRlcignbWludXRlcycpO1xuICAgIHZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xuICAgIHZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IG1ha2VHZXR0ZXIoJ21vbnRocycpO1xuICAgIHZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHZhciB0aHJlc2hvbGRzID0ge1xuICAgICAgICBzOiA0NSwgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgIG06IDQ1LCAgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgIGg6IDIyLCAgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgIGQ6IDI2LCAgLy8gZGF5cyB0byBtb250aFxuICAgICAgICBNOiAxMSAgIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG4gICAgZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX3JlbGF0aXZlVGltZSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKTtcbiAgICAgICAgdmFyIHNlY29uZHMgID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSk7XG4gICAgICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgICAgICB2YXIgaG91cnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKTtcbiAgICAgICAgdmFyIGRheXMgICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSk7XG4gICAgICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgICAgICB2YXIgeWVhcnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygneScpKTtcblxuICAgICAgICB2YXIgYSA9IHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8PSAxICAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPD0gMSAgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAmJiBbJ2hoJywgaG91cnNdICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPCB0aHJlc2hvbGRzLmQgJiYgWydkZCcsIGRheXNdICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8PSAxICAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICYmIFsnTU0nLCBtb250aHNdICB8fFxuICAgICAgICAgICAgICAgIHllYXJzICAgPD0gMSAgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyAocm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZihyb3VuZGluZ0Z1bmN0aW9uKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IGR1cmF0aW9uX2h1bWFuaXplX19yZWxhdGl2ZVRpbWUodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGlzb19zdHJpbmdfX2FicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gaXNvX3N0cmluZ19fdG9JU09TdHJpbmcoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICB2YXIgc2Vjb25kcyA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9tb250aHMpO1xuICAgICAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgbWludXRlcyAlPSA2MDtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgdmFyIFkgPSB5ZWFycztcbiAgICAgICAgdmFyIE0gPSBtb250aHM7XG4gICAgICAgIHZhciBEID0gZGF5cztcbiAgICAgICAgdmFyIGggPSBob3VycztcbiAgICAgICAgdmFyIG0gPSBtaW51dGVzO1xuICAgICAgICB2YXIgcyA9IHNlY29uZHM7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICh0b3RhbCA8IDAgPyAnLScgOiAnJykgK1xuICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgIChZID8gWSArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAoTSA/IE0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKEQgPyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChoID8gaCArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobSA/IG0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHMgPyBzICsgJ1MnIDogJycpO1xuICAgIH1cblxuICAgIHZhciBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hYnMgICAgICAgICAgICA9IGR1cmF0aW9uX2Fic19fYWJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYWRkICAgICAgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnN1YnRyYWN0ICAgICAgID0gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19zdWJ0cmFjdDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzICAgICAgICAgICAgID0gYXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICAgID0gZHVyYXRpb25fYXNfX3ZhbHVlT2Y7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmdldCAgICAgICAgICAgID0gZHVyYXRpb25fZ2V0X19nZXQ7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmhvdXJzICAgICAgICAgID0gaG91cnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5kYXlzICAgICAgICAgICA9IGRheXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubW9udGhzICAgICAgICAgPSBtb250aHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by55ZWFycyAgICAgICAgICA9IHllYXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSVNPU3RyaW5nICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b1N0cmluZyAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9KU09OICAgICAgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG4gICAgLy8gRGVwcmVjYXRpb25zXG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCBpc29fc3RyaW5nX190b0lTT1N0cmluZyk7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sYW5nID0gbGFuZztcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG4gICAgYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy52ZXJzaW9uID0gJzIuMTQuMSc7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2sobG9jYWxfX2NyZWF0ZUxvY2FsKTtcblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5mbiAgICAgICAgICAgICAgICAgICAgPSBtb21lbnRQcm90b3R5cGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcbiAgICB1dGlsc19ob29rc19faG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQztcbiAgICB1dGlsc19ob29rc19faG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gbW9tZW50X19jcmVhdGVVbml4O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tb250aHMgICAgICAgICAgICAgICAgPSBsaXN0c19fbGlzdE1vbnRocztcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pbnZhbGlkICAgICAgICAgICAgICAgPSB2YWxpZF9fY3JlYXRlSW52YWxpZDtcbiAgICB1dGlsc19ob29rc19faG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbjtcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzICAgICAgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IG1vbWVudF9fY3JlYXRlSW5ab25lO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc0R1cmF0aW9uICAgICAgICAgICAgPSBpc0R1cmF0aW9uO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0c19fbGlzdE1vbnRoc1Nob3J0O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzTWluO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZWZpbmVMb2NhbGUgICAgICAgICAgPSBkZWZpbmVMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZUxvY2FsZSAgICAgICAgICA9IHVwZGF0ZUxvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubG9jYWxlcyAgICAgICAgICAgICAgID0gbG9jYWxlX2xvY2FsZXNfX2xpc3RMb2NhbGVzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyA9IGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbiAgICB1dGlsc19ob29rc19faG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbiAgICB1dGlsc19ob29rc19faG9va3MuY2FsZW5kYXJGb3JtYXQgICAgICAgID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnByb3RvdHlwZSAgICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZTtcblxuICAgIHZhciBfbW9tZW50ID0gdXRpbHNfaG9va3NfX2hvb2tzO1xuXG4gICAgcmV0dXJuIF9tb21lbnQ7XG5cbn0pKTsiLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgR3JhcGggPSByZXF1aXJlKCcuLi9wcm9qZWN0aW9uL0dyYXBoJyk7XG5cbiAgICBMLkNSUy5HcmFwaCA9IEwuZXh0ZW5kKHt9LCBMLkNSUywge1xuXG4gICAgICAgIHByb2plY3Rpb246IEdyYXBoLFxuXG4gICAgICAgIHRyYW5zZm9ybWF0aW9uOiBuZXcgTC5UcmFuc2Zvcm1hdGlvbigxLCAwLCAxLCAwKSxcblxuICAgICAgICBpbmZpbml0ZTogZmFsc2UsXG5cbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uKHpvb20pIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdygyLCB6b29tKTtcbiAgICAgICAgfSxcblxuICAgICAgICB6b29tOiBmdW5jdGlvbihzY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3RhbmNlOiBmdW5jdGlvbihsYXRsbmcxLCBsYXRsbmcyKSB7XG4gICAgICAgICAgICBsZXQgZHggPSBsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nO1xuICAgICAgICAgICAgbGV0IGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEwuQ1JTLkdyYXBoO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIEdyYXBoOiByZXF1aXJlKCcuL0dyYXBoJylcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIE1hcDogcmVxdWlyZSgnLi9tYXAvTWFwJyksXG4gICAgICAgIFByb2plY3Rpb246IHJlcXVpcmUoJy4vcHJvamVjdGlvbi9leHBvcnRzJyksXG4gICAgICAgIENSUzogcmVxdWlyZSgnLi9DUlMvZXhwb3J0cycpLFxuICAgICAgICBUaWxlTGF5ZXI6IHJlcXVpcmUoJy4vbGF5ZXIvZXhwb3J0cycpLFxuICAgICAgICBSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlci9leHBvcnRzJyksXG4gICAgICAgIFRpbGVSZXF1ZXN0b3I6IHJlcXVpcmUoJy4vcmVxdWVzdC9UaWxlUmVxdWVzdG9yJyksXG4gICAgICAgIE1ldGFSZXF1ZXN0b3I6IHJlcXVpcmUoJy4vcmVxdWVzdC9NZXRhUmVxdWVzdG9yJyksXG4gICAgICAgIENvbG9yUmFtcDoge1xuICAgICAgICAgICAgLy8gZXhwb3NlIGFzIHN0YXRpYyBtZXRob2RcbiAgICAgICAgICAgIGdldENvbG9yUmFtcDogcmVxdWlyZSgnLi9yZW5kZXJlci9taXhpbi9Db2xvclJhbXAnKS5nZXRDb2xvclJhbXBcbiAgICAgICAgfVxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgc2V0RGF0ZUhpc3RvZ3JhbSA9IGZ1bmN0aW9uKGZpZWxkLCBmcm9tLCB0bywgaW50ZXJ2YWwpIHtcbiAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgJ0RhdGVIaXN0b2dyYW0gYGZpZWxkYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93ICdEYXRlSGlzdG9ncmFtIGBmcm9tYCBhcmUgbWlzc2luZyBmcm9tIGFyZ3VtZW50JztcbiAgICAgICAgfVxuICAgICAgICBpZiAodG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgJ0RhdGVIaXN0b2dyYW0gYHRvYCBhcmUgbWlzc2luZyBmcm9tIGFyZ3VtZW50JztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXJhbXMuZGF0ZV9oaXN0b2dyYW0gPSB7XG4gICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgdG86IHRvLFxuICAgICAgICAgICAgaW50ZXJ2YWw6IGludGVydmFsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xlYXJFeHRyZW1hKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBsZXQgZ2V0RGF0ZUhpc3RvZ3JhbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zLmRhdGVfaGlzdG9ncmFtO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgc2V0RGF0ZUhpc3RvZ3JhbTogc2V0RGF0ZUhpc3RvZ3JhbSxcbiAgICAgICAgZ2V0RGF0ZUhpc3RvZ3JhbTogZ2V0RGF0ZUhpc3RvZ3JhbVxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAoIW1ldGEuZXh0cmVtYSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdIaXN0b2dyYW0gYGZpZWxkYCAnICsgZmllbGQgKyAnIGlzIG5vdCBvcmRpbmFsIGluIG1ldGEgZGF0YSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnSGlzdG9ncmFtIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGxldCBzZXRIaXN0b2dyYW0gPSBmdW5jdGlvbihmaWVsZCwgaW50ZXJ2YWwpIHtcbiAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgJ0hpc3RvZ3JhbSBgZmllbGRgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhyb3cgJ0hpc3RvZ3JhbSBgaW50ZXJ2YWxgIGFyZSBtaXNzaW5nIGZyb20gYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRmllbGQodGhpcy5fbWV0YVtmaWVsZF0sIGZpZWxkKTtcbiAgICAgICAgdGhpcy5fcGFyYW1zLmhpc3RvZ3JhbSA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgIGludGVydmFsOiBpbnRlcnZhbFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsZWFyRXh0cmVtYSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgbGV0IGdldEhpc3RvZ3JhbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zLmhpc3RvZ3JhbTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHNldEhpc3RvZ3JhbTogc2V0SGlzdG9ncmFtLFxuICAgICAgICBnZXRIaXN0b2dyYW06IGdldEhpc3RvZ3JhbVxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgTUVUUklDUyA9IHtcbiAgICAgICAgJ21pbic6IHRydWUsXG4gICAgICAgICdtYXgnOiB0cnVlLFxuICAgICAgICAnc3VtJzogdHJ1ZSxcbiAgICAgICAgJ2F2Zyc6IHRydWVcbiAgICB9O1xuXG4gICAgbGV0IGNoZWNrRmllbGQgPSBmdW5jdGlvbihtZXRhLCBmaWVsZCkge1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgaWYgKCFtZXRhLmV4dHJlbWEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnTWV0cml4IGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3Qgb3JkaW5hbCBpbiBtZXRhIGRhdGEnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ01ldHJpYyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IHJlY29nbml6ZWQgaW4gbWV0YSBkYXRhJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgc2V0TWV0cmljID0gZnVuY3Rpb24oZmllbGQsIHR5cGUpIHtcbiAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgJ01ldHJpYyBgZmllbGRgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyAnTWV0cmljIGB0eXBlYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRmllbGQodGhpcy5fbWV0YVtmaWVsZF0sIGZpZWxkKTtcbiAgICAgICAgaWYgKCFNRVRSSUNTW3R5cGVdKSB7XG4gICAgICAgICAgICB0aHJvdyAnTWV0cmljIHR5cGUgYCcgKyB0eXBlICsgJ2AgaXMgbm90IHN1cHBvcnRlZCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFyYW1zLm1ldHJpYyA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGxldCBnZXRNZXRyaWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcy5tZXRyaWM7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvLyB0aWxpbmdcbiAgICAgICAgc2V0TWV0cmljOiBzZXRNZXRyaWMsXG4gICAgICAgIGdldE1ldHJpYzogZ2V0TWV0cmljLFxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAobWV0YS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93ICdUZXJtcyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IG9mIHR5cGUgYHN0cmluZ2AgaW4gbWV0YSBkYXRhJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93ICdUZXJtcyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IHJlY29nbml6ZWQgaW4gbWV0YSBkYXRhJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgc2V0VGVybXMgPSBmdW5jdGlvbihmaWVsZCwgc2l6ZSkge1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyAnVGVybXMgYGZpZWxkYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRmllbGQodGhpcy5fbWV0YVtmaWVsZF0sIGZpZWxkKTtcbiAgICAgICAgdGhpcy5fcGFyYW1zLnRlcm1zID0ge1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsZWFyRXh0cmVtYSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgbGV0IGdldFRlcm1zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbXMudGVybXM7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBzZXRUZXJtczogc2V0VGVybXMsXG4gICAgICAgIGdldFRlcm1zOiBnZXRUZXJtc1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAobWV0YS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93ICdUZXJtcyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IG9mIHR5cGUgYHN0cmluZ2AgaW4gbWV0YSBkYXRhJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93ICdUZXJtcyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IHJlY29nbml6ZWQgaW4gbWV0YSBkYXRhJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgc2V0VGVybXNGaWx0ZXIgPSBmdW5jdGlvbihmaWVsZCwgdGVybXMpIHtcbiAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgJ1Rlcm1zIGBmaWVsZGAgaXMgbWlzc2luZyBmcm9tIGFyZ3VtZW50JztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVybXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgJ1Rlcm1zIGB0ZXJtc2AgYXJlIG1pc3NpbmcgZnJvbSBhcmd1bWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tGaWVsZCh0aGlzLl9tZXRhW2ZpZWxkXSwgZmllbGQpO1xuICAgICAgICB0aGlzLl9wYXJhbXMudGVybXNfZmlsdGVyID0ge1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgdGVybXM6IHRlcm1zXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xlYXJFeHRyZW1hKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBsZXQgZ2V0VGVybXNGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcy50ZXJtc19maWx0ZXI7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBzZXRUZXJtc0ZpbHRlcjogc2V0VGVybXNGaWx0ZXIsXG4gICAgICAgIGdldFRlcm1zRmlsdGVyOiBnZXRUZXJtc0ZpbHRlclxuICAgIH07XG5cbn0oKSk7XG4iLCIvLyBQcm92aWRlcyB0b3AgaGl0cyBxdWVyeSBmdW5jdGlvbmFsaXR5LiAnc2l6ZScgaW5kaWNhdGVzIHRoZSBudW1iZXIgb2YgdG9wXG4vLyBoaXRzIHRvIHJldHVybiwgJ2luY2x1ZGUnIGlzIHRoZSBsaXN0IG9mIGZpZWxkcyB0byBpbmNsdWRlIGluIHRoZSByZXR1cm5lZFxuLy8gZGF0YSwgJ3NvcnQnIGlzIHRoZSBmaWVsZCB0byB1c2UgZm9yIHNvcnQgY3JpdGVyYSwgYW5kICdvcmRlcicgaXMgdmFsdWUgb2Zcbi8vICdhc2MnIG9yICdkZXNjJyB0byBpbmRpY2F0ZSBzb3J0IG9yZGVyaW5nLlxuKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IGNoZWNrRmllbGQgPSBmdW5jdGlvbihtZXRhLCBmaWVsZCkge1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgaWYgKCFtZXRhLmV4dHJlbWEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnUmFuZ2UgYGZpZWxkYCAnICsgZmllbGQgKyAnIGlzIG5vdCBvcmRpbmFsIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ1RvcFRlcm1zIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGxldCBzZXRUb3BIaXRzID0gZnVuY3Rpb24oc2l6ZSwgaW5jbHVkZSwgc29ydCwgb3JkZXIpIHtcbiAgICAgICAgaWYgKHNvcnQpIHtcbiAgICAgICAgICAgIGNoZWNrRmllbGQodGhpcy5fbWV0YVtzb3J0XSwgc29ydCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFyYW1zLnRvcF9oaXRzID0ge1xuICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgIGluY2x1ZGU6IGluY2x1ZGUsXG4gICAgICAgICAgICBzb3J0OiBzb3J0LFxuICAgICAgICAgICAgb3JkZXI6IG9yZGVyXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xlYXJFeHRyZW1hKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBsZXQgZ2V0VG9wSGl0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zLnRvcF9oaXRzO1xuICAgIH07XG5cbiAgICAvLyBiaW5kIHBvaW50IGZvciBleHRlcm5hbCBjb250cm9sc1xuICAgIGxldCBzZXRTb3J0RmllbGQgPSBmdW5jdGlvbihzb3J0KSB7XG4gICAgICAgIGlmICghc29ydCkge1xuICAgICAgICAgICAgdGhyb3cgJ1RvcEhpdHMgYHNvcnRgIGFyZ3VtZW50IGlzIG1pc3NpbmcnO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRmllbGQodGhpcy5fbWV0YVtzb3J0XSwgc29ydCk7XG4gICAgICAgIGlmIChzb3J0ICE9PSB0aGlzLl9wYXJhbXMudG9wX2hpdHMuc29ydCkge1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1zLnRvcF9oaXRzLnNvcnQgPSBzb3J0O1xuICAgICAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLy8gYmluZCBwb2ludCBmb3IgZXh0ZXJuYWwgY29udHJvbHNcbiAgICBsZXQgZ2V0U29ydEZpZWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbXMudG9wX2hpdHMuc29ydDtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHNldFRvcEhpdHM6IHNldFRvcEhpdHMsXG4gICAgICAgIGdldFRvcEhpdHM6IGdldFRvcEhpdHMsXG4gICAgICAgIHNldFNvcnRGaWVsZDogc2V0U29ydEZpZWxkLFxuICAgICAgICBnZXRTb3J0RmllbGQ6IGdldFNvcnRGaWVsZFxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAobWV0YS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93ICdUb3BUZXJtcyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IG9mIHR5cGUgYHN0cmluZ2AgaW4gbWV0YSBkYXRhJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93ICdUb3BUZXJtcyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IHJlY29nbml6ZWQgaW4gbWV0YSBkYXRhJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgc2V0VG9wVGVybXMgPSBmdW5jdGlvbihmaWVsZCwgc2l6ZSkge1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyAnVG9wVGVybXMgYGZpZWxkYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRmllbGQodGhpcy5fbWV0YVtmaWVsZF0sIGZpZWxkKTtcbiAgICAgICAgdGhpcy5fcGFyYW1zLnRvcF90ZXJtcyA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGxldCBnZXRUb3BUZXJtcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zLnRvcF90ZXJtcztcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHNldFRvcFRlcm1zOiBzZXRUb3BUZXJtcyxcbiAgICAgICAgZ2V0VG9wVGVybXM6IGdldFRvcFRlcm1zXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIG1vZChuLCBtKSB7XG4gICAgICAgIHJldHVybiAoKG4gJSBtKSArIG0pICUgbTtcbiAgICB9XG5cbiAgICBsZXQgQmFzZSA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgdG1zOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldE9wYWNpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5vcGFjaXR5O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5faGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9wcmV2TWFwLmFkZExheWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5faGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZNYXAgPSB0aGlzLl9tYXA7XG4gICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNIaWRkZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hpZGRlbjtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRCcmlnaHRuZXNzOiBmdW5jdGlvbihicmlnaHRuZXNzKSB7XG4gICAgICAgICAgICB0aGlzLl9icmlnaHRuZXNzID0gYnJpZ2h0bmVzcztcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5jc3MoJy13ZWJraXQtZmlsdGVyJywgJ2JyaWdodG5lc3MoJyArICh0aGlzLl9icmlnaHRuZXNzICogMTAwKSArICclKScpO1xuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLmNzcygnZmlsdGVyJywgJ2JyaWdodG5lc3MoJyArICh0aGlzLl9icmlnaHRuZXNzICogMTAwKSArICclKScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJyaWdodG5lc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9icmlnaHRuZXNzICE9PSB1bmRlZmluZWQpID8gdGhpcy5fYnJpZ2h0bmVzcyA6IDE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNUYXJnZXRMYXllcjogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jb250YWluZXIgPT09IGVsZW0gfHwgJC5jb250YWlucyh0aGlzLl9jb250YWluZXIsIGVsZW0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRMYXllclBvaW50RnJvbUxvbkxhdDogZnVuY3Rpb24obG9ubGF0UG9pbnQsIHpvb20pIHtcbiAgICAgICAgICAgIHpvb20gPSAoem9vbSAhPT0gdW5kZWZpbmVkKSA/IHpvb20gOiB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgbGV0IHBpeGVsID0gdGhpcy5fbWFwLnByb2plY3QobG9ubGF0UG9pbnQsIHpvb20pO1xuICAgICAgICAgICAgbGV0IHBvdyA9IE1hdGgucG93KDIsIHpvb20pO1xuICAgICAgICAgICAgbGV0IHRpbGVTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBtb2QocGl4ZWwueCwgcG93ICogdGlsZVNpemUpLFxuICAgICAgICAgICAgICAgIHk6IG1vZChwaXhlbC55LCBwb3cgKiB0aWxlU2l6ZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGF5ZXJQb2ludEZyb21FdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbGV0IGxvbmxhdCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXRMbmcoZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TGF5ZXJQb2ludEZyb21Mb25MYXQobG9ubGF0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRUaWxlQ29vcmRGcm9tTGF5ZXJQb2ludDogZnVuY3Rpb24obGF5ZXJQb2ludCkge1xuICAgICAgICAgICAgbGV0IHRpbGVTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBNYXRoLmZsb29yKGxheWVyUG9pbnQueCAvIHRpbGVTaXplKSxcbiAgICAgICAgICAgICAgICB5OiBNYXRoLmZsb29yKGxheWVyUG9pbnQueSAvIHRpbGVTaXplKSxcbiAgICAgICAgICAgICAgICB6OiB0aGlzLl9tYXAuZ2V0Wm9vbSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJpbkNvb3JkRnJvbUxheWVyUG9pbnQ6IGZ1bmN0aW9uKGxheWVyUG9pbnQsIHJlcykge1xuICAgICAgICAgICAgbGV0IHRpbGVTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuICAgICAgICAgICAgbGV0IHJlc29sdXRpb24gPSByZXMgfHwgdGhpcy5nZXRSZXNvbHV0aW9uKCkgfHwgdGlsZVNpemU7XG4gICAgICAgICAgICBsZXQgdHggPSBtb2QobGF5ZXJQb2ludC54LCB0aWxlU2l6ZSk7XG4gICAgICAgICAgICBsZXQgeSA9IHRoaXMub3B0aW9ucy50bXMgPyByZXNvbHV0aW9uIC0gbGF5ZXJQb2ludC55IDogbGF5ZXJQb2ludC55O1xuICAgICAgICAgICAgbGV0IHR5ID0gbW9kKHksIHRpbGVTaXplKTtcbiAgICAgICAgICAgIGxldCBwaXhlbFNpemUgPSB0aWxlU2l6ZSAvIHJlc29sdXRpb247XG4gICAgICAgICAgICBsZXQgYnggPSBNYXRoLmZsb29yKHR4IC8gcGl4ZWxTaXplKTtcbiAgICAgICAgICAgIGxldCBieSA9IE1hdGguZmxvb3IodHkgLyBwaXhlbFNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBieCxcbiAgICAgICAgICAgICAgICB5OiBieSxcbiAgICAgICAgICAgICAgICBpbmRleDogYnggKyAoYnkgKiByZXNvbHV0aW9uKSxcbiAgICAgICAgICAgICAgICBzaXplOiBwaXhlbFNpemVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FkZFRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgY29udGFpbmVyKSB7XG4gICAgICAgICAgICBsZXQgdGlsZVBvcyA9IHRoaXMuX2dldFRpbGVQb3MoY29vcmRzKTtcbiAgICAgICAgICAgIGxldCBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIHNvIHRoYXQgd2UgZG9uJ3QgcGFzcyBpbiB3cmFwcGVkIGNvb3JkcyBoZXJlXG4gICAgICAgICAgICBsZXQgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZShjb29yZHMsIEwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcykpO1xuICAgICAgICAgICAgdGhpcy5faW5pdFRpbGUodGlsZSk7XG4gICAgICAgICAgICAvLyBpZiBjcmVhdGVUaWxlIGlzIGRlZmluZWQgd2l0aCBhIHNlY29uZCBhcmd1bWVudCAoXCJkb25lXCIgY2FsbGJhY2spLFxuICAgICAgICAgICAgLy8gd2Uga25vdyB0aGF0IHRpbGUgaXMgYXN5bmMgYW5kIHdpbGwgYmUgcmVhZHkgbGF0ZXI7IG90aGVyd2lzZVxuICAgICAgICAgICAgaWYgKHRoaXMuY3JlYXRlVGlsZS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFyayB0aWxlIGFzIHJlYWR5LCBidXQgZGVsYXkgb25lIGZyYW1lIGZvciBvcGFjaXR5IGFuaW1hdGlvbiB0byBoYXBwZW5cbiAgICAgICAgICAgICAgICBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShMLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMsIG51bGwsIHRpbGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zKTtcbiAgICAgICAgICAgIC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuICAgICAgICAgICAgdGhpcy5fdGlsZXNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBlbDogdGlsZSxcbiAgICAgICAgICAgICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50OiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRpbGUpO1xuICAgICAgICAgICAgLy8gQGV2ZW50IHRpbGVsb2Fkc3RhcnQ6IFRpbGVFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVxdWVzdGVkIGFuZCBzdGFydHMgbG9hZGluZy5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZWxvYWRzdGFydCcsIHtcbiAgICAgICAgICAgICAgICB0aWxlOiB0aWxlLFxuICAgICAgICAgICAgICAgIGNvb3JkczogY29vcmRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gdmFsaWRUb0NvcHkoZnVuY05hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmNOYW1lICE9PSAnY29uc3RydWN0b3InICYmXG4gICAgICAgICAgICBmdW5jTmFtZSAhPT0gJ29uJyAmJlxuICAgICAgICAgICAgZnVuY05hbWUgIT09ICdvZmYnICYmXG4gICAgICAgICAgICBmdW5jTmFtZSAhPT0gJ3NldFF1ZXJ5JyAmJlxuICAgICAgICAgICAgZnVuY05hbWUgIT09ICdjbGVhclF1ZXJ5JyAmJlxuICAgICAgICAgICAgZnVuY05hbWVbMF0gIT09ICdfJztcbiAgICB9XG5cbiAgICBsZXQgQ29tcG9zaXRlID0gTC5DbGFzcy5leHRlbmQoe1xuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGxheWVycyA9IFtdKSB7XG4gICAgICAgICAgICBsZXQgZnVuY3Rpb25zID0ge307XG4gICAgICAgICAgICAvLyBnZXQgYSBsaXN0IG9mIGFsbCBmdW5jdGlvbnMgZm9yIGVhY2ggbGF5ZXJcbiAgICAgICAgICAgIGxheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgICAgICAgICAgICBfLmZvckluKGxheWVyLCAodmFsLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih2YWwpICYmIHZhbGlkVG9Db3B5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uc1trZXldID0gZnVuY3Rpb25zW2tleV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbnNba2V5XS5wdXNoKGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBzZXQgcHJvcGVydGllc1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzID0gbGF5ZXJzO1xuICAgICAgICAgICAgdGhpcy5fZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXJ5ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIGV4dGVuZCB0aGlzIGNvbXBvc2l0ZSBjbGFzcyBmb3IgZWFjaCBmdW5jdGlvblxuICAgICAgICAgICAgXy5mb3JJbihmdW5jdGlvbnMsIChsYXllcnMsIGZ1bmMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9leHRlbmQoZnVuYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbjogZnVuY3Rpb24oZXZ0LCBmdW5jKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICAgICAgICAgICAgbGF5ZXIub24oZXZ0LCBmdW5jKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZ0XSA9IHRoaXMuX2hhbmRsZXJzW2V2dF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldnRdLnB1c2goZnVuYyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb2ZmOiBmdW5jdGlvbihldnQsIGZ1bmMpIHtcbiAgICAgICAgICAgIGxldCBoYW5kbGVycyA9IHRoaXMuX2hhbmRsZXJzW2V2dF07XG4gICAgICAgICAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBoYW5kbGVycy5pbmRleE9mKGZ1bmMpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLm9mZihldnQsIGZ1bmMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hhbmRsZXJzW2V2dF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0UXVlcnk6IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuc2V0UXVlcnkocXVlcnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyUXVlcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuY2xlYXJRdWVyeSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXJ5ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZXh0ZW5kOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICBsZXQgZnVuY3Rpb25zID0gdGhpcy5fZnVuY3Rpb25zO1xuICAgICAgICAgICAgdGhpc1tmdW5jXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGxldCBsYXllcnMgPSBmdW5jdGlvbnNbZnVuY107XG4gICAgICAgICAgICAgICAgbGV0IGxheWVyLCBpO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8bGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBsYXllcltmdW5jXS5hcHBseShsYXllciwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdCAhPT0gbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFN1YkxheWVyOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmdW5jdGlvbnMgPSB0aGlzLl9mdW5jdGlvbnM7XG4gICAgICAgICAgICBfLmZvckluKGxheWVyLCAodmFsLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhIGZ1bmN0aW9uIGFuZCB2YWxpZCB0byBjb3B5XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih2YWwpICYmIHZhbGlkVG9Db3B5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGxheWVyIHRvIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbnNba2V5XSA9IGZ1bmN0aW9uc1trZXldIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbnNba2V5XS5wdXNoKGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uc1trZXldLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYSBuZXcgZnVuY3Rpb24sIGV4dGVuZCB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHRlbmQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gYWRkIHRvIGxheWVyc1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgICAgICAgLy8gYWRkIGhhbmRsZXJzIHRvIGxheWVyXG4gICAgICAgICAgICBfLmZvckluKHRoaXMuX2hhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVycywgZXZ0KSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLm9uKGV2dCwgZnVuYyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9xdWVyeSkge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBxdWVyeSB0byBsYXllclxuICAgICAgICAgICAgICAgIGxheWVyLnNldFF1ZXJ5KHRoaXMuX3F1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVTdWJMYXllcjogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMuX2xheWVycy5pbmRleE9mKGxheWVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZnVuY3Rpb25zID0gdGhpcy5fZnVuY3Rpb25zO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBmdW5jdGlvbnMgdXNlZCBleGNsdXNpdmVseSBieSB0aGlzIGxheWVyXG4gICAgICAgICAgICBfLmZvckluKGxheWVyLCAodmFsLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbCkgJiYgdmFsaWRUb0NvcHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBmdW5jdGlvbnNba2V5XS5pbmRleE9mKGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gZnVuY3Rpb24gbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zW2tleV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBleGNsdXNpdmUgb3duZXIgb2YgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uc1trZXldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gbW9yZSB1c2UgZm9yIHRoaXMgZnVuY3Rpb24sIHJlbW92ZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZ1bmN0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGxheWVyXG4gICAgICAgICAgICB0aGlzLl9sYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBoYW5kbGVycyBmcm9tIGxheWVyXG4gICAgICAgICAgICBfLmZvckluKHRoaXMuX2hhbmRsZXJzLCAoaGFuZGxlcnMsIGV2dCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuYyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLm9mZihldnQsIGZ1bmMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBjbGVhciB0aGUgcXVlcnkgZnJvbSB0aGUgbGF5ZXJcbiAgICAgICAgICAgIGxheWVyLmNsZWFyUXVlcnkoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb21wb3NpdGU7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgQmFzZSA9IHJlcXVpcmUoJy4vQmFzZScpO1xuXG4gICAgbGV0IERlYnVnID0gQmFzZS5leHRlbmQoe1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHVubG9hZEludmlzaWJsZVRpbGVzOiB0cnVlLFxuICAgICAgICAgICAgekluZGV4OiA1MDAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgLy8gc2V0IHJlbmRlcmVyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucmVuZGVyZXJDbGFzcykge1xuICAgICAgICAgICAgICAgIHRocm93ICdObyBgcmVuZGVyZXJDbGFzc2Agb3B0aW9uIGZvdW5kLic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGV4dGVuZFxuICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIHRoaXMsIG9wdGlvbnMucmVuZGVyZXJDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgb3B0aW9uc1xuICAgICAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSA8ZGl2PiBlbGVtZW50IGZvciBkcmF3aW5nXG4gICAgICAgICAgICBsZXQgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXRpbGUnKTtcbiAgICAgICAgICAgIC8vIGRyYXcgdG8gaXRcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZSh0aWxlLCBjb29yZCk7XG4gICAgICAgICAgICAvLyBwYXNzIHRpbGUgdG8gY2FsbGJhY2tcbiAgICAgICAgICAgIHJldHVybiB0aWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IERlYnVnO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IEltYWdlID0gTC5UaWxlTGF5ZXIuZXh0ZW5kKHtcblxuICAgICAgICBnZXRPcGFjaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMub3BhY2l0eTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fcHJldk1hcC5hZGRMYXllcih0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9wcmV2TWFwID0gdGhpcy5fbWFwO1xuICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzSGlkZGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oaWRkZW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0QnJpZ2h0bmVzczogZnVuY3Rpb24oYnJpZ2h0bmVzcykge1xuICAgICAgICAgICAgdGhpcy5fYnJpZ2h0bmVzcyA9IGJyaWdodG5lc3M7XG4gICAgICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikuY3NzKCctd2Via2l0LWZpbHRlcicsICdicmlnaHRuZXNzKCcgKyAodGhpcy5fYnJpZ2h0bmVzcyAqIDEwMCkgKyAnJSknKTtcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5jc3MoJ2ZpbHRlcicsICdicmlnaHRuZXNzKCcgKyAodGhpcy5fYnJpZ2h0bmVzcyAqIDEwMCkgKyAnJSknKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCcmlnaHRuZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fYnJpZ2h0bmVzcyAhPT0gdW5kZWZpbmVkKSA/IHRoaXMuX2JyaWdodG5lc3MgOiAxO1xuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBJbWFnZTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBib29sUXVlcnlDaGVjayA9IHJlcXVpcmUoJy4uL3F1ZXJ5L0Jvb2wnKTtcblxuICAgIGZ1bmN0aW9uIG1vZChuLCBtKSB7XG4gICAgICAgIHJldHVybiAoKG4gJSBtKSArIG0pICUgbTtcbiAgICB9XG5cbiAgICBsZXQgTGl2ZSA9IEwuQ2xhc3MuZXh0ZW5kKHtcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHZhbCA9PiB7IHJldHVybiB2YWw7IH1cbiAgICAgICAgfSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbihtZXRhLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIC8vIHNldCByZW5kZXJlclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVuZGVyZXJDbGFzcykge1xuICAgICAgICAgICAgICAgIGxldCByZW5kZXJlcjtcbiAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSBleHRlbmQgYW5kIGluaXRpYWxpemVcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yZW5kZXJlckNsYXNzLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlciA9IG5ldyBvcHRpb25zLnJlbmRlcmVyQ2xhc3MoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlciA9IG9wdGlvbnMucmVuZGVyZXJDbGFzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXh0ZW5kIHRoaXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgdGhpcywgcmVuZGVyZXIpO1xuICAgICAgICAgICAgICAgIC8vIGNvcHkgcHJvdG90eXBlIG9wdGlvbnMgcHJvcGVydHkgYnkgdmFsdWUsIHRoaXMgaXMgaW1wb3J0YW50XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMucmVuZGVyZXJDbGFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBvcHRpb25zXG4gICAgICAgICAgICBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBzZXQgbWV0YVxuICAgICAgICAgICAgdGhpcy5fbWV0YSA9IG1ldGE7XG4gICAgICAgICAgICAvLyBzZXQgcGFyYW1zXG4gICAgICAgICAgICB0aGlzLl9wYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgYmlubmluZzoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBzZXQgZXh0cmVtYSAvIGNhY2hlXG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhckV4dHJlbWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fZXh0cmVtYSA9IHtcbiAgICAgICAgICAgICAgICBtaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICAgICAgbWF4OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEV4dHJlbWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4dHJlbWE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlRXh0cmVtYTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgbGV0IGV4dHJlbWEgPSB0aGlzLmV4dHJhY3RFeHRyZW1hKGRhdGEpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChleHRyZW1hLm1pbiA8IHRoaXMuX2V4dHJlbWEubWluKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXh0cmVtYS5taW4gPSBleHRyZW1hLm1pbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyZW1hLm1heCA+IHRoaXMuX2V4dHJlbWEubWF4KSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXh0cmVtYS5tYXggPSBleHRyZW1hLm1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV4dHJhY3RFeHRyZW1hOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1pbjogXy5taW4oZGF0YSksXG4gICAgICAgICAgICAgICAgbWF4OiBfLm1heChkYXRhKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRRdWVyeTogZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICAgIGlmICghcXVlcnkubXVzdCAmJiAhcXVlcnkubXVzdF9ub3QgJiYgIXF1ZXJ5LnNob3VsZCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdSb290IHF1ZXJ5IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgYG11c3RgLCBgbXVzdF9ub3RgLCBvciBgc2hvdWxkYCBhcmd1bWVudC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgdGhhdCB0aGUgcXVlcnkgaXMgdmFsaWRcbiAgICAgICAgICAgIGJvb2xRdWVyeUNoZWNrKHRoaXMuX21ldGEsIHF1ZXJ5KTtcbiAgICAgICAgICAgIC8vIHNldCBxdWVyeVxuICAgICAgICAgICAgdGhpcy5fcGFyYW1zLm11c3QgPSBxdWVyeS5tdXN0O1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1zLm11c3Rfbm90ID0gcXVlcnkubXVzdF9ub3Q7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbXMuc2hvdWxkID0gcXVlcnkuc2hvdWxkO1xuICAgICAgICAgICAgLy8gY2xlYXQgZXh0cmVtYVxuICAgICAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRRdWVyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG11c3Q6IHRoaXMuX3BhcmFtcy5tdXN0LFxuICAgICAgICAgICAgICAgIG11c3Rfbm90OiB0aGlzLl9wYXJhbXMubXVzdF9ub3QsXG4gICAgICAgICAgICAgICAgc2hvdWxkOiB0aGlzLl9wYXJhbXMuc2hvdWxkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhclF1ZXJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGNsZWFyIHF1ZXJ5XG4gICAgICAgICAgICB0aGlzLl9wYXJhbXMubXVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5tdXN0X25vdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5zaG91bGQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBjbGVhdCBleHRyZW1hXG4gICAgICAgICAgICB0aGlzLmNsZWFyRXh0cmVtYSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldE1ldGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21ldGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0UGFyYW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJhbXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Tm9ybWFsaXplZENvb3JkczogZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgICAgICBsZXQgcG93ID0gTWF0aC5wb3coMiwgY29vcmRzLnopO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBtb2QoY29vcmRzLngsIHBvdyksXG4gICAgICAgICAgICAgICAgeTogbW9kKGNvb3Jkcy55LCBwb3cpLFxuICAgICAgICAgICAgICAgIHo6IGNvb3Jkcy56XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNhY2hlS2V5RnJvbUNvb3JkOiBmdW5jdGlvbihjb29yZHMsIG5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICAgIC8vIGxlYWZsZXQgbGF5ZXIgeCBhbmQgeSBtYXkgYmUgPiBuXjIsIGFuZCA8IDAgaW4gdGhlIGNhc2VcbiAgICAgICAgICAgICAgICAvLyBvZiBhIHdyYXBhcm91bmQuIElmIG5vcm1hbGl6ZSBpcyB0cnVlLCBtb2QgdGhlIGNvb3Jkc1xuICAgICAgICAgICAgICAgIGNvb3JkcyA9IHRoaXMuZ2V0Tm9ybWFsaXplZENvb3Jkcyhjb29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvb3Jkcy56ICsgJzonICsgY29vcmRzLnggKyAnOicgKyBjb29yZHMueTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb29yZEZyb21DYWNoZUtleTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBsZXQgYXJyID0ga2V5LnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHBhcnNlSW50KGFyclsxXSwgMTApLFxuICAgICAgICAgICAgICAgIHk6IHBhcnNlSW50KGFyclsyXSwgMTApLFxuICAgICAgICAgICAgICAgIHo6IHBhcnNlSW50KGFyclswXSwgMTApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVGlsZVVubG9hZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGxldCBjb29yZHMgPSBldmVudC5jb29yZHM7XG4gICAgICAgICAgICAvLyByZXNwZWN0IHRoZSBUTVMgc2V0dGluZyBpbiB0aGUgb3B0aW9uc1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50bXMpIHtcbiAgICAgICAgICAgICAgICBjb29yZHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGV2ZW50LmNvb3Jkcy54LFxuICAgICAgICAgICAgICAgICAgICB5OiBNYXRoLnBvdygyLCBldmVudC5jb29yZHMueikgLSAxIC0gZXZlbnQuY29vcmRzLnksXG4gICAgICAgICAgICAgICAgICAgIHo6IGV2ZW50LmNvb3Jkcy56XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhY2hlIGtleSBmcm9tIGNvb3Jkc1xuICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29vcmRzKTtcbiAgICAgICAgICAgIC8vIGNhY2hlIGtleSBmcm9tIG5vcm1hbGl6ZWQgY29vcmRzXG4gICAgICAgICAgICBsZXQgbmtleSA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29vcmRzLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGdldCBjYWNoZSBlbnRyeVxuICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX2NhY2hlW25rZXldO1xuICAgICAgICAgICAgLy8gY291bGQgdGhlIGJlIGNhc2Ugd2hlcmUgdGhlIGNhY2hlIGlzIGNsZWFyZWQgYmVmb3JlIHRpbGVzIGFyZVxuICAgICAgICAgICAgLy8gdW5sb2FkZWRcbiAgICAgICAgICAgIGlmICghY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSB0aWxlIGZyb20gdGhlIGNhY2hlXG4gICAgICAgICAgICBkZWxldGUgY2FjaGVkLnRpbGVzW2tleV07XG4gICAgICAgICAgICAvLyBkb24ndCByZW1vdmUgY2FjaGUgZW50cnkgdW5sZXNzIHRvIHRpbGVzIHVzZSBpdCBhbnltb3JlXG4gICAgICAgICAgICBpZiAoXy5rZXlzKGNhY2hlZC50aWxlcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSB0aWxlIGJlaW5nIGRlbGV0ZWRcbiAgICAgICAgICAgICAgICBsZXQgdGlsZSA9IGNhY2hlZC50aWxlc1trZXldO1xuICAgICAgICAgICAgICAgIC8vIG5vIG1vcmUgdGlsZXMgdXNlIHRoaXMgY2FjaGVkIGRhdGEsIHNvIGRlbGV0ZSBpdFxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnY2FjaGV1bmxvYWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHRpbGU6IHRpbGUsXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkczogY29vcmRzLFxuICAgICAgICAgICAgICAgICAgICBlbnRyeTogY2FjaGVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NhY2hlW25rZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9yZXF1ZXN0VGlsZTogZnVuY3Rpb24oY29vcmRzLCB0aWxlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gcmVzcGVjdCB0aGUgVE1TIHNldHRpbmcgaW4gdGhlIG9wdGlvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XG4gICAgICAgICAgICAgICAgY29vcmRzID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBjb29yZHMueCxcbiAgICAgICAgICAgICAgICAgICAgeTogTWF0aC5wb3coMiwgY29vcmRzLnopIC0gMSAtIGNvb3Jkcy55LFxuICAgICAgICAgICAgICAgICAgICB6OiBjb29yZHMuelxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmNvb3JkcyA9IHRoaXMuZ2V0Tm9ybWFsaXplZENvb3Jkcyhjb29yZHMpO1xuICAgICAgICAgICAgLy8gY2FjaGUga2V5IGZyb20gY29vcmRzXG4gICAgICAgICAgICBsZXQga2V5ID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZHMpO1xuICAgICAgICAgICAgLy8gY2FjaGUga2V5IGZyb20gbm9ybWFsaXplZCBjb29yZHNcbiAgICAgICAgICAgIGxldCBua2V5ID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZHMsIHRydWUpO1xuICAgICAgICAgICAgLy8gY2hlY2sgY2FjaGVcbiAgICAgICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9jYWNoZVtua2V5XTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGlsZSB1bmRlciBub3JtYWxpemUgY29vcmRzXG4gICAgICAgICAgICAgICAgY2FjaGVkLnRpbGVzW2tleV0gPSB0aWxlO1xuICAgICAgICAgICAgICAgIGlmICghY2FjaGVkLmlzUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWNoZSBlbnRyeSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2NhY2hlaGl0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZTogdGlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkczogY29vcmRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnk6IGNhY2hlZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhlY3V0ZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aWxlIGlzIGFscmVhZHkgcGVuZGluZywgYWRkIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZC5jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBjYWNoZSBlbnRyeVxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlW25rZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBpc1BlbmRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRpbGVzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBbIGNhbGxiYWNrIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIGFkZCB0aWxlIHRvIHRoZSBjYWNoZSBlbnRyeVxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlW25rZXldLnRpbGVzW2tleV0gPSB0aWxlO1xuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgdGhlIHRpbGVcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RUaWxlKG5jb29yZHMsIGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5fY2FjaGVbbmtleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aWxlIGlzIG5vIGxvbmdlciBiZWluZyB0cmFja2VkLCBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBmbGFnIGFzIG5vIGxvbmdlciBwZW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZC5pc1BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtIGFuZCBzdG9yZSB0aWxlIGRhdGEgaW4gY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkLmRhdGEgPSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBleGVjdXRlIHBlbmRpbmcgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZC5jYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkLmNhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAvLyBkYXRhIGlzIGxvYWRlZCBpbnRvIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnY2FjaGVsb2FkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZTogdGlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkczogY29vcmRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnk6IGNhY2hlZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGV4dHJlbWFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnVwZGF0ZUV4dHJlbWEoY2FjaGVkLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgZXh0cmVtYSBjaGFuZ2VkLCBmaXJlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdleHRyZW1hY2hhbmdlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlOiB0aWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnk6IGNhY2hlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVxdWVzdFRpbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExpdmU7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgQmFzZSA9IHJlcXVpcmUoJy4vQmFzZScpO1xuXG4gICAgZnVuY3Rpb24gbW9kKG4sIG0pIHtcbiAgICAgICAgcmV0dXJuICgobiAlIG0pICsgbSkgJSBtO1xuICAgIH1cblxuICAgIGxldCBQZW5kaW5nID0gQmFzZS5leHRlbmQoe1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHVubG9hZEludmlzaWJsZVRpbGVzOiB0cnVlLFxuICAgICAgICAgICAgekluZGV4OiA1MDAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1RpbGVzID0ge307XG4gICAgICAgICAgICAvLyBzZXQgcmVuZGVyZXJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5yZW5kZXJlckNsYXNzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ05vIGByZW5kZXJlckNsYXNzYCBvcHRpb24gZm91bmQuJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgZXh0ZW5kXG4gICAgICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgdGhpcywgb3B0aW9ucy5yZW5kZXJlckNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBvcHRpb25zXG4gICAgICAgICAgICBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgbGF5ZXIuX2luY3JlbWVudEhhbmRsZXIgPSB0aWxlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmNyZW1lbnQodGlsZS5jb29yZHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxheWVyLl9kZWNyZW1lbnRIYW5kbGVyID0gdGlsZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVjcmVtZW50KHRpbGUuY29vcmRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsYXllci5vbigndGlsZXN0YXJ0bG9hZCcsIGxheWVyLl9pbmNyZW1lbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIGxheWVyLm9uKCd0aWxlbG9hZCcsIGxheWVyLl9kZWNyZW1lbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIGxheWVyLm9uKCd0aWxlZXJyb3InLCBsYXllci5fZGVjcmVtZW50SGFuZGxlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgbGF5ZXIub2ZmKCd0aWxlc3RhcnRsb2FkJywgbGF5ZXIuX2luY3JlbWVudEhhbmRsZXIpO1xuICAgICAgICAgICAgbGF5ZXIub2ZmKCd0aWxlbG9hZCcsIGxheWVyLl9kZWNyZW1lbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIGxheWVyLm9mZigndGlsZWVycm9yJywgbGF5ZXIuX2RlY3JlbWVudEhhbmRsZXIpO1xuICAgICAgICAgICAgbGF5ZXIuX2luY3JlbWVudEhhbmRsZXIgPSBudWxsO1xuICAgICAgICAgICAgbGF5ZXIuX2RlY3JlbWVudEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbmNyZW1lbnQ6IGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgICAgICBsZXQgaGFzaCA9IHRoaXMuX2dldFRpbGVIYXNoKGNvb3JkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nVGlsZXNbaGFzaF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdUaWxlc1toYXNoXSA9IDE7XG4gICAgICAgICAgICAgICAgbGV0IHRpbGVzID0gdGhpcy5fZ2V0VGlsZXNXaXRoSGFzaChoYXNoKTtcbiAgICAgICAgICAgICAgICB0aWxlcy5mb3JFYWNoKHRpbGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVUaWxlKGNvb3JkLCB0aWxlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1RpbGVzW2hhc2hdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RlY3JlbWVudDogZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgICAgIGxldCBoYXNoID0gdGhpcy5fZ2V0VGlsZUhhc2goY29vcmQpO1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1RpbGVzW2hhc2hdLS07XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ1RpbGVzW2hhc2hdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdUaWxlc1toYXNoXTtcbiAgICAgICAgICAgICAgICBsZXQgdGlsZXMgPSB0aGlzLl9nZXRUaWxlc1dpdGhIYXNoKGhhc2gpO1xuICAgICAgICAgICAgICAgIHRpbGVzLmZvckVhY2godGlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRpbGUoY29vcmQsIHRpbGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRUaWxlQ2xhc3M6IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiAnbGVhZmxldC1wZW5kaW5nLScgKyBoYXNoO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXROb3JtYWxpemVkQ29vcmRzOiBmdW5jdGlvbihjb29yZHMpIHtcbiAgICAgICAgICAgIGxldCBwb3cgPSBNYXRoLnBvdygyLCBjb29yZHMueik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IG1vZChjb29yZHMueCwgcG93KSxcbiAgICAgICAgICAgICAgICB5OiBtb2QoY29vcmRzLnksIHBvdyksXG4gICAgICAgICAgICAgICAgejogY29vcmRzLnpcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFRpbGVIYXNoOiBmdW5jdGlvbihjb29yZHMpIHtcbiAgICAgICAgICAgIGxldCBuY29vcmRzID0gdGhpcy5fZ2V0Tm9ybWFsaXplZENvb3Jkcyhjb29yZHMpO1xuICAgICAgICAgICAgcmV0dXJuIG5jb29yZHMueiArICctJyArIG5jb29yZHMueCArICctJyArIG5jb29yZHMueTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0VGlsZXNXaXRoSGFzaDogZnVuY3Rpb24oaGFzaCkge1xuICAgICAgICAgICAgbGV0IGNsYXNzTmFtZSA9IHRoaXMuX2dldFRpbGVDbGFzcyhoYXNoKTtcbiAgICAgICAgICAgIGxldCB0aWxlcyA9IFtdO1xuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLmZpbmQoJy4nICsgY2xhc3NOYW1lKS5lYWNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aWxlcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGlsZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkLCB0aWxlKSB7XG4gICAgICAgICAgICAvLyBnZXQgaGFzaFxuICAgICAgICAgICAgbGV0IGhhc2ggPSB0aGlzLl9nZXRUaWxlSGFzaChjb29yZCk7XG4gICAgICAgICAgICAkKHRpbGUpLmFkZENsYXNzKHRoaXMuX2dldFRpbGVDbGFzcyhoYXNoKSArICcgcGVuZGluZycpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdUaWxlc1toYXNoXSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbGUodGlsZSwgY29vcmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKHRpbGUpLnJlbW92ZUNsYXNzKCdwZW5kaW5nJyk7XG4gICAgICAgICAgICAgICAgdGlsZS5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGEgPGRpdj4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICAgICAgICAgICAgbGV0IHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC10aWxlIGxlYWZsZXQtdGlsZS1wZW5kaW5nJyk7XG4gICAgICAgICAgICAvLyBnZXQgaGFzaFxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGlsZShjb29yZCwgdGlsZSk7XG4gICAgICAgICAgICAvLyBwYXNzIHRpbGUgdG8gY2FsbGJhY2tcbiAgICAgICAgICAgIHJldHVybiB0aWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBlbmRpbmc7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBkZWJ1ZyB0aWxlIGxheWVyXG4gICAgbGV0IERlYnVnID0gcmVxdWlyZSgnLi9jb3JlL0RlYnVnJyk7XG5cbiAgICAvLyBwZW5kaW5nIHRpbGUgbGF5ZXJcbiAgICBsZXQgUGVuZGluZyA9IHJlcXVpcmUoJy4vY29yZS9QZW5kaW5nJyk7XG5cbiAgICAvLyBpbWFnZSBsYXllclxuICAgIGxldCBJbWFnZSA9IHJlcXVpcmUoJy4vY29yZS9JbWFnZScpO1xuXG4gICAgLy8gY29tcG9zaXRlIGxheWVyXG4gICAgbGV0IENvbXBvc2l0ZSA9IHJlcXVpcmUoJy4vY29yZS9Db21wb3NpdGUnKTtcblxuICAgIC8vIGxpdmUgbGF5ZXIgLSBiYXNlIHR5cGUgZm9yIGV4dGVuc2lvblxuICAgIGxldCBMaXZlID0gcmVxdWlyZSgnLi9jb3JlL0xpdmUnKTtcblxuICAgIC8vIGxpdmUgdGlsZSBsYXllcnNcbiAgICBsZXQgSGVhdG1hcCA9IHJlcXVpcmUoJy4vdHlwZS9IZWF0bWFwJyk7XG4gICAgbGV0IFRvcFRyYWlscyA9IHJlcXVpcmUoJy4vdHlwZS9Ub3BUcmFpbHMnKTtcbiAgICBsZXQgVG9wQ291bnQgPSByZXF1aXJlKCcuL3R5cGUvVG9wQ291bnQnKTtcbiAgICBsZXQgVG9wRnJlcXVlbmN5ID0gcmVxdWlyZSgnLi90eXBlL1RvcEZyZXF1ZW5jeScpO1xuICAgIGxldCBUb3BpY0NvdW50ID0gcmVxdWlyZSgnLi90eXBlL1RvcGljQ291bnQnKTtcbiAgICBsZXQgVG9waWNGcmVxdWVuY3kgPSByZXF1aXJlKCcuL3R5cGUvVG9waWNGcmVxdWVuY3knKTtcbiAgICBsZXQgUHJldmlldyA9IHJlcXVpcmUoJy4vdHlwZS9QcmV2aWV3Jyk7XG4gICAgbGV0IE1hY3JvID0gcmVxdWlyZSgnLi90eXBlL01hY3JvJyk7XG4gICAgbGV0IE1pY3JvID0gcmVxdWlyZSgnLi90eXBlL01pY3JvJyk7XG4gICAgbGV0IENvdW50ID0gcmVxdWlyZSgnLi90eXBlL0NvdW50Jyk7XG4gICAgbGV0IENvbW11bml0eSA9IHJlcXVpcmUoJy4vdHlwZS9Db21tdW5pdHknKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBEZWJ1ZzogRGVidWcsXG4gICAgICAgIFBlbmRpbmc6IFBlbmRpbmcsXG4gICAgICAgIEltYWdlOiBJbWFnZSxcbiAgICAgICAgQ29tcG9zaXRlOiBDb21wb3NpdGUsXG4gICAgICAgIExpdmU6IExpdmUsXG4gICAgICAgIEhlYXRtYXA6IEhlYXRtYXAsXG4gICAgICAgIFRvcENvdW50OiBUb3BDb3VudCxcbiAgICAgICAgVG9wVHJhaWxzOiBUb3BUcmFpbHMsXG4gICAgICAgIFRvcEZyZXF1ZW5jeTogVG9wRnJlcXVlbmN5LFxuICAgICAgICBUb3BpY0NvdW50OiBUb3BpY0NvdW50LFxuICAgICAgICBUb3BpY0ZyZXF1ZW5jeTogVG9waWNGcmVxdWVuY3ksXG4gICAgICAgIFByZXZpZXc6IFByZXZpZXcsXG4gICAgICAgIE1hY3JvOiBNYWNybyxcbiAgICAgICAgTWljcm86IE1pY3JvLFxuICAgICAgICBDb3VudDogQ291bnQsXG4gICAgICAgIENvbW11bml0eTogQ29tbXVuaXR5XG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBERUZBVUxUX1JFU09MVVRJT04gPSAyNTY7XG5cbiAgICBsZXQgVGlsaW5nID0gcmVxdWlyZSgnLi9UaWxpbmcnKTtcblxuICAgIGxldCBzZXRSZXNvbHV0aW9uID0gZnVuY3Rpb24ocmVzb2x1dGlvbikge1xuICAgICAgICBpZiAocmVzb2x1dGlvbiAhPT0gdGhpcy5fcGFyYW1zLmJpbm5pbmcucmVzb2x1dGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1zLmJpbm5pbmcucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgICAgICB0aGlzLmNsZWFyRXh0cmVtYSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBsZXQgZ2V0UmVzb2x1dGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zLmJpbm5pbmcucmVzb2x1dGlvbiB8fCBERUZBVUxUX1JFU09MVVRJT047XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvLyB0aWxpbmdcbiAgICAgICAgc2V0WEZpZWxkOiBUaWxpbmcuc2V0WEZpZWxkLFxuICAgICAgICBnZXRYRmllbGQ6IFRpbGluZy5nZXRYRmllbGQsXG4gICAgICAgIHNldFlGaWVsZDogVGlsaW5nLnNldFlGaWVsZCxcbiAgICAgICAgZ2V0WUZpZWxkOiBUaWxpbmcuZ2V0WUZpZWxkLFxuICAgICAgICBnZXRMYXllclBvaW50RnJvbURhdGFQb2ludDogVGlsaW5nLmdldExheWVyUG9pbnRGcm9tRGF0YVBvaW50LFxuICAgICAgICBnZXREYXRhUG9pbnRGcm9tTGF5ZXJQb2ludDogVGlsaW5nLmdldERhdGFQb2ludEZyb21MYXllclBvaW50LFxuICAgICAgICBERUZBVUxUX1hfRklFTEQ6IFRpbGluZy5ERUZBVUxUX1hfRklFTEQsXG4gICAgICAgIERFRkFVTFRfWV9GSUVMRDogVGlsaW5nLkRFRkFVTFRfWV9GSUVMRCxcbiAgICAgICAgREVGQVVMVF9QSVhFTF9NQVg6IFRpbGluZy5ERUZBVUxUX1BJWEVMX01BWCxcbiAgICAgICAgLy8gYmlubmluZ1xuICAgICAgICBzZXRSZXNvbHV0aW9uOiBzZXRSZXNvbHV0aW9uLFxuICAgICAgICBnZXRSZXNvbHV0aW9uOiBnZXRSZXNvbHV0aW9uLFxuICAgICAgICBERUZBVUxUX1JFU09MVVRJT046IERFRkFVTFRfUkVTT0xVVElPTlxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgZ2V0VHlwZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcy5lbGFzdGljID8gdGhpcy5fcGFyYW1zLmVsYXN0aWMudHlwZSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgbGV0IHNldFR5cGVzID0gZnVuY3Rpb24odHlwZXMpIHtcbiAgICAgICAgaWYgKCF0eXBlcykge1xuICAgICAgICAgICAgdGhyb3cgJ1F1ZXJ5U3RyaW5nIGB0eXBlc2AgYXJlIG5vdCBwcm92aWRlZC4nO1xuICAgICAgICB9XG4gICAgICAgIHR5cGVzID0gQXJyYXkuaXNBcnJheSh0eXBlcykgPyB0eXBlcyA6IFsgdHlwZXMgXTtcbiAgICAgICAgdGhpcy5fcGFyYW1zLmVsYXN0aWMgPSB7XG4gICAgICAgICAgICB0eXBlczogdHlwZXNcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHNldFR5cGVzOiBzZXRUeXBlcyxcbiAgICAgICAgZ2V0VHlwZXM6IGdldFR5cGVzXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcblxuICAgIGxldCBERUZBVUxUX1RJTEVfU0laRSA9IDI1NjtcbiAgICBsZXQgREVGQVVMVF9YX0ZJRUxEID0gJ3BpeGVsLngnO1xuICAgIGxldCBERUZBVUxUX1lfRklFTEQgPSAncGl4ZWwueSc7XG4gICAgbGV0IERFRkFVTFRfUElYRUxfTUlOID0gMDtcbiAgICBsZXQgREVGQVVMVF9QSVhFTF9NQVggPSBNYXRoLnBvdygyLCAzMik7XG5cbiAgICBsZXQgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAobWV0YS5leHRyZW1hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93ICdGaWVsZCBgJyArIGZpZWxkICsgJ2AgaXMgbm90IG9yZGluYWwgaW4gbWV0YSBkYXRhLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnRmllbGQgYCcgKyBmaWVsZCArICdgIGlzIG5vdCByZWNvZ25pemVkIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgbGV0IHNldFhGaWVsZCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgIGlmIChmaWVsZCAhPT0gdGhpcy5fcGFyYW1zLmJpbm5pbmcueCkge1xuICAgICAgICAgICAgaWYgKGZpZWxkID09PSBERUZBVUxUX1hfRklFTEQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXNldCBpZiBkZWZhdWx0XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zLmJpbm5pbmcueCA9IERFRkFVTFRfWF9GSUVMRDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMuYmlubmluZy5sZWZ0ID0gREVGQVVMVF9QSVhFTF9NSU47XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zLmJpbm5pbmcucmlnaHQgPSBERUZBVUxUX1BJWEVMX01BWDtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyRXh0cmVtYSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWV0YSA9IHRoaXMuX21ldGFbZmllbGRdO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0ZpZWxkKG1ldGEsIGZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMuYmlubmluZy54ID0gZmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5iaW5uaW5nLmxlZnQgPSBtZXRhLmV4dHJlbWEubWluO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMuYmlubmluZy5yaWdodCA9IG1ldGEuZXh0cmVtYS5tYXg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJFeHRyZW1hKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBsZXQgZ2V0WEZpZWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbXMuYmlubmluZy54O1xuICAgIH07XG5cbiAgICBsZXQgc2V0WUZpZWxkID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgaWYgKGZpZWxkICE9PSB0aGlzLl9wYXJhbXMuYmlubmluZy55KSB7XG4gICAgICAgICAgICBpZiAoZmllbGQgPT09IERFRkFVTFRfWV9GSUVMRCkge1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IGlmIGRlZmF1bHRcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMuYmlubmluZy55ID0gREVGQVVMVF9ZX0ZJRUxEO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5iaW5uaW5nLmJvdHRvbSA9IERFRkFVTFRfUElYRUxfTUFYO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5iaW5uaW5nLnRvcCA9IERFRkFVTFRfUElYRUxfTUlOO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJFeHRyZW1hKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtZXRhID0gdGhpcy5fbWV0YVtmaWVsZF07XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrRmllbGQobWV0YSwgZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5iaW5uaW5nLnkgPSBmaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zLmJpbm5pbmcuYm90dG9tID0gbWV0YS5leHRyZW1hLm1pbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zLmJpbm5pbmcudG9wID0gbWV0YS5leHRyZW1hLm1heDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGxldCBnZXRZRmllbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcy5iaW5uaW5nLnk7XG4gICAgfTtcblxuICAgIGxldCBnZXRMYXllclBvaW50RnJvbURhdGFQb2ludCA9IGZ1bmN0aW9uKHgsIHksIHpvb20pIHtcbiAgICAgICAgbGV0IGJpbm5pbmcgPSB0aGlzLl9wYXJhbXMuYmlubmluZztcbiAgICAgICAgbGV0IHRpbGVTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplIHx8IERFRkFVTFRfVElMRV9TSVpFO1xuICAgICAgICBsZXQgcG93ID0gTWF0aC5wb3coMiwgem9vbSk7XG4gICAgICAgIGxldCBleHRlbnQgPSB0aWxlU2l6ZSAqIHBvdztcbiAgICAgICAgbGV0IG1ldGEgPSB0aGlzLmdldE1ldGEoKTtcblxuICAgICAgICBsZXQgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wO1xuICAgICAgICBpZiAobWV0YVtiaW5uaW5nLnhdLnR5cGUgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgbGVmdCA9IG1vbWVudChiaW5uaW5nLmxlZnQpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gbW9tZW50KGJpbm5pbmcucmlnaHQpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHggPSBtb21lbnQoeCkudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCA9IGJpbm5pbmcubGVmdDtcbiAgICAgICAgICAgIHJpZ2h0ID0gYmlubmluZy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YVtiaW5uaW5nLnldLnR5cGUgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgYm90dG9tID0gbW9tZW50KGJpbm5pbmcuYm90dG9tKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICB0b3AgPSBtb21lbnQoYmlubmluZy50b3ApLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHkgPSBtb21lbnQoeSkudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm90dG9tID0gYmlubmluZy5ib3R0b207XG4gICAgICAgICAgICB0b3AgPSBiaW5uaW5nLnRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB4UmFuZ2UgPSBNYXRoLmFicyhyaWdodCAtIGxlZnQpO1xuICAgICAgICBsZXQgeVJhbmdlID0gTWF0aC5hYnMoYm90dG9tIC0gdG9wKTtcbiAgICAgICAgbGV0IG54LCBueTtcbiAgICAgICAgaWYgKGxlZnQgPiByaWdodCkge1xuICAgICAgICAgICAgbnggPSAxIC0gKCh4IC0gcmlnaHQpIC8geFJhbmdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG54ID0gKHggLSBsZWZ0KSAvIHhSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9wID4gYm90dG9tKSB7XG4gICAgICAgICAgICBueSA9IDEgLSAoKHkgLSBib3R0b20pIC8geVJhbmdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG55ID0gKHkgLSB0b3ApIC8geVJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBleHRlbnQgKiBueCxcbiAgICAgICAgICAgIHk6IGV4dGVudCAqIG55XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGxldCBnZXREYXRhUG9pbnRGcm9tTGF5ZXJQb2ludCA9IGZ1bmN0aW9uKHgsIHksIHpvb20pIHtcbiAgICAgICAgbGV0IGJpbm5pbmcgPSB0aGlzLl9wYXJhbXMuYmlubmluZztcbiAgICAgICAgbGV0IHRpbGVTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplIHx8IERFRkFVTFRfVElMRV9TSVpFO1xuICAgICAgICBsZXQgcG93ID0gTWF0aC5wb3coMiwgem9vbSk7XG4gICAgICAgIGxldCBleHRlbnQgPSB0aWxlU2l6ZSAqIHBvdztcbiAgICAgICAgbGV0IG54ID0geCAvIGV4dGVudDtcbiAgICAgICAgbGV0IG55ID0geSAvIGV4dGVudDtcbiAgICAgICAgbGV0IHhSYW5nZSA9IE1hdGguYWJzKGJpbm5pbmcucmlnaHQgLSBiaW5uaW5nLmxlZnQpO1xuICAgICAgICBsZXQgeVJhbmdlID0gTWF0aC5hYnMoYmlubmluZy5ib3R0b20gLSBiaW5uaW5nLnRvcCk7XG4gICAgICAgIGxldCBweCwgcHk7XG4gICAgICAgIGlmIChiaW5uaW5nLmxlZnQgPiBiaW5uaW5nLnJpZ2h0KSB7XG4gICAgICAgICAgICBweCA9IGJpbm5pbmcucmlnaHQgKyAoMSAtIG54KSAqIHhSYW5nZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHB4ID0gYmlubmluZy5sZWZ0ICsgbnggKiB4UmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbm5pbmcudG9wID4gYmlubmluZy5ib3R0b20pIHtcbiAgICAgICAgICAgIHB5ID0gYmlubmluZy5ib3R0b20gKyAoMSAtIG55KSAqIHlSYW5nZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHB5ID0gYmlubmluZy50b3AgKyBueSAqIHlSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcHgsXG4gICAgICAgICAgICB5OiBweVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgc2V0WEZpZWxkOiBzZXRYRmllbGQsXG4gICAgICAgIGdldFhGaWVsZDogZ2V0WEZpZWxkLFxuICAgICAgICBzZXRZRmllbGQ6IHNldFlGaWVsZCxcbiAgICAgICAgZ2V0WUZpZWxkOiBnZXRZRmllbGQsXG4gICAgICAgIGdldExheWVyUG9pbnRGcm9tRGF0YVBvaW50OiBnZXRMYXllclBvaW50RnJvbURhdGFQb2ludCxcbiAgICAgICAgZ2V0RGF0YVBvaW50RnJvbUxheWVyUG9pbnQ6IGdldERhdGFQb2ludEZyb21MYXllclBvaW50LFxuICAgICAgICBERUZBVUxUX1hfRklFTEQ6IERFRkFVTFRfWF9GSUVMRCxcbiAgICAgICAgREVGQVVMVF9ZX0ZJRUxEOiBERUZBVUxUX1lfRklFTEQsXG4gICAgICAgIERFRkFVTFRfUElYRUxfTUFYOiBERUZBVUxUX1BJWEVMX01BWFxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgY2hlY2s7XG5cbiAgICBmdW5jdGlvbiBjaGVja1F1ZXJ5KG1ldGEsIHF1ZXJ5KSB7XG4gICAgICAgIGxldCBrZXlzID0gXy5rZXlzKHF1ZXJ5KTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyAnQm9vbCBzdWItcXVlcnkgbXVzdCBvbmx5IGhhdmUgYSBzaW5nbGUga2V5LCBxdWVyeSBoYXMgbXVsdGlwbGUga2V5czogYCcgKyBKU09OLnN0cmluZ2lmeShrZXlzKSArICdgLic7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSBrZXlzWzBdO1xuICAgICAgICBsZXQgY2hlY2tGdW5jID0gY2hlY2tbdHlwZV07XG4gICAgICAgIGlmICghY2hlY2tGdW5jKSB7XG4gICAgICAgICAgICB0aHJvdyAnUXVlcnkgdHlwZSBgJyArIHR5cGUgKyAnYCBpcyBub3QgcmVjb2duaXplZC4nO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIHF1ZXJ5IGJ5IHR5cGVcbiAgICAgICAgY2hlY2tbdHlwZV0obWV0YSwgcXVlcnlbdHlwZV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrUXVlcmllcyhtZXRhLCBxdWVyaWVzKSB7XG4gICAgICAgIGlmIChfLmlzQXJyYXkocXVlcmllcykpIHtcbiAgICAgICAgICAgIHF1ZXJpZXMuZm9yRWFjaChxdWVyeSA9PiB7XG4gICAgICAgICAgICAgICAgY2hlY2tRdWVyeShtZXRhLHF1ZXJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tRdWVyeShtZXRhLCBxdWVyaWVzKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHF1ZXJpZXNcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0Jvb2wobWV0YSwgcXVlcnkpIHtcbiAgICAgICAgaWYgKCFxdWVyeS5tdXN0ICYmICFxdWVyeS5tdXN0X25vdCAmJiAhcXVlcnkuc2hvdWxkKSB7XG4gICAgICAgICAgICB0aHJvdyAnQm9vbCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGBtdXN0YCwgYG11c3Rfbm90YCwgb3IgYHNob3VsZGAgcXVlcnkgYXJndW1lbnQuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkubXVzdCkge1xuICAgICAgICAgICAgY2hlY2tRdWVyaWVzKG1ldGEsIHF1ZXJ5Lm11c3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWVyeS5tdXN0X25vdCkge1xuICAgICAgICAgICAgY2hlY2tRdWVyaWVzKG1ldGEsIHF1ZXJ5Lm11c3Rfbm90KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkuc2hvdWxkKSB7XG4gICAgICAgICAgICBjaGVja1F1ZXJpZXMobWV0YSwgcXVlcnkuc2hvdWxkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrID0ge1xuICAgICAgICBib29sOiBjaGVja0Jvb2wsXG4gICAgICAgIGV4aXN0czogcmVxdWlyZSgnLi9FeGlzdHMnKSxcbiAgICAgICAgcHJlZml4OiByZXF1aXJlKCcuL1ByZWZpeCcpLFxuICAgICAgICBxdWVyeV9zdHJpbmc6IHJlcXVpcmUoJy4vUXVlcnlTdHJpbmcnKSxcbiAgICAgICAgcmFuZ2U6IHJlcXVpcmUoJy4vUmFuZ2UnKSxcbiAgICAgICAgdGVybXM6IHJlcXVpcmUoJy4vVGVybXMnKSxcbiAgICAgICAgbWF0Y2g6IHJlcXVpcmUoJy4vTWF0Y2gnKSxcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjaGVja0Jvb2w7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmICghbWV0YSkge1xuICAgICAgICAgICAgdGhyb3cgJ1Rlcm1zIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEuJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1ldGEsIHF1ZXJ5KSB7XG4gICAgICAgIGlmICghcXVlcnkuZmllbGQpIHtcbiAgICAgICAgICAgIHRocm93ICdFeGlzdHMgYGZpZWxkYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQuJztcbiAgICAgICAgfVxuICAgICAgICBjaGVja0ZpZWxkKG1ldGFbcXVlcnkuZmllbGRdLCBxdWVyeS5maWVsZCk7XG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBjaGVja0ZpZWxkID0gZnVuY3Rpb24obWV0YSwgZmllbGQpIHtcbiAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgIGlmIChtZXRhLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ01hdGNoIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgYHN0cmluZ2AgaW4gbWV0YSBkYXRhLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnTWF0Y2ggYGZpZWxkYCAnICsgZmllbGQgKyAnIGlzIG5vdCByZWNvZ25pemVkIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0YSwgcXVlcnkpIHtcbiAgICAgICAgaWYgKCFxdWVyeS5maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgJ01hdGNoIGBmaWVsZGAgaXMgbWlzc2luZyBmcm9tIGFyZ3VtZW50Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFxdWVyeS5zdHJpbmcpIHtcbiAgICAgICAgICAgIHRocm93ICdNYXRjaCBgc3RyaW5nYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQuJztcbiAgICAgICAgfVxuICAgICAgICBjaGVja0ZpZWxkKG1ldGFbcXVlcnkuZmllbGRdLCBxdWVyeS5maWVsZCk7XG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBjaGVja0ZpZWxkID0gZnVuY3Rpb24obWV0YSwgZmllbGQpIHtcbiAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgIGlmIChtZXRhLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1ByZWZpeCBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IG9mIHR5cGUgYHN0cmluZ2AgaW4gbWV0YSBkYXRhLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnUHJlZml4IGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEuJztcbiAgICAgICAgfSAgICAgICAgXG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0YSwgcXVlcnkpIHtcbiAgICAgICAgaWYgKCFxdWVyeS5maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgJ1ByZWZpeCBgZmllbGRgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5LnByZWZpeGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93ICdQcmVmaXggYHByZWZpeGVzYCBhcmUgbWlzc2luZyBmcm9tIGFyZ3VtZW50JztcbiAgICAgICAgfVxuICAgICAgICBjaGVja0ZpZWxkKG1ldGFbcXVlcnkuZmllbGRdLCBxdWVyeS5maWVsZCk7XG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBjaGVja0ZpZWxkID0gZnVuY3Rpb24obWV0YSwgZmllbGQpIHtcbiAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgIGlmIChtZXRhLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1F1ZXJ5U3RyaW5nIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgYHN0cmluZ2AgaW4gbWV0YSBkYXRhLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnUXVlcnlTdHJpbmcgYGZpZWxkYCAnICsgZmllbGQgKyAnIGlzIG5vdCByZWNvZ25pemVkIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICB9ICAgICAgICBcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRhLCBxdWVyeSkge1xuICAgICAgICBpZiAoIXF1ZXJ5LmZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyAnUXVlcnlTdHJpbmcgYGZpZWxkYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXF1ZXJ5LnN0cmluZykge1xuICAgICAgICAgICAgdGhyb3cgJ1F1ZXJ5U3RyaW5nIGBzdHJpbmdgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudC4nO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRmllbGQobWV0YVtxdWVyeS5maWVsZF0sIHF1ZXJ5LmZpZWxkKTtcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IGNoZWNrRmllbGQgPSBmdW5jdGlvbihtZXRhLCBmaWVsZCkge1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgaWYgKCFtZXRhLmV4dHJlbWEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnUmFuZ2UgYGZpZWxkYCAnICsgZmllbGQgKyAnIGlzIG5vdCBvcmRpbmFsIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ1JhbmdlIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEuJztcbiAgICAgICAgfSAgICAgICAgXG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0YSwgcXVlcnkpIHtcbiAgICAgICAgaWYgKCFxdWVyeS5maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgJ1JhbmdlIGBmaWVsZGAgaXMgbWlzc2luZyBmcm9tIGFyZ3VtZW50Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5LmZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgJ1JhbmdlIGBmcm9tYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkudG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgJ1JhbmdlIGB0b2AgaXMgbWlzc2luZyBmcm9tIGFyZ3VtZW50Lic7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tGaWVsZChtZXRhW3F1ZXJ5LmZpZWxkXSwgcXVlcnkuZmllbGQpO1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAobWV0YS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93ICdUZXJtcyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IG9mIHR5cGUgYHN0cmluZ2AgaW4gbWV0YSBkYXRhLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnVGVybXMgYGZpZWxkYCAnICsgZmllbGQgKyAnIGlzIG5vdCByZWNvZ25pemVkIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICB9ICAgIFxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1ldGEsIHF1ZXJ5KSB7XG4gICAgICAgIGlmICghcXVlcnkuZmllbGQpIHtcbiAgICAgICAgICAgIHRocm93ICdUZXJtcyBgZmllbGRgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWVyeS50ZXJtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyAnVGVybXMgYHRlcm1zYCBhcmUgbWlzc2luZyBmcm9tIGFyZ3VtZW50Lic7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tGaWVsZChtZXRhW3F1ZXJ5LmZpZWxkXSwgcXVlcnkuZmllbGQpO1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgTGl2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvTGl2ZScpO1xuXG4gICAgbGV0IENvbW11bml0eSA9IExpdmUuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnY29tbXVuaXR5JyxcblxuICAgICAgICBleHRyYWN0RXh0cmVtYTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1pbjogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgbWF4OiAtSW5maW5pdHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ29tbXVuaXR5O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IExpdmUgPSByZXF1aXJlKCcuLi9jb3JlL0xpdmUnKTtcbiAgICBsZXQgRWxhc3RpYyA9IHJlcXVpcmUoJy4uL3BhcmFtL0VsYXN0aWMnKTtcbiAgICBsZXQgVGlsaW5nID0gcmVxdWlyZSgnLi4vcGFyYW0vVGlsaW5nJyk7XG5cbiAgICBsZXQgQ291bnQgPSBMaXZlLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIHBhcmFtc1xuICAgICAgICAgICAgRWxhc3RpYyxcbiAgICAgICAgICAgIFRpbGluZ1xuICAgICAgICBdLFxuXG4gICAgICAgIHR5cGU6ICdjb3VudCcsXG5cbiAgICAgICAgLy8gZXh0cmVtZSBub3QgcmVsZXZhbnQgZm9yIGNvdW50IHRpbGVcbiAgICAgICAgZXh0cmFjdEV4dHJlbWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIG1heDogLUluZmluaXR5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvdW50O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IExpdmUgPSByZXF1aXJlKCcuLi9jb3JlL0xpdmUnKTtcbiAgICBsZXQgRWxhc3RpYyA9IHJlcXVpcmUoJy4uL3BhcmFtL0VsYXN0aWMnKTtcbiAgICBsZXQgQmlubmluZyA9IHJlcXVpcmUoJy4uL3BhcmFtL0Jpbm5pbmcnKTtcbiAgICBsZXQgTWV0cmljID0gcmVxdWlyZSgnLi4vYWdnL01ldHJpYycpO1xuXG4gICAgbGV0IEhlYXRtYXAgPSBMaXZlLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIHBhcmFtc1xuICAgICAgICAgICAgRWxhc3RpYyxcbiAgICAgICAgICAgIEJpbm5pbmcsXG4gICAgICAgICAgICAvLyBhZ2dzXG4gICAgICAgICAgICBNZXRyaWNcbiAgICAgICAgXSxcblxuICAgICAgICB0eXBlOiAnaGVhdG1hcCcsXG5cbiAgICAgICAgZXh0cmFjdEV4dHJlbWE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGxldCBiaW5zID0gbmV3IEZsb2F0NjRBcnJheShkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWluOiBfLm1pbihiaW5zKSxcbiAgICAgICAgICAgICAgICBtYXg6IF8ubWF4KGJpbnMpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGVhdG1hcDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBMaXZlID0gcmVxdWlyZSgnLi4vY29yZS9MaXZlJyk7XG4gICAgbGV0IEVsYXN0aWMgPSByZXF1aXJlKCcuLi9wYXJhbS9FbGFzdGljJyk7XG4gICAgbGV0IEJpbm5pbmcgPSByZXF1aXJlKCcuLi9wYXJhbS9CaW5uaW5nJyk7XG5cbiAgICBsZXQgTWFjcm8gPSBMaXZlLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIHBhcmFtc1xuICAgICAgICAgICAgRWxhc3RpYyxcbiAgICAgICAgICAgIEJpbm5pbmdcbiAgICAgICAgXSxcblxuICAgICAgICB0eXBlOiAnbWFjcm8nLFxuXG4gICAgICAgIGV4dHJhY3RFeHRyZW1hOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBsZXQgYmlucyA9IG5ldyBGbG9hdDY0QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1pbjogXy5taW4oYmlucyksXG4gICAgICAgICAgICAgICAgbWF4OiBfLm1heChiaW5zKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1hY3JvO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IExpdmUgPSByZXF1aXJlKCcuLi9jb3JlL0xpdmUnKTtcbiAgICBsZXQgRWxhc3RpYyA9IHJlcXVpcmUoJy4uL3BhcmFtL0VsYXN0aWMnKTtcbiAgICBsZXQgVGlsaW5nID0gcmVxdWlyZSgnLi4vcGFyYW0vVGlsaW5nJyk7XG4gICAgbGV0IFRvcEhpdHMgPSByZXF1aXJlKCcuLi9hZ2cvVG9wSGl0cycpO1xuXG4gICAgbGV0IE1pY3JvID0gTGl2ZS5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBwYXJhbXNcbiAgICAgICAgICAgIEVsYXN0aWMsXG4gICAgICAgICAgICBUaWxpbmcsXG4gICAgICAgICAgICAvLyBhZ2dzXG4gICAgICAgICAgICBUb3BIaXRzXG4gICAgICAgIF0sXG5cbiAgICAgICAgdHlwZTogJ21pY3JvJyxcblxuICAgICAgICAvLyBleHRyZW1lIG5vdCByZWxldmFudCBmb3IgbWljcm9cbiAgICAgICAgZXh0cmFjdEV4dHJlbWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIG1heDogLUluZmluaXR5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1pY3JvO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IExpdmUgPSByZXF1aXJlKCcuLi9jb3JlL0xpdmUnKTtcbiAgICBsZXQgRWxhc3RpYyA9IHJlcXVpcmUoJy4uL3BhcmFtL0VsYXN0aWMnKTtcbiAgICBsZXQgQmlubmluZyA9IHJlcXVpcmUoJy4uL3BhcmFtL0Jpbm5pbmcnKTtcbiAgICBsZXQgVG9wSGl0cyA9IHJlcXVpcmUoJy4uL2FnZy9Ub3BIaXRzJyk7XG5cbiAgICBsZXQgUHJldmlldyA9IExpdmUuZXh0ZW5kKHtcblxuICAgICAgICBpbmNsdWRlczogW1xuICAgICAgICAgICAgLy8gcGFyYW1zXG4gICAgICAgICAgICBFbGFzdGljLFxuICAgICAgICAgICAgQmlubmluZyxcbiAgICAgICAgICAgIC8vIGFnZ3NcbiAgICAgICAgICAgIFRvcEhpdHNcbiAgICAgICAgXSxcblxuICAgICAgICB0eXBlOiAncHJldmlldycsXG5cbiAgICAgICAgLy8gZXh0cmVtZSBub3QgcmVsZXZhbnQgZm9yIHByZXZpZXdcbiAgICAgICAgZXh0cmFjdEV4dHJlbWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIG1heDogLUluZmluaXR5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFByZXZpZXc7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgTGl2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvTGl2ZScpO1xuICAgIGxldCBFbGFzdGljID0gcmVxdWlyZSgnLi4vcGFyYW0vRWxhc3RpYycpO1xuICAgIGxldCBUaWxpbmcgPSByZXF1aXJlKCcuLi9wYXJhbS9UaWxpbmcnKTtcbiAgICBsZXQgVG9wVGVybXMgPSByZXF1aXJlKCcuLi9hZ2cvVG9wVGVybXMnKTtcbiAgICBsZXQgSGlzdG9ncmFtID0gcmVxdWlyZSgnLi4vYWdnL0hpc3RvZ3JhbScpO1xuXG4gICAgbGV0IFRvcENvdW50ID0gTGl2ZS5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBwYXJhbXNcbiAgICAgICAgICAgIEVsYXN0aWMsXG4gICAgICAgICAgICBUaWxpbmcsXG4gICAgICAgICAgICBUb3BUZXJtcyxcbiAgICAgICAgICAgIC8vIGFnZ3NcbiAgICAgICAgICAgIEhpc3RvZ3JhbVxuICAgICAgICBdLFxuXG4gICAgICAgIHR5cGU6ICd0b3BfY291bnQnXG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVG9wQ291bnQ7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgTGl2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvTGl2ZScpO1xuICAgIGxldCBFbGFzdGljID0gcmVxdWlyZSgnLi4vcGFyYW0vRWxhc3RpYycpO1xuICAgIGxldCBUaWxpbmcgPSByZXF1aXJlKCcuLi9wYXJhbS9UaWxpbmcnKTtcbiAgICBsZXQgVG9wVGVybXMgPSByZXF1aXJlKCcuLi9hZ2cvVG9wVGVybXMnKTtcbiAgICBsZXQgRGF0ZUhpc3RvZ3JhbSA9IHJlcXVpcmUoJy4uL2FnZy9EYXRlSGlzdG9ncmFtJyk7XG4gICAgbGV0IEhpc3RvZ3JhbSA9IHJlcXVpcmUoJy4uL2FnZy9IaXN0b2dyYW0nKTtcblxuICAgIGxldCBUb3BGcmVxdWVuY3kgPSBMaXZlLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIHBhcmFtc1xuICAgICAgICAgICAgRWxhc3RpYyxcbiAgICAgICAgICAgIFRpbGluZyxcbiAgICAgICAgICAgIC8vIGFnZ3NcbiAgICAgICAgICAgIFRvcFRlcm1zLFxuICAgICAgICAgICAgRGF0ZUhpc3RvZ3JhbSxcbiAgICAgICAgICAgIEhpc3RvZ3JhbVxuICAgICAgICBdLFxuXG4gICAgICAgIHR5cGU6ICd0b3BfZnJlcXVlbmN5JyxcblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUb3BGcmVxdWVuY3k7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgTGl2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvTGl2ZScpO1xuICAgIGxldCBFbGFzdGljID0gcmVxdWlyZSgnLi4vcGFyYW0vRWxhc3RpYycpO1xuICAgIGxldCBCaW5uaW5nID0gcmVxdWlyZSgnLi4vcGFyYW0vQmlubmluZycpO1xuICAgIGxldCBUZXJtcyA9IHJlcXVpcmUoJy4uL2FnZy9UZXJtcycpO1xuXG4gICAgbGV0IFRvcFRyYWlscyA9IExpdmUuZXh0ZW5kKHtcblxuICAgICAgICBpbmNsdWRlczogW1xuICAgICAgICAgICAgLy8gcGFyYW1zXG4gICAgICAgICAgICBFbGFzdGljLFxuICAgICAgICAgICAgQmlubmluZyxcbiAgICAgICAgICAgIC8vIGFnZ3NcbiAgICAgICAgICAgIFRlcm1zXG4gICAgICAgIF0sXG5cbiAgICAgICAgdHlwZTogJ3RvcF90cmFpbHMnLFxuXG4gICAgICAgIGV4dHJhY3RFeHRyZW1hOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWluOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBtYXg6IC1JbmZpbml0eVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvcFRyYWlscztcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBMaXZlID0gcmVxdWlyZSgnLi4vY29yZS9MaXZlJyk7XG4gICAgbGV0IEVsYXN0aWMgPSByZXF1aXJlKCcuLi9wYXJhbS9FbGFzdGljJyk7XG4gICAgbGV0IFRpbGluZyA9IHJlcXVpcmUoJy4uL3BhcmFtL1RpbGluZycpO1xuICAgIGxldCBUZXJtc0ZpbHRlciA9IHJlcXVpcmUoJy4uL2FnZy9UZXJtc0ZpbHRlcicpO1xuICAgIGxldCBIaXN0b2dyYW0gPSByZXF1aXJlKCcuLi9hZ2cvSGlzdG9ncmFtJyk7XG5cbiAgICBsZXQgVG9waWNDb3VudCA9IExpdmUuZXh0ZW5kKHtcblxuICAgICAgICBpbmNsdWRlczogW1xuICAgICAgICAgICAgLy8gcGFyYW1zXG4gICAgICAgICAgICBFbGFzdGljLFxuICAgICAgICAgICAgVGlsaW5nLFxuICAgICAgICAgICAgLy8gYWdnc1xuICAgICAgICAgICAgVGVybXNGaWx0ZXIsXG4gICAgICAgICAgICBIaXN0b2dyYW0sXG4gICAgICAgIF0sXG5cbiAgICAgICAgdHlwZTogJ3RvcGljX2NvdW50JyxcblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUb3BpY0NvdW50O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IExpdmUgPSByZXF1aXJlKCcuLi9jb3JlL0xpdmUnKTtcbiAgICBsZXQgRWxhc3RpYyA9IHJlcXVpcmUoJy4uL3BhcmFtL0VsYXN0aWMnKTtcbiAgICBsZXQgVGlsaW5nID0gcmVxdWlyZSgnLi4vcGFyYW0vVGlsaW5nJyk7XG4gICAgbGV0IFRlcm1zRmlsdGVyID0gcmVxdWlyZSgnLi4vYWdnL1Rlcm1zRmlsdGVyJyk7XG4gICAgbGV0IERhdGVIaXN0b2dyYW0gPSByZXF1aXJlKCcuLi9hZ2cvRGF0ZUhpc3RvZ3JhbScpO1xuICAgIGxldCBIaXN0b2dyYW0gPSByZXF1aXJlKCcuLi9hZ2cvSGlzdG9ncmFtJyk7XG5cbiAgICBsZXQgVG9waWNGcmVxdWVuY3kgPSBMaXZlLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIHBhcmFtcyAgICAgICAgICAgIFxuICAgICAgICAgICAgRWxhc3RpYyxcbiAgICAgICAgICAgIFRpbGluZyxcbiAgICAgICAgICAgIC8vIGFnZ3NcbiAgICAgICAgICAgIFRlcm1zRmlsdGVyLFxuICAgICAgICAgICAgRGF0ZUhpc3RvZ3JhbSxcbiAgICAgICAgICAgIEhpc3RvZ3JhbVxuICAgICAgICBdLFxuXG4gICAgICAgIHR5cGU6ICd0b3BpY19mcmVxdWVuY3knXG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVG9waWNGcmVxdWVuY3k7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgcmVzZXRNb3VzZUN1cnNvclN0eWxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHdlIG9ubHkgd2FudCB0aGlzIGJvdW5kIE9OQ0UgcGVyIG1hcFxuICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikuY3NzKCdjdXJzb3InLCAnJyk7XG4gICAgfTtcblxuICAgIGxldCBNYXAgPSBMLk1hcC5leHRlbmQoe1xuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgTC5NYXAucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMub24oJ21vdXNlbW92ZScsIHJlc2V0TW91c2VDdXJzb3JTdHlsZSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNYXA7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBjYXJ0ZXNpYW4gcHJvamVjdGlvbiBpbiAoMCwwKSwgKDI1NiwgMjU2KSBjb29yZGluYXRlIHNwYWNlXG4gICAgTC5Qcm9qZWN0aW9uLkdyYXBoID0ge1xuXG4gICAgICAgIHByb2plY3Q6IGZ1bmN0aW9uKGxhdGxuZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMLlBvaW50KGxhdGxuZy5sbmcsIGxhdGxuZy5sYXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVucHJvamVjdDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTC5MYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYm91bmRzOiBMLmJvdW5kcyhbMCwgMF0sIFsyNTYsIDI1Nl0pXG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gTC5Qcm9qZWN0aW9uLkdyYXBoO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IERPTSA9IHJlcXVpcmUoJy4vRE9NJyk7XG5cbiAgICBsZXQgQ2FudmFzID0gRE9NLmV4dGVuZCh7XG5cbiAgICAgICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgRE9NLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgICAgICAvLyBoYW5kbGVyc1xuICAgICAgICAgICAgbWFwLm9uKCdjbGljaycsIHRoaXMub25DbGljaywgdGhpcyk7XG4gICAgICAgICAgICBtYXAub24oJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZXJzXG4gICAgICAgICAgICBtYXAub2ZmKCdjbGljaycsIHRoaXMub25DbGljaywgdGhpcyk7XG4gICAgICAgICAgICBtYXAub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLCB0aGlzKTtcbiAgICAgICAgICAgIERPTS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgZG9uZSkge1xuICAgICAgICAgICAgbGV0IHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gICAgICAgICAgICB0aWxlLnN0eWxlWydwb2ludGVyLWV2ZW50cyddID0gJ2FsbCc7XG4gICAgICAgICAgICB0aWxlLndpZHRoID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuICAgICAgICAgICAgdGlsZS5oZWlnaHQgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0VGlsZShjb29yZHMsIHRpbGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICBkb25lKG51bGwsIHRpbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGlsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhclRpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxldCB0aWxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcbiAgICAgICAgICAgIF8uZm9ySW4odGhpcy5fdGlsZXMsIHRpbGUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjdHggPSB0aWxlLmVsLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aWxlU2l6ZSwgdGlsZVNpemUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDYW52YXM7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgQmFzZSA9IHJlcXVpcmUoJy4uLy4uL2xheWVyL2NvcmUvQmFzZScpO1xuXG4gICAgbGV0IERPTSA9IEJhc2UuZXh0ZW5kKHtcblxuICAgICAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICBMLkdyaWRMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgbWFwLm9uKCd6b29tc3RhcnQnLCB0aGlzLmNsZWFyRXh0cmVtYSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9uKCd0aWxldW5sb2FkJywgdGhpcy5vblRpbGVVbmxvYWQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbignY2FjaGVsb2FkJywgdGhpcy5vbkNhY2hlTG9hZCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9uKCdjYWNoZWhpdCcsIHRoaXMub25DYWNoZUhpdCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9uKCdjYWNoZXVubG9hZCcsIHRoaXMub25DYWNoZVVubG9hZCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9uKCdleHRyZW1hY2hhbmdlJywgdGhpcy5vbkV4dHJlbWFDaGFuZ2UsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgIEwuR3JpZExheWVyLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgICAgICBtYXAub2ZmKCd6b29tc3RhcnQnLCB0aGlzLmNsZWFyRXh0cmVtYSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9mZigndGlsZXVubG9hZCcsIHRoaXMub25UaWxlVW5sb2FkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdjYWNoZWxvYWQnLCB0aGlzLm9uQ2FjaGVMb2FkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdjYWNoZWhpdCcsIHRoaXMub25DYWNoZUhpdCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9mZignY2FjaGV1bmxvYWQnLCB0aGlzLm9uQ2FjaGVVbmxvYWQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2V4dHJlbWFjaGFuZ2UnLCB0aGlzLm9uRXh0cmVtYUNoYW5nZSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DYWNoZUhpdDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGxldCBjYWNoZWQgPSBldmVudC5lbnRyeTtcbiAgICAgICAgICAgIGxldCB0aWxlID0gZXZlbnQudGlsZTtcbiAgICAgICAgICAgIGxldCBjb29yZHMgPSBldmVudC5jb29yZHM7XG4gICAgICAgICAgICAvLyBkYXRhIGV4aXN0cywgcmVuZGVyIG9ubHkgdGhpcyB0aWxlXG4gICAgICAgICAgICBpZiAoY2FjaGVkLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbGUodGlsZSwgY2FjaGVkLmRhdGEsIGNvb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DYWNoZUxvYWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBzYW1lIGV4dHJlbWEsIHdlIGFyZSBnb29kIHRvIHJlbmRlciB0aGUgdGlsZXMuIEluXG4gICAgICAgICAgICAvLyB0aGUgY2FzZSBvZiBhIG1hcCB3aXRoIHdyYXBhcm91bmQsIHdlIG1heSBoYXZlXG4gICAgICAgICAgICAvLyBtdWx0aXBsZSB0aWxlcyBkZXBlbmRlbnQgb24gdGhlIHJlc3BvbnNlLCBzbyBpdGVyYXRlXG4gICAgICAgICAgICAvLyBvdmVyIGVhY2ggdGlsZSBhbmQgZHJhdyBpdC5cbiAgICAgICAgICAgIGxldCBjYWNoZWQgPSBldmVudC5lbnRyeTtcbiAgICAgICAgICAgIGxldCBjb29yZHMgPSBldmVudC5jb29yZHM7XG4gICAgICAgICAgICBpZiAoY2FjaGVkLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBfLmZvckluKGNhY2hlZC50aWxlcywgdGlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZSh0aWxlLCBjYWNoZWQuZGF0YSwgY29vcmRzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkV4dHJlbWFDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gcmVkcmF3IGFsbCB0aWxlc1xuICAgICAgICAgICAgXy5mb3JJbih0aGlzLl9jYWNoZSwgY2FjaGVkID0+IHtcbiAgICAgICAgICAgICAgICBfLmZvckluKGNhY2hlZC50aWxlcywgKHRpbGUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZSh0aWxlLCBjYWNoZWQuZGF0YSwgdGhpcy5jb29yZEZyb21DYWNoZUtleShrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DYWNoZVVubG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gRE9NO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IERPTSA9IHJlcXVpcmUoJy4vRE9NJyk7XG5cbiAgICBsZXQgSFRNTCA9IERPTS5leHRlbmQoe1xuXG4gICAgICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgIERPTS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgLy8gaGFuZGxlcnNcbiAgICAgICAgICAgIG1hcC5vbignY2xpY2snLCB0aGlzLm9uQ2xpY2ssIHRoaXMpO1xuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLm9uKCdtb3VzZW1vdmUnLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vdXNlTW92ZShldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5vbignbW91c2VvdmVyJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25Nb3VzZU92ZXIoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikub24oJ21vdXNlb3V0JywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25Nb3VzZU91dChldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGVyc1xuICAgICAgICAgICAgbWFwLm9mZignY2xpY2snLCB0aGlzLm9uQ2xpY2ssIHRoaXMpO1xuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLm9mZignbW91c2Vtb3ZlJyk7XG4gICAgICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikub2ZmKCdtb3VzZW92ZXInKTtcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5vZmYoJ21vdXNlb3V0Jyk7XG4gICAgICAgICAgICBET00ucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMsIGRvbmUpIHtcbiAgICAgICAgICAgIGxldCB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdGlsZSBsZWFmbGV0LWh0bWwtdGlsZScpO1xuICAgICAgICAgICAgdGlsZS53aWR0aCA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcbiAgICAgICAgICAgIHRpbGUuaGVpZ2h0ID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdFRpbGUoY29vcmRzLCB0aWxlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZG9uZShudWxsLCB0aWxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlT3ZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2VPdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIVE1MO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IEJhc2UgPSByZXF1aXJlKCcuLi8uLi9sYXllci9jb3JlL0Jhc2UnKTtcblxuICAgIGxldCBOT19PUCA9IGZ1bmN0aW9uKCkge307XG5cbiAgICBsZXQgT3ZlcmxheSA9IEJhc2UuZXh0ZW5kKHtcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICB6SW5kZXg6IDFcbiAgICAgICAgfSxcblxuICAgICAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICB0aGlzLm9uKCd0aWxldW5sb2FkJywgdGhpcy5vblRpbGVVbmxvYWQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbignY2FjaGVsb2FkJywgdGhpcy5vbkNhY2hlTG9hZCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9uKCdjYWNoZWhpdCcsIHRoaXMub25DYWNoZUhpdCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9uKCdjYWNoZXVubG9hZCcsIHRoaXMub25DYWNoZVVubG9hZCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9uKCdleHRyZW1hY2hhbmdlJywgdGhpcy5vbkV4dHJlbWFDaGFuZ2UsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fdGlsZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRDb250YWluZXIoKTtcbiAgICAgICAgICAgIC8vIGFkZCBldmVudCBoYW5kbGVyc1xuICAgICAgICAgICAgbWFwLm9uKCdjbGljaycsIHRoaXMub25DbGljaywgdGhpcyk7XG4gICAgICAgICAgICBtYXAub24oJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRWaWV3KCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgbGF5ZXJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG4gICAgICAgICAgICBMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICBtYXAuX3JlbW92ZVpvb21MaW1pdCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVab29tID0gbnVsbDtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBoYW5kbGVyc1xuICAgICAgICAgICAgdGhpcy5vZmYoJ3RpbGV1bmxvYWQnLCB0aGlzLm9uVGlsZVVubG9hZCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9mZignY2FjaGVsb2FkJywgdGhpcy5vbkNhY2hlTG9hZCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9mZignY2FjaGVoaXQnLCB0aGlzLm9uQ2FjaGVIaXQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2NhY2hldW5sb2FkJywgdGhpcy5vbkNhY2hlVW5sb2FkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdleHRyZW1hY2hhbmdlJywgdGhpcy5vbkV4dHJlbWFDaGFuZ2UsIHRoaXMpO1xuICAgICAgICAgICAgbWFwLm9mZignY2xpY2snLCB0aGlzLm9uQ2xpY2ssIHRoaXMpO1xuICAgICAgICAgICAgbWFwLm9mZignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gTm8tb3AgdGhlc2UgZnVuY3Rpb25zXG4gICAgICAgIF91cGRhdGVPcGFjaXR5OiBOT19PUCxcbiAgICAgICAgX2luaXRUaWxlOiBOT19PUCxcbiAgICAgICAgX3VwZGF0ZUxldmVsczogTk9fT1AsXG4gICAgICAgIF9yZW1vdmVUaWxlc0F0Wm9vbTogTk9fT1AsXG4gICAgICAgIF9zZXRab29tVHJhbnNmb3JtczogTk9fT1AsXG5cbiAgICAgICAgX2luaXRDb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIuY2xhc3NOYW1lICs9ICdsZWFmbGV0LWxheWVyIGxlYWZsZXQtem9vbS1hbmltYXRlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVaSW5kZXgoKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3BydW5lVGlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9tYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICAgICAgICBpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8XG4gICAgICAgICAgICAgICAgem9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLmZvckluKHRoaXMuX3RpbGVzLCB0aWxlID0+IHtcbiAgICAgICAgICAgICAgICB0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXy5mb3JJbih0aGlzLl90aWxlcywgdGlsZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbGUuY3VycmVudCAmJiAhdGlsZS5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvb3JkcyA9IHRpbGUuY29vcmRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3JldGFpblBhcmVudChjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiAtIDUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXRhaW5DaGlsZHJlbihjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiArIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfLmZvckluKHRoaXMuX3RpbGVzLCAodGlsZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aWxlLnJldGFpbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlbW92ZUFsbFRpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF8uZm9ySW4odGhpcy5fdGlsZXMsICh0aWxlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaW52YWxpZGF0ZUFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuICAgICAgICAgICAgdGhpcy5fdGlsZVpvb20gPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zZXRWaWV3OiBmdW5jdGlvbihjZW50ZXIsIHpvb20sIG5vUHJ1bmUsIG5vVXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgdGlsZVpvb20gPSBNYXRoLnJvdW5kKHpvb20pO1xuICAgICAgICAgICAgaWYgKCh0aGlzLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkpIHtcbiAgICAgICAgICAgICAgICB0aWxlWm9vbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0aWxlWm9vbUNoYW5nZWQgPSB0aGlzLm9wdGlvbnMudXBkYXRlV2hlblpvb21pbmcgJiYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSk7XG4gICAgICAgICAgICBpZiAoIW5vVXBkYXRlIHx8IHRpbGVab29tQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Fib3J0TG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hYm9ydExvYWRpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzZXRHcmlkKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbGVab29tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKGNlbnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbm9QcnVuZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcnVuZVRpbGVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0Wm9vbVRyYW5zZm9ybShjZW50ZXIsIHpvb20pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zZXRab29tVHJhbnNmb3JtOiBmdW5jdGlvbihjZW50ZXIsIHpvb20pIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Q2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRab29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgICAgICAgICAgIGxldCBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgY3VycmVudFpvb20pO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICBsZXQgdmlld0hhbGYgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLm11bHRpcGx5QnkoMC41KTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdChjdXJyZW50Q2VudGVyLCB6b29tKTtcbiAgICAgICAgICAgIGxldCBkZXN0Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdChjZW50ZXIsIHpvb20pO1xuICAgICAgICAgICAgbGV0IGNlbnRlck9mZnNldCA9IGRlc3RDZW50ZXJQb2ludC5zdWJ0cmFjdChjdXJyZW50Q2VudGVyUG9pbnQpO1xuICAgICAgICAgICAgbGV0IHRvcExlZnRPZmZzZXQgPSB2aWV3SGFsZi5tdWx0aXBseUJ5KC1zY2FsZSkuYWRkKHBvc2l0aW9uKS5hZGQodmlld0hhbGYpLnN1YnRyYWN0KGNlbnRlck9mZnNldCk7XG4gICAgICAgICAgICBpZiAoTC5Ccm93c2VyLmFueTNkKSB7XG4gICAgICAgICAgICAgICAgTC5Eb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQsIHNjYWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgTC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUHJpdmF0ZSBtZXRob2QgdG8gbG9hZCB0aWxlcyBpbiB0aGUgZ3JpZCdzIGFjdGl2ZSB6b29tIGxldmVsIGFjY29yZGluZyB0byBtYXAgYm91bmRzXG4gICAgICAgIF91cGRhdGU6IGZ1bmN0aW9uKGNlbnRlcikge1xuICAgICAgICAgICAgbGV0IG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgaWYgKGNlbnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2VudGVyID0gbWFwLmdldENlbnRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBpeGVsQm91bmRzID0gdGhpcy5fZ2V0VGlsZWRQaXhlbEJvdW5kcyhjZW50ZXIpLFxuICAgICAgICAgICAgICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuICAgICAgICAgICAgICAgIHRpbGVDZW50ZXIgPSB0aWxlUmFuZ2UuZ2V0Q2VudGVyKCksXG4gICAgICAgICAgICAgICAgcXVldWUgPSBbXTtcblxuICAgICAgICAgICAgXy5mb3JJbih0aGlzLl90aWxlcywgdGlsZSA9PiB7XG4gICAgICAgICAgICAgICAgdGlsZS5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIF91cGRhdGUganVzdCBsb2FkcyBtb3JlIHRpbGVzLiBJZiB0aGUgdGlsZSB6b29tIGxldmVsIGRpZmZlcnMgdG9vIG11Y2hcbiAgICAgICAgICAgIC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgdGlsZXMuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoem9vbSAtIHRoaXMuX3RpbGVab29tKSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRWaWV3KGNlbnRlciwgem9vbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgcXVldWUgb2YgY29vcmRpbmF0ZXMgdG8gbG9hZCB0aWxlcyBmcm9tXG4gICAgICAgICAgICBsZXQgaSwgajtcbiAgICAgICAgICAgIGZvciAoaiA9IHRpbGVSYW5nZS5taW4ueTsgaiA8PSB0aWxlUmFuZ2UubWF4Lnk7IGorKykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IHRpbGVSYW5nZS5taW4ueDsgaSA8PSB0aWxlUmFuZ2UubWF4Lng7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29vcmRzID0gbmV3IEwuUG9pbnQoaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkcy56ID0gdGhpcy5fdGlsZVpvb207XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCB0aWxlID0gdGhpcy5fdGlsZXNbdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZS5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goY29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNvcnQgdGlsZSBxdWV1ZSB0byBsb2FkIHRpbGVzIGluIG9yZGVyIG9mIHRoZWlyIGRpc3RhbmNlIHRvIGNlbnRlclxuICAgICAgICAgICAgcXVldWUuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmRpc3RhbmNlVG8odGlsZUNlbnRlcikgLSBiLmRpc3RhbmNlVG8odGlsZUNlbnRlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdHMgdGhlIGZpcnN0IGJhdGNoIG9mIHRpbGVzIHRvIGxvYWRcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIEBldmVudCBsb2FkaW5nOiBFdmVudFxuICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIHN0YXJ0cyBsb2FkaW5nIHRpbGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbG9hZGluZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGlsZShxdWV1ZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9yZW1vdmVUaWxlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGxldCB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcbiAgICAgICAgICAgIGlmICghdGlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuICAgICAgICAgICAgLy8gQGV2ZW50IHRpbGV1bmxvYWQ6IFRpbGVFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVtb3ZlZCAoZS5nLiB3aGVuIGEgdGlsZSBnb2VzIG9mZiB0aGUgc2NyZWVuKS5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHtcbiAgICAgICAgICAgICAgICBjb29yZHM6IHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMsIGRvbmUpIHtcbiAgICAgICAgICAgIGxldCB0aWxlID0ge1xuICAgICAgICAgICAgICAgIGNvb3JkczogY29vcmRzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0VGlsZShjb29yZHMsIHRpbGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICBkb25lKG51bGwsIHRpbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGlsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYWRkVGlsZTogZnVuY3Rpb24oY29vcmRzKSB7XG5cbiAgICAgICAgICAgIGxldCB0aWxlID0gdGhpcy5jcmVhdGVUaWxlKGNvb3JkcywgTC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzKSk7XG4gICAgICAgICAgICBsZXQga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG4gICAgICAgICAgICB0aGlzLl90aWxlc1trZXldID0gdGlsZTtcblxuICAgICAgICAgICAgLy8gQGV2ZW50IHRpbGVsb2Fkc3RhcnQ6IFRpbGVFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVxdWVzdGVkIGFuZCBzdGFydHMgbG9hZGluZy5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZWxvYWRzdGFydCcsIHtcbiAgICAgICAgICAgICAgICBjb29yZHM6IGNvb3Jkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3RpbGVSZWFkeTogZnVuY3Rpb24oY29vcmRzLCBlcnIsIHRpbGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIC8vIEBldmVudCB0aWxlZXJyb3I6IFRpbGVFcnJvckV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBsb2FkaW5nIGEgdGlsZS5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGVlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICAgICAgdGlsZTogdGlsZSxcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzOiBjb29yZHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRpbGUgbG9hZGVkXG4gICAgICAgICAgICB0aWxlLmxvYWRlZCA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdGlsZS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcHJ1bmVUaWxlcygpO1xuXG4gICAgICAgICAgICAvLyBAZXZlbnQgdGlsZWxvYWQ6IFRpbGVFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIHRpbGUgbG9hZHMuXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGVsb2FkJywge1xuICAgICAgICAgICAgICAgIGNvb3JkczogY29vcmRzLFxuICAgICAgICAgICAgICAgIHRpbGU6IHRpbGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fbm9UaWxlc1RvTG9hZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIEBldmVudCBsb2FkOiBFdmVudFxuICAgICAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgbG9hZGVkIGFsbCB2aXNpYmxlIHRpbGVzLlxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbG9hZCcpO1xuICAgICAgICAgICAgICAgIGlmIChMLkJyb3dzZXIuaWVsdDkgfHwgIXRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gdHJpZ2dlciBhIHBydW5pbmcuXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpLCAyNTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkNhY2hlSGl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DYWNoZUxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfSxcblxuICAgICAgICBvbkV4dHJlbWFDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNhY2hlVW5sb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBPdmVybGF5O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IGVzcGVyID0gcmVxdWlyZSgnZXNwZXInKTtcbiAgICBsZXQgT3ZlcmxheSA9IHJlcXVpcmUoJy4vT3ZlcmxheScpO1xuXG4gICAgbGV0IFdlYkdMID0gT3ZlcmxheS5leHRlbmQoe1xuXG4gICAgICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgIE92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgICAgIG1hcC5vbignem9vbXN0YXJ0JywgdGhpcy5vblpvb21TdGFydCwgdGhpcyk7XG4gICAgICAgICAgICBtYXAub24oJ3pvb21lbmQnLCB0aGlzLm9uWm9vbUVuZCwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25SZW1vdmU6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgT3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgbWFwLm9mZignem9vbXN0YXJ0JywgdGhpcy5vblpvb21TdGFydCwgdGhpcyk7XG4gICAgICAgICAgICBtYXAub2ZmKCd6b29tZW5kJywgdGhpcy5vblpvb21FbmQsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uWm9vbVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzWm9vbWluZyA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25ab29tRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzWm9vbWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGdsID0gdGhpcy5fZ2w7XG4gICAgICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGcmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIE92ZXJsYXkucHJvdG90eXBlLl9pbml0Q29udGFpbmVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2dsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdEdMKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2lzWm9vbWluZyA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uV2ViR0xJbml0OiBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBkb25lKG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0R0w6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGV0IGdsID0gdGhpcy5fZ2wgPSBlc3Blci5XZWJHTENvbnRleHQuZ2V0KHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlzc2luZyBjb250ZXh0XG4gICAgICAgICAgICBpZiAoIWdsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1VuYWJsZSB0byBhY3F1aXJlIGEgV2ViR0wgY29udGV4dCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbml0IHRoZSB3ZWJnbCBzdGF0ZVxuICAgICAgICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkUpO1xuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAgICAgICAgIC8vIGdldCBtYXAgc2l6ZVxuICAgICAgICAgICAgbGV0IHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgbGV0IGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgICAgIC8vIHNldCB2aWV3cG9ydCBzaXplXG4gICAgICAgICAgICB0aGlzLl92aWV3cG9ydCA9IG5ldyBlc3Blci5WaWV3cG9ydCh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHNpemUueCAqIGRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzaXplLnkgKiBkZXZpY2VQaXhlbFJhdGlvXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHNldCBjYW52YXMgc2l6ZVxuICAgICAgICAgICAgdGhpcy5fZ2wuY2FudmFzLnN0eWxlLndpZHRoID0gc2l6ZS54ICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuX2dsLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuICAgICAgICAgICAgLy8gd2ViZ2wgaW5pdCBjYWxsYmFja1xuICAgICAgICAgICAgdGhpcy5vbldlYkdMSW5pdChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZsYWcgYXMgcmVhZHlcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgZHJhdyBsb29wXG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhdygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VHJhbnNsYXRpb25NYXRyaXg6IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICAgICAgICAgIGxldCBtYXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICAgICAgICAgIG1hdFswXSA9IDE7XG4gICAgICAgICAgICBtYXRbMV0gPSAwO1xuICAgICAgICAgICAgbWF0WzJdID0gMDtcbiAgICAgICAgICAgIG1hdFszXSA9IDA7XG4gICAgICAgICAgICBtYXRbNF0gPSAwO1xuICAgICAgICAgICAgbWF0WzVdID0gMTtcbiAgICAgICAgICAgIG1hdFs2XSA9IDA7XG4gICAgICAgICAgICBtYXRbN10gPSAwO1xuICAgICAgICAgICAgbWF0WzhdID0gMDtcbiAgICAgICAgICAgIG1hdFs5XSA9IDA7XG4gICAgICAgICAgICBtYXRbMTBdID0gMTtcbiAgICAgICAgICAgIG1hdFsxMV0gPSAwO1xuICAgICAgICAgICAgbWF0WzEyXSA9IHg7XG4gICAgICAgICAgICBtYXRbMTNdID0geTtcbiAgICAgICAgICAgIG1hdFsxNF0gPSB6O1xuICAgICAgICAgICAgbWF0WzE1XSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gbWF0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldE9ydGhvTWF0cml4OiBmdW5jdGlvbihsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgICAgICAgICAgbGV0IG1hdCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgICAgICAgICAgbWF0WzBdID0gMiAvIChyaWdodCAtIGxlZnQpO1xuICAgICAgICAgICAgbWF0WzFdID0gMDtcbiAgICAgICAgICAgIG1hdFsyXSA9IDA7XG4gICAgICAgICAgICBtYXRbM10gPSAwO1xuICAgICAgICAgICAgbWF0WzRdID0gMDtcbiAgICAgICAgICAgIG1hdFs1XSA9IDIgLyAodG9wIC0gYm90dG9tKTtcbiAgICAgICAgICAgIG1hdFs2XSA9IDA7XG4gICAgICAgICAgICBtYXRbN10gPSAwO1xuICAgICAgICAgICAgbWF0WzhdID0gMDtcbiAgICAgICAgICAgIG1hdFs5XSA9IDA7XG4gICAgICAgICAgICBtYXRbMTBdID0gLTIgLyAoZmFyIC0gbmVhcik7XG4gICAgICAgICAgICBtYXRbMTFdID0gMDtcbiAgICAgICAgICAgIG1hdFsxMl0gPSAtKChyaWdodCArIGxlZnQpIC8gKHJpZ2h0IC0gbGVmdCkpO1xuICAgICAgICAgICAgbWF0WzEzXSA9IC0oKHRvcCArIGJvdHRvbSkgLyAodG9wIC0gYm90dG9tKSk7XG4gICAgICAgICAgICBtYXRbMTRdID0gLSgoZmFyICsgbmVhcikgLyAoZmFyIC0gbmVhcikpO1xuICAgICAgICAgICAgbWF0WzE1XSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gbWF0O1xuICAgICAgICB9LFxuXG4gICAgICAgIF9wb3NpdGlvbkNvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuX21hcC5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICAgICAgLy8gc2V0IHZpZXdwb3J0IHNpemVcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0LnJlc2l6ZShcbiAgICAgICAgICAgICAgICBzaXplLnggKiBkZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgIHNpemUueSAqIGRldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgLy8gc2V0IGNhbnZhcyBzaXplXG4gICAgICAgICAgICB0aGlzLl9nbC5jYW52YXMuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5fZ2wuY2FudmFzLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG4gICAgICAgICAgICAvLyByZS1wb3NpdGlvbiBjb250YWluZXJcbiAgICAgICAgICAgIGxldCB0b3BMZWZ0ID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KFswLCAwXSk7XG4gICAgICAgICAgICBMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWFwICYmIHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGlkZGVuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmUtcG9zaXRpb24gY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNab29taW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbiB0aGUgY29udGFpbmVyIGFuZCByZXNpemUgdmlld3BvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uQ29udGFpbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuX2dsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHRoZSBmcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGcmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9kcmF3LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlckZyYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGltcGxlbWVudCB0aGlzXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBXZWJHTDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBDb3JlID0ge1xuICAgICAgICBIVE1MOiByZXF1aXJlKCcuL2NvcmUvSFRNTCcpLFxuICAgICAgICBXZWJHTDogcmVxdWlyZSgnLi9jb3JlL1dlYkdMJyksXG4gICAgICAgIENhbnZhczogcmVxdWlyZSgnLi9jb3JlL0NhbnZhcycpXG4gICAgfTtcblxuICAgIC8vIGNhbnZhcyByZW5kZXJlcnNcbiAgICBsZXQgQ2FudmFzID0ge1xuICAgICAgICBIZWF0bWFwOiByZXF1aXJlKCcuL3R5cGUvY2FudmFzL0hlYXRtYXAnKSxcbiAgICAgICAgVG9wVHJhaWxzOiByZXF1aXJlKCcuL3R5cGUvY2FudmFzL1RvcFRyYWlscycpLFxuICAgICAgICBQcmV2aWV3OiByZXF1aXJlKCcuL3R5cGUvY2FudmFzL1ByZXZpZXcnKVxuICAgIH07XG5cbiAgICAvLyBodG1sIHJlbmRlcmVyc1xuICAgIGxldCBIVE1MID0ge1xuICAgICAgICBFbXB0eTogcmVxdWlyZSgnLi90eXBlL2h0bWwvRW1wdHknKSxcbiAgICAgICAgSGVhdG1hcDogcmVxdWlyZSgnLi90eXBlL2h0bWwvSGVhdG1hcCcpLFxuICAgICAgICBSaW5nOiByZXF1aXJlKCcuL3R5cGUvaHRtbC9SaW5nJyksXG4gICAgICAgIFdvcmRDbG91ZDogcmVxdWlyZSgnLi90eXBlL2h0bWwvV29yZENsb3VkJyksXG4gICAgICAgIFdvcmRIaXN0b2dyYW06IHJlcXVpcmUoJy4vdHlwZS9odG1sL1dvcmRIaXN0b2dyYW0nKSxcbiAgICAgICAgQ29tbXVuaXR5OiByZXF1aXJlKCcuL3R5cGUvaHRtbC9Db21tdW5pdHknKSxcbiAgICAgICAgQ29tbXVuaXR5TGFiZWw6IHJlcXVpcmUoJy4vdHlwZS9odG1sL0NvbW11bml0eUxhYmVsJylcbiAgICB9O1xuXG4gICAgLy8gd2ViZ2wgcmVuZGVyZXJzXG4gICAgbGV0IFdlYkdMID0ge1xuICAgICAgICBIZWF0bWFwOiByZXF1aXJlKCcuL3R5cGUvd2ViZ2wvSGVhdG1hcCcpLFxuICAgICAgICBQb2ludDogcmVxdWlyZSgnLi90eXBlL3dlYmdsL1BvaW50JylcbiAgICB9O1xuXG4gICAgLy8gcGVuZGluZyBsYXllciByZW5kZXJlcnNcbiAgICBsZXQgUGVuZGluZyA9IHtcbiAgICAgICAgRGVsYXllZEJsaW5rOiByZXF1aXJlKCcuL3R5cGUvcGVuZGluZy9EZWxheWVkQmxpbmsnKSxcbiAgICAgICAgRGVsYXllZFNwaW46IHJlcXVpcmUoJy4vdHlwZS9wZW5kaW5nL0RlbGF5ZWRTcGluJyksXG4gICAgICAgIEJsaW5rOiByZXF1aXJlKCcuL3R5cGUvcGVuZGluZy9CbGluaycpLFxuICAgICAgICBTcGluOiByZXF1aXJlKCcuL3R5cGUvcGVuZGluZy9TcGluJyksXG4gICAgICAgIEJsaW5rU3BpbjogcmVxdWlyZSgnLi90eXBlL3BlbmRpbmcvQmxpbmtTcGluJylcbiAgICB9O1xuXG4gICAgLy8gcGVuZGluZyBsYXllciByZW5kZXJlcnNcbiAgICBsZXQgRGVidWcgPSB7XG4gICAgICAgIENvb3JkOiByZXF1aXJlKCcuL3R5cGUvZGVidWcvQ29vcmQnKVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgQ29yZTogQ29yZSxcbiAgICAgICAgSFRNTDogSFRNTCxcbiAgICAgICAgQ2FudmFzOiBDYW52YXMsXG4gICAgICAgIFdlYkdMOiBXZWJHTCxcbiAgICAgICAgRGVidWc6IERlYnVnLFxuICAgICAgICBQZW5kaW5nOiBQZW5kaW5nXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBOVU1fR1JBRElFTlRfU1RFUFMgPSAxMDA7XG5cbiAgICBmdW5jdGlvbiByZ2IybGFiKHJnYikge1xuICAgICAgICBsZXQgciA9IHJnYlswXSA+IDAuMDQwNDUgPyBNYXRoLnBvdygocmdiWzBdICsgMC4wNTUpIC8gMS4wNTUsIDIuNCkgOiByZ2JbMF0gLyAxMi45MjtcbiAgICAgICAgbGV0IGcgPSByZ2JbMV0gPiAwLjA0MDQ1ID8gTWF0aC5wb3coKHJnYlsxXSArIDAuMDU1KSAvIDEuMDU1LCAyLjQpIDogcmdiWzFdIC8gMTIuOTI7XG4gICAgICAgIGxldCBiID0gcmdiWzJdID4gMC4wNDA0NSA/IE1hdGgucG93KChyZ2JbMl0gKyAwLjA1NSkgLyAxLjA1NSwgMi40KSA6IHJnYlsyXSAvIDEyLjkyO1xuICAgICAgICAvL09ic2VydmVyLiA9IDLCsCwgSWxsdW1pbmFudCA9IEQ2NVxuICAgICAgICBsZXQgeCA9IHIgKiAwLjQxMjQ1NjQgKyBnICogMC4zNTc1NzYxICsgYiAqIDAuMTgwNDM3NTtcbiAgICAgICAgbGV0IHkgPSByICogMC4yMTI2NzI5ICsgZyAqIDAuNzE1MTUyMiArIGIgKiAwLjA3MjE3NTA7XG4gICAgICAgIGxldCB6ID0gciAqIDAuMDE5MzMzOSArIGcgKiAwLjExOTE5MjAgKyBiICogMC45NTAzMDQxO1xuICAgICAgICB4ID0geCAvIDAuOTUwNDc7IC8vIE9ic2VydmVyPSAywrAsIElsbHVtaW5hbnQ9IEQ2NVxuICAgICAgICB5ID0geSAvIDEuMDAwMDA7XG4gICAgICAgIHogPSB6IC8gMS4wODg4MztcbiAgICAgICAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEgLyAzKSA6ICg3Ljc4NzAzNyAqIHgpICsgKDE2IC8gMTE2KTtcbiAgICAgICAgeSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEgLyAzKSA6ICg3Ljc4NzAzNyAqIHkpICsgKDE2IC8gMTE2KTtcbiAgICAgICAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEgLyAzKSA6ICg3Ljc4NzAzNyAqIHopICsgKDE2IC8gMTE2KTtcbiAgICAgICAgcmV0dXJuIFsoMTE2ICogeSkgLSAxNixcbiAgICAgICAgICAgIDUwMCAqICh4IC0geSksXG4gICAgICAgICAgICAyMDAgKiAoeSAtIHopLFxuICAgICAgICAgICAgcmdiWzNdXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsYWIycmdiKGxhYikge1xuICAgICAgICBsZXQgeSA9IChsYWJbMF0gKyAxNikgLyAxMTY7XG4gICAgICAgIGxldCB4ID0geSArIGxhYlsxXSAvIDUwMDtcbiAgICAgICAgbGV0IHogPSB5IC0gbGFiWzJdIC8gMjAwO1xuICAgICAgICB4ID0geCA+IDAuMjA2ODkzMDM0ID8geCAqIHggKiB4IDogKHggLSA0IC8gMjkpIC8gNy43ODcwMzc7XG4gICAgICAgIHkgPSB5ID4gMC4yMDY4OTMwMzQgPyB5ICogeSAqIHkgOiAoeSAtIDQgLyAyOSkgLyA3Ljc4NzAzNztcbiAgICAgICAgeiA9IHogPiAwLjIwNjg5MzAzNCA/IHogKiB6ICogeiA6ICh6IC0gNCAvIDI5KSAvIDcuNzg3MDM3O1xuICAgICAgICB4ID0geCAqIDAuOTUwNDc7IC8vIE9ic2VydmVyPSAywrAsIElsbHVtaW5hbnQ9IEQ2NVxuICAgICAgICB5ID0geSAqIDEuMDAwMDA7XG4gICAgICAgIHogPSB6ICogMS4wODg4MztcbiAgICAgICAgbGV0IHIgPSB4ICogMy4yNDA0NTQyICsgeSAqIC0xLjUzNzEzODUgKyB6ICogLTAuNDk4NTMxNDtcbiAgICAgICAgbGV0IGcgPSB4ICogLTAuOTY5MjY2MCArIHkgKiAxLjg3NjAxMDggKyB6ICogMC4wNDE1NTYwO1xuICAgICAgICBsZXQgYiA9IHggKiAwLjA1NTY0MzQgKyB5ICogLTAuMjA0MDI1OSArIHogKiAxLjA1NzIyNTI7XG4gICAgICAgIHIgPSByID4gMC4wMDMwNCA/IDEuMDU1ICogTWF0aC5wb3cociwgMSAvIDIuNCkgLSAwLjA1NSA6IDEyLjkyICogcjtcbiAgICAgICAgZyA9IGcgPiAwLjAwMzA0ID8gMS4wNTUgKiBNYXRoLnBvdyhnLCAxIC8gMi40KSAtIDAuMDU1IDogMTIuOTIgKiBnO1xuICAgICAgICBiID0gYiA+IDAuMDAzMDQgPyAxLjA1NSAqIE1hdGgucG93KGIsIDEgLyAyLjQpIC0gMC4wNTUgOiAxMi45MiAqIGI7XG4gICAgICAgIHJldHVybiBbTWF0aC5tYXgoTWF0aC5taW4ociwgMSksIDApLCBNYXRoLm1heChNYXRoLm1pbihnLCAxKSwgMCksIE1hdGgubWF4KE1hdGgubWluKGIsIDEpLCAwKSwgbGFiWzNdXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXN0YW5jZShjMSwgYzIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgICAgICAgIChjMVswXSAtIGMyWzBdKSAqIChjMVswXSAtIGMyWzBdKSArXG4gICAgICAgICAgICAoYzFbMV0gLSBjMlsxXSkgKiAoYzFbMV0gLSBjMlsxXSkgK1xuICAgICAgICAgICAgKGMxWzJdIC0gYzJbMl0pICogKGMxWzJdIC0gYzJbMl0pICtcbiAgICAgICAgICAgIChjMVszXSAtIGMyWzNdKSAqIChjMVszXSAtIGMyWzNdKSk7XG4gICAgfVxuXG4gICAgbGV0IGJ1aWxkRmxhdExvb2t1cFRhYmxlID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5VTV9HUkFESUVOVF9TVEVQUzsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChjb2xvclswXSk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChjb2xvclsxXSk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChjb2xvclsyXSk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChjb2xvclszXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG4gICAgLy8gSW50ZXJwb2xhdGUgYmV0d2VlbiBhIHNldCBvZiBjb2xvcnMgdXNpbmcgZXZlbiBwZXJjZXB0dWFsIGRpc3RhbmNlIGFuZCBpbnRlcnBvbGF0aW9uIGluIENJRSBMKmEqYiogc3BhY2VcbiAgICBsZXQgYnVpbGRQZXJjZXB0dWFsTG9va3VwVGFibGUgPSBmdW5jdGlvbihiYXNlQ29sb3JzKSB7XG4gICAgICAgIGxldCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoTlVNX0dSQURJRU5UX1NURVBTICogNCAqIDQpO1xuICAgICAgICBsZXQgb3V0cHV0R3JhZGllbnQgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBwZXJjZXB0dWFsIHNwcmVhZCBpbiBMKmEqYiogc3BhY2VcbiAgICAgICAgbGV0IGxhYnMgPSBfLm1hcChiYXNlQ29sb3JzLCBjb2xvciA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmdiMmxhYihbY29sb3JbMF0gLyAyNTUsIGNvbG9yWzFdIC8gMjU1LCBjb2xvclsyXSAvIDI1NSwgY29sb3JbM10gLyAyNTVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBkaXN0YW5jZXMgPSBfLm1hcChsYWJzLCAoY29sb3IsIGluZGV4LCBjb2xvcnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleCA+IDAgPyBkaXN0YW5jZShjb2xvciwgY29sb3JzW2luZGV4IC0gMV0pIDogMDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBjdW11bGF0aXZlIGRpc3RhbmNlcyBpbiBbMCwxXVxuICAgICAgICBsZXQgdG90YWxEaXN0YW5jZSA9IF8ucmVkdWNlKGRpc3RhbmNlcywgKGEsIGIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhICsgYjtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGRpc3RhbmNlcyA9IF8ubWFwKGRpc3RhbmNlcywgZCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZCAvIHRvdGFsRGlzdGFuY2U7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZGlzdGFuY2VUcmF2ZXJzZWQgPSAwO1xuICAgICAgICBsZXQga2V5ID0gMDtcbiAgICAgICAgbGV0IHByb2dyZXNzO1xuICAgICAgICBsZXQgc3RlcFByb2dyZXNzO1xuICAgICAgICBsZXQgcmdiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5VTV9HUkFESUVOVF9TVEVQUzsgaSsrKSB7XG4gICAgICAgICAgICBwcm9ncmVzcyA9IGkgLyAoTlVNX0dSQURJRU5UX1NURVBTIC0gMSk7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3MgPiBkaXN0YW5jZVRyYXZlcnNlZCArIGRpc3RhbmNlc1trZXkgKyAxXSAmJiBrZXkgKyAxIDwgbGFicy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAga2V5ICs9IDE7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VUcmF2ZXJzZWQgKz0gZGlzdGFuY2VzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGVwUHJvZ3Jlc3MgPSAocHJvZ3Jlc3MgLSBkaXN0YW5jZVRyYXZlcnNlZCkgLyBkaXN0YW5jZXNba2V5ICsgMV07XG4gICAgICAgICAgICByZ2IgPSBsYWIycmdiKFtcbiAgICAgICAgICAgICAgICBsYWJzW2tleV1bMF0gKyAobGFic1trZXkgKyAxXVswXSAtIGxhYnNba2V5XVswXSkgKiBzdGVwUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbGFic1trZXldWzFdICsgKGxhYnNba2V5ICsgMV1bMV0gLSBsYWJzW2tleV1bMV0pICogc3RlcFByb2dyZXNzLFxuICAgICAgICAgICAgICAgIGxhYnNba2V5XVsyXSArIChsYWJzW2tleSArIDFdWzJdIC0gbGFic1trZXldWzJdKSAqIHN0ZXBQcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBsYWJzW2tleV1bM10gKyAobGFic1trZXkgKyAxXVszXSAtIGxhYnNba2V5XVszXSkgKiBzdGVwUHJvZ3Jlc3NcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgb3V0cHV0R3JhZGllbnRbaSAqIDRdID0gcmdiWzBdO1xuICAgICAgICAgICAgb3V0cHV0R3JhZGllbnRbaSAqIDQgKyAxXSA9IHJnYlsxXTtcbiAgICAgICAgICAgIG91dHB1dEdyYWRpZW50W2kgKiA0ICsgMl0gPSByZ2JbMl07XG4gICAgICAgICAgICBvdXRwdXRHcmFkaWVudFtpICogNCArIDNdID0gcmdiWzNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXRHcmFkaWVudDtcbiAgICB9O1xuXG4gICAgbGV0IENPT0wgPSBidWlsZFBlcmNlcHR1YWxMb29rdXBUYWJsZShbXG4gICAgICAgIFsweDA0LCAweDIwLCAweDQwLCAweDUwXSxcbiAgICAgICAgWzB4MDgsIDB4NDAsIDB4ODEsIDB4N2ZdLFxuICAgICAgICBbMHgwOCwgMHg2OCwgMHhhYywgMHhmZl0sXG4gICAgICAgIFsweDJiLCAweDhjLCAweGJlLCAweGZmXSxcbiAgICAgICAgWzB4NGUsIDB4YjMsIDB4ZDMsIDB4ZmZdLFxuICAgICAgICBbMHg3YiwgMHhjYywgMHhjNCwgMHhmZl0sXG4gICAgICAgIFsweGE4LCAweGRkLCAweGI1LCAweGZmXSxcbiAgICAgICAgWzB4Y2MsIDB4ZWIsIDB4YzUsIDB4ZmZdLFxuICAgICAgICBbMHhlMCwgMHhmMywgMHhkYiwgMHhmZl0sXG4gICAgICAgIFsweGY3LCAweGZjLCAweGYwLCAweGZmXVxuICAgIF0pO1xuXG4gICAgbGV0IEhPVCA9IGJ1aWxkUGVyY2VwdHVhbExvb2t1cFRhYmxlKFtcbiAgICAgICAgWzB4NDAsIDB4MDAsIDB4MTMsIDB4NTBdLFxuICAgICAgICBbMHg4MCwgMHgwMCwgMHgyNiwgMHg3Zl0sXG4gICAgICAgIFsweGJkLCAweDAwLCAweDI2LCAweGZmXSxcbiAgICAgICAgWzB4ZTMsIDB4MWEsIDB4MWMsIDB4ZmZdLFxuICAgICAgICBbMHhmYywgMHg0ZSwgMHgyYSwgMHhmZl0sXG4gICAgICAgIFsweGZkLCAweDhkLCAweDNjLCAweGZmXSxcbiAgICAgICAgWzB4ZmUsIDB4YjIsIDB4NGMsIDB4ZmZdLFxuICAgICAgICBbMHhmZSwgMHhkOSwgMHg3NiwgMHhmZl0sXG4gICAgICAgIFsweGZmLCAweGVkLCAweGEwLCAweGZmXVxuICAgIF0pO1xuXG4gICAgbGV0IFZFUkRBTlQgPSBidWlsZFBlcmNlcHR1YWxMb29rdXBUYWJsZShbXG4gICAgICAgIFsweDAwLCAweDQwLCAweDI2LCAweDUwXSxcbiAgICAgICAgWzB4MDAsIDB4NWEsIDB4MzIsIDB4N2ZdLFxuICAgICAgICBbMHgyMywgMHg4NCwgMHg0MywgMHhmZl0sXG4gICAgICAgIFsweDQxLCAweGFiLCAweDVkLCAweGZmXSxcbiAgICAgICAgWzB4NzgsIDB4YzYsIDB4NzksIDB4ZmZdLFxuICAgICAgICBbMHhhZCwgMHhkZCwgMHg4ZSwgMHhmZl0sXG4gICAgICAgIFsweGQ5LCAweGYwLCAweGEzLCAweGZmXSxcbiAgICAgICAgWzB4ZjcsIDB4ZmMsIDB4YjksIDB4ZmZdLFxuICAgICAgICBbMHhmZiwgMHhmZiwgMHhlNSwgMHhmZl1cbiAgICBdKTtcblxuICAgIGxldCBTUEVDVFJBTCA9IGJ1aWxkUGVyY2VwdHVhbExvb2t1cFRhYmxlKFtcbiAgICAgICAgWzB4MjYsIDB4MWEsIDB4NDAsIDB4NTBdLFxuICAgICAgICBbMHg0NCwgMHgyZiwgMHg3MiwgMHg3Zl0sXG4gICAgICAgIFsweGUxLCAweDJiLCAweDAyLCAweGZmXSxcbiAgICAgICAgWzB4MDIsIDB4ZGMsIDB4MDEsIDB4ZmZdLFxuICAgICAgICBbMHhmZiwgMHhkMiwgMHgwMiwgMHhmZl0sXG4gICAgICAgIFsweGZmLCAweGZmLCAweGZmLCAweGZmXVxuICAgIF0pO1xuXG4gICAgbGV0IFRFTVBFUkFUVVJFID0gYnVpbGRQZXJjZXB0dWFsTG9va3VwVGFibGUoW1xuICAgICAgICBbMHgwMCwgMHgxNiwgMHg0MCwgMHg1MF0sXG4gICAgICAgIFsweDAwLCAweDM5LCAweDY2LCAweDdmXSxcbiAgICAgICAgWzB4MzEsIDB4M2QsIDB4NjYsIDB4ZmZdLFxuICAgICAgICBbMHhlMSwgMHgyYiwgMHgwMiwgMHhmZl0sXG4gICAgICAgIFsweGZmLCAweGQyLCAweDAyLCAweGZmXSxcbiAgICAgICAgWzB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmZdXG4gICAgXSk7XG5cbiAgICBsZXQgR1JFWVNDQUxFID0gYnVpbGRQZXJjZXB0dWFsTG9va3VwVGFibGUoW1xuICAgICAgICBbMHgwMCwgMHgwMCwgMHgwMCwgMHg3Zl0sXG4gICAgICAgIFsweDQwLCAweDQwLCAweDQwLCAweGZmXSxcbiAgICAgICAgWzB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmZdXG4gICAgXSk7XG5cbiAgICBsZXQgUE9MQVJfSE9UID0gYnVpbGRQZXJjZXB0dWFsTG9va3VwVGFibGUoW1xuICAgICAgICBbIDB4ZmYsIDB4NDQsIDB4MDAsIDB4ZmYgXSxcbiAgICAgICAgWyAweGJkLCAweGJkLCAweGJkLCAweGIwIF1cbiAgICBdKTtcblxuICAgIGxldCBQT0xBUl9DT0xEID0gYnVpbGRQZXJjZXB0dWFsTG9va3VwVGFibGUoW1xuICAgICAgICBbIDB4YmQsIDB4YmQsIDB4YmQsIDB4YjAgXSxcbiAgICAgICAgWyAweDMyLCAweGE1LCAweGY5LCAweGZmIF1cbiAgICBdKTtcblxuICAgIGxldCBGSVJFID0gYnVpbGRQZXJjZXB0dWFsTG9va3VwVGFibGUoW1xuICAgICAgICBbMHg5NiwgMHgwMCwgMHgwMCwgMHg5Nl0sXG4gICAgICAgIFsweGZmLCAweGZmLCAweDMyLCAweGZmXVxuICAgIF0pO1xuXG4gICAgbGV0IEZMQVQgPSBidWlsZEZsYXRMb29rdXBUYWJsZShbMHhmZiwgMHhmZiwgMHhmZiwgMHhmZl0pO1xuXG4gICAgbGV0IGJ1aWxkTG9va3VwRnVuY3Rpb24gPSBmdW5jdGlvbihSQU1QKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzY2FsZWRWYWx1ZSwgaW5Db2xvcikge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gTWF0aC5mbG9vcihzY2FsZWRWYWx1ZSAqIChOVU1fR1JBRElFTlRfU1RFUFMgLSAxKSk7XG4gICAgICAgICAgICBpbkNvbG9yWzBdID0gUkFNUFtpbmRleCAqIDRdO1xuICAgICAgICAgICAgaW5Db2xvclsxXSA9IFJBTVBbaW5kZXggKiA0ICsgMV07XG4gICAgICAgICAgICBpbkNvbG9yWzJdID0gUkFNUFtpbmRleCAqIDQgKyAyXTtcbiAgICAgICAgICAgIGluQ29sb3JbM10gPSBSQU1QW2luZGV4ICogNCArIDNdO1xuICAgICAgICAgICAgcmV0dXJuIGluQ29sb3I7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGxldCBjb25jYXQgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIGxldCBjb21iaW5lZCA9IG5ldyBGbG9hdDMyQXJyYXkoYS5sZW5ndGggKyBiLmxlbmd0aCk7XG4gICAgICAgIGNvbWJpbmVkLnNldChhLCAwKTtcbiAgICAgICAgY29tYmluZWQuc2V0KGIsIGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkO1xuICAgIH07XG5cbiAgICBsZXQgQ29sb3JUYWJsZXMgPSB7XG4gICAgICAgIGNvb2w6IENPT0wsXG4gICAgICAgIGhvdDogSE9ULFxuICAgICAgICB2ZXJkYW50OiBWRVJEQU5ULFxuICAgICAgICBzcGVjdHJhbDogU1BFQ1RSQUwsXG4gICAgICAgIHRlbXBlcmF0dXJlOiBURU1QRVJBVFVSRSxcbiAgICAgICAgZ3JleTogR1JFWVNDQUxFLFxuICAgICAgICBwb2xhcjogY29uY2F0KFBPTEFSX0hPVCwgUE9MQVJfQ09MRCksXG4gICAgICAgIGZsYXQ6IEZMQVRcbiAgICB9O1xuXG4gICAgbGV0IENvbG9yUmFtcCA9IHtcbiAgICAgICAgY29vbDogYnVpbGRMb29rdXBGdW5jdGlvbihDT09MKSxcbiAgICAgICAgaG90OiBidWlsZExvb2t1cEZ1bmN0aW9uKEhPVCksXG4gICAgICAgIHZlcmRhbnQ6IGJ1aWxkTG9va3VwRnVuY3Rpb24oVkVSREFOVCksXG4gICAgICAgIHNwZWN0cmFsOiBidWlsZExvb2t1cEZ1bmN0aW9uKFNQRUNUUkFMKSxcbiAgICAgICAgdGVtcGVyYXR1cmU6IGJ1aWxkTG9va3VwRnVuY3Rpb24oVEVNUEVSQVRVUkUpLFxuICAgICAgICBncmV5OiBidWlsZExvb2t1cEZ1bmN0aW9uKEdSRVlTQ0FMRSksXG4gICAgICAgIGZpcmU6IGJ1aWxkTG9va3VwRnVuY3Rpb24oRklSRSksXG4gICAgICAgIHBvbGFyOiBidWlsZExvb2t1cEZ1bmN0aW9uKGNvbmNhdChQT0xBUl9IT1QsIFBPTEFSX0NPTEQpKSxcbiAgICAgICAgZmxhdDogYnVpbGRMb29rdXBGdW5jdGlvbihGTEFUKVxuICAgIH07XG5cbiAgICBsZXQgc2V0Q29sb3JSYW1wID0gZnVuY3Rpb24odHlwZSwgYmFzZUNvbG9ycykge1xuICAgICAgICBsZXQgZnVuYyA9IENvbG9yUmFtcFt0eXBlLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgdGhpcy5fY29sb3JSYW1wID0gZnVuYztcbiAgICAgICAgfSBlbHNlIGlmIChiYXNlQ29sb3JzKSB7XG4gICAgICAgICAgICBDb2xvclJhbXBbdHlwZS50b0xvd2VyQ2FzZSgpXSA9IGJ1aWxkTG9va3VwRnVuY3Rpb24oYnVpbGRQZXJjZXB0dWFsTG9va3VwVGFibGUoYmFzZUNvbG9ycykpO1xuICAgICAgICAgICAgdGhpcy5fY29sb3JSYW1wID0gQ29sb3JSYW1wW3R5cGUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NvbG9yUmFtcFR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBsZXQgZ2V0Q29sb3JSYW1wID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JSYW1wIHx8IENvbG9yUmFtcFt0eXBlLnRvTG93ZXJDYXNlKCldO1xuICAgIH07XG5cbiAgICBsZXQgZ2V0Q29sb3JSYW1wVGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIENvbG9yVGFibGVzW3RoaXMuX2NvbG9yUmFtcFR5cGVdO1xuICAgIH07XG5cbiAgICBsZXQgaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jb2xvclJhbXAgPSBDb2xvclJhbXAudmVyZGFudDtcbiAgICAgICAgdGhpcy5fY29sb3JSYW1wVHlwZSA9ICd2ZXJkYW50JztcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGluaXRpYWxpemU6IGluaXRpYWxpemUsXG4gICAgICAgIHNldENvbG9yUmFtcDogc2V0Q29sb3JSYW1wLFxuICAgICAgICBnZXRDb2xvclJhbXA6IGdldENvbG9yUmFtcCxcbiAgICAgICAgZ2V0Q29sb3JSYW1wVGFibGU6IGdldENvbG9yUmFtcFRhYmxlLFxuICAgICAgICBOVU1fR1JBRElFTlRfU1RFUFM6IE5VTV9HUkFESUVOVF9TVEVQU1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgVElMRV9TSVpFID0gMjU2O1xuXG4gICAgZnVuY3Rpb24gZnJhY3QoZikge1xuICAgICAgICByZXR1cm4gZiAlIDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9kKG4sIG0pIHtcbiAgICAgICAgcmV0dXJuICgobiAlIG0pICsgbSkgJSBtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEhhc2gobHgsIGx5LCByYWRpdXMpIHtcbiAgICAgICAgbGV0IGRpYW1ldGVyID0gcmFkaXVzICogMjtcbiAgICAgICAgbGV0IHhIYXNoID0gTWF0aC5mbG9vcihseCAvIGRpYW1ldGVyKTtcbiAgICAgICAgbGV0IHlIYXNoID0gTWF0aC5mbG9vcihseSAvIGRpYW1ldGVyKTtcbiAgICAgICAgcmV0dXJuIHhIYXNoICsgJzonICsgeUhhc2g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SGFzaGVzKGx4LCBseSwgcmFkaXVzLCB6b29tKSB7XG4gICAgICAgIGxldCBkaWFtZXRlciA9IHJhZGl1cyAqIDI7XG4gICAgICAgIGxldCBudW1DZWxscyA9IE1hdGguY2VpbCgoTWF0aC5wb3coMiwgem9vbSkgKiBUSUxFX1NJWkUpIC8gZGlhbWV0ZXIpO1xuICAgICAgICBsZXQgeCA9IGx4IC8gZGlhbWV0ZXI7XG4gICAgICAgIGxldCB5ID0gbHkgLyBkaWFtZXRlcjtcbiAgICAgICAgbGV0IGZ4ID0gZnJhY3QoeCk7XG4gICAgICAgIGxldCBmeSA9IGZyYWN0KHkpO1xuICAgICAgICBsZXQgcHggPSBmeCA+IDAuNTtcbiAgICAgICAgbGV0IG54ID0gZnggPCAwLjU7XG4gICAgICAgIGxldCBweSA9IGZ5ID4gMC41O1xuICAgICAgICBsZXQgbnkgPSBmeSA8IDAuNTtcbiAgICAgICAgbGV0IGN4ID0gTWF0aC5mbG9vcih4KTtcbiAgICAgICAgbGV0IGN5ID0gTWF0aC5mbG9vcih5KTtcbiAgICAgICAgbGV0IGNlbGxzID0gW1xuICAgICAgICAgICAgW2N4LCBjeV1cbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHB4KSB7XG4gICAgICAgICAgICBjZWxscy5wdXNoKFtjeCsxLCBjeV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChweSkge1xuICAgICAgICAgICAgY2VsbHMucHVzaChbY3gsIGN5KzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobngpIHtcbiAgICAgICAgICAgIGNlbGxzLnB1c2goW2N4LTEsIGN5XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG55KSB7XG4gICAgICAgICAgICBjZWxscy5wdXNoKFtjeCwgY3ktMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChueCAmJiBueSkge1xuICAgICAgICAgICAgY2VsbHMucHVzaChbY3gtMSwgY3ktMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChweCAmJiBweSkge1xuICAgICAgICAgICAgY2VsbHMucHVzaChbY3grMSwgY3krMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChueCAmJiBweSkge1xuICAgICAgICAgICAgY2VsbHMucHVzaChbY3gtMSwgY3krMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChweCAmJiBueSkge1xuICAgICAgICAgICAgY2VsbHMucHVzaChbY3grMSwgY3ktMV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiBoYXNoZXNcbiAgICAgICAgcmV0dXJuIGNlbGxzLm1hcChjZWxsID0+IHtcbiAgICAgICAgICAgIC8vIG1vZCB0aGUgY2VsbCBjb29yZHMgaWYgdGhleSBvdmVyZmxvd1xuICAgICAgICAgICAgY2VsbFswXSA9IG1vZChjZWxsWzBdLCBudW1DZWxscyk7XG4gICAgICAgICAgICBjZWxsWzFdID0gbW9kKGNlbGxbMV0sIG51bUNlbGxzKTtcbiAgICAgICAgICAgIC8vIGhhc2hcbiAgICAgICAgICAgIHJldHVybiBjZWxsWzBdICsgJzonICsgY2VsbFsxXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2lyY2xlQ29sbGlzaW9uKHBvaW50LCBvcmlnaW4sIHJhZGl1cywgem9vbSkge1xuICAgICAgICBsZXQgZGltID0gTWF0aC5wb3coMiwgem9vbSkgKiBUSUxFX1NJWkU7XG4gICAgICAgIGxldCBwLCBvO1xuICAgICAgICAvLyBjaGVjayBjYXNlcyB3aGVyZSB0aGUgcG9pbnQgaXMgbmVhciB0aGUgb3Bwb3NpbmcgaG9yaXpvbnRhbCBleHRyZW1hXG4gICAgICAgIC8vIG9mIHRoZSBtYXAgYW5kIGVuc3VyZSB0aGF0IHRoZSBkaXN0YW5jZSBjYWxjdWxhdGVkIGlzIHRoZSBzaG9ydGVzdFxuICAgICAgICBpZiAocG9pbnQueCA8IHJhZGl1cyAmJiBkaW0gLSBvcmlnaW4ueCA8IHJhZGl1cykge1xuICAgICAgICAgICAgcCA9IHBvaW50O1xuICAgICAgICAgICAgbyA9IHtcbiAgICAgICAgICAgICAgICB4OiBvcmlnaW4ueCAtIGRpbSxcbiAgICAgICAgICAgICAgICB5OiBvcmlnaW4ueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkaW0gLSBwb2ludC54IDwgcmFkaXVzICYmIG9yaWdpbi54IDwgcmFkaXVzKSB7XG4gICAgICAgICAgICBwID0ge1xuICAgICAgICAgICAgICAgIHg6IHBvaW50LnggLSBkaW0sXG4gICAgICAgICAgICAgICAgeTogcG9pbnQueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG8gPSBvcmlnaW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gcG9pbnQ7XG4gICAgICAgICAgICBvID0gb3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkeCA9IHAueCAtIG8ueDtcbiAgICAgICAgbGV0IGR5ID0gcC55IC0gby55O1xuICAgICAgICBsZXQgZGlzdFNxciA9IChkeCAqIGR4KSArIChkeSAqIGR5KTtcbiAgICAgICAgaWYgKGRpc3RTcXIgPCAocmFkaXVzICogcmFkaXVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJIYXNoKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJIYXNoKCkge1xuICAgICAgICB0aGlzLl9zcGF0aWFsSGFzaCA9IHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFBvaW50KHBvaW50LCByYWRpdXMsIHpvb20pIHtcbiAgICAgICAgLy8gc3BhdGlhbCBoYXNoIGtleVxuICAgICAgICBsZXQgeCA9IHBvaW50Lng7XG4gICAgICAgIGxldCB5ID0gcG9pbnQueTtcbiAgICAgICAgbGV0IGhhc2hlcyA9IGdldEhhc2hlcyh4LCB5LCByYWRpdXMsIHpvb20pO1xuICAgICAgICAvLyBhZGQgcGl4ZWwgdG8gaGFzaFxuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpPTA7IGk8aGFzaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaGFzaCA9IGhhc2hlc1tpXTtcbiAgICAgICAgICAgIHRoaXMuX3NwYXRpYWxIYXNoW2hhc2hdID0gdGhpcy5fc3BhdGlhbEhhc2hbaGFzaF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLl9zcGF0aWFsSGFzaFtoYXNoXS5wdXNoKHBvaW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVBvaW50KHBvaW50LCByYWRpdXMsIHpvb20pIHtcbiAgICAgICAgLy8gc3BhdGlhbCBoYXNoIGtleVxuICAgICAgICBsZXQgaGFzaGVzID0gZ2V0SGFzaGVzKHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgem9vbSk7XG4gICAgICAgIC8vIGFkZCBwaXhlbCB0byBoYXNoXG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGk9MDsgaTxoYXNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBoYXNoID0gaGFzaGVzW2ldO1xuICAgICAgICAgICAgbGV0IHBvaW50cyA9IHRoaXMuX3NwYXRpYWxIYXNoW2hhc2hdO1xuICAgICAgICAgICAgaWYgKHBvaW50cykge1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IHBvaW50cy5pbmRleE9mKHBvaW50KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwaWNrKHBvaW50LCByYWRpdXMsIHpvb20pIHtcbiAgICAgICAgbGV0IGhhc2ggPSBnZXRIYXNoKHBvaW50LngsIHBvaW50LnksIHJhZGl1cyk7XG4gICAgICAgIC8vIGdldCBwb2ludHMgaW4gYmluXG4gICAgICAgIGxldCBwb2ludHMgPSB0aGlzLl9zcGF0aWFsSGFzaFtoYXNoXTtcbiAgICAgICAgaWYgKHBvaW50cykge1xuICAgICAgICAgICAgLy8gZmluZCBmaXJzdCBpbnRlcnNlY3RpbmcgcG9pbnQgaW4gdGhlIGJpblxuICAgICAgICAgICAgbGV0IHAsIGk7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICBpZiAoY2lyY2xlQ29sbGlzaW9uKHBvaW50LCBwLCByYWRpdXMsIHpvb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBmaXJzdCBwb2ludFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgaW5pdGlhbGl6ZTogaW5pdGlhbGl6ZSxcbiAgICAgICAgY2xlYXJIYXNoOiBjbGVhckhhc2gsXG4gICAgICAgIGFkZFBvaW50OiBhZGRQb2ludCxcbiAgICAgICAgcmVtb3ZlUG9pbnQ6IHJlbW92ZVBvaW50LFxuICAgICAgICBwaWNrOiBwaWNrXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBTSUdNT0lEX1NDQUxFID0gMC4xNTtcblxuICAgIC8vIGxvZzEwXG5cbiAgICBmdW5jdGlvbiBsb2cxMFRyYW5zZm9ybSh2YWwsIG1pbiwgbWF4KSB7XG4gICAgICAgIGxldCBsb2dNaW4gPSBNYXRoLmxvZzEwKG1pbiB8fCAxKTtcbiAgICAgICAgbGV0IGxvZ01heCA9IE1hdGgubG9nMTAobWF4IHx8IDEpO1xuICAgICAgICBsZXQgbG9nVmFsID0gTWF0aC5sb2cxMCh2YWwgfHwgMSk7XG4gICAgICAgIHJldHVybiAobG9nVmFsIC0gbG9nTWluKSAvICgobG9nTWF4IC0gbG9nTWluKSB8fCAxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZlcnNlTG9nMTBUcmFuc2Zvcm0obnZhbCwgbWluLCBtYXgpIHtcbiAgICAgICAgbGV0IGxvZ01pbiA9IE1hdGgubG9nMTAobWluIHx8IDEpO1xuICAgICAgICBsZXQgbG9nTWF4ID0gTWF0aC5sb2cxMChtYXggfHwgMSk7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdygxMCwgKG52YWwgKiBsb2dNYXggLSBudmFsICogbG9nTWluKSArIGxvZ01pbik7XG4gICAgfVxuXG4gICAgLy8gc2lnbW9pZFxuXG4gICAgZnVuY3Rpb24gc2lnbW9pZFRyYW5zZm9ybSh2YWwsIG1pbiwgbWF4KSB7XG4gICAgICAgIGxldCBhYnNNaW4gPSBNYXRoLmFicyhtaW4pO1xuICAgICAgICBsZXQgYWJzTWF4ID0gTWF0aC5hYnMobWF4KTtcbiAgICAgICAgbGV0IGRpc3RhbmNlID0gTWF0aC5tYXgoYWJzTWluLCBhYnNNYXgpO1xuICAgICAgICBsZXQgc2NhbGVkVmFsID0gdmFsIC8gKFNJR01PSURfU0NBTEUgKiBkaXN0YW5jZSk7XG4gICAgICAgIHJldHVybiAxIC8gKDEgKyBNYXRoLmV4cCgtc2NhbGVkVmFsKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52ZXJzZVNpZ21vaWRUcmFuc2Zvcm0obnZhbCwgbWluLCBtYXgpIHtcbiAgICAgICAgbGV0IGFic01pbiA9IE1hdGguYWJzKG1pbik7XG4gICAgICAgIGxldCBhYnNNYXggPSBNYXRoLmFicyhtYXgpO1xuICAgICAgICBsZXQgZGlzdGFuY2UgPSBNYXRoLm1heChhYnNNaW4sIGFic01heCk7XG4gICAgICAgIGlmIChudmFsID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLWRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudmFsID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKCgxL252YWwpIC0gMSkgKiAtKFNJR01PSURfU0NBTEUgKiBkaXN0YW5jZSk7XG4gICAgfVxuXG4gICAgLy8gbGluZWFyXG5cbiAgICBmdW5jdGlvbiBsaW5lYXJUcmFuc2Zvcm0odmFsLCBtaW4sIG1heCkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBtYXggLSBtaW47XG4gICAgICAgIGlmIChyYW5nZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh2YWwgLSBtaW4pIC8gcmFuZ2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52ZXJzZUxpbmVhclRyYW5zZm9ybShudmFsLCBtaW4sIG1heCkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBtYXggLSBtaW47XG4gICAgICAgIGlmIChyYW5nZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbiArIG52YWwgKiByYW5nZTtcbiAgICB9XG5cbiAgICBsZXQgVHJhbnNmb3JtID0ge1xuICAgICAgICBsaW5lYXI6IGxpbmVhclRyYW5zZm9ybSxcbiAgICAgICAgbG9nMTA6IGxvZzEwVHJhbnNmb3JtLFxuICAgICAgICBzaWdtb2lkOiBzaWdtb2lkVHJhbnNmb3JtXG4gICAgfTtcblxuICAgIGxldCBJbnZlcnNlID0ge1xuICAgICAgICBsaW5lYXI6IGludmVyc2VMaW5lYXJUcmFuc2Zvcm0sXG4gICAgICAgIGxvZzEwOiBpbnZlcnNlTG9nMTBUcmFuc2Zvcm0sXG4gICAgICAgIHNpZ21vaWQ6IGludmVyc2VTaWdtb2lkVHJhbnNmb3JtXG4gICAgfTtcblxuICAgIGxldCBpbml0aWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JhbmdlID0ge1xuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiAxXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUZ1bmMgPSBsb2cxMFRyYW5zZm9ybTtcbiAgICAgICAgdGhpcy5faW52ZXJzZUZ1bmMgPSBpbnZlcnNlTG9nMTBUcmFuc2Zvcm07XG4gICAgfTtcblxuICAgIGxldCBzZXRUcmFuc2Zvcm1GdW5jID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICBsZXQgZnVuYyA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtRnVuYyA9IFRyYW5zZm9ybVtmdW5jXTtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtVHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX2ludmVyc2VGdW5jID0gSW52ZXJzZVtmdW5jXTtcbiAgICB9O1xuXG4gICAgbGV0IHNldFZhbHVlUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICB0aGlzLl9yYW5nZS5taW4gPSByYW5nZS5taW47XG4gICAgICAgIHRoaXMuX3JhbmdlLm1heCA9IHJhbmdlLm1heDtcbiAgICB9O1xuXG4gICAgbGV0IGdldFZhbHVlUmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhbmdlO1xuICAgIH07XG5cbiAgICBsZXQgZ2V0VHJhbnNmb3JtRW51bSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNmb3JtVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3RyYW5zZm9ybVR5cGUgPT09ICdzaWdtb2lkJykge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcblxuICAgIGxldCBpbnRlcnBvbGF0ZVRvUmFuZ2UgPSBmdW5jdGlvbihudmFsKSB7XG4gICAgICAgIC8vIGludGVycG9sYXRlIGJldHdlZW4gdGhlIGZpbHRlciByYW5nZVxuICAgICAgICBsZXQgck1pbiA9IHRoaXMuX3JhbmdlLm1pbjtcbiAgICAgICAgbGV0IHJNYXggPSB0aGlzLl9yYW5nZS5tYXg7XG4gICAgICAgIGxldCBydmFsID0gKG52YWwgLSByTWluKSAvIChyTWF4IC0gck1pbik7XG4gICAgICAgIC8vIGVuc3VyZSBvdXRwdXQgaXMgWzA6MV1cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHJ2YWwpKTtcbiAgICB9O1xuXG4gICAgbGV0IHRyYW5zZm9ybVZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIC8vIGNsYW1wIHRoZSB2YWx1ZSBiZXR3ZWVuIHRoZSBleHRyZW1lIChzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5KVxuICAgICAgICBsZXQgbWluID0gdGhpcy5fZXh0cmVtYS5taW47XG4gICAgICAgIGxldCBtYXggPSB0aGlzLl9leHRyZW1hLm1heDtcbiAgICAgICAgbGV0IGNsYW1wZWQgPSBNYXRoLm1heChNYXRoLm1pbih2YWwsIG1heCksIG1pbik7XG4gICAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgdmFsdWVcbiAgICAgICAgaWYgKG1pbiAhPT0gbWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtRnVuYyhjbGFtcGVkLCBtaW4sIG1heCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbWluID09PSBtYXgsIGFsd2F5cyByZXR1cm4gMVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9O1xuXG4gICAgbGV0IHVudHJhbnNmb3JtVmFsdWUgPSBmdW5jdGlvbihudmFsKSB7XG4gICAgICAgIGxldCBtaW4gPSB0aGlzLl9leHRyZW1hLm1pbjtcbiAgICAgICAgbGV0IG1heCA9IHRoaXMuX2V4dHJlbWEubWF4O1xuICAgICAgICAvLyBjbGFtcCB0aGUgdmFsdWUgYmV0d2VlbiB0aGUgZXh0cmVtZSAoc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSlcbiAgICAgICAgbGV0IGNsYW1wZWQgPSBNYXRoLm1heChNYXRoLm1pbihudmFsLCAxKSwgMCk7XG4gICAgICAgIC8vIHVubm9ybWFsaXplIHRoZSB2YWx1ZVxuICAgICAgICBpZiAobWluICE9PSBtYXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnZlcnNlRnVuYyhjbGFtcGVkLCBtaW4sIG1heCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbWluID09PSBtYXgsIGFsd2F5cyByZXR1cm4gMVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGluaXRpYWxpemU6IGluaXRpYWxpemUsXG4gICAgICAgIHNldFRyYW5zZm9ybUZ1bmM6IHNldFRyYW5zZm9ybUZ1bmMsXG4gICAgICAgIHNldFZhbHVlUmFuZ2U6IHNldFZhbHVlUmFuZ2UsXG4gICAgICAgIGdldFZhbHVlUmFuZ2U6IGdldFZhbHVlUmFuZ2UsXG4gICAgICAgIGdldFRyYW5zZm9ybUVudW06IGdldFRyYW5zZm9ybUVudW0sXG4gICAgICAgIHRyYW5zZm9ybVZhbHVlOiB0cmFuc2Zvcm1WYWx1ZSxcbiAgICAgICAgdW50cmFuc2Zvcm1WYWx1ZTogdW50cmFuc2Zvcm1WYWx1ZSxcbiAgICAgICAgaW50ZXJwb2xhdGVUb1JhbmdlOiBpbnRlcnBvbGF0ZVRvUmFuZ2VcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IFBPU0lUSVZFID0gJzEnO1xuICAgIGxldCBORVVUUkFMID0gJzAnO1xuICAgIGxldCBORUdBVElWRSA9ICctMSc7XG5cbiAgICBmdW5jdGlvbiBnZXRDbGFzc0Z1bmMobWluLCBtYXgpIHtcbiAgICAgICAgbWluID0gbWluICE9PSB1bmRlZmluZWQgPyBtaW4gOiAtMTtcbiAgICAgICAgbWF4ID0gbWF4ICE9PSB1bmRlZmluZWQgPyBtYXggOiAxO1xuICAgICAgICBsZXQgcG9zaXRpdmUgPSBbMC4yNSAqIG1heCwgMC41ICogbWF4LCAwLjc1ICogbWF4XTtcbiAgICAgICAgbGV0IG5lZ2F0aXZlID0gWy0wLjI1ICogbWluLCAtMC41ICogbWluLCAtMC43NSAqIG1pbl07XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzZW50aW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBwcmVmaXg7XG4gICAgICAgICAgICBsZXQgcmFuZ2U7XG4gICAgICAgICAgICBpZiAoc2VudGltZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICduZWctJztcbiAgICAgICAgICAgICAgICByYW5nZSA9IG5lZ2F0aXZlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAncG9zLSc7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBwb3NpdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhYnMgPSBNYXRoLmFicyhzZW50aW1lbnQpO1xuICAgICAgICAgICAgaWYgKGFicyA+IHJhbmdlWzJdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArICc0JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzID4gcmFuZ2VbMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgJzMnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhYnMgPiByYW5nZVswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyAnMic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgJzEnO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRvdGFsKGNvdW50KSB7XG4gICAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwb3MgPSBjb3VudFtQT1NJVElWRV0gPyBjb3VudFtQT1NJVElWRV0gOiAwO1xuICAgICAgICBsZXQgbmV1ID0gY291bnRbTkVVVFJBTF0gPyBjb3VudFtORVVUUkFMXSA6IDA7XG4gICAgICAgIGxldCBuZWcgPSBjb3VudFtORUdBVElWRV0gPyBjb3VudFtORUdBVElWRV0gOiAwO1xuICAgICAgICByZXR1cm4gcG9zICsgbmV1ICsgbmVnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEF2Zyhjb3VudCkge1xuICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcG9zID0gY291bnRbUE9TSVRJVkVdID8gY291bnRbUE9TSVRJVkVdIDogMDtcbiAgICAgICAgbGV0IG5ldSA9IGNvdW50W05FVVRSQUxdID8gY291bnRbTkVVVFJBTF0gOiAwO1xuICAgICAgICBsZXQgbmVnID0gY291bnRbTkVHQVRJVkVdID8gY291bnRbTkVHQVRJVkVdIDogMDtcbiAgICAgICAgbGV0IHRvdGFsID0gcG9zICsgbmV1ICsgbmVnO1xuICAgICAgICByZXR1cm4gKHRvdGFsICE9PSAwKSA/IChwb3MgLSBuZWcpIC8gdG90YWwgOiAwO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBnZXRDbGFzc0Z1bmM6IGdldENsYXNzRnVuYyxcbiAgICAgICAgZ2V0VG90YWw6IGdldFRvdGFsLFxuICAgICAgICBnZXRBdmc6IGdldEF2Z1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgQ2FudmFzID0gcmVxdWlyZSgnLi4vLi4vY29yZS9DYW52YXMnKTtcbiAgICBsZXQgQ29sb3JSYW1wID0gcmVxdWlyZSgnLi4vLi4vbWl4aW4vQ29sb3JSYW1wJyk7XG4gICAgbGV0IFZhbHVlVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vLi4vbWl4aW4vVmFsdWVUcmFuc2Zvcm0nKTtcblxuICAgIGxldCBIZWF0bWFwID0gQ2FudmFzLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIG1peGluc1xuICAgICAgICAgICAgQ29sb3JSYW1wLFxuICAgICAgICAgICAgVmFsdWVUcmFuc2Zvcm1cbiAgICAgICAgXSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIENvbG9yUmFtcC5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBWYWx1ZVRyYW5zZm9ybS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyQ2FudmFzOiBmdW5jdGlvbihiaW5zLCByZXNvbHV0aW9uLCByYW1wKSB7XG4gICAgICAgICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHJlc29sdXRpb247XG4gICAgICAgICAgICBsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBsZXQgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCByZXNvbHV0aW9uLCByZXNvbHV0aW9uKTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICBsZXQgY29sb3IgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgICAgICBsZXQgbnZhbCwgcnZhbCwgYmluLCBpO1xuICAgICAgICAgICAgZm9yIChpPTA7IGk8Ymlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJpbiA9IGJpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGJpbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvclswXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yWzFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JbMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb2xvclszXSA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbnZhbCA9IHRoaXMudHJhbnNmb3JtVmFsdWUoYmluKTtcbiAgICAgICAgICAgICAgICAgICAgcnZhbCA9IHRoaXMuaW50ZXJwb2xhdGVUb1JhbmdlKG52YWwpO1xuICAgICAgICAgICAgICAgICAgICByYW1wKHJ2YWwsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YVtpICogNF0gPSBNYXRoLnJvdW5kKGNvbG9yWzBdICogMjU1KTtcbiAgICAgICAgICAgICAgICBkYXRhW2kgKiA0ICsgMV0gPSBNYXRoLnJvdW5kKGNvbG9yWzFdICogMjU1KTtcbiAgICAgICAgICAgICAgICBkYXRhW2kgKiA0ICsgMl0gPSBNYXRoLnJvdW5kKGNvbG9yWzJdICogMjU1KTtcbiAgICAgICAgICAgICAgICBkYXRhW2kgKiA0ICsgM10gPSBNYXRoLnJvdW5kKGNvbG9yWzNdICogMjU1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyVGlsZTogZnVuY3Rpb24oY2FudmFzLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYmlucyA9IG5ldyBGbG9hdDY0QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICBsZXQgcmVzb2x1dGlvbiA9IE1hdGguc3FydChiaW5zLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgcmFtcCA9IHRoaXMuZ2V0Q29sb3JSYW1wKCk7XG4gICAgICAgICAgICBsZXQgdGlsZUNhbnZhcyA9IHRoaXMucmVuZGVyQ2FudmFzKGJpbnMsIHJlc29sdXRpb24sIHJhbXApO1xuICAgICAgICAgICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICB0aWxlQ2FudmFzLFxuICAgICAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbiwgcmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICAwLCAwLFxuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIZWF0bWFwO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IENhbnZhcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQ2FudmFzJyk7XG5cbiAgICBsZXQgUHJldmlldyA9IENhbnZhcy5leHRlbmQoe1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICAgIGxpbmVDb2xvcjogJyNmZmYnXG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlnaGxpZ2h0ZWQ6IGZhbHNlLFxuXG4gICAgICAgIF9kcmF3SGlnaGxpZ2h0OiBmdW5jdGlvbihjYW52YXMsIHgsIHksIHNpemUpIHtcbiAgICAgICAgICAgIGxldCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLm9wdGlvbnMuZmlsbENvbG9yO1xuICAgICAgICAgICAgY3R4LnJlY3QoXG4gICAgICAgICAgICAgICAgeCAqIHNpemUsXG4gICAgICAgICAgICAgICAgeSAqIHNpemUsXG4gICAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgICBzaXplKTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLm9wdGlvbnMubGluZVdpZHRoO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5vcHRpb25zLmxpbmVDb2xvcjtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlTW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGUub3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgICAgIC8vIGNsZWFyIGV4aXN0aW5nIGhpZ2hsaWdodFxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaWxlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZ2V0IGxheWVyIGNvb3JkXG4gICAgICAgICAgICBsZXQgbGF5ZXJQb2ludCA9IHRoaXMuZ2V0TGF5ZXJQb2ludEZyb21FdmVudChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgLy8gZ2V0IHRpbGUgY29vcmRcbiAgICAgICAgICAgIGxldCBjb29yZCA9IHRoaXMuZ2V0VGlsZUNvb3JkRnJvbUxheWVyUG9pbnQobGF5ZXJQb2ludCk7XG4gICAgICAgICAgICAvLyBnZXQgY2FjaGUga2V5XG4gICAgICAgICAgICBsZXQgbmtleSA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29vcmQsIHRydWUpO1xuICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGVudHJ5XG4gICAgICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5fY2FjaGVbbmtleV07XG4gICAgICAgICAgICBpZiAoY2FjaGVkICYmIGNhY2hlZC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGJpbiBjb29yZGluYXRlXG4gICAgICAgICAgICAgICAgbGV0IGJpbiA9IHRoaXMuZ2V0QmluQ29vcmRGcm9tTGF5ZXJQb2ludChsYXllclBvaW50KTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgYmluIGRhdGEgZW50cnlcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IGNhY2hlZC5kYXRhW2Jpbi5pbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggdGlsZSByZWx5aW5nIG9uIHRoYXQgZGF0YVxuICAgICAgICAgICAgICAgICAgICBfLmZvckluKGNhY2hlZC50aWxlcywgdGlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmF3SGlnaGxpZ2h0KHRpbGUsIGJpbi54LCBiaW4ueSwgYmluLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbGxpc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogY29vcmQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNvb3JkLnosXG4gICAgICAgICAgICAgICAgICAgICAgICB6OiBjb29yZC56LFxuICAgICAgICAgICAgICAgICAgICAgICAgYng6IGJpbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgYnk6IGJpbi55LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3ByZXZpZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhpZ2hsaWdodGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleGVjdXRlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3ZlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbGxpc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZmxhZyBhcyBoaWdobGlnaHRlZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkID0gY29sbGlzaW9uO1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgY3Vyc29yXG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5fbWFwLl9jb250YWluZXIpLmNzcygnY3Vyc29yJywgJ3BvaW50ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1vdXNlIG91dFxuICAgICAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3V0Jywge1xuICAgICAgICAgICAgICAgICAgICBlbGVtOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmhpZ2hsaWdodGVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjbGVhciBoaWdobGlnaHRlZCBmbGFnXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFByZXZpZXc7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgQ2FudmFzID0gcmVxdWlyZSgnLi4vLi4vY29yZS9DYW52YXMnKTtcbiAgICBsZXQgQ29sb3JSYW1wID0gcmVxdWlyZSgnLi4vLi4vbWl4aW4vQ29sb3JSYW1wJyk7XG4gICAgbGV0IFZhbHVlVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vLi4vbWl4aW4vVmFsdWVUcmFuc2Zvcm0nKTtcblxuICAgIGxldCBUb3BUcmFpbHMgPSBDYW52YXMuZXh0ZW5kKHtcblxuICAgICAgICBpbmNsdWRlczogW1xuICAgICAgICAgICAgLy8gbWl4aW5zXG4gICAgICAgICAgICBDb2xvclJhbXAsXG4gICAgICAgICAgICBWYWx1ZVRyYW5zZm9ybVxuICAgICAgICBdLFxuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNlbGVjdGVkQ29sb3I6IFsyNTUsIDEwMCwgMjU1LCAyNTVdLFxuICAgICAgICAgICAgaGlnaGxpZ2h0ZWRDb2xvcjogWzIwMCwgMCwgMjU1LCAyNTVdLFxuICAgICAgICAgICAgZG93blNhbXBsZUZhY3RvcjogOFxuICAgICAgICB9LFxuXG4gICAgICAgIGhpZ2hsaWdodGVkOiBudWxsLFxuXG4gICAgICAgIHNlbGVjdGVkOiBudWxsLFxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgQ29sb3JSYW1wLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIFZhbHVlVHJhbnNmb3JtLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhckhpZ2hsaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaWxlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEhpZ2hsaWdodDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJIaWdobGlnaHQoKTtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQgPSB2YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZS5vcmlnaW5hbEV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGxldCBiaW4gPSB0aGlzLl9nZXRCaW5EYXRhKGUpO1xuICAgICAgICAgICAgaWYgKGJpbikge1xuICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2NsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICBlbGVtOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBiaW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBmbGFnIGFzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oYmluKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRUcmFpbHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjbGVhciBzZWxlY3RlZCBmbGFnXG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRUcmFpbHMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlTW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGUub3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICBsZXQgYmluID0gdGhpcy5fZ2V0QmluRGF0YShlKTtcbiAgICAgICAgICAgIGlmIChiaW4pIHtcbiAgICAgICAgICAgICAgICAvLyBleGVjdXRlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhpZ2hsaWdodGVkKSB7XG4gICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW92ZXInLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYmluXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmbGFnIGFzIGhpZ2hsaWdodGVkXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIaWdobGlnaHQoYmluKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRUcmFpbHMoKTtcbiAgICAgICAgICAgICAgICAvLyBzZXQgY3Vyc29yXG4gICAgICAgICAgICAgICAgJCh0aGlzLl9tYXAuX2NvbnRhaW5lcikuY3NzKCdjdXJzb3InLCAncG9pbnRlcicpO1xuICAgICAgICAgICAgICAgIC8vIGV4aXQgZWFybHlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtb3VzZSBvdXRcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW91dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbTogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5oaWdobGlnaHRlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGVhckhpZ2hsaWdodCgpO1xuICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0VHJhaWxzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEJpbkRhdGE6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIC8vIGdldCBsYXllciBjb29yZFxuICAgICAgICAgICAgbGV0IGxheWVyUG9pbnQgPSB0aGlzLmdldExheWVyUG9pbnRGcm9tRXZlbnQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIC8vIGdldCB0aWxlIGNvb3JkXG4gICAgICAgICAgICBsZXQgY29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZyb21MYXllclBvaW50KGxheWVyUG9pbnQpO1xuICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGtleVxuICAgICAgICAgICAgbGV0IG5rZXkgPSB0aGlzLmNhY2hlS2V5RnJvbUNvb3JkKGNvb3JkLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGdldCBjYWNoZSBlbnRyeVxuICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX2NhY2hlW25rZXldO1xuICAgICAgICAgICAgaWYgKGNhY2hlZCAmJiBjYWNoZWQucGl4ZWxzKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGJpbiBjb29yZGluYXRlXG4gICAgICAgICAgICAgICAgbGV0IGJpbiA9IHRoaXMuZ2V0QmluQ29vcmRGcm9tTGF5ZXJQb2ludChsYXllclBvaW50KTtcbiAgICAgICAgICAgICAgICAvLyBkb3duc2FtcGxlIHRoZSBiaW4gcmVzXG4gICAgICAgICAgICAgICAgbGV0IHggPSBNYXRoLmZsb29yKGJpbi54IC8gdGhpcy5vcHRpb25zLmRvd25TYW1wbGVGYWN0b3IpO1xuICAgICAgICAgICAgICAgIGxldCB5ID0gTWF0aC5mbG9vcihiaW4ueSAvIHRoaXMub3B0aW9ucy5kb3duU2FtcGxlRmFjdG9yKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBoaXRzIGEgcGl4ZWxcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkLnBpeGVsc1t4XSAmJiBjYWNoZWQucGl4ZWxzW3hdW3ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyhjYWNoZWQucGl4ZWxzW3hdW3ldKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGFrZSBmaXJzdCBlbnRyeVxuICAgICAgICAgICAgICAgICAgICBsZXQgaWQgPSBpZHNbMF07XG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBjb2xsaXNpb24gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2xsaXNpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjb29yZC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogY29vcmQueixcbiAgICAgICAgICAgICAgICAgICAgICAgIHo6IGNvb3JkLnosXG4gICAgICAgICAgICAgICAgICAgICAgICBieDogYmluLngsXG4gICAgICAgICAgICAgICAgICAgICAgICBieTogYmluLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndG9wLXRyYWlscycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sbGlzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9oaWdobGlnaHRUcmFpbHNGb3JEYXRhOiBmdW5jdGlvbihjYWNoZWQpIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICAgICAgICBsZXQgaGlnaGxpZ2h0ZWQgPSB0aGlzLmhpZ2hsaWdodGVkO1xuICAgICAgICAgICAgaWYgKGNhY2hlZC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyYWlsO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFpbCA9IGNhY2hlZC50cmFpbHNbc2VsZWN0ZWQudmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIHRpbGUgcmVseWluZyBvbiB0aGF0IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9ySW4oY2FjaGVkLnRpbGVzLCB0aWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJUcmFpbCh0aWxlLCB0cmFpbCwgdGhpcy5vcHRpb25zLnNlbGVjdGVkQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhpZ2hsaWdodGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWlsID0gY2FjaGVkLnRyYWlsc1toaWdobGlnaHRlZC52YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JJbihjYWNoZWQudGlsZXMsIHRpbGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclRyYWlsKHRpbGUsIHRyYWlsLCB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ZWRDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaGlnaGxpZ2h0VHJhaWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF8uZm9ySW4odGhpcy5fY2FjaGUsIGNhY2hlZCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0VHJhaWxzRm9yRGF0YShjYWNoZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlbmRlclRyYWlsOiBmdW5jdGlvbihjYW52YXMsIHBpeGVscywgY29sb3IpIHtcbiAgICAgICAgICAgIGxldCByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICBsZXQgaGlnaGxpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBoaWdobGlnaHQuaGVpZ2h0ID0gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIGhpZ2hsaWdodC53aWR0aCA9IHJlc29sdXRpb247XG4gICAgICAgICAgICBsZXQgaGlnaGxpZ2h0Q3R4ID0gaGlnaGxpZ2h0LmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBsZXQgaW1hZ2VEYXRhID0gaGlnaGxpZ2h0Q3R4LmdldEltYWdlRGF0YSgwLCAwLCByZXNvbHV0aW9uLCByZXNvbHV0aW9uKTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICBsZXQgcGl4ZWwsIHgsIHksIGksIGo7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxwaXhlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwaXhlbCA9IHBpeGVsc1tpXTtcbiAgICAgICAgICAgICAgICB4ID0gcGl4ZWxbMF07XG4gICAgICAgICAgICAgICAgeSA9IHBpeGVsWzFdO1xuICAgICAgICAgICAgICAgIGogPSB4ICsgKHJlc29sdXRpb24gKiB5KTtcbiAgICAgICAgICAgICAgICBkYXRhW2ogKiA0XSA9IGNvbG9yWzBdO1xuICAgICAgICAgICAgICAgIGRhdGFbaiAqIDQgKyAxXSA9IGNvbG9yWzFdO1xuICAgICAgICAgICAgICAgIGRhdGFbaiAqIDQgKyAyXSA9IGNvbG9yWzJdO1xuICAgICAgICAgICAgICAgIGRhdGFbaiAqIDQgKyAzXSA9IGNvbG9yWzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGlnaGxpZ2h0Q3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgICAgICAgICAgLy8gZHJhdyB0byB0aWxlXG4gICAgICAgICAgICBsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodCxcbiAgICAgICAgICAgICAgICAwLCAwLFxuICAgICAgICAgICAgICAgIHJlc29sdXRpb24sIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgMCwgMCxcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGF0YSwgY29vcmQpIHtcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1vZGlmeSBjYWNoZSBlbnRyeVxuICAgICAgICAgICAgbGV0IG5rZXkgPSB0aGlzLmNhY2hlS2V5RnJvbUNvb3JkKGNvb3JkLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9jYWNoZVtua2V5XTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQudHJhaWxzKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJhaWxzIGFscmVhZHkgYWRkZWQsIGV4aXQgZWFybHlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdHJhaWxzID0gY2FjaGVkLnRyYWlscyA9IHt9O1xuICAgICAgICAgICAgbGV0IHBpeGVscyA9IGNhY2hlZC5waXhlbHMgPSB7fTtcbiAgICAgICAgICAgIGxldCBpZHMgID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICAgICAgICBsZXQgYmlucywgYmluO1xuICAgICAgICAgICAgbGV0IGlkLCBpLCBqO1xuICAgICAgICAgICAgbGV0IHJ4LCByeSwgeCwgeTtcbiAgICAgICAgICAgIGZvciAoaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgICAgIGJpbnMgPSBkYXRhW2lkXTtcbiAgICAgICAgICAgICAgICBmb3IgKGo9MDsgajxiaW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbiA9IGJpbnNbal07XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvd24gc2FtcGxlIHRoZSBwaXhlbCB0byBtYWtlIGludGVyYWN0aW9uIGVhc2llclxuICAgICAgICAgICAgICAgICAgICByeCA9IE1hdGguZmxvb3IoYmluWzBdIC8gdGhpcy5vcHRpb25zLmRvd25TYW1wbGVGYWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICByeSA9IE1hdGguZmxvb3IoYmluWzFdIC8gdGhpcy5vcHRpb25zLmRvd25TYW1wbGVGYWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBwaXhlbHNbcnhdID0gcGl4ZWxzW3J4XSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3J4XVtyeV0gPSBwaXhlbHNbcnhdW3J5XSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3J4XVtyeV1baWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHBpeGVsIHVuZGVyIHRoZSB0cmFpbCBhdCBjb3JyZWN0IHJlc29sdXRpb25cbiAgICAgICAgICAgICAgICAgICAgeCA9IGJpblswXTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGJpblsxXTtcbiAgICAgICAgICAgICAgICAgICAgdHJhaWxzW2lkXSA9IHRyYWlsc1tpZF0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHRyYWlsc1tpZF0ucHVzaChbIHgsIHkgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGhpZ2hsaWdodCBzZWxlY3RlZCB0cmFpbHMgaW4gdGhlIHRpbGVcbiAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodFRyYWlsc0ZvckRhdGEoY2FjaGVkKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvcFRyYWlscztcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKGVsZW0sIGNvb3JkKSB7XG4gICAgICAgICAgICAkKGVsZW0pLmVtcHR5KCk7XG4gICAgICAgICAgICAkKGVsZW0pLmFwcGVuZCgnPGRpdiBzdHlsZT1cInRvcDowOyBsZWZ0OjA7XCI+JyArIGNvb3JkLnogKyAnLCAnICsgY29vcmQueCArICcsICcgKyBjb29yZC55ICsgJzwvZGl2PicpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IEhUTUwgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0hUTUwnKTtcblxuICAgIGxldCBDb21tdW5pdHkgPSBIVE1MLmV4dGVuZCh7XG5cbiAgICAgICAgX2dldEJpbkNvb3JkRnJvbUNhcnRlc2lhbjogZnVuY3Rpb24ocHgsIHB5LCB6b29tKSB7XG4gICAgICAgICAgICAvLyBDb29yZHMgYXJlIG5hbWVkIGxvbi9sYXQsIGJ1dCBhcmUgYWN0dWFsbHkgaW4gdGhlIHJhbmdlIFswLCAyNTVdLlxuICAgICAgICAgICAgLy8gVGhlIExlYWZsZXQgbWFwIGlzIHNldHVwIHRvIHVzZSBhIGN1c3RvbSBwcm9qZWN0aW9uIHRvIHJlZmxlY3QgdGhpcyBvblxuICAgICAgICAgICAgLy8gY3JlYXRpb24uXG4gICAgICAgICAgICBsZXQgbGF5ZXJQdCA9IHRoaXMuX2dldExheWVyUG9pbnRGcm9tTG9uTGF0KHtcbiAgICAgICAgICAgICAgICAnbG9uJzogcHgsXG4gICAgICAgICAgICAgICAgJ2xhdCc6IHB5XG4gICAgICAgICAgICB9LCB6b29tKTtcbiAgICAgICAgICAgIGxldCByZXMgPSAgdGhpcy5nZXRCaW5Db29yZEZyb21MYXllclBvaW50KGxheWVyUHQsIDI1Nik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHJlbmRlciBjb21tdW5pdHkgcmluZ3NcbiAgICAgICAgcmVuZGVyVGlsZTogZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhLCBjb29yZCkge1xuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGRhdGEpO1xuICAgICAgICAgICAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG4gICAgICAgICAgICBsZXQgZGVjb2RlZFN0cmluZyA9IGRlY29kZXIuZGVjb2RlKGRhdGFWaWV3KTtcbiAgICAgICAgICAgIGxldCBqc29uT2JqID0gSlNPTi5wYXJzZShkZWNvZGVkU3RyaW5nKTtcblxuICAgICAgICAgICAgbGV0IGRpdnMgPSAkKCk7XG4gICAgICAgICAgICBfLmZvckVhY2goanNvbk9iai5jb21tdW5pdGllcywgY29tbXVuaXR5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbXVuaXR5Lm51bU5vZGVzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGl2ID0gdGhpcy5fY3JlYXRlUmluZ0RpdihcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW11bml0eS5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tdW5pdHkuY29vcmRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmQueixcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb21tdW5pdHktcmluZycpO1xuICAgICAgICAgICAgICAgICAgICBkaXYuZGF0YSgnbmFtZScsIGNvbW11bml0eS5tZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5kYXRhKCdjb3VudCcsIGNvbW11bml0eS5udW1Ob2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIGRpdnMgPSBkaXZzLmFkZChkaXYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJChjb250YWluZXIpLmFwcGVuZChkaXZzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBmb3J3YXJkIGNvbW11bml0eSBtZXRhZGF0YSBzdHJpbmcgdG8gYXBwIGxldmVsIG1vdXNlbW92ZSBoYW5kbGVyIHdoZW4gcG9pbnRlciBpc1xuICAgICAgICAvLyBvdmVyIGEgY29tbXVuaXR5IHJpbmdcbiAgICAgICAgb25Nb3VzZU92ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSAkKGUub3JpZ2luYWxFdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0ge25hbWU6IHRhcmdldC5kYXRhKCduYW1lJyksIGNvdW50OiB0YXJnZXQuZGF0YSgnY291bnQnKX07XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdmVyJywge1xuICAgICAgICAgICAgICAgIGVsZW06IGUub3JpZ2luYWxFdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tdW5pdHknLFxuICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBmb3J3YXJkIGNsZWFyZWQgc3RyaW5nIHRvIGFwcCBsZXZlbCBtb3VzZW1vdmUgaGFuZGxlciB3aGVuIHBvaW50ZXIgbW92ZXMgb2ZmXG4gICAgICAgIC8vIGEgY29tbXVuaXR5IHJpbmdcbiAgICAgICAgb25Nb3VzZU91dDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW91dCcsIHtcbiAgICAgICAgICAgICAgICBlbGVtOiBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tdW5pdHknLFxuICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfY3JlYXRlUmluZ0RpdjogZnVuY3Rpb24oY29tbXVuaXR5UmFkaXVzLCBjb21tdW5pdHlDb29yZHMsIHpvb21MZXZlbCwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBsZXQgcmFkaXVzID0gTWF0aC5tYXgoNCwgY29tbXVuaXR5UmFkaXVzICogTWF0aC5wb3coMiwgem9vbUxldmVsKSk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gcmFkaXVzIC8gMjtcbiAgICAgICAgICAgIGxldCBiaW5Db29yZCA9IHRoaXMuX2dldEJpbkNvb3JkRnJvbUNhcnRlc2lhbihcbiAgICAgICAgICAgICAgICBjb21tdW5pdHlDb29yZHNbMF0sXG4gICAgICAgICAgICAgICAgY29tbXVuaXR5Q29vcmRzWzFdLFxuICAgICAgICAgICAgICAgIHpvb21MZXZlbCk7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IGJpbkNvb3JkLng7XG4gICAgICAgICAgICBsZXQgdG9wID0gYmluQ29vcmQueTtcblxuICAgICAgICAgICAgcmV0dXJuICQoXG4gICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke2NsYXNzTmFtZX1cIiBzdHlsZT1cIlxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAke2xlZnQgLSBvZmZzZXR9cHg7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogJHt0b3AgLSBvZmZzZXR9cHg7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAke3JhZGl1c31weDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAke3JhZGl1c31weDtcIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb21tdW5pdHk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgSFRNTCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvSFRNTCcpO1xuXG4gICAgbGV0IENvbW11bml0eUxhYmVsID0gSFRNTC5leHRlbmQoe1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGxhYmVsU2NhbGU6IDEuMCxcbiAgICAgICAgICAgIGxhYmVsTWF4TGVuZ3RoOiAyMDAsXG4gICAgICAgICAgICBsYWJlbFRocmVzaG9sZDogW1xuICAgICAgICAgICAgICAgIFswLCA1MDAwXSxcbiAgICAgICAgICAgICAgICBbMTAsIDEwMF0sXG4gICAgICAgICAgICAgICAgWzE0LCAxMF0sXG4gICAgICAgICAgICAgICAgWzE2LCAwXVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gZXhwYW5kIHRocmVzaG9sZHMgZm9yIGxvb2t1cHMgZHVyaW5nIHJlbmRlcmluZ1xuICAgICAgICAgICAgdGhpcy5sYWJlbFRocmVzaG9sZCA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbFRocmVzaG9sZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsVGhyZXNob2xkID0gdGhpcy5vcHRpb25zLmxhYmVsVGhyZXNob2xkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goXy5kcm9wUmlnaHQodGhpcy5vcHRpb25zLmxhYmVsVGhyZXNob2xkLCAxKSwgKHYsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLm9wdGlvbnMubGFiZWxUaHJlc2hvbGRbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IG5leHRbMF0gLSB2WzBdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhYmVsVGhyZXNob2xkID0gdGhpcy5sYWJlbFRocmVzaG9sZC5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBfLnppcChfLnJhbmdlKHZbMF0sIG5leHRbMF0pLCBfLmZpbGwoQXJyYXkoc3RlcCksIHZbMV0pKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbFRocmVzaG9sZC5wdXNoKF8ubGFzdCh0aGlzLm9wdGlvbnMubGFiZWxUaHJlc2hvbGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyByZW5kZXIgY29tbXVuaXR5IHJpbmdzXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGF0YSwgY29vcmQpIHtcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhkYXRhKTtcbiAgICAgICAgICAgIGxldCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgICAgICAgICAgbGV0IGRlY29kZWRTdHJpbmcgPSBkZWNvZGVyLmRlY29kZShkYXRhVmlldyk7XG4gICAgICAgICAgICBsZXQganNvbk9iaiA9IEpTT04ucGFyc2UoZGVjb2RlZFN0cmluZyk7XG5cbiAgICAgICAgICAgIGxldCBkaXZzID0gJCgpO1xuICAgICAgICAgICAgXy5mb3JFYWNoKGpzb25PYmouY29tbXVuaXRpZXMsIGNvbW11bml0eSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGlkeCA9IF8uY2xhbXAoY29vcmQueiwgMCwgdGhpcy5sYWJlbFRocmVzaG9sZC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tbXVuaXR5Lm51bU5vZGVzID4gdGhpcy5sYWJlbFRocmVzaG9sZFtpZHhdWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXYgPSB0aGlzLl9jcmVhdGVMYWJlbERpdihcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW11bml0eS5jb29yZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tdW5pdHkucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmQueixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW11bml0eS5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb21tdW5pdHktbGFiZWwnKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2LmRhdGEoJ25hbWUnLCBjb21tdW5pdHkubWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBkaXYuZGF0YSgnY291bnQnLCBjb21tdW5pdHkubnVtTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICBkaXZzID0gZGl2cy5hZGQoZGl2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICQoY29udGFpbmVyKS5hcHBlbmQoZGl2cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gZm9yd2FyZCBjb21tdW5pdHkgbWV0YWRhdGEgc3RyaW5nIHRvIGFwcCBsZXZlbCBtb3VzZW1vdmUgaGFuZGxlciB3aGVuIHBvaW50ZXIgaXNcbiAgICAgICAgLy8gb3ZlciBhIGNvbW11bml0eSByaW5nXG4gICAgICAgIG9uTW91c2VPdmVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gJChlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHtuYW1lOiB0YXJnZXQuZGF0YSgnbmFtZScpLCBjb3VudDogdGFyZ2V0LmRhdGEoJ2NvdW50Jyl9O1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3ZlcicsIHtcbiAgICAgICAgICAgICAgICBlbGVtOiBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbXVuaXR5LWxhYmVscycsXG4gICAgICAgICAgICAgICAgbGF5ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGZvcndhcmQgY2xlYXJlZCBzdHJpbmcgdG8gYXBwIGxldmVsIG1vdXNlbW92ZSBoYW5kbGVyIHdoZW4gcG9pbnRlciBtb3ZlcyBvZmZcbiAgICAgICAgLy8gYSBjb21tdW5pdHkgcmluZ1xuICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3V0Jywge1xuICAgICAgICAgICAgICAgIGVsZW06IGUub3JpZ2luYWxFdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW11bml0eS1sYWJlbHMnLFxuICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0QmluQ29vcmRGcm9tQ2FydGVzaWFuOiBmdW5jdGlvbihweCwgcHksIHpvb20pIHtcbiAgICAgICAgICAgIC8vIENvb3JkcyBhcmUgbmFtZWQgbG9uL2xhdCwgYnV0IGFyZSBhY3R1YWxseSBpbiB0aGUgcmFuZ2UgWzAsIDI1NV0uXG4gICAgICAgICAgICAvLyBUaGUgTGVhZmxldCBtYXAgaXMgc2V0dXAgdG8gdXNlIGEgY3VzdG9tIHByb2plY3Rpb24gdG8gcmVmbGVjdCB0aGlzIG9uXG4gICAgICAgICAgICAvLyBjcmVhdGlvbi5cbiAgICAgICAgICAgIGxldCBsYXllclB0ID0gdGhpcy5fZ2V0TGF5ZXJQb2ludEZyb21Mb25MYXQoe1xuICAgICAgICAgICAgICAgICdsb24nOiBweCxcbiAgICAgICAgICAgICAgICAnbGF0JzogcHlcbiAgICAgICAgICAgIH0sIHpvb20pO1xuICAgICAgICAgICAgbGV0IHJlcyA9ICB0aGlzLmdldEJpbkNvb3JkRnJvbUxheWVyUG9pbnQobGF5ZXJQdCwgMjU2KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NyZWF0ZUxhYmVsRGl2OiBmdW5jdGlvbihjb21tdW5pdHlDb29yZHMsIGNvbW11bml0eVJhZGl1cywgem9vbUxldmVsLCBsYWJlbCwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBsZXQgcmFkaXVzID0gTWF0aC5tYXgoMTYsIGNvbW11bml0eVJhZGl1cyAqIE1hdGgucG93KDIsIHpvb21MZXZlbCkpO1xuICAgICAgICAgICAgbGV0IGJpbkNvb3JkID0gdGhpcy5fZ2V0QmluQ29vcmRGcm9tQ2FydGVzaWFuKFxuICAgICAgICAgICAgICAgIGNvbW11bml0eUNvb3Jkc1swXSxcbiAgICAgICAgICAgICAgICBjb21tdW5pdHlDb29yZHNbMV0sXG4gICAgICAgICAgICAgICAgem9vbUxldmVsKTtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gYmluQ29vcmQueCAtIHRoaXMub3B0aW9ucy5sYWJlbE1heExlbmd0aCAvIDI7XG4gICAgICAgICAgICBsZXQgdG9wID0gYmluQ29vcmQueSAtIChyYWRpdXMgLyAyKTtcbiAgICAgICAgICAgIHJldHVybiAkKFxuICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtjbGFzc05hbWV9ICR7cmFkaXVzfVwiIHN0eWxlPVwiXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6ICR7bGVmdH1weDtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAke3RvcH1weDtcbiAgICAgICAgICAgICAgICAgICAgbGluZS1oZWlnaHQ6ICR7cmFkaXVzfXB4O1wiPiR7bGFiZWx9PC9kaXY+XG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ29tbXVuaXR5TGFiZWw7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgSFRNTCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvSFRNTCcpO1xuXG4gICAgbGV0IEVtcHR5ID0gSFRNTC5leHRlbmQoe30pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFbXB0eTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBIVE1MID0gcmVxdWlyZSgnLi4vLi4vY29yZS9IVE1MJyk7XG4gICAgbGV0IENvbG9yUmFtcCA9IHJlcXVpcmUoJy4uLy4uL21peGluL0NvbG9yUmFtcCcpO1xuICAgIGxldCBWYWx1ZVRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uLy4uL21peGluL1ZhbHVlVHJhbnNmb3JtJyk7XG5cbiAgICBsZXQgSGVhdG1hcCA9IEhUTUwuZXh0ZW5kKHtcblxuICAgICAgICBpbmNsdWRlczogW1xuICAgICAgICAgICAgLy8gbWl4aW5zXG4gICAgICAgICAgICBDb2xvclJhbXAsXG4gICAgICAgICAgICBWYWx1ZVRyYW5zZm9ybVxuICAgICAgICBdLFxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgQ29sb3JSYW1wLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIFZhbHVlVHJhbnNmb3JtLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlT3ZlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9ICQoZS5vcmlnaW5hbEV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0YXJnZXQuYXR0cignZGF0YS12YWx1ZScpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0ICRwYXJlbnQgPSB0YXJnZXQucGFyZW50cygnLmxlYWZsZXQtaHRtbC10aWxlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW92ZXInLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW06IGUub3JpZ2luYWxFdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludCh2YWx1ZSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB4OiBwYXJzZUludCgkcGFyZW50LmF0dHIoJ2RhdGEteCcpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHk6IHBhcnNlSW50KCRwYXJlbnQuYXR0cignZGF0YS15JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgejogdGhpcy5fbWFwLmdldFpvb20oKSxcbiAgICAgICAgICAgICAgICAgICAgYng6IHBhcnNlSW50KHRhcmdldC5hdHRyKCdkYXRhLWJ4JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgYnk6IHBhcnNlSW50KHRhcmdldC5hdHRyKCdkYXRhLWJ5JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2hlYXRtYXAnLFxuICAgICAgICAgICAgICAgICAgICBsYXllcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2VPdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSAkKGUub3JpZ2luYWxFdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGFyZ2V0LmF0dHIoJ2RhdGEtdmFsdWUnKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGxldCAkcGFyZW50ID0gdGFyZ2V0LnBhcmVudHMoJy5sZWFmbGV0LWh0bWwtdGlsZScpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW06IGUub3JpZ2luYWxFdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludCh2YWx1ZSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB4OiBwYXJzZUludCgkcGFyZW50LmF0dHIoJ2RhdGEteCcpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHk6IHBhcnNlSW50KCRwYXJlbnQuYXR0cignZGF0YS15JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgejogdGhpcy5fbWFwLmdldFpvb20oKSxcbiAgICAgICAgICAgICAgICAgICAgYng6IHBhcnNlSW50KHRhcmdldC5hdHRyKCdkYXRhLWJ4JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgYnk6IHBhcnNlSW50KHRhcmdldC5hdHRyKCdkYXRhLWJ5JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2hlYXRtYXAnLFxuICAgICAgICAgICAgICAgICAgICBsYXllcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIC8vIHVuLXNlbGVjdCBhbnkgcHJldiBzZWxlY3RlZCBwaXhlbFxuICAgICAgICAgICAgJCgnLmhlYXRtYXAtcGl4ZWwnKS5yZW1vdmVDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICAvLyBnZXQgdGFyZ2V0XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gJChlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1RhcmdldExheWVyKGUub3JpZ2luYWxFdmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBsYXllciBpcyBub3QgdGhlIHRhcmdldFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQuaGFzQ2xhc3MoJ2hlYXRtYXAtcGl4ZWwnKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0YXJnZXQuYXR0cignZGF0YS12YWx1ZScpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0ICRwYXJlbnQgPSB0YXJnZXQucGFyZW50cygnLmxlYWZsZXQtaHRtbC10aWxlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdjbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbTogZS5vcmlnaW5hbEV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KHZhbHVlLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHg6IHBhcnNlSW50KCRwYXJlbnQuYXR0cignZGF0YS14JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgeTogcGFyc2VJbnQoJHBhcmVudC5hdHRyKCdkYXRhLXknKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB6OiB0aGlzLl9tYXAuZ2V0Wm9vbSgpLFxuICAgICAgICAgICAgICAgICAgICBieDogcGFyc2VJbnQodGFyZ2V0LmF0dHIoJ2RhdGEtYngnKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBieTogcGFyc2VJbnQodGFyZ2V0LmF0dHIoJ2RhdGEtYnknKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaGVhdG1hcCcsXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyVGlsZTogZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYmlucyA9IG5ldyBGbG9hdDY0QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICBsZXQgcmVzb2x1dGlvbiA9IE1hdGguc3FydChiaW5zLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgcmFtcCA9IHRoaXMuZ2V0Q29sb3JSYW1wKCk7XG4gICAgICAgICAgICBsZXQgcGl4ZWxTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIGxldCBjb2xvciA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgICAgIGxldCBodG1sID0gJyc7XG4gICAgICAgICAgICBsZXQgbnZhbCwgcnZhbCwgYmluO1xuICAgICAgICAgICAgbGV0IGxlZnQsIHRvcDtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgZm9yIChpPTA7IGk8Ymlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJpbiA9IGJpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGJpbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKGkgJSByZXNvbHV0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gTWF0aC5mbG9vcihpIC8gcmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgICAgIG52YWwgPSB0aGlzLnRyYW5zZm9ybVZhbHVlKGJpbik7XG4gICAgICAgICAgICAgICAgICAgIHJ2YWwgPSB0aGlzLmludGVycG9sYXRlVG9SYW5nZShudmFsKTtcbiAgICAgICAgICAgICAgICAgICAgcmFtcChydmFsLCBjb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByID0gTWF0aC5yb3VuZChjb2xvclswXSAqIDI1NSk7XG4gICAgICAgICAgICAgICAgbGV0IGcgPSBNYXRoLnJvdW5kKGNvbG9yWzFdICogMjU1KTtcbiAgICAgICAgICAgICAgICBsZXQgYiA9IE1hdGgucm91bmQoY29sb3JbMl0gKiAyNTUpO1xuICAgICAgICAgICAgICAgIGxldCBhID0gY29sb3JbM107XG4gICAgICAgICAgICAgICAgbGV0IHJnYmEgPSBgcmdiYSgke3J9LCAke2d9LCAke2J9LCAke2F9KWA7XG4gICAgICAgICAgICAgICAgaHRtbCArPSBgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJoZWF0bWFwLXBpeGVsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtdmFsdWU9XCIke2Jpbn1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1ieD1cIiR7bGVmdH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1ieT1cIiR7dG9wfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJHtwaXhlbFNpemV9cHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICR7cGl4ZWxTaXplfXB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6ICR7bGVmdCAqIHBpeGVsU2l6ZX1weDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6ICR7dG9wICogcGl4ZWxTaXplfXB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7cmdiYX07XCI+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIZWF0bWFwO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IEhUTUwgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0hUTUwnKTtcbiAgICBsZXQgVmFsdWVUcmFuc2Zvcm0gPSByZXF1aXJlKCcuLi8uLi9taXhpbi9WYWx1ZVRyYW5zZm9ybScpO1xuXG4gICAgbGV0IEhlYXRtYXAgPSBIVE1MLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIG1peGluc1xuICAgICAgICAgICAgVmFsdWVUcmFuc2Zvcm1cbiAgICAgICAgXSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFZhbHVlVHJhbnNmb3JtLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gJChlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICQoJy5oZWF0bWFwLXJpbmcnKS5yZW1vdmVDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUYXJnZXRMYXllcihlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgbGF5ZXIgaXMgbm90IHRoZSB0YXJnZXRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lmhhc0NsYXNzKCdoZWF0bWFwLXJpbmcnKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyVGlsZTogZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYmlucyA9IG5ldyBGbG9hdDY0QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICBsZXQgcmVzb2x1dGlvbiA9IE1hdGguc3FydChiaW5zLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgYmluU2l6ZSA9ICh0aGlzLm9wdGlvbnMudGlsZVNpemUgLyByZXNvbHV0aW9uKTtcbiAgICAgICAgICAgIGxldCBodG1sID0gJyc7XG4gICAgICAgICAgICBiaW5zLmZvckVhY2goKGJpbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWJpbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwZXJjZW50ID0gdGhpcy50cmFuc2Zvcm1WYWx1ZShiaW4pO1xuICAgICAgICAgICAgICAgIGxldCByYWRpdXMgPSBwZXJjZW50ICogYmluU2l6ZTtcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gKGJpblNpemUgLSByYWRpdXMpIC8gMjtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCA9IChpbmRleCAlIHJlc29sdXRpb24pICogYmluU2l6ZTtcbiAgICAgICAgICAgICAgICBsZXQgdG9wID0gTWF0aC5mbG9vcihpbmRleCAvIHJlc29sdXRpb24pICogYmluU2l6ZTtcbiAgICAgICAgICAgICAgICBodG1sICs9XG4gICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImhlYXRtYXAtcmluZ1wiIHN0eWxlPVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAke2xlZnQgKyBvZmZzZXR9cHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6ICR7dG9wICsgb2Zmc2V0fXB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICR7cmFkaXVzfXB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAke3JhZGl1c31weDtcIj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIGA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGVhdG1hcDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBIVE1MID0gcmVxdWlyZSgnLi4vLi4vY29yZS9IVE1MJyk7XG4gICAgbGV0IFZhbHVlVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vLi4vbWl4aW4vVmFsdWVUcmFuc2Zvcm0nKTtcbiAgICBsZXQgc2VudGltZW50ID0gcmVxdWlyZSgnLi4vLi4vc2VudGltZW50L1NlbnRpbWVudCcpO1xuICAgIGxldCBzZW50aW1lbnRGdW5jID0gc2VudGltZW50LmdldENsYXNzRnVuYygtMSwgMSk7XG5cbiAgICBsZXQgVkVSVElDQUxfT0ZGU0VUID0gMjQ7XG4gICAgbGV0IEhPUklaT05UQUxfT0ZGU0VUID0gMTA7XG4gICAgbGV0IE5VTV9BVFRFTVBUUyA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBpbml0aWFsIHBvc2l0aW9uLCByZXR1cm4gYSBuZXcgcG9zaXRpb24sIGluY3JlbWVudGFsbHkgc3BpcmFsbGVkXG4gICAgICogb3V0d2FyZHMuXG4gICAgICovXG4gICAgbGV0IHNwaXJhbFBvc2l0aW9uID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIGxldCBwaTIgPSAyICogTWF0aC5QSTtcbiAgICAgICAgbGV0IGNpcmMgPSBwaTIgKiBwb3MucmFkaXVzO1xuICAgICAgICBsZXQgaW5jID0gKHBvcy5hcmNMZW5ndGggPiBjaXJjIC8gMTApID8gY2lyYyAvIDEwIDogcG9zLmFyY0xlbmd0aDtcbiAgICAgICAgbGV0IGRhID0gaW5jIC8gcG9zLnJhZGl1cztcbiAgICAgICAgbGV0IG50ID0gKHBvcy50ICsgZGEpO1xuICAgICAgICBpZiAobnQgPiBwaTIpIHtcbiAgICAgICAgICAgIG50ID0gbnQgJSBwaTI7XG4gICAgICAgICAgICBwb3MucmFkaXVzID0gcG9zLnJhZGl1cyArIHBvcy5yYWRpdXNJbmM7XG4gICAgICAgIH1cbiAgICAgICAgcG9zLnQgPSBudDtcbiAgICAgICAgcG9zLnggPSBwb3MucmFkaXVzICogTWF0aC5jb3MobnQpO1xuICAgICAgICBwb3MueSA9IHBvcy5yYWRpdXMgKiBNYXRoLnNpbihudCk7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgYm91bmRpbmcgYm94IGEgaW50ZXJzZWN0cyBib3VuZGluZyBib3ggYlxuICAgICAqL1xuICAgIGxldCBpbnRlcnNlY3RUZXN0ID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gKE1hdGguYWJzKGEueCAtIGIueCkgKiAyIDwgKGEud2lkdGggKyBiLndpZHRoKSkgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhhLnkgLSBiLnkpICogMiA8IChhLmhlaWdodCArIGIuaGVpZ2h0KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgYm91bmRpbmcgYm94IGEgaXMgbm90IGZ1bGx5IGNvbnRhaW5lZCBpbnNpZGUgYm91bmRpbmcgYm94IGJcbiAgICAgKi9cbiAgICBsZXQgb3ZlcmxhcFRlc3QgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYS54ICsgYS53aWR0aCAvIDIgPiBiLnggKyBiLndpZHRoIC8gMiB8fFxuICAgICAgICAgICAgYS54IC0gYS53aWR0aCAvIDIgPCBiLnggLSBiLndpZHRoIC8gMiB8fFxuICAgICAgICAgICAgYS55ICsgYS5oZWlnaHQgLyAyID4gYi55ICsgYi5oZWlnaHQgLyAyIHx8XG4gICAgICAgICAgICBhLnkgLSBhLmhlaWdodCAvIDIgPCBiLnkgLSBiLmhlaWdodCAvIDIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHdvcmQgaW50ZXJzZWN0cyBhbm90aGVyIHdvcmQsIG9yIGlzIG5vdCBmdWxseSBjb250YWluZWQgaW4gdGhlXG4gICAgICogdGlsZSBib3VuZGluZyBib3hcbiAgICAgKi9cbiAgICBsZXQgaW50ZXJzZWN0V29yZCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCB3b3JkLCBjbG91ZCwgYmIpIHtcbiAgICAgICAgbGV0IGJveCA9IHtcbiAgICAgICAgICAgIHg6IHBvc2l0aW9uLngsXG4gICAgICAgICAgICB5OiBwb3NpdGlvbi55LFxuICAgICAgICAgICAgaGVpZ2h0OiB3b3JkLmhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB3b3JkLndpZHRoXG4gICAgICAgIH07XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2xvdWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3RUZXN0KGJveCwgY2xvdWRbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSBzdXJlIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHRoZSBib3JkZXI7XG4gICAgICAgIGlmIChvdmVybGFwVGVzdChib3gsIGJiKSkge1xuICAgICAgICAgICAgLy8gaWYgaXQgaGl0cyBhIGJvcmRlciwgaW5jcmVtZW50IGNvbGxpc2lvbiBjb3VudFxuICAgICAgICAgICAgLy8gYW5kIGV4dGVuZCBhcmMgbGVuZ3RoXG4gICAgICAgICAgICBwb3NpdGlvbi5jb2xsaXNpb25zKys7XG4gICAgICAgICAgICBwb3NpdGlvbi5hcmNMZW5ndGggPSBwb3NpdGlvbi5yYWRpdXM7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGxldCBXb3JkQ2xvdWQgPSBIVE1MLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIG1peGluc1xuICAgICAgICAgICAgVmFsdWVUcmFuc2Zvcm1cbiAgICAgICAgXSxcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBtYXhOdW1Xb3JkczogMTUsXG4gICAgICAgICAgICBtaW5Gb250U2l6ZTogMTAsXG4gICAgICAgICAgICBtYXhGb250U2l6ZTogMjBcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFZhbHVlVHJhbnNmb3JtLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhclNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHQgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEhpZ2hsaWdodDogZnVuY3Rpb24od29yZCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IHNlbGVjdGVkIHdvcmRcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5hZGRDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICAkKGAud29yZC1jbG91ZC1sYWJlbFtkYXRhLXdvcmQ9XCIke3dvcmR9XCJdYCkuYWRkQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHQgPSB3b3JkO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2VPdmVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gJChlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICQoJy53b3JkLWNsb3VkLWxhYmVsJykucmVtb3ZlQ2xhc3MoJ2hvdmVyJyk7XG4gICAgICAgICAgICBsZXQgd29yZCA9IHRhcmdldC5hdHRyKCdkYXRhLXdvcmQnKTtcbiAgICAgICAgICAgIGlmICh3b3JkKSB7XG4gICAgICAgICAgICAgICAgLy8gaGlnaGxpZ2h0IGFsbCBpbnN0YW5jZXMgb2YgdGhlIHdvcmRcbiAgICAgICAgICAgICAgICAkKGAud29yZC1jbG91ZC1sYWJlbFtkYXRhLXdvcmQ9XCIke3dvcmR9XCJdYCkuYWRkQ2xhc3MoJ2hvdmVyJyk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGxheWVyIGNvb3JkXG4gICAgICAgICAgICAgICAgbGV0IGxheWVyUG9pbnQgPSB0aGlzLmdldExheWVyUG9pbnRGcm9tRXZlbnQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGlsZSBjb29yZFxuICAgICAgICAgICAgICAgIGxldCBjb29yZCA9IHRoaXMuZ2V0VGlsZUNvb3JkRnJvbUxheWVyUG9pbnQobGF5ZXJQb2ludCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGtleVxuICAgICAgICAgICAgICAgIGxldCBua2V5ID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGVudHJ5XG4gICAgICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX2NhY2hlW25rZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW92ZXInLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtOiBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHdvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjb29yZC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogY29vcmQueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHo6IGNvb3JkLnosXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjYWNoZWQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3b3JkLWNsb3VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gJChlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICQoJy53b3JkLWNsb3VkLWxhYmVsJykucmVtb3ZlQ2xhc3MoJ2hvdmVyJyk7XG4gICAgICAgICAgICBsZXQgd29yZCA9IHRhcmdldC5hdHRyKCdkYXRhLXdvcmQnKTtcbiAgICAgICAgICAgIGlmICh3b3JkKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGxheWVyIGNvb3JkXG4gICAgICAgICAgICAgICAgbGV0IGxheWVyUG9pbnQgPSB0aGlzLmdldExheWVyUG9pbnRGcm9tRXZlbnQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGlsZSBjb29yZFxuICAgICAgICAgICAgICAgIGxldCBjb29yZCA9IHRoaXMuZ2V0VGlsZUNvb3JkRnJvbUxheWVyUG9pbnQobGF5ZXJQb2ludCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGtleVxuICAgICAgICAgICAgICAgIGxldCBua2V5ID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGVudHJ5XG4gICAgICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX2NhY2hlW25rZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW91dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW06IGUub3JpZ2luYWxFdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNvb3JkLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBjb29yZC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgejogY29vcmQueixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGNhY2hlZC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3dvcmQtY2xvdWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIC8vIHVuLXNlbGVjdCBhbnkgcHJldiBzZWxlY3RlZCB3b3Jkc1xuICAgICAgICAgICAgJCgnLndvcmQtY2xvdWQtbGFiZWwnKS5yZW1vdmVDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgLy8gZ2V0IHRhcmdldFxuICAgICAgICAgICAgbGV0IHRhcmdldCA9ICQoZS5vcmlnaW5hbEV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUYXJnZXRMYXllcihlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgbGF5ZXIgaXMgbm90IHRoZSB0YXJnZXRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgd29yZCA9IHRhcmdldC5hdHRyKCdkYXRhLXdvcmQnKTtcbiAgICAgICAgICAgIGlmICh3b3JkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIaWdobGlnaHQod29yZCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGxheWVyIGNvb3JkXG4gICAgICAgICAgICAgICAgbGV0IGxheWVyUG9pbnQgPSB0aGlzLmdldExheWVyUG9pbnRGcm9tRXZlbnQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGlsZSBjb29yZFxuICAgICAgICAgICAgICAgIGxldCBjb29yZCA9IHRoaXMuZ2V0VGlsZUNvb3JkRnJvbUxheWVyUG9pbnQobGF5ZXJQb2ludCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGtleVxuICAgICAgICAgICAgICAgIGxldCBua2V5ID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGVudHJ5XG4gICAgICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX2NhY2hlW25rZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdjbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW06IGUub3JpZ2luYWxFdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNvb3JkLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBjb29yZC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgejogY29vcmQueixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGNhY2hlZC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3dvcmQtY2xvdWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX21lYXN1cmVXb3JkczogZnVuY3Rpb24od29yZENvdW50cykge1xuICAgICAgICAgICAgLy8gc29ydCB3b3JkcyBieSBmcmVxdWVuY3lcbiAgICAgICAgICAgIHdvcmRDb3VudHMgPSB3b3JkQ291bnRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYi5jb3VudCAtIGEuY291bnQ7XG4gICAgICAgICAgICB9KS5zbGljZSgwLCB0aGlzLm9wdGlvbnMubWF4TnVtV29yZHMpO1xuICAgICAgICAgICAgLy8gYnVpbGQgbWVhc3VyZW1lbnQgaHRtbFxuICAgICAgICAgICAgbGV0ICRodG1sID0gJCgnPGRpdiBzdHlsZT1cImhlaWdodDoyNTZweDsgd2lkdGg6MjU2cHg7XCI+PC9kaXY+Jyk7XG4gICAgICAgICAgICBsZXQgbWluRm9udFNpemUgPSB0aGlzLm9wdGlvbnMubWluRm9udFNpemU7XG4gICAgICAgICAgICBsZXQgbWF4Rm9udFNpemUgPSB0aGlzLm9wdGlvbnMubWF4Rm9udFNpemU7XG4gICAgICAgICAgICB3b3JkQ291bnRzLmZvckVhY2god29yZCA9PiB7XG4gICAgICAgICAgICAgICAgd29yZC5wZXJjZW50ID0gdGhpcy50cmFuc2Zvcm1WYWx1ZSh3b3JkLmNvdW50KTtcbiAgICAgICAgICAgICAgICB3b3JkLmZvbnRTaXplID0gbWluRm9udFNpemUgKyB3b3JkLnBlcmNlbnQgKiAobWF4Rm9udFNpemUgLSBtaW5Gb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgJGh0bWwuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3b3JkLWNsb3VkLWxhYmVsXCIgc3R5bGU9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6aGlkZGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAke3dvcmQuZm9udFNpemV9cHg7XCI+JHt3b3JkLnRleHR9PC9kaXY+O1xuICAgICAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gYXBwZW5kIG1lYXN1cmVtZW50c1xuICAgICAgICAgICAgJCgnYm9keScpLmFwcGVuZCgkaHRtbCk7XG4gICAgICAgICAgICAkaHRtbC5jaGlsZHJlbigpLmVhY2goKGluZGV4LCBlbGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgd29yZENvdW50c1tpbmRleF0ud2lkdGggPSBlbGVtLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIHdvcmRDb3VudHNbaW5kZXhdLmhlaWdodCA9IGVsZW0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkaHRtbC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHJldHVybiB3b3JkQ291bnRzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGVXb3JkQ2xvdWQ6IGZ1bmN0aW9uKHdvcmRDb3VudHMpIHtcbiAgICAgICAgICAgIGxldCB0aWxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcbiAgICAgICAgICAgIGxldCBib3VuZGluZ0JveCA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGlsZVNpemUgLSBIT1JJWk9OVEFMX09GRlNFVCAqIDIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aWxlU2l6ZSAtIFZFUlRJQ0FMX09GRlNFVCAqIDIsXG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGNsb3VkID0gW107XG4gICAgICAgICAgICAvLyBzb3J0IHdvcmRzIGJ5IGZyZXF1ZW5jeVxuICAgICAgICAgICAgd29yZENvdW50cyA9IHRoaXMuX21lYXN1cmVXb3Jkcyh3b3JkQ291bnRzKTtcbiAgICAgICAgICAgIC8vIGFzc2VtYmxlIHdvcmQgY2xvdWRcbiAgICAgICAgICAgIHdvcmRDb3VudHMuZm9yRWFjaCh3b3JkQ291bnQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0aW5nIHNwaXJhbCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIGxldCBwb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJhZGl1czogMSxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzSW5jOiA1LFxuICAgICAgICAgICAgICAgICAgICBhcmNMZW5ndGg6IDEwLFxuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICB0OiAwLFxuICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25zOiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBzcGlyYWwgb3V0d2FyZHMgdG8gZmluZCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIHdoaWxlIChwb3MuY29sbGlzaW9ucyA8IE5VTV9BVFRFTVBUUykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgcG9zaXRpb24gaW4gYSBzcGlyYWxcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gc3BpcmFsUG9zaXRpb24ocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGVzdCBmb3IgaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW50ZXJzZWN0V29yZChwb3MsIHdvcmRDb3VudCwgY2xvdWQsIGJvdW5kaW5nQm94KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvdWQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB3b3JkQ291bnQua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHdvcmRDb3VudC50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiB3b3JkQ291bnQuZm9udFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudDogTWF0aC5yb3VuZCgod29yZENvdW50LnBlcmNlbnQgKiAxMDApIC8gMTApICogMTAsIC8vIHJvdW5kIHRvIG5lYXJlc3QgMTBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBwb3MueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwb3MueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd29yZENvdW50LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogd29yZENvdW50LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW50aW1lbnQ6IHdvcmRDb3VudC5zZW50aW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZnOiB3b3JkQ291bnQuYXZnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2xvdWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXh0cmFjdEV4dHJlbWE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGxldCBzdW1zID0gXy5tYXAoZGF0YSwgZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgICAgICAgICBjb3VudCA9IGNvdW50LmNvdW50cyB8fCBjb3VudDtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc051bWJlcihjb3VudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VudGltZW50LmdldFRvdGFsKGNvdW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IF8ubWluKHN1bXMpLFxuICAgICAgICAgICAgICAgIG1heDogXy5tYXgoc3VtcyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFRleHQ6IGZ1bmN0aW9uKGtleURhdGEsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghZGF0YSB8fCBfLmlzRW1wdHkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaGlnaGxpZ2h0ID0gdGhpcy5oaWdobGlnaHQ7XG4gICAgICAgICAgICBsZXQgd29yZENvdW50cyA9IF8ubWFwKGRhdGEsIChrZXlEYXRhLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY291bnQgPSBrZXlEYXRhLmNvdW50cyB8fCBrZXlEYXRhO1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gdGhpcy5nZXRUZXh0KGtleURhdGEsIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNOdW1iZXIoY291bnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogY291bnRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsID0gc2VudGltZW50LmdldFRvdGFsKGNvdW50KTtcbiAgICAgICAgICAgICAgICBsZXQgYXZnID0gc2VudGltZW50LmdldEF2Zyhjb3VudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiB0b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgYXZnOiBhdmcsXG4gICAgICAgICAgICAgICAgICAgIHNlbnRpbWVudDogc2VudGltZW50RnVuYyhhdmcpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZXhpdCBlYXJseSBpZiBubyB3b3Jkc1xuICAgICAgICAgICAgaWYgKHdvcmRDb3VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZ2VuZXJlYXRlIHRoZSBjbG91ZFxuICAgICAgICAgICAgbGV0IGNsb3VkID0gdGhpcy5fY3JlYXRlV29yZENsb3VkKHdvcmRDb3VudHMpO1xuICAgICAgICAgICAgLy8gYnVpbGQgaHRtbCBlbGVtZW50c1xuICAgICAgICAgICAgbGV0IGhhbGZTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplIC8gMjtcbiAgICAgICAgICAgIGxldCBodG1sID0gJyc7XG4gICAgICAgICAgICBjbG91ZC5mb3JFYWNoKGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgY2xhc3Nlc1xuICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3dvcmQtY2xvdWQtbGFiZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYHdvcmQtY2xvdWQtbGFiZWwtJHt3b3JkLnBlcmNlbnR9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQudGV4dCA9PT0gaGlnaGxpZ2h0ID8gJ2hpZ2hsaWdodCcgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQuc2VudGltZW50ID8gd29yZC5zZW50aW1lbnQgOiAnJ1xuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgc3R5bGVzXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBmb250LXNpemU6ICR7d29yZC5mb250U2l6ZX1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICBgbGVmdDogJHsoaGFsZlNpemUgKyB3b3JkLngpIC0gKHdvcmQud2lkdGggLyAyKX1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICBgdG9wOiAkeyhoYWxmU2l6ZSArIHdvcmQueSkgLSAod29yZC5oZWlnaHQgLyAyKX1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICBgd2lkdGg6ICR7d29yZC53aWR0aH1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICBgaGVpZ2h0OiAke3dvcmQuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKCc7Jyk7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGh0bWwgZm9yIGVudHJ5XG4gICAgICAgICAgICAgICAgaHRtbCArPVxuICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke2NsYXNzTmFtZXN9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwiJHtzdHlsZXN9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtc2VudGltZW50PVwiJHt3b3JkLmF2Z31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS13b3JkPVwiJHt3b3JkLmtleX1cIj4ke3dvcmQudGV4dH08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBXb3JkQ2xvdWQ7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgSFRNTCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvSFRNTCcpO1xuICAgIGxldCBWYWx1ZVRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uLy4uL21peGluL1ZhbHVlVHJhbnNmb3JtJyk7XG4gICAgbGV0IHNlbnRpbWVudCA9IHJlcXVpcmUoJy4uLy4uL3NlbnRpbWVudC9TZW50aW1lbnQnKTtcbiAgICBsZXQgc2VudGltZW50RnVuYyA9IHNlbnRpbWVudC5nZXRDbGFzc0Z1bmMoLTEsIDEpO1xuXG4gICAgbGV0IGlzU2luZ2xlVmFsdWUgPSBmdW5jdGlvbihjb3VudCkge1xuICAgICAgICAvLyBzaW5nbGUgdmFsdWVzIGFyZSBuZXZlciBudWxsLCBhbmQgYWx3YXlzIG51bWJlcnNcbiAgICAgICAgcmV0dXJuIGNvdW50ICE9PSBudWxsICYmIF8uaXNOdW1iZXIoY291bnQpO1xuICAgIH07XG5cbiAgICBsZXQgZXh0cmFjdENvdW50ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgaWYgKGlzU2luZ2xlVmFsdWUoY291bnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbnRpbWVudC5nZXRUb3RhbChjb3VudCk7XG4gICAgfTtcblxuICAgIGxldCBleHRyYWN0U2VudGltZW50Q2xhc3MgPSBmdW5jdGlvbihhdmcpIHtcbiAgICAgICAgaWYgKGF2ZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VudGltZW50RnVuYyhhdmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuXG4gICAgbGV0IGV4dHJhY3RGcmVxdWVuY3kgPSBmdW5jdGlvbihjb3VudCkge1xuICAgICAgICBjb3VudCA9IGNvdW50LmNvdW50cyB8fCBjb3VudDtcbiAgICAgICAgaWYgKGlzU2luZ2xlVmFsdWUoY291bnQpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY291bnQ6IHNlbnRpbWVudC5nZXRUb3RhbChjb3VudCksXG4gICAgICAgICAgICBhdmc6IHNlbnRpbWVudC5nZXRBdmcoY291bnQpXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGxldCBleHRyYWN0QXZnID0gZnVuY3Rpb24oZnJlcXVlbmNpZXMpIHtcbiAgICAgICAgaWYgKGZyZXF1ZW5jaWVzWzBdLmF2ZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1bSA9IF8uc3VtQnkoZnJlcXVlbmNpZXMsIGZ1bmN0aW9uKGZyZXF1ZW5jeSkge1xuICAgICAgICAgICAgcmV0dXJuIGZyZXF1ZW5jeS5hdmc7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3VtIC8gZnJlcXVlbmNpZXMubGVuZ3RoO1xuICAgIH07XG5cbiAgICBsZXQgV29yZEhpc3RvZ3JhbSA9IEhUTUwuZXh0ZW5kKHtcblxuICAgICAgICBpbmNsdWRlczogW1xuICAgICAgICAgICAgLy8gbWl4aW5zXG4gICAgICAgICAgICBWYWx1ZVRyYW5zZm9ybVxuICAgICAgICBdLFxuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1heE51bVdvcmRzOiA4LFxuICAgICAgICAgICAgbWluRm9udFNpemU6IDE2LFxuICAgICAgICAgICAgbWF4Rm9udFNpemU6IDIyXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBWYWx1ZVRyYW5zZm9ybS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRIaWdobGlnaHQ6IGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIC8vIEhpZ2hsaWdodCBzZWxlY3RlZCB3b3JkXG4gICAgICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikuYWRkQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgJChgLndvcmQtaGlzdG9ncmFtLWVudHJ5W2RhdGEtd29yZD1cIiR7d29yZH1cIl1gKS5hZGRDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodCA9IHdvcmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU92ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSAkKGUub3JpZ2luYWxFdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgJCgnLndvcmQtaGlzdG9ncmFtLWVudHJ5JykucmVtb3ZlQ2xhc3MoJ2hvdmVyJyk7XG4gICAgICAgICAgICBsZXQgd29yZCA9IHRhcmdldC5hdHRyKCdkYXRhLXdvcmQnKTtcbiAgICAgICAgICAgIGlmICh3b3JkKSB7XG4gICAgICAgICAgICAgICAgJChgLndvcmQtaGlzdG9ncmFtLWVudHJ5W2RhdGEtd29yZD1cIiR7d29yZH1cIl1gKS5hZGRDbGFzcygnaG92ZXInKTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgbGF5ZXIgY29vcmRcbiAgICAgICAgICAgICAgICBsZXQgbGF5ZXJQb2ludCA9IHRoaXMuZ2V0TGF5ZXJQb2ludEZyb21FdmVudChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aWxlIGNvb3JkXG4gICAgICAgICAgICAgICAgbGV0IGNvb3JkID0gdGhpcy5nZXRUaWxlQ29vcmRGcm9tTGF5ZXJQb2ludChsYXllclBvaW50KTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgY2FjaGUga2V5XG4gICAgICAgICAgICAgICAgbGV0IG5rZXkgPSB0aGlzLmNhY2hlS2V5RnJvbUNvb3JkKGNvb3JkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgY2FjaGUgZW50cnlcbiAgICAgICAgICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5fY2FjaGVbbmtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZCAmJiBjYWNoZWQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3ZlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW06IGUub3JpZ2luYWxFdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNvb3JkLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBjb29yZC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgejogY29vcmQueixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGNhY2hlZC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3dvcmQtaGlzdG9ncmFtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gJChlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICQoJy53b3JkLWhpc3RvZ3JhbS1lbnRyeScpLnJlbW92ZUNsYXNzKCdob3ZlcicpO1xuICAgICAgICAgICAgbGV0IHdvcmQgPSB0YXJnZXQuYXR0cignZGF0YS13b3JkJyk7XG4gICAgICAgICAgICBpZiAod29yZCkge1xuICAgICAgICAgICAgICAgIC8vIGdldCBsYXllciBjb29yZFxuICAgICAgICAgICAgICAgIGxldCBsYXllclBvaW50ID0gdGhpcy5nZXRMYXllclBvaW50RnJvbUV2ZW50KGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRpbGUgY29vcmRcbiAgICAgICAgICAgICAgICBsZXQgY29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZyb21MYXllclBvaW50KGxheWVyUG9pbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjYWNoZSBrZXlcbiAgICAgICAgICAgICAgICBsZXQgbmtleSA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29vcmQsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjYWNoZSBlbnRyeVxuICAgICAgICAgICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9jYWNoZVtua2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkICYmIGNhY2hlZC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtOiBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHdvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjb29yZC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogY29vcmQueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHo6IGNvb3JkLnosXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjYWNoZWQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3b3JkLWhpc3RvZ3JhbScsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgLy8gdW4tc2VsZWN0IGFuZCBwcmV2IHNlbGVjdGVkIGhpc3RvZ3JhbVxuICAgICAgICAgICAgJCgnLndvcmQtaGlzdG9ncmFtLWVudHJ5JykucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgIC8vIGdldCB0YXJnZXRcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSAkKGUub3JpZ2luYWxFdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVGFyZ2V0TGF5ZXIoZS5vcmlnaW5hbEV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGxheWVyIGlzIG5vdCB0aGUgdGFyZ2V0XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHdvcmQgPSB0YXJnZXQuYXR0cignZGF0YS13b3JkJyk7XG4gICAgICAgICAgICBpZiAod29yZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SGlnaGxpZ2h0KHdvcmQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBsYXllciBjb29yZFxuICAgICAgICAgICAgICAgIGxldCBsYXllclBvaW50ID0gdGhpcy5nZXRMYXllclBvaW50RnJvbUV2ZW50KGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRpbGUgY29vcmRcbiAgICAgICAgICAgICAgICBsZXQgY29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZyb21MYXllclBvaW50KGxheWVyUG9pbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjYWNoZSBrZXlcbiAgICAgICAgICAgICAgICBsZXQgbmtleSA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29vcmQsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjYWNoZSBlbnRyeVxuICAgICAgICAgICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9jYWNoZVtua2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkICYmIGNhY2hlZC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdmVyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbTogZS5vcmlnaW5hbEV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogY29vcmQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNvb3JkLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB6OiBjb29yZC56LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY2FjaGVkLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd29yZC1oaXN0b2dyYW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXh0cmFjdEV4dHJlbWE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGxldCBzdW1zID0gXy5tYXAoZGF0YSwgY291bnRzID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zdW1CeShjb3VudHMsIGV4dHJhY3RDb3VudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWluOiBfLm1pbihzdW1zKSxcbiAgICAgICAgICAgICAgICBtYXg6IF8ubWF4KHN1bXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRUZXh0OiBmdW5jdGlvbihrZXlEYXRhLCBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXh0cmFjdFZhbHVlczogKGRhdGEsIGtleSkgPT4ge1xuICAgICAgICAgICAgbGV0IGZyZXF1ZW5jaWVzID0gXy5tYXAoZGF0YSwgZXh0cmFjdEZyZXF1ZW5jeSk7XG4gICAgICAgICAgICBsZXQgYXZnID0gZXh0cmFjdEF2ZyhmcmVxdWVuY2llcyk7XG4gICAgICAgICAgICBsZXQgbWF4ID0gXy5tYXhCeShmcmVxdWVuY2llcywgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5jb3VudDtcbiAgICAgICAgICAgIH0pLmNvdW50O1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gXy5zdW1CeShmcmVxdWVuY2llcywgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5jb3VudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB0b3BpYzogdGhpcy5nZXRUZXh0KGRhdGEsIGtleSksXG4gICAgICAgICAgICAgICAgZnJlcXVlbmNpZXM6IGZyZXF1ZW5jaWVzLFxuICAgICAgICAgICAgICAgIG1heDogbWF4LFxuICAgICAgICAgICAgICAgIHRvdGFsOiB0b3RhbCxcbiAgICAgICAgICAgICAgICBhdmc6IGF2Z1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghZGF0YSB8fCBfLmlzRW1wdHkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaGlnaGxpZ2h0ID0gdGhpcy5oaWdobGlnaHQ7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IG9iamVjdCB0byBhcnJheVxuICAgICAgICAgICAgbGV0IHZhbHVlcyA9IF8ubWFwKGRhdGEsIHRoaXMuZXh0cmFjdFZhbHVlcykuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiLnRvdGFsIC0gYS50b3RhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZ2V0IG51bWJlciBvZiBlbnRyaWVzXG4gICAgICAgICAgICBsZXQgbnVtRW50cmllcyA9IE1hdGgubWluKHZhbHVlcy5sZW5ndGgsIHRoaXMub3B0aW9ucy5tYXhOdW1Xb3Jkcyk7XG4gICAgICAgICAgICBsZXQgJGh0bWwgPSAkKCc8ZGl2IGNsYXNzPVwid29yZC1oaXN0b2dyYW1zXCIgc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9jaztcIj48L2Rpdj4nKTtcbiAgICAgICAgICAgIGxldCB0b3RhbEhlaWdodCA9IDA7XG4gICAgICAgICAgICBsZXQgbWluRm9udFNpemUgPSB0aGlzLm9wdGlvbnMubWluRm9udFNpemU7XG4gICAgICAgICAgICBsZXQgbWF4Rm9udFNpemUgPSB0aGlzLm9wdGlvbnMubWF4Rm9udFNpemU7XG4gICAgICAgICAgICB2YWx1ZXMuc2xpY2UoMCwgbnVtRW50cmllcykuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IHZhbHVlLmtleTtcbiAgICAgICAgICAgICAgICBsZXQgdG9waWMgPSB2YWx1ZS50b3BpYztcbiAgICAgICAgICAgICAgICBsZXQgZnJlcXVlbmNpZXMgPSB2YWx1ZS5mcmVxdWVuY2llcztcbiAgICAgICAgICAgICAgICBsZXQgbWF4ID0gdmFsdWUubWF4O1xuICAgICAgICAgICAgICAgIGxldCB0b3RhbCA9IHZhbHVlLnRvdGFsO1xuICAgICAgICAgICAgICAgIGxldCBhdmcgPSB2YWx1ZS5hdmc7XG4gICAgICAgICAgICAgICAgbGV0IHNlbnRpbWVudENsYXNzID0gZXh0cmFjdFNlbnRpbWVudENsYXNzKGF2Zyk7XG4gICAgICAgICAgICAgICAgbGV0IGhpZ2hsaWdodENsYXNzID0gKGtleSA9PT0gaGlnaGxpZ2h0KSA/ICdoaWdobGlnaHQnIDogJyc7XG4gICAgICAgICAgICAgICAgLy8gc2NhbGUgdGhlIGhlaWdodCBiYXNlZCBvbiBsZXZlbCBtaW4gLyBtYXhcbiAgICAgICAgICAgICAgICBsZXQgcGVyY2VudCA9IHRoaXMudHJhbnNmb3JtVmFsdWUodG90YWwpO1xuICAgICAgICAgICAgICAgIGxldCBwZXJjZW50TGFiZWwgPSBNYXRoLnJvdW5kKChwZXJjZW50ICogMTAwKSAvIDEwKSAqIDEwO1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBtaW5Gb250U2l6ZSArIHBlcmNlbnQgKiAobWF4Rm9udFNpemUgLSBtaW5Gb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgdG90YWxIZWlnaHQgKz0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBjb250YWluZXIgJ2VudHJ5JyBmb3IgY2hhcnQgYW5kIGhhc2h0YWdcbiAgICAgICAgICAgICAgICBsZXQgJGVudHJ5ID0gJChcbiAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwid29yZC1oaXN0b2dyYW0tZW50cnkgJHtoaWdobGlnaHRDbGFzc31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1zZW50aW1lbnQ9XCIke2F2Z31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS13b3JkPVwiJHtrZXl9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwiaGVpZ2h0OiR7aGVpZ2h0fXB4O1wiPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGNoYXJ0XG4gICAgICAgICAgICAgICAgbGV0ICRjaGFydCA9ICQoXG4gICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIndvcmQtaGlzdG9ncmFtLWxlZnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1zZW50aW1lbnQ9XCIke2F2Z31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS13b3JkPVwiJHtrZXl9XCI+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgYmFyV2lkdGggPSAnY2FsYygnICsgKDEwMCAvIGZyZXF1ZW5jaWVzLmxlbmd0aCkgKyAnJSknO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBiYXJzXG4gICAgICAgICAgICAgICAgZnJlcXVlbmNpZXMuZm9yRWFjaChmcmVxdWVuY3kgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY291bnQgPSBmcmVxdWVuY3kuY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhdmcgPSBmcmVxdWVuY3kuYXZnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VudGltZW50Q2xhc3MgPSBleHRyYWN0U2VudGltZW50Q2xhc3MoYXZnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBwZXJjZW50IHJlbGF0aXZlIHRvIHRoZSBoaWdoZXN0IGNvdW50IGluIHRoZSB0aWxlXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWxhdGl2ZVBlcmNlbnQgPSAobWF4ICE9PSAwKSA/IChjb3VudCAvIG1heCkgKiAxMDAgOiAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGludmlzaWJsZSBpZiB6ZXJvIGNvdW50XG4gICAgICAgICAgICAgICAgICAgIGxldCB2aXNpYmlsaXR5ID0gcmVsYXRpdmVQZXJjZW50ID09PSAwID8gJ2hpZGRlbicgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzdHlsZSBjbGFzcyBvZiB0aGUgYmFyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwZXJjZW50TGFiZWwgPSBNYXRoLnJvdW5kKHJlbGF0aXZlUGVyY2VudCAvIDEwKSAqIDEwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmFyQ2xhc3NlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnd29yZC1oaXN0b2dyYW0tYmFyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgd29yZC1oaXN0b2dyYW0tYmFyLSR7cGVyY2VudExhYmVsfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7c2VudGltZW50Q2xhc3N9LWZpbGxgXG4gICAgICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJhckhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJhclRvcDtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIHRoZXJlIGlzIGF0IGxlYXN0IGEgc2luZ2xlIHBpeGVsIG9mIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgIGlmICgocmVsYXRpdmVQZXJjZW50IC8gMTAwKSAqIGhlaWdodCA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhckhlaWdodCA9ICczcHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyVG9wID0gJ2NhbGMoMTAwJSAtIDNweCknO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFySGVpZ2h0ID0gYCR7cmVsYXRpdmVQZXJjZW50fSVgO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyVG9wID0gYCgxMDAgLSByZWxhdGl2ZVBlcmNlbnQpJWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGJhclxuICAgICAgICAgICAgICAgICAgICAkY2hhcnQuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7YmFyQ2xhc3Nlc31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtd29yZD1cIiR7a2V5fVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiAke3Zpc2liaWxpdHl9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAke2JhcldpZHRofTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICR7YmFySGVpZ2h0fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6ICR7YmFyVG9wfTtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgJGVudHJ5LmFwcGVuZCgkY2hhcnQpO1xuICAgICAgICAgICAgICAgIGxldCB0b3BpY0NsYXNzZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICd3b3JkLWhpc3RvZ3JhbS1sYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgIGB3b3JkLWhpc3RvZ3JhbS1sYWJlbC0ke3BlcmNlbnRMYWJlbH1gLFxuICAgICAgICAgICAgICAgICAgICBzZW50aW1lbnRDbGFzc1xuICAgICAgICAgICAgICAgIF0uam9pbignICcpO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0YWcgbGFiZWxcbiAgICAgICAgICAgICAgICBsZXQgJHRvcGljID0gJChcbiAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwid29yZC1oaXN0b2dyYW0tcmlnaHRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke3RvcGljQ2xhc3Nlc31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtc2VudGltZW50PVwiJHthdmd9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXdvcmQ9XCIke2tleX1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6ICR7aGVpZ2h0fXB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAke2hlaWdodH1weDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICR7aGVpZ2h0fXB4O1wiPiR7dG9waWN9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICAkZW50cnkuYXBwZW5kKCR0b3BpYyk7XG4gICAgICAgICAgICAgICAgJGh0bWwuYXBwZW5kKCRlbnRyeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRodG1sLmNzcygndG9wJywgKHRoaXMub3B0aW9ucy50aWxlU2l6ZSAvIDIpIC0gKHRvdGFsSGVpZ2h0IC8gMikpO1xuICAgICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICRodG1sWzBdLm91dGVySFRNTDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBXb3JkSGlzdG9ncmFtO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IERFTEFZID0gMTIwMDtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgIGxldCBkZWxheSA9IC0oTWF0aC5yYW5kb20oKSAqIERFTEFZKTtcbiAgICAgICAgICAgIGVsZW0uaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XCJibGlua2luZyBibGlua2luZy10aWxlXCIgc3R5bGU9XCJhbmltYXRpb24tZGVsYXk6JHtkZWxheX1tc1wiPjwvZGl2PmA7XG4gICAgICAgIH1cblxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgREVMQVkgPSAxMjAwO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgcmVuZGVyVGlsZTogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgbGV0IGRlbGF5ID0gLShNYXRoLnJhbmRvbSgpICogREVMQVkpO1xuICAgICAgICAgICAgZWxlbS5pbm5lckhUTUwgPVxuICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidmVydGljYWwtY2VudGVyZWQtYm94IGJsaW5raW5nXCIgc3R5bGU9XCJhbmltYXRpb24tZGVsYXk6ICR7ZGVsYXl9bXNcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsb2FkZXItY2lyY2xlXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibG9hZGVyLWxpbmUtbWFza1wiIHN0eWxlPVwiYW5pbWF0aW9uLWRlbGF5OiAke2RlbGF5fW1zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxvYWRlci1saW5lXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgICAgfVxuXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBERUxBWSA9IDEyMDA7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZGVsYXkgPSAtKE1hdGgucmFuZG9tKCkgKiBERUxBWSk7XG4gICAgICAgICAgICAgICAgaWYgKCQoZWxlbSkuaGFzQ2xhc3MoJ3BlbmRpbmcnKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwiYmxpbmtpbmcgYmxpbmtpbmctdGlsZVwiIHN0eWxlPVwiYW5pbWF0aW9uLWRlbGF5OiAke2RlbGF5fW1zXCI+PC9kaXY+YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBERUxBWSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgREVMQVkgPSAxMjAwO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgcmVuZGVyVGlsZTogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGRlbGF5ID0gLShNYXRoLnJhbmRvbSgpICogREVMQVkpO1xuICAgICAgICAgICAgICAgIGlmICgkKGVsZW0pLmhhc0NsYXNzKCdwZW5kaW5nJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5pbm5lckhUTUwgPVxuICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInZlcnRpY2FsLWNlbnRlcmVkLWJveFwiIHN0eWxlPVwiYW5pbWF0aW9uLWRlbGF5OiAke2RlbGF5fW1zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxvYWRlci1jaXJjbGVcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxvYWRlci1saW5lLW1hc2tcIiBzdHlsZT1cImFuaW1hdGlvbi1kZWxheTogJHtkZWxheX1tc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxvYWRlci1saW5lXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIERFTEFZKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBERUxBWSA9IDEyMDA7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICBsZXQgZGVsYXkgPSAtKE1hdGgucmFuZG9tKCkgKiBERUxBWSk7XG4gICAgICAgICAgICBlbGVtLmlubmVySFRNTCA9XG4gICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ2ZXJ0aWNhbC1jZW50ZXJlZC1ib3hcIiBzdHlsZT1cImFuaW1hdGlvbi1kZWxheTogJHtkZWxheX1tc1wiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxvYWRlci1jaXJjbGVcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsb2FkZXItbGluZS1tYXNrXCIgc3R5bGU9XCJhbmltYXRpb24tZGVsYXk6ICR7ZGVsYXl9bXNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibG9hZGVyLWxpbmVcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICBgO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IGVzcGVyID0gcmVxdWlyZSgnZXNwZXInKTtcbiAgICBsZXQgV2ViR0wgPSByZXF1aXJlKCcuLi8uLi9jb3JlL1dlYkdMJyk7XG4gICAgbGV0IENvbG9yUmFtcCA9IHJlcXVpcmUoJy4uLy4uL21peGluL0NvbG9yUmFtcCcpO1xuICAgIGxldCBWYWx1ZVRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uLy4uL21peGluL1ZhbHVlVHJhbnNmb3JtJyk7XG4gICAgbGV0IFNoYWRlcnMgPSByZXF1aXJlKCcuL1NoYWRlcnMnKTtcblxuICAgIGxldCBUSUxFX1NJWkUgPSAyNTY7XG5cbiAgICBmdW5jdGlvbiBlbmNvZGUoZW5jLCB2YWwpIHtcbiAgICAgICAgZW5jWzBdID0gKHZhbCAvIDE2Nzc3MjE2LjApICYgMHhGRjtcbiAgICAgICAgZW5jWzFdID0gKHZhbCAvIDY1NTM2LjApICYgMHhGRjtcbiAgICAgICAgZW5jWzJdID0gKHZhbCAvIDI1Ni4wKSAmIDB4RkY7XG4gICAgICAgIGVuY1szXSA9IHZhbCAmIDB4RkY7XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgfVxuXG4gICAgbGV0IEhlYXRtYXAgPSBXZWJHTC5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBtaXhpbnNcbiAgICAgICAgICAgIENvbG9yUmFtcCxcbiAgICAgICAgICAgIFZhbHVlVHJhbnNmb3JtXG4gICAgICAgIF0sXG5cbiAgICAgICAgb25XZWJHTEluaXQ6IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB3ZSB1c2UgdGhlIGNvcnJlY3QgY29udGV4dFxuICAgICAgICAgICAgZXNwZXIuV2ViR0xDb250ZXh0LmJpbmQodGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgICAgIC8vIHF1YWQgdmVydGljZXNcbiAgICAgICAgICAgIGxldCB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgIDAsIC1USUxFX1NJWkUsXG4gICAgICAgICAgICAgICAgVElMRV9TSVpFLCAtVElMRV9TSVpFLFxuICAgICAgICAgICAgICAgIFRJTEVfU0laRSwgMCxcbiAgICAgICAgICAgICAgICAwLCAtVElMRV9TSVpFLFxuICAgICAgICAgICAgICAgIFRJTEVfU0laRSwgMCxcbiAgICAgICAgICAgICAgICAwLCAwLFxuICAgICAgICAgICAgICAgIC8vIHV2c1xuICAgICAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICAgICAgMSwgMCxcbiAgICAgICAgICAgICAgICAxLCAxLFxuICAgICAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICAgICAgMSwgMSxcbiAgICAgICAgICAgICAgICAwLCAxXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIC8vIHF1YWQgYnVmZmVyXG4gICAgICAgICAgICB0aGlzLl9xdWFkQnVmZmVyID0gbmV3IGVzcGVyLlZlcnRleEJ1ZmZlcihcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIDA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRkxPQVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldDogMFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZMT0FUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IDIgKiA2ICogNFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiA2LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gbG9hZCBzaGFkZXJcbiAgICAgICAgICAgIHRoaXMuX3NoYWRlciA9IG5ldyBlc3Blci5TaGFkZXIoe1xuICAgICAgICAgICAgICAgIHZlcnQ6IFNoYWRlcnMuaGVhdG1hcC52ZXJ0LFxuICAgICAgICAgICAgICAgIGZyYWc6IFNoYWRlcnMuaGVhdG1hcC5mcmFnXG4gICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb25lKG51bGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBDb2xvclJhbXAuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgVmFsdWVUcmFuc2Zvcm0uaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2FjaGVMb2FkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgbGV0IGNhY2hlZCA9IGV2ZW50LmVudHJ5O1xuICAgICAgICAgICAgbGV0IGNvb3JkcyA9IGV2ZW50LmNvb3JkcztcbiAgICAgICAgICAgIGlmIChjYWNoZWQuZGF0YSAmJiBjYWNoZWQuZGF0YS5ieXRlTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyVGlsZVRleHR1cmUoY2FjaGVkLCBjb29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uRXh0cmVtYUNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfLmZvckluKHRoaXMuX2NhY2hlLCBjYWNoZWQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQuZGF0YSAmJiBjYWNoZWQuZGF0YS5ieXRlTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlclRpbGVUZXh0dXJlKGNhY2hlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVmZmVyVGlsZVRleHR1cmU6IGZ1bmN0aW9uKGNhY2hlZCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KGNhY2hlZC5kYXRhKTtcbiAgICAgICAgICAgIGxldCByZXNvbHV0aW9uID0gTWF0aC5zcXJ0KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBiaW5zID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKiA0KTtcbiAgICAgICAgICAgIGxldCBlbmMgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgICAgICBsZXQgYmluLCBpO1xuICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYmluID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICBzdW0gKz0gYmluO1xuICAgICAgICAgICAgICAgIGVuY29kZShlbmMsIGJpbik7XG4gICAgICAgICAgICAgICAgYmluc1tpICogNF0gPSBlbmNbMF07XG4gICAgICAgICAgICAgICAgYmluc1tpICogNCArIDFdID0gZW5jWzFdO1xuICAgICAgICAgICAgICAgIGJpbnNbaSAqIDQgKyAyXSA9IGVuY1syXTtcbiAgICAgICAgICAgICAgICBiaW5zW2kgKiA0ICsgM10gPSBlbmNbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VtID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSB3ZSB1c2UgdGhlIGNvcnJlY3QgY29udGV4dFxuICAgICAgICAgICAgICAgIGVzcGVyLldlYkdMQ29udGV4dC5iaW5kKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSB0ZXh0dXJlXG4gICAgICAgICAgICAgICAgY2FjaGVkLnRleHR1cmUgPSBuZXcgZXNwZXIuVGV4dHVyZTJEKHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgc3JjOiBiaW5zLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdSR0JBJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1VOU0lHTkVEX0JZVEUnLFxuICAgICAgICAgICAgICAgICAgICB3cmFwOiAnQ0xBTVBfVE9fRURHRScsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogJ05FQVJFU1QnLFxuICAgICAgICAgICAgICAgICAgICBpbnZlcnRZOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0UHJvamVjdGlvbk1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsZXQgYm91bmRzID0gdGhpcy5fbWFwLmdldFBpeGVsQm91bmRzKCk7XG4gICAgICAgICAgICBsZXQgZGltID0gTWF0aC5wb3coMiwgdGhpcy5fbWFwLmdldFpvb20oKSkgKiBUSUxFX1NJWkU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPcnRob01hdHJpeChcbiAgICAgICAgICAgICAgICBib3VuZHMubWluLngsXG4gICAgICAgICAgICAgICAgYm91bmRzLm1heC54LFxuICAgICAgICAgICAgICAgIChkaW0gLSBib3VuZHMubWF4LnkpLFxuICAgICAgICAgICAgICAgIChkaW0gLSBib3VuZHMubWluLnkpLFxuICAgICAgICAgICAgICAgIC0xLCAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXJUaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsZXQgYnVmZmVyID0gdGhpcy5fcXVhZEJ1ZmZlcjtcbiAgICAgICAgICAgIGxldCBzaGFkZXIgPSB0aGlzLl9zaGFkZXI7XG4gICAgICAgICAgICBsZXQgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICAgICAgICBsZXQgZGltID0gTWF0aC5wb3coMiwgem9vbSkgKiBUSUxFX1NJWkU7XG4gICAgICAgICAgICAvLyBiaW5kIGJ1ZmZlclxuICAgICAgICAgICAgYnVmZmVyLmJpbmQoKTtcbiAgICAgICAgICAgIC8vIGZvciBlYWNoIHRpbGVcbiAgICAgICAgICAgIF8uZm9ySW4odGhpcy5fY2FjaGUsIGNhY2hlZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZWQudGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGJpbmQgdGlsZSB0ZXh0dXJlIHRvIHRleHR1cmUgdW5pdCAwXG4gICAgICAgICAgICAgICAgY2FjaGVkLnRleHR1cmUuYmluZCgwKTtcbiAgICAgICAgICAgICAgICBfLmZvckluKGNhY2hlZC50aWxlcywgKHRpbGUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSB0aWxlcyBwb3NpdGlvbiBmcm9tIGl0cyBrZXlcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvb3JkcyA9IHRoaXMuY29vcmRGcm9tQ2FjaGVLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2UgaGF2ZSB0byBjaGVjayBoZXJlIGlmIHRoZSB0aWxlcyBhcmUgc3RhbGUgb3Igbm90XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb29yZHMueiAhPT0gem9vbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCB4ID0gVElMRV9TSVpFICogY29vcmRzLng7XG4gICAgICAgICAgICAgICAgICAgIGxldCB5ID0gKHRoaXMub3B0aW9ucy50bXMpID8gKFRJTEVfU0laRSAqIChjb29yZHMueSArIDEpKSA6IGRpbSAtIChUSUxFX1NJWkUgKiBjb29yZHMueSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBtb2RlbCBtYXRyaXhcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vZGVsID0gdGhpcy5nZXRUcmFuc2xhdGlvbk1hdHJpeCh4LCB5LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VNb2RlbE1hdHJpeCcsIG1vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZHJhdyB0aGUgdGlsZVxuICAgICAgICAgICAgICAgICAgICBidWZmZXIuZHJhdygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHVuYmluZCB0ZXh0dXJlXG4gICAgICAgICAgICAgICAgY2FjaGVkLnRleHR1cmUudW5iaW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHVuYmluZCBidWZmZXJcbiAgICAgICAgICAgIGJ1ZmZlci51bmJpbmQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXJGcmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBzZXR1cFxuICAgICAgICAgICAgdGhpcy5fdmlld3BvcnQucHVzaCgpO1xuICAgICAgICAgICAgdGhpcy5fc2hhZGVyLnVzZSgpO1xuICAgICAgICAgICAgLy8gc2V0IHVuaWZvcm1zXG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybSgndVByb2plY3Rpb25NYXRyaXgnLCB0aGlzLmdldFByb2plY3Rpb25NYXRyaXgoKSk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybSgndU9wYWNpdHknLCB0aGlzLmdldE9wYWNpdHkoKSk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybSgndVJhbmdlTWluJywgdGhpcy5nZXRWYWx1ZVJhbmdlKCkubWluKTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRlci5zZXRVbmlmb3JtKCd1UmFuZ2VNYXgnLCB0aGlzLmdldFZhbHVlUmFuZ2UoKS5tYXgpO1xuICAgICAgICAgICAgdGhpcy5fc2hhZGVyLnNldFVuaWZvcm0oJ3VNaW4nLCB0aGlzLmdldEV4dHJlbWEoKS5taW4pO1xuICAgICAgICAgICAgdGhpcy5fc2hhZGVyLnNldFVuaWZvcm0oJ3VNYXgnLCB0aGlzLmdldEV4dHJlbWEoKS5tYXgpO1xuICAgICAgICAgICAgdGhpcy5fc2hhZGVyLnNldFVuaWZvcm0oJ3VUcmFuc2Zvcm1UeXBlJywgdGhpcy5nZXRUcmFuc2Zvcm1FbnVtKCkpO1xuICAgICAgICAgICAgdGhpcy5fc2hhZGVyLnNldFVuaWZvcm0oJ3VUZXh0dXJlU2FtcGxlcicsIDApO1xuICAgICAgICAgICAgdGhpcy5fc2hhZGVyLnNldFVuaWZvcm0oJ3VSYW1wJywgdGhpcy5nZXRDb2xvclJhbXBUYWJsZSgpKTtcbiAgICAgICAgICAgIC8vIGRyYXdcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZXMoKTtcbiAgICAgICAgICAgIC8vIHRlYXJkb3duXG4gICAgICAgICAgICB0aGlzLl92aWV3cG9ydC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhlYXRtYXA7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgZXNwZXIgPSByZXF1aXJlKCdlc3BlcicpO1xuICAgIGxldCBwYXJhbGxlbCA9IHJlcXVpcmUoJ2FzeW5jL3BhcmFsbGVsJyk7XG4gICAgbGV0IFdlYkdMID0gcmVxdWlyZSgnLi4vLi4vY29yZS9XZWJHTCcpO1xuICAgIGxldCBTcGF0aWFsSGFzaCA9IHJlcXVpcmUoJy4uLy4uL21peGluL1NwYXRpYWxIYXNoJyk7XG4gICAgbGV0IFNoYWRlcnMgPSByZXF1aXJlKCcuL1NoYWRlcnMnKTtcblxuICAgIGxldCBUSUxFX1NJWkUgPSAyNTY7XG4gICAgbGV0IENPTVBPTkVOVF9CWVRFX1NJWkUgPSAyO1xuICAgIGxldCBDT01QT05FTlRTX1BFUl9QT0lOVCA9IDQ7IC8vIGVuY29kaW5nIHR3byB1aW50MzIncyBhY3Jvc3MgeHkvendcbiAgICBsZXQgTUFYX1RJTEVTID0gMTI4O1xuICAgIGxldCBNQVhfUE9JTlRTX1BFUl9USUxFID0gMjU2ICogMjU2O1xuICAgIGxldCBNQVhfVElMRV9CWVRFX1NJWkUgPSBNQVhfUE9JTlRTX1BFUl9USUxFICogQ09NUE9ORU5UU19QRVJfUE9JTlQgKiBDT01QT05FTlRfQllURV9TSVpFO1xuICAgIGxldCBNQVhfQlVGRkVSX0JZVEVfU0laRSA9IE1BWF9USUxFUyAqIE1BWF9USUxFX0JZVEVfU0laRTtcblxuICAgIGxldCBOVU1fU0xJQ0VTID0gNjQ7XG4gICAgbGV0IFBPSU5UX1JBRElVUyA9IDg7XG4gICAgbGV0IFBPSU5UX1JBRElVU19JTkMgPSAyO1xuXG4gICAgbGV0IFBPU0lUSU9OU19JTkRFWCA9IDA7XG4gICAgbGV0IE9GRlNFVFNfSU5ERVggPSAxO1xuXG4gICAgZnVuY3Rpb24gZW5jb2RlUG9pbnQoYXJyYXlidWZmZXIsIGluZGV4LCB4LCB5KSB7XG4gICAgICAgIGFycmF5YnVmZmVyW2luZGV4XSA9IHggPj4gMTY7XG4gICAgICAgIGFycmF5YnVmZmVyW2luZGV4KzFdID0geCAmIDB4MDAwMEZGRkY7XG4gICAgICAgIGFycmF5YnVmZmVyW2luZGV4KzJdID0geSA+PiAxNjtcbiAgICAgICAgYXJyYXlidWZmZXJbaW5kZXgrM10gPSB5ICYgMHgwMDAwRkZGRjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseUppdHRlcihwb2ludCwgbWF4RGlzdCkge1xuICAgICAgICBsZXQgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogKE1hdGguUEkgKiAyKTtcbiAgICAgICAgbGV0IGRpc3QgPSBNYXRoLnJhbmRvbSgpICogbWF4RGlzdDtcbiAgICAgICAgcG9pbnQueCArPSBNYXRoLkZsb29yKE1hdGguY29zKGFuZ2xlKSAqIGRpc3QpO1xuICAgICAgICBwb2ludC55ICs9IE1hdGguRmxvb3IoTWF0aC5zaW4oYW5nbGUpICogZGlzdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2lyY2xlT3V0bGluZUJ1ZmZlcihudW1TZWdtZW50cykge1xuICAgICAgICBsZXQgdGhldGEgPSAoMiAqIE1hdGguUEkpIC8gbnVtU2VnbWVudHM7XG4gICAgICAgIGxldCByYWRpdXMgPSAxLjA7XG4gICAgICAgIC8vIHByZWNhbGN1bGF0ZSBzaW5lIGFuZCBjb3NpbmVcbiAgICAgICAgbGV0IGMgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgIGxldCBzID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgICBsZXQgdDtcbiAgICAgICAgLy8gc3RhcnQgYXQgYW5nbGUgPSAwXG4gICAgICAgIGxldCB4ID0gcmFkaXVzO1xuICAgICAgICBsZXQgeSA9IDA7XG4gICAgICAgIGxldCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KG51bVNlZ21lbnRzICogMik7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICBwb3NpdGlvbnNbaSoyXSA9IHg7XG4gICAgICAgICAgICBwb3NpdGlvbnNbaSoyKzFdID0geTtcbiAgICAgICAgICAgIC8vIGFwcGx5IHRoZSByb3RhdGlvblxuICAgICAgICAgICAgdCA9IHg7XG4gICAgICAgICAgICB4ID0gYyAqIHggLSBzICogeTtcbiAgICAgICAgICAgIHkgPSBzICogdCArIGMgKiB5O1xuICAgICAgICB9XG4gICAgICAgIGxldCBwb2ludGVycyA9IHt9O1xuICAgICAgICBwb2ludGVyc1tQT1NJVElPTlNfSU5ERVhdID0ge1xuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIHR5cGU6ICdGTE9BVCdcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtb2RlOiAnTElORV9MT09QJyxcbiAgICAgICAgICAgIGNvdW50OiBwb3NpdGlvbnMubGVuZ3RoIC8gMlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IGVzcGVyLlZlcnRleEJ1ZmZlcihwb3NpdGlvbnMsIHBvaW50ZXJzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDaXJjbGVGaWxsQnVmZmVyKG51bVNlZ21lbnRzKSB7XG4gICAgICAgIGxldCB0aGV0YSA9ICgyICogTWF0aC5QSSkgLyBudW1TZWdtZW50cztcbiAgICAgICAgbGV0IHJhZGl1cyA9IDEuMDtcbiAgICAgICAgLy8gcHJlY2FsY3VsYXRlIHNpbmUgYW5kIGNvc2luZVxuICAgICAgICBsZXQgYyA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgbGV0IHMgPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgIGxldCB0O1xuICAgICAgICAvLyBzdGFydCBhdCBhbmdsZSA9IDBcbiAgICAgICAgbGV0IHggPSByYWRpdXM7XG4gICAgICAgIGxldCB5ID0gMDtcbiAgICAgICAgbGV0IHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoKG51bVNlZ21lbnRzICsgMikgKiAyKTtcbiAgICAgICAgcG9zaXRpb25zWzBdID0gMDtcbiAgICAgICAgcG9zaXRpb25zWzFdID0gMDtcbiAgICAgICAgcG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGgtMl0gPSByYWRpdXM7XG4gICAgICAgIHBvc2l0aW9uc1twb3NpdGlvbnMubGVuZ3RoLTFdID0gMDtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHBvc2l0aW9uc1soaSsxKSoyXSA9IHg7XG4gICAgICAgICAgICBwb3NpdGlvbnNbKGkrMSkqMisxXSA9IHk7XG4gICAgICAgICAgICAvLyBhcHBseSB0aGUgcm90YXRpb25cbiAgICAgICAgICAgIHQgPSB4O1xuICAgICAgICAgICAgeCA9IGMgKiB4IC0gcyAqIHk7XG4gICAgICAgICAgICB5ID0gcyAqIHQgKyBjICogeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwb2ludGVycyA9IHt9O1xuICAgICAgICBwb2ludGVyc1tQT1NJVElPTlNfSU5ERVhdID0ge1xuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIHR5cGU6ICdGTE9BVCdcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtb2RlOiAnVFJJQU5HTEVfRkFOJyxcbiAgICAgICAgICAgIGNvdW50OiBwb3NpdGlvbnMubGVuZ3RoIC8gMlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IGVzcGVyLlZlcnRleEJ1ZmZlcihwb3NpdGlvbnMsIHBvaW50ZXJzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBsZXQgUG9pbnQgPSBXZWJHTC5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBtaXhpbnNcbiAgICAgICAgICAgIFNwYXRpYWxIYXNoXG4gICAgICAgIF0sXG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgcG9pbnRPdXRsaW5lOiAxLFxuICAgICAgICAgICAgcG9pbnRPdXRsaW5lQ29sb3I6IFswLjAsIDAuMCwgMC4wLCAxLjBdLFxuICAgICAgICAgICAgcG9pbnRGaWxsQ29sb3I6IFswLjIsIDAuMTUsIDAuNCwgMC41XSxcbiAgICAgICAgICAgIHBvaW50UmFkaXVzOiBQT0lOVF9SQURJVVMsXG4gICAgICAgICAgICBzZWxlY3RlZE91dGxpbmVDb2xvcjogWzAuMCwgMC4wLCAwLjAsIDEuMF0sXG4gICAgICAgICAgICBzZWxlY3RlZEZpbGxDb2xvcjogWzAuOCwgMC40LCAwLjIsIDAuNV0sXG4gICAgICAgICAgICBzZWxlY3RlZFJhZGl1czogUE9JTlRfUkFESVVTICsgUE9JTlRfUkFESVVTX0lOQyxcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkT3V0bGluZUNvbG9yOiBbMC4wLCAwLjAsIDAuMCwgMS4wXSxcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkRmlsbENvbG9yOiBbMC4zLCAwLjI1LCAwLjUsIDAuNV0sXG4gICAgICAgICAgICBoaWdobGlnaHRlZFJhZGl1czogUE9JTlRfUkFESVVTICsgUE9JTlRfUkFESVVTX0lOQyxcbiAgICAgICAgICAgIGJsZW5kaW5nOiB0cnVlLFxuICAgICAgICAgICAgaml0dGVyOiB0cnVlLFxuICAgICAgICAgICAgaml0dGVyRGlzdGFuY2U6IDEwXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBTcGF0aWFsSGFzaC5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25XZWJHTEluaXQ6IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB3ZSB1c2UgdGhlIGNvcnJlY3QgY29udGV4dFxuICAgICAgICAgICAgZXNwZXIuV2ViR0xDb250ZXh0LmJpbmQodGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgY2lyY2xlIHZlcnRleGJ1ZmZlclxuICAgICAgICAgICAgdGhpcy5fY2lyY2xlRmlsbEJ1ZmZlciA9IGNyZWF0ZUNpcmNsZUZpbGxCdWZmZXIoTlVNX1NMSUNFUyk7XG4gICAgICAgICAgICB0aGlzLl9jaXJjbGVPdXRsaW5lQnVmZmVyID0gY3JlYXRlQ2lyY2xlT3V0bGluZUJ1ZmZlcihOVU1fU0xJQ0VTKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgcm9vdCBvZmZzZXQgYnVmZmVyXG4gICAgICAgICAgICB0aGlzLl9vZmZzZXRCdWZmZXIgPSBuZXcgZXNwZXIuVmVydGV4QnVmZmVyKE1BWF9CVUZGRVJfQllURV9TSVpFKTtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgZXh0ZW5zaW9uIGZvciBoYXJkd2FyZSBpbnN0YW5jaW5nXG4gICAgICAgICAgICB0aGlzLl9leHQgPSBlc3Blci5XZWJHTENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2V4dCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzIFdlYkdMIGV4dGVuc2lvbiBpcyBub3Qgc3VwcG9ydGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBjaHVua3NcbiAgICAgICAgICAgIHRoaXMuaW5pdENodW5rcygpO1xuICAgICAgICAgICAgLy8gbG9hZCBzaGFkZXJzXG4gICAgICAgICAgICBwYXJhbGxlbCh7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VkOiAoZG9uZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2hhZGVyID0gbmV3IGVzcGVyLlNoYWRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0OiBTaGFkZXJzLmluc3RhbmNlZFBvaW50LnZlcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnOiBTaGFkZXJzLmluc3RhbmNlZFBvaW50LmZyYWdcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKG51bGwsIHNoYWRlcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5kaXZpZHVhbDogKGRvbmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNoYWRlciA9IG5ldyBlc3Blci5TaGFkZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydDogU2hhZGVycy5wb2ludC52ZXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZzogU2hhZGVycy5wb2ludC5mcmFnXG4gICAgICAgICAgICAgICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShudWxsLCBzaGFkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAoZXJyLCBzaGFkZXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlZFNoYWRlciA9IHNoYWRlcnMuaW5zdGFuY2VkO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZGl2aWR1YWxTaGFkZXIgPSBzaGFkZXJzLmluZGl2aWR1YWw7XG4gICAgICAgICAgICAgICAgZG9uZShudWxsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbGxpc2lvblJhZGl1czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBvaW50UmFkaXVzICsgdGhpcy5vcHRpb25zLnBvaW50T3V0bGluZTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICBXZWJHTC5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgbWFwLm9uKCd6b29tZW5kJywgdGhpcy5vblpvb21FbmQsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgIFdlYkdMLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgICAgICBtYXAub2ZmKCd6b29tZW5kJywgdGhpcy5vblpvb21FbmQsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uWm9vbVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJIYXNoKCk7XG4gICAgICAgICAgICBXZWJHTC5wcm90b3R5cGUub25ab29tU3RhcnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0Q2h1bmtzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB3ZSB1c2UgdGhlIGNvcnJlY3QgY29udGV4dFxuICAgICAgICAgICAgZXNwZXIuV2ViR0xDb250ZXh0LmJpbmQodGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgICAgIC8vIGFsbG9jYXRlIGF2YWlsYWJsZSBjaHVua3NcbiAgICAgICAgICAgIHRoaXMuX2F2YWlsYWJsZUNodW5rcyA9IG5ldyBBcnJheShNQVhfVElMRVMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPE1BWF9USUxFUzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJ5dGVPZmZzZXQgPSBpICogTUFYX1RJTEVfQllURV9TSVpFO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F2YWlsYWJsZUNodW5rc1tpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldDogYnl0ZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlcjogbmV3IGVzcGVyLlZlcnRleEJ1ZmZlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldEJ1ZmZlci5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnVU5TSUdORURfU0hPUlQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0OiBieXRlT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICdQT0lOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGg6IE1BWF9CVUZGRVJfQllURV9TSVpFXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91c2VkQ2h1bmtzID0ge307XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgbGV0IGxheWVyUGl4ZWwgPSB0aGlzLmdldExheWVyUG9pbnRGcm9tRXZlbnQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIGxldCByYWRpdXMgPSB0aGlzLmdldENvbGxpc2lvblJhZGl1cygpO1xuICAgICAgICAgICAgbGV0IHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgbGV0IGNvbGxpc2lvbiA9IHRoaXMucGljayhsYXllclBpeGVsLCByYWRpdXMsIHpvb20pO1xuICAgICAgICAgICAgbGV0IHNpemUgPSBNYXRoLnBvdygyLCB6b29tKTtcbiAgICAgICAgICAgIGlmIChjb2xsaXNpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBtaW1pYyBtb3VzZW92ZXIgLyBtb3VzZW91dCBldmVudHNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRlZC52YWx1ZSAhPT0gY29sbGlzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXcgY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleGVjdXRlIG1vdXNlb3V0IGZvciBvbGRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbTogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmhpZ2hsaWdodGVkLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGUgbW91c2VvdmVyIGZvciBuZXdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdmVyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW06IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIHByZXZpb3VzIGNvbGxpc2lvbiwgZXhlY3V0ZSBtb3VzZW92ZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW92ZXInLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1c2UgY29sbGlzaW9uIHBvaW50IHRvIGZpbmQgdGlsZVxuICAgICAgICAgICAgICAgIGxldCBjb29yZCA9IHRoaXMuZ2V0VGlsZUNvb3JkRnJvbUxheWVyUG9pbnQoY29sbGlzaW9uKTtcbiAgICAgICAgICAgICAgICBsZXQgaGFzaCA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29vcmQpO1xuICAgICAgICAgICAgICAgIC8vIGZsYWcgYXMgaGlnaGxpZ2h0ZWRcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkID0ge1xuICAgICAgICAgICAgICAgICAgICB0aWxlczogdGhpcy5fY2FjaGVbaGFzaF0udGlsZXMsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2xsaXNpb24sXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIChzaXplICogVElMRV9TSVpFKSAtIGNvbGxpc2lvbi55XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIHNldCBjdXJzb3JcbiAgICAgICAgICAgICAgICAkKHRoaXMuX21hcC5fY29udGFpbmVyKS5jc3MoJ2N1cnNvcicsICdwb2ludGVyJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbW91c2Ugb3V0XG4gICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW06IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuaGlnaGxpZ2h0ZWQudmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNsZWFyIGhpZ2hsaWdodGVkIGZsYWdcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgbGV0IGxheWVyUGl4ZWwgPSB0aGlzLmdldExheWVyUG9pbnRGcm9tRXZlbnQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIGxldCByYWRpdXMgPSB0aGlzLmdldENvbGxpc2lvblJhZGl1cygpO1xuICAgICAgICAgICAgbGV0IHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgbGV0IHNpemUgPSBNYXRoLnBvdygyLCB6b29tKTtcbiAgICAgICAgICAgIGxldCBjb2xsaXNpb24gPSB0aGlzLnBpY2sobGF5ZXJQaXhlbCwgcmFkaXVzLCB6b29tKTtcbiAgICAgICAgICAgIGlmIChjb2xsaXNpb24pIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgY29sbGlzaW9uIHBvaW50IHRvIGZpbmQgdGlsZVxuICAgICAgICAgICAgICAgIGxldCBjb29yZCA9IHRoaXMuZ2V0VGlsZUNvb3JkRnJvbUxheWVyUG9pbnQoY29sbGlzaW9uKTtcbiAgICAgICAgICAgICAgICBsZXQgaGFzaCA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29vcmQpO1xuICAgICAgICAgICAgICAgIC8vIGZsYWcgYXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0ge1xuICAgICAgICAgICAgICAgICAgICB0aWxlczogdGhpcy5fY2FjaGVbaGFzaF0udGlsZXMsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2xsaXNpb24sXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIChzaXplICogVElMRV9TSVpFKSAtIGNvbGxpc2lvbi55XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnY2xpY2snLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW06IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbGxpc2lvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFRpbGVUb0J1ZmZlcjogZnVuY3Rpb24oY29vcmRzLCBkYXRhLCBjb3VudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2F2YWlsYWJsZUNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIGF2YWlsYWJsZSBjaHVua3MgcmVtYWluaW5nIHRvIGJ1ZmZlciBkYXRhJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZ2V0IGFuIGF2YWlsYWJsZSBjaHVua1xuICAgICAgICAgICAgbGV0IGNodW5rID0gdGhpcy5fYXZhaWxhYmxlQ2h1bmtzLnBvcCgpO1xuICAgICAgICAgICAgLy8gc2V0IGNvdW50XG4gICAgICAgICAgICBjaHVuay5jb3VudCA9IGNvdW50O1xuICAgICAgICAgICAgLy8gYnVmZmVyIHRoZSBkYXRhIGludG8gdGhlIHBoeXNpY2FsIGNodW5rXG4gICAgICAgICAgICB0aGlzLl9vZmZzZXRCdWZmZXIuYnVmZmVyU3ViRGF0YShkYXRhLCBjaHVuay5ieXRlT2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIGZsYWcgYXMgdXNlZFxuICAgICAgICAgICAgbGV0IG5jb29yZHMgPSB0aGlzLmdldE5vcm1hbGl6ZWRDb29yZHMoY29vcmRzKTtcbiAgICAgICAgICAgIGxldCBoYXNoID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChuY29vcmRzKTtcbiAgICAgICAgICAgIHRoaXMuX3VzZWRDaHVua3NbaGFzaF0gPSBjaHVuaztcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVUaWxlRnJvbUJ1ZmZlcjogZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgICAgICBsZXQgbmNvb3JkcyA9IHRoaXMuZ2V0Tm9ybWFsaXplZENvb3Jkcyhjb29yZHMpO1xuICAgICAgICAgICAgbGV0IGhhc2ggPSB0aGlzLmNhY2hlS2V5RnJvbUNvb3JkKG5jb29yZHMpO1xuICAgICAgICAgICAgbGV0IGNodW5rID0gdGhpcy5fdXNlZENodW5rc1toYXNoXTtcbiAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBjb3VudFxuICAgICAgICAgICAgY2h1bmsuY291bnQgPSAwO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3VzZWRDaHVua3NbaGFzaF07XG4gICAgICAgICAgICAvLyBhZGQgYXMgYSBuZXcgYXZhaWxhYmxlIGNodW5rXG4gICAgICAgICAgICB0aGlzLl9hdmFpbGFibGVDaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIGFjdHVhbGx5IHVuYnVmZmVyIHRoZSBkYXRhXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DYWNoZUxvYWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBsZXQgY2FjaGVkID0gZXZlbnQuZW50cnk7XG4gICAgICAgICAgICBsZXQgY29vcmRzID0gZXZlbnQuY29vcmRzO1xuICAgICAgICAgICAgaWYgKGNhY2hlZC5kYXRhICYmIGNhY2hlZC5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHggLyB5IHRvIHRpbGUgcGl4ZWxzXG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBjYWNoZWQuZGF0YTtcbiAgICAgICAgICAgICAgICBsZXQgeEZpZWxkID0gdGhpcy5nZXRYRmllbGQoKTtcbiAgICAgICAgICAgICAgICBsZXQgeUZpZWxkID0gdGhpcy5nZXRZRmllbGQoKTtcbiAgICAgICAgICAgICAgICBsZXQgem9vbSA9IGNvb3Jkcy56O1xuICAgICAgICAgICAgICAgIGxldCBzaXplID0gTWF0aC5wb3coMiwgem9vbSk7XG4gICAgICAgICAgICAgICAgbGV0IHJhZGl1cyA9IHRoaXMuZ2V0Q29sbGlzaW9uUmFkaXVzKCk7XG4gICAgICAgICAgICAgICAgbGV0IG51bUJ5dGVzID0gZGF0YS5sZW5ndGggKiBDT01QT05FTlRfQllURV9TSVpFICogQ09NUE9ORU5UU19QRVJfUE9JTlQ7XG4gICAgICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihNYXRoLm1pbihudW1CeXRlcywgTUFYX1RJTEVfQllURV9TSVpFKSk7XG4gICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9ucyA9IG5ldyBVaW50MTZBcnJheShidWZmZXIpO1xuICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IG51bURhdHVtID0gTWF0aC5taW4oZGF0YS5sZW5ndGgsIE1BWF9QT0lOVFNfUEVSX1RJTEUpO1xuICAgICAgICAgICAgICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgY29sbGlzaW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgICAgIC8vIGNhbGMgcGl4ZWwgbG9jYXRpb25zXG4gICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8bnVtRGF0dW07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGl0ID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBfLmdldChoaXQsIHhGaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB5ID0gXy5nZXQoaGl0LCB5RmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeCAhPT0gdW5kZWZpbmVkICYmIHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHBvc2l0aW9uIGluIGxheWVyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGF5ZXJQb2ludCA9IHRoaXMuZ2V0TGF5ZXJQb2ludEZyb21EYXRhUG9pbnQoeCwgeSwgem9vbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgcGl4ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb2ludCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBsYXllclBvaW50LngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogbGF5ZXJQb2ludC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoYXNoID0gcG9pbnQueCArICc6JyArIHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmppdHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsaXNpb25zW2hhc2hdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5Sml0dGVyKHBvaW50LCB0aGlzLm9wdGlvbnMuaml0dGVyRGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25zW2hhc2hdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuY29kZSB0aGUgcG9pbnQgaW50byB0aGUgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVQb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSo0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNpemUgKiBUSUxFX1NJWkUpIC0gcG9pbnQueSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBwb2ludCB0byBzcGF0aWFsIGhhc2hcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQocG9pbnQsIHJhZGl1cywgem9vbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgY291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBwb2ludHMgaW4gdGhlIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZC5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciB0aGUgZGF0YVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRpbGVUb0J1ZmZlcihjb29yZHMsIHBvc2l0aW9ucywgY291bnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkNhY2hlVW5sb2FkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgbGV0IGNhY2hlZCA9IGV2ZW50LmVudHJ5O1xuICAgICAgICAgICAgbGV0IGNvb3JkcyA9IGV2ZW50LmNvb3JkcztcbiAgICAgICAgICAgIGlmIChjYWNoZWQucG9pbnRzKSB7IC8vY2FjaGVkLmRhdGEgJiYgY2FjaGVkLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGlsZUZyb21CdWZmZXIoY29vcmRzKTtcbiAgICAgICAgICAgICAgICBsZXQgcmFkaXVzID0gdGhpcy5nZXRDb2xsaXNpb25SYWRpdXMoKTtcbiAgICAgICAgICAgICAgICBjYWNoZWQucG9pbnRzLmZvckVhY2gocG9pbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVBvaW50KHBvaW50LCByYWRpdXMsIGNvb3Jkcy56KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYWNoZWQucG9pbnRzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRXcmFwQXJvdW5kT2Zmc2V0OiBmdW5jdGlvbihjb29yZHMpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gTWF0aC5wb3coMiwgdGhpcy5fbWFwLmdldFpvb20oKSk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgbW9kZWwgbWF0cml4XG4gICAgICAgICAgICBsZXQgeFdyYXAgPSBNYXRoLmZsb29yKGNvb3Jkcy54IC8gc2l6ZSk7XG4gICAgICAgICAgICBsZXQgeVdyYXAgPSBNYXRoLmZsb29yKGNvb3Jkcy55IC8gc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHNpemUgKiBUSUxFX1NJWkUgKiB4V3JhcCxcbiAgICAgICAgICAgICAgICBzaXplICogVElMRV9TSVpFICogeVdyYXBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0UHJvamVjdGlvbk1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuX21hcC5nZXRTaXplKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPcnRob01hdHJpeChcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIHNpemUueCxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIHNpemUueSxcbiAgICAgICAgICAgICAgICAtMSwgMSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Vmlld09mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsZXQgYm91bmRzID0gdGhpcy5fbWFwLmdldFBpeGVsQm91bmRzKCk7XG4gICAgICAgICAgICBsZXQgZGltID0gTWF0aC5wb3coMiwgdGhpcy5fbWFwLmdldFpvb20oKSkgKiBUSUxFX1NJWkU7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGJvdW5kcy5taW4ueCxcbiAgICAgICAgICAgICAgICBkaW0gLSBib3VuZHMubWF4LnlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZHJhd0luc3RhbmNlZDogZnVuY3Rpb24oYnVmZmVyLCBjb2xvciwgcmFkaXVzKSB7XG4gICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgICAgIGxldCBleHQgPSB0aGlzLl9leHQ7XG4gICAgICAgICAgICBsZXQgc2hhZGVyID0gdGhpcy5faW5zdGFuY2VkU2hhZGVyO1xuICAgICAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICAgICAgICBsZXQgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJsZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5hYmxlIGJsZW5kaW5nXG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXNlIHNoYWRlclxuICAgICAgICAgICAgc2hhZGVyLnVzZSgpO1xuICAgICAgICAgICAgLy8gc2V0IHVuaWZvcm1zXG4gICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndUNvbG9yJywgY29sb3IpO1xuICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VQcm9qZWN0aW9uTWF0cml4JywgdGhpcy5nZXRQcm9qZWN0aW9uTWF0cml4KCkpO1xuICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VPcGFjaXR5JywgdGhpcy5nZXRPcGFjaXR5KCkpO1xuICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VTY2FsZScsIHJhZGl1cyk7XG4gICAgICAgICAgICAvLyBjYWxjIHZpZXcgb2Zmc2V0XG4gICAgICAgICAgICBsZXQgdmlld09mZnNldCA9IHRoaXMuZ2V0Vmlld09mZnNldCgpO1xuICAgICAgICAgICAgLy8gYmluZHMgdGhlIGJ1ZmZlciB0byBpbnN0YW5jZVxuICAgICAgICAgICAgYnVmZmVyLmJpbmQoKTtcbiAgICAgICAgICAgIC8vIGVuYWJsZSBpbnN0YW5jaW5nXG4gICAgICAgICAgICBleHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKE9GRlNFVFNfSU5ERVgsIDEpO1xuICAgICAgICAgICAgLy8gZm9yIGVhY2ggYWxsb2NhdGVkIGNodW5rXG4gICAgICAgICAgICBfLmZvckluKHRoaXMuX3VzZWRDaHVua3MsIChjaHVuaywgaGFzaCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIHRpbGUgcmVmZXJyaW5nIHRvIHRoZSBkYXRhXG4gICAgICAgICAgICAgICAgbGV0IGNhY2hlZCA9IGNhY2hlW2hhc2hdO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmluZCB0aGUgY2h1bmsncyBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsudmVydGV4QnVmZmVyLmJpbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIGZvciBlYWNoIHRpbGVcbiAgICAgICAgICAgICAgICAgICAgXy5rZXlzKGNhY2hlZC50aWxlcykuZm9yRWFjaChoYXNoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb29yZHMgPSB0aGlzLmNvb3JkRnJvbUNhY2hlS2V5KGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3Jkcy56ICE9PSB6b29tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2UgaGF2ZSB0byBjaGVjayBoZXJlIGlmIHRoZSB0aWxlcyBhcmUgc3RhbGUgb3Igbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBsb2FkIHZpZXcgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5nZXRXcmFwQXJvdW5kT2Zmc2V0KGNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG90YWxPZmZzZXQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld09mZnNldFswXSAtIG9mZnNldFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3T2Zmc2V0WzFdIC0gb2Zmc2V0WzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1Vmlld09mZnNldCcsIHRvdGFsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyYXcgdGhlIGlzdGFuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBleHQuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKGdsW2J1ZmZlci5tb2RlXSwgMCwgYnVmZmVyLmNvdW50LCBjaHVuay5jb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyB1bmJpbmRcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsudmVydGV4QnVmZmVyLnVuYmluZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZGlzYWJsZSBpbnN0YW5jaW5nXG4gICAgICAgICAgICBleHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKE9GRlNFVFNfSU5ERVgsIDApO1xuICAgICAgICAgICAgLy8gdW5iaW5kIGJ1ZmZlclxuICAgICAgICAgICAgYnVmZmVyLnVuYmluZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyYXdJbmRpdmlkdWFsOiBmdW5jdGlvbihidWZmZXIsIGNvbG9yLCByYWRpdXMsIHRpbGVzLCBwb2ludCkge1xuICAgICAgICAgICAgLy8gZHJhdyBzZWxlY3RlZCBwb2ludHNcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuX2dsO1xuICAgICAgICAgICAgbGV0IHNoYWRlciA9IHRoaXMuX2luZGl2aWR1YWxTaGFkZXI7XG4gICAgICAgICAgICBsZXQgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICAgICAgICAvLyBiaW5kIHRoZSBidWZmZXJcbiAgICAgICAgICAgIGJ1ZmZlci5iaW5kKCk7XG4gICAgICAgICAgICAvLyBkaXNhYmxlIGJsZW5kaW5nXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgIC8vIHVzZSBzaGFkZXJcbiAgICAgICAgICAgIHNoYWRlci51c2UoKTtcbiAgICAgICAgICAgIC8vIHVzZSB1bmlmb3JtIGZvciBvZmZzZXRcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1UHJvamVjdGlvbk1hdHJpeCcsIHRoaXMuZ2V0UHJvamVjdGlvbk1hdHJpeCgpKTtcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1T3BhY2l0eScsIHRoaXMuZ2V0T3BhY2l0eSgpKTtcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1U2NhbGUnLCByYWRpdXMpO1xuICAgICAgICAgICAgLy8gdmlldyBvZmZzZXRcbiAgICAgICAgICAgIGxldCB2aWV3T2Zmc2V0ID0gdGhpcy5nZXRWaWV3T2Zmc2V0KCk7XG4gICAgICAgICAgICBfLmZvckluKHRpbGVzLCB0aWxlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGlsZS5jb29yZHMueiAhPT0gem9vbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBoYXZlIHRvIGNoZWNrIGhlcmUgaWYgdGhlIHRpbGVzIGFyZSBzdGFsZSBvciBub3RcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1cGxvYWQgdmlldyBvZmZzZXRcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5nZXRXcmFwQXJvdW5kT2Zmc2V0KHRpbGUuY29vcmRzKTtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxPZmZzZXQgPSBbXG4gICAgICAgICAgICAgICAgICAgIHZpZXdPZmZzZXRbMF0gLSBvZmZzZXRbMF0sXG4gICAgICAgICAgICAgICAgICAgIHZpZXdPZmZzZXRbMV0gLSBvZmZzZXRbMV0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndVZpZXdPZmZzZXQnLCB0b3RhbE9mZnNldCk7XG4gICAgICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VPZmZzZXQnLCBwb2ludCk7XG4gICAgICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VDb2xvcicsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICBidWZmZXIuZHJhdygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB1bmJpbmQgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgYnVmZmVyLnVuYmluZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlckZyYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHNldHVwXG4gICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgICAgIGxldCB2aWV3cG9ydCA9IHRoaXMuX3ZpZXdwb3J0O1xuICAgICAgICAgICAgdmlld3BvcnQucHVzaCgpO1xuXG4gICAgICAgICAgICAvLyBkcmF3IGluc3RhbmNlZCBwb2ludHNcblxuICAgICAgICAgICAgLy8gZHJhdyBpbnN0YW5jZWQgZmlsbFxuICAgICAgICAgICAgdGhpcy5kcmF3SW5zdGFuY2VkKFxuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZUZpbGxCdWZmZXIsXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBvaW50RmlsbENvbG9yLFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wb2ludFJhZGl1cyk7XG4gICAgICAgICAgICAvLyBkcmF3IGluc3RhbmNlZCBvdXRsaW5lc1xuICAgICAgICAgICAgZ2wubGluZVdpZHRoKHRoaXMub3B0aW9ucy5wb2ludE91dGxpbmUpO1xuICAgICAgICAgICAgdGhpcy5kcmF3SW5zdGFuY2VkKFxuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZU91dGxpbmVCdWZmZXIsXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBvaW50T3V0bGluZUNvbG9yLFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wb2ludFJhZGl1cyk7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgaW5kaXZpZHVhbCBwb2ludHNcblxuICAgICAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBkcmF3IGluZGl2aWR1YWwgZmlsbFxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0luZGl2aWR1YWwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZUZpbGxCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5oaWdobGlnaHRlZEZpbGxDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmhpZ2hsaWdodGVkUmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkLnRpbGVzLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkLnBvaW50KTtcbiAgICAgICAgICAgICAgICAvLyBkcmF3IGluZGl2aWR1YWwgb3V0bGluZVxuICAgICAgICAgICAgICAgIGdsLmxpbmVXaWR0aCh0aGlzLm9wdGlvbnMucG9pbnRPdXRsaW5lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdJbmRpdmlkdWFsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGVPdXRsaW5lQnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ZWRPdXRsaW5lQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5oaWdobGlnaHRlZFJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZC50aWxlcyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZC5wb2ludCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZHJhdyBpbmRpdmlkdWFsIGZpbGxcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdJbmRpdmlkdWFsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGVGaWxsQnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRGaWxsQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zZWxlY3RlZFJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC50aWxlcyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC5wb2ludCk7XG4gICAgICAgICAgICAgICAgLy8gZHJhdyBpbmRpdmlkdWFsIG91dGxpbmVcbiAgICAgICAgICAgICAgICBnbC5saW5lV2lkdGgodGhpcy5vcHRpb25zLnBvaW50T3V0bGluZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3SW5kaXZpZHVhbChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlT3V0bGluZUJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNlbGVjdGVkT3V0bGluZUNvbG9yLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQudGlsZXMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQucG9pbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0ZWFyZG93blxuICAgICAgICAgICAgdmlld3BvcnQucG9wKCk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBDb2xvclJhbXAgPSByZXF1aXJlKCcuLi8uLi9taXhpbi9Db2xvclJhbXAnKTtcblxuICAgIC8qKlxuICAgICAqIHByZWNpc2lvblxuICAgICAqL1xuICAgIGxldCBwcmVjaXNpb24gPVxuICAgICAgICBgXG4gICAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGludDtcbiAgICAgICAgYDtcblxuICAgIC8qKlxuICAgICAqIGRlY29kZSBmbG9hdFxuICAgICAqL1xuICAgIGxldCBkZWNvZGVSR0JBVG9GbG9hdCA9XG4gICAgICAgIGBcbiAgICAgICAgZmxvYXQgZGVjb2RlUkdCQVRvRmxvYXQodmVjNCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gKHYueCAqIDI1NS4wICogMTY3NzcyMTYuMCkgK1xuICAgICAgICAgICAgICAgICh2LnkgKiAyNTUuMCAqIDY1NTM2LjApICtcbiAgICAgICAgICAgICAgICAodi56ICogMjU1LjAgKiAyNTYuMCkgK1xuICAgICAgICAgICAgICAgIHYudyAqIDI1NS4wO1xuICAgICAgICB9XG4gICAgICAgIGA7XG5cbiAgICBsZXQgZGVjb2RlVWludDE2VG9VaW50MzIgPVxuICAgICAgICBgXG4gICAgICAgIGludCBkZWNvZGVVaW50MTZUb1VpbnQzMihmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50KGEgKiA2NTUzNi4wKSArIGludChiKTtcbiAgICAgICAgfVxuICAgICAgICBgO1xuXG4gICAgLyoqXG4gICAgICogdHJhbnNmb3Jtc1xuICAgICAqL1xuXG4gICAgLy8gbG9nMTBcbiAgICBsZXQgbG9nMTBUcmFuc2Zvcm0gPVxuICAgICAgICBgXG4gICAgICAgIGZsb2F0IGxvZzEwKGZsb2F0IHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvZyh2YWwpIC8gbG9nKDEwLjApO1xuICAgICAgICB9XG4gICAgICAgIGZsb2F0IGxvZzEwVHJhbnNmb3JtKGZsb2F0IHZhbCwgZmxvYXQgbWluVmFsLCBmbG9hdCBtYXhWYWwpIHtcbiAgICAgICAgICAgIGlmIChtaW5WYWwgPCAxLjApIHsgbWluVmFsID0gMS4wOyB9XG4gICAgICAgICAgICBpZiAobWF4VmFsIDwgMS4wKSB7IG1heFZhbCA9IDEuMDsgfVxuICAgICAgICAgICAgaWYgKHZhbCA8IDEuMCkgeyB2YWwgPSAxLjA7IH1cbiAgICAgICAgICAgIGZsb2F0IGxvZ01pbiA9IGxvZzEwKG1pblZhbCk7XG4gICAgICAgICAgICBmbG9hdCBsb2dNYXggPSBsb2cxMChtYXhWYWwpO1xuICAgICAgICAgICAgZmxvYXQgbG9nVmFsID0gbG9nMTAodmFsKTtcbiAgICAgICAgICAgIGZsb2F0IHJhbmdlID0gbG9nTWF4IC0gbG9nTWluO1xuICAgICAgICAgICAgaWYgKHJhbmdlID09IDAuMCkgeyByYW5nZSA9IDEuMDsgfVxuICAgICAgICAgICAgcmV0dXJuIChsb2dWYWwgLSBsb2dNaW4pIC8gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgYDtcblxuICAgIC8vIHNpZ21vaWRcbiAgICBsZXQgc2lnbW9pZFRyYW5zZm9ybSA9XG4gICAgICAgIGBcbiAgICAgICAgZmxvYXQgc2lnbW9pZFRyYW5zZm9ybShmbG9hdCB2YWwsIGZsb2F0IG1pblZhbCwgZmxvYXQgbWF4VmFsKSB7XG4gICAgICAgICAgICBtaW5WYWwgPSBhYnMobWluVmFsKTtcbiAgICAgICAgICAgIG1heFZhbCA9IGFicyhtYXhWYWwpO1xuICAgICAgICAgICAgZmxvYXQgZGlzdCA9IG1heChtaW5WYWwsIG1heFZhbCk7XG4gICAgICAgICAgICBmbG9hdCBTSUdNT0lEX1NDQUxFID0gMC4xNTtcbiAgICAgICAgICAgIGZsb2F0IHNjYWxlZFZhbCA9IHZhbCAvIChTSUdNT0lEX1NDQUxFICogZGlzdCk7XG4gICAgICAgICAgICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtc2NhbGVkVmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgYDtcblxuICAgIC8vIGxpbmVhclxuICAgIGxldCBsaW5lYXJUcmFuc2Zvcm0gPVxuICAgICAgICBgXG4gICAgICAgIGZsb2F0IGxpbmVhclRyYW5zZm9ybShmbG9hdCB2YWwsIGZsb2F0IG1pblZhbCwgZmxvYXQgbWF4VmFsKSB7XG4gICAgICAgICAgICBmbG9hdCByYW5nZSA9IG1heFZhbCAtIG1pblZhbDtcbiAgICAgICAgICAgIGlmIChyYW5nZSA9PSAwLjApIHsgcmFuZ2UgPSAxLjA7IH1cbiAgICAgICAgICAgIHJldHVybiAodmFsIC0gbWluVmFsKSAvIHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGA7XG5cbiAgICBsZXQgdHJhbnNmb3JtID1cbiAgICAgICAgbG9nMTBUcmFuc2Zvcm0gK1xuICAgICAgICBzaWdtb2lkVHJhbnNmb3JtICtcbiAgICAgICAgbGluZWFyVHJhbnNmb3JtICtcbiAgICAgICAgYFxuICAgICAgICAjZGVmaW5lIExPR19UUkFOU0ZPUk0gMFxuICAgICAgICAjZGVmaW5lIExJTkVBUl9UUkFOU0ZPUk0gMVxuICAgICAgICAjZGVmaW5lIFNJR01PSURfVFJBTlNGT1JNIDJcbiAgICAgICAgdW5pZm9ybSBpbnQgdVRyYW5zZm9ybVR5cGU7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdU1pbjtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCB1TWF4O1xuICAgICAgICBmbG9hdCB0cmFuc2Zvcm0oZmxvYXQgdmFsKSB7XG4gICAgICAgICAgICBpZiAodmFsIDwgdU1pbikgeyB2YWwgPSB1TWluOyB9XG4gICAgICAgICAgICBpZiAodmFsID4gdU1heCkgeyB2YWwgPSB1TWF4OyB9XG4gICAgICAgICAgICBpZiAodVRyYW5zZm9ybVR5cGUgPT0gTElORUFSX1RSQU5TRk9STSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lYXJUcmFuc2Zvcm0odmFsLCB1TWluLCB1TWF4KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodVRyYW5zZm9ybVR5cGUgPT0gU0lHTU9JRF9UUkFOU0ZPUk0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbW9pZFRyYW5zZm9ybSh2YWwsIHVNaW4sIHVNYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZzEwVHJhbnNmb3JtKHZhbCwgdU1pbiwgdU1heCk7XG4gICAgICAgIH1cbiAgICAgICAgYDtcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHJhbXBcbiAgICAgKi9cbiAgICBsZXQgY29sb3JSYW1wID1cbiAgICAgICAgYFxuICAgICAgICAjZGVmaW5lIFJBTVBfVkFMVUVTICR7Q29sb3JSYW1wLk5VTV9HUkFESUVOVF9TVEVQU31cbiAgICAgICAgdW5pZm9ybSB2ZWM0IHVSYW1wW1JBTVBfVkFMVUVTXTtcbiAgICAgICAgdmVjNCBjb2xvclJhbXAoZmxvYXQgdmFsdWUpIHtcbiAgICAgICAgICAgIGZsb2F0IG1heEluZGV4ID0gZmxvYXQoUkFNUF9WQUxVRVMgLSAxKTtcbiAgICAgICAgICAgIGludCBpbmRleCA9IGludCh2YWx1ZSAqIG1heEluZGV4KTtcbiAgICAgICAgICAgIC8vIE5PVEU6IEkgUkVBTExZIGRvbid0IGxpa2UgdGhpcywgYnV0IGl0IHNlZW1zIHRvIGJlIHRoZSBvbmx5IHdheVxuICAgICAgICAgICAgLy8gdG8gaW5kZXggdGhlIHVSYW1wIGFycmF5XG4gICAgICAgICAgICBmb3IgKGludCBpPTA7IGk8UkFNUF9WQUxVRVM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpID09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1UmFtcFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmVjNCgxLjAsIDAuMCwgMS4wLCAxLjApO1xuICAgICAgICB9XG4gICAgICAgIGA7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBSYW5nZVxuICAgICAqL1xuICAgIGxldCB2YWx1ZVJhbmdlID1cbiAgICAgICAgYFxuICAgICAgICB1bmlmb3JtIGZsb2F0IHVSYW5nZU1pbjtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCB1UmFuZ2VNYXg7XG4gICAgICAgIGZsb2F0IGludGVycG9sYXRlVG9SYW5nZShmbG9hdCBudmFsKSB7XG4gICAgICAgICAgICBmbG9hdCBydmFsID0gKG52YWwgLSB1UmFuZ2VNaW4pIC8gKHVSYW5nZU1heCAtIHVSYW5nZU1pbik7XG4gICAgICAgICAgICBpZiAocnZhbCA+IDEuMCkge1xuICAgICAgICAgICAgICAgIHJ2YWwgPSAxLjA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJ2YWwgPCAwLjApIHtcbiAgICAgICAgICAgICAgICBydmFsID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgYDtcblxuICAgIC8qKlxuICAgICAqIGhlYXRtYXAgc2hhZGVyXG4gICAgICovXG4gICAgbGV0IGhlYXRtYXAgPSB7XG4gICAgICAgIHZlcnQ6XG4gICAgICAgICAgICBwcmVjaXNpb24gK1xuICAgICAgICAgICAgYFxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdU1vZGVsTWF0cml4ICogdmVjNChhUG9zaXRpb24sIDAuMCwgMS4wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGAsXG4gICAgICAgIGZyYWc6XG4gICAgICAgICAgICBwcmVjaXNpb24gK1xuICAgICAgICAgICAgZGVjb2RlUkdCQVRvRmxvYXQgK1xuICAgICAgICAgICAgdHJhbnNmb3JtICtcbiAgICAgICAgICAgIGNvbG9yUmFtcCArXG4gICAgICAgICAgICB2YWx1ZVJhbmdlICtcbiAgICAgICAgICAgIGBcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlU2FtcGxlcjtcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdU9wYWNpdHk7XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICB2ZWM0IGVuYyA9IHRleHR1cmUyRCh1VGV4dHVyZVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuICAgICAgICAgICAgICAgIGZsb2F0IGNvdW50ID0gZGVjb2RlUkdCQVRvRmxvYXQoZW5jKTtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2NhcmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZsb2F0IG52YWwgPSB0cmFuc2Zvcm0oY291bnQpO1xuICAgICAgICAgICAgICAgIGZsb2F0IHJ2YWwgPSBpbnRlcnBvbGF0ZVRvUmFuZ2UobnZhbCk7XG4gICAgICAgICAgICAgICAgdmVjNCBjb2xvciA9IGNvbG9yUmFtcChydmFsKTtcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiwgY29sb3IuYSAqIHVPcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGBcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogaW5zdGFuY2VkIHBvaW50IHNoYWRlclxuICAgICAqL1xuICAgIGxldCBpbnN0YW5jZWRQb2ludCA9IHtcbiAgICAgICAgdmVydDpcbiAgICAgICAgICAgIHByZWNpc2lvbiArXG4gICAgICAgICAgICBkZWNvZGVVaW50MTZUb1VpbnQzMiArXG4gICAgICAgICAgICBgXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjNCBhT2Zmc2V0O1xuICAgICAgICAgICAgdW5pZm9ybSBpdmVjMiB1Vmlld09mZnNldDtcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdVNjYWxlO1xuICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIGl2ZWMyIGlPZmZzZXQgPSBpdmVjMihcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlVWludDE2VG9VaW50MzIoYU9mZnNldC54LCBhT2Zmc2V0LnkpLFxuICAgICAgICAgICAgICAgICAgICBkZWNvZGVVaW50MTZUb1VpbnQzMihhT2Zmc2V0LnosIGFPZmZzZXQudykpO1xuICAgICAgICAgICAgICAgIHZlYzIgbVBvc2l0aW9uID0gdVNjYWxlICogYVBvc2l0aW9uICsgdmVjMihpT2Zmc2V0IC0gdVZpZXdPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB2ZWM0KG1Qb3NpdGlvbiwgMC4wLCAxLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYCxcbiAgICAgICAgZnJhZzpcbiAgICAgICAgICAgIHByZWNpc2lvbiArXG4gICAgICAgICAgICBgXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVPcGFjaXR5O1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IHVDb2xvcjtcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVDb2xvci5yZ2IsIHVDb2xvci5hICogdU9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYFxuICAgIH07XG5cbiAgICBsZXQgcG9pbnQgPSB7XG4gICAgICAgIHZlcnQ6XG4gICAgICAgICAgICBwcmVjaXNpb24gK1xuICAgICAgICAgICAgYFxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xuICAgICAgICAgICAgdW5pZm9ybSBpdmVjMiB1T2Zmc2V0O1xuICAgICAgICAgICAgdW5pZm9ybSBpdmVjMiB1Vmlld09mZnNldDtcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdVNjYWxlO1xuICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIHZlYzIgbVBvc2l0aW9uID0gdVNjYWxlICogYVBvc2l0aW9uICsgdmVjMih1T2Zmc2V0IC0gdVZpZXdPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB2ZWM0KG1Qb3NpdGlvbiwgMC4wLCAxLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYCxcbiAgICAgICAgZnJhZzpcbiAgICAgICAgICAgIHByZWNpc2lvbiArXG4gICAgICAgICAgICBgXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVPcGFjaXR5O1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IHVDb2xvcjtcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVDb2xvci5yZ2IsIHVDb2xvci5hICogdU9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYFxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogaGVhdG1hcCBzaGFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGhlYXRtYXA6IGhlYXRtYXAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluc3RhbmNlZCBwb2ludCBzaGFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGluc3RhbmNlZFBvaW50OiBpbnN0YW5jZWRQb2ludCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcG9pbnQgc2hhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBwb2ludDogcG9pbnRcblxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgUmVxdWVzdG9yID0gcmVxdWlyZSgnLi9SZXF1ZXN0b3InKTtcblxuICAgIGNsYXNzIE1ldGFSZXF1ZXN0b3IgZXh0ZW5kcyBSZXF1ZXN0b3Ige1xuICAgICAgICBjb25zdHJ1Y3Rvcih1cmwsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzdXBlcih1cmwsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRIYXNoKHJlcSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3JlcS50eXBlfS0ke3JlcS5pbmRleH0tJHtyZXEuc3RvcmV9YDtcbiAgICAgICAgfVxuICAgICAgICBnZXRVUkwocmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gYG1ldGEvJHtyZXMudHlwZX0vJHtyZXMuZW5kcG9pbnR9LyR7cmVzLmluZGV4fS8ke3Jlcy5zdG9yZX1gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNZXRhUmVxdWVzdG9yO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IFJFVFJZX0lOVEVSVkFMID0gNTAwMDtcblxuICAgIGZ1bmN0aW9uIGdldEhvc3QoKSB7XG4gICAgICAgIGxldCBsb2MgPSB3aW5kb3cubG9jYXRpb247XG4gICAgICAgIGxldCBuZXdfdXJpO1xuICAgICAgICBpZiAobG9jLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgbmV3X3VyaSA9ICd3c3M6JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld191cmkgPSAnd3M6JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7bmV3X3VyaX0vLyR7bG9jLmhvc3R9JHtsb2MucGF0aG5hbWV9YDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc3RhYmxpc2hDb25uZWN0aW9uKHJlcXVlc3RvciwgY2FsbGJhY2spIHtcbiAgICAgICAgcmVxdWVzdG9yLnNvY2tldCA9IG5ldyBXZWJTb2NrZXQoZ2V0SG9zdCgpICsgcmVxdWVzdG9yLnVybCk7XG4gICAgICAgIC8vIG9uIG9wZW5cbiAgICAgICAgcmVxdWVzdG9yLnNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlcXVlc3Rvci5pc09wZW4gPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dlYnNvY2tldCBjb25uZWN0aW9uIGVzdGFibGlzaGVkJyk7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBvbiBtZXNzYWdlXG4gICAgICAgIHJlcXVlc3Rvci5zb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGxldCByZXMgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgbGV0IGhhc2ggPSByZXF1ZXN0b3IuZ2V0SGFzaChyZXMpO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSByZXF1ZXN0b3IucmVxdWVzdHNbaGFzaF07XG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdG9yLnJlcXVlc3RzW2hhc2hdO1xuICAgICAgICAgICAgaWYgKHJlcy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNvbHZlKHJlcXVlc3Rvci5nZXRVUkwocmVzKSwgcmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZWplY3QocmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gb24gY2xvc2VcbiAgICAgICAgcmVxdWVzdG9yLnNvY2tldC5vbmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBsb2cgY2xvc2Ugb25seSBpZiBjb25uZWN0aW9uIHdhcyBldmVyIG9wZW5cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0b3IuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXZWJzb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQsIGF0dGVtcHRpbmcgdG8gcmUtY29ubmVjdCBpbicsIFJFVFJZX0lOVEVSVkFMKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3Rvci5zb2NrZXQgPSBudWxsO1xuICAgICAgICAgICAgcmVxdWVzdG9yLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gcmVqZWN0IGFsbCBwZW5kaW5nIHJlcXVlc3RzXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhyZXF1ZXN0b3IucmVxdWVzdHMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdG9yLnJlcXVlc3RzW2tleV0ucmVqZWN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGNsZWFyIHJlcXVlc3QgbWFwXG4gICAgICAgICAgICByZXF1ZXN0b3IucmVxdWVzdHMgPSB7fTtcbiAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gcmUtZXN0YWJsaXNoIGNvbm5lY3Rpb25cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZXN0YWJsaXNoQ29ubmVjdGlvbihyZXF1ZXN0b3IsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmNlIGNvbm5lY3Rpb24gaXMgcmUtZXN0YWJsaXNoZWQsIHNlbmQgcGVuZGluZyByZXF1ZXN0c1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0b3IucGVuZGluZy5mb3JFYWNoKGZ1bmN0aW9uKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdG9yLmdldChyZXEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdG9yLnBlbmRpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIFJFVFJZX0lOVEVSVkFMKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjbGFzcyBSZXF1ZXN0b3Ige1xuICAgICAgICBjb25zdHJ1Y3Rvcih1cmwsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGVzdGFibGlzaENvbm5lY3Rpb24odGhpcywgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGdldEhhc2goKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9XG4gICAgICAgIGdldFVSTCgpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH1cbiAgICAgICAgZ2V0KHJlcSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIGNvbm5lY3Rpb24sIGFkZCByZXF1ZXN0IHRvIHBlbmRpbmcgcXVldWVcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcucHVzaChyZXEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBoYXNoID0gdGhpcy5nZXRIYXNoKHJlcSk7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMucmVxdWVzdHNbaGFzaF07XG4gICAgICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0LnByb21pc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzW2hhc2hdID0gJC5EZWZlcnJlZCgpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShyZXEpKTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0LnByb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uY2xvc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gUmVxdWVzdG9yO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IHN0cmluZ2lmeSA9IHJlcXVpcmUoJ2pzb24tc3RhYmxlLXN0cmluZ2lmeScpO1xuICAgIGxldCBSZXF1ZXN0b3IgPSByZXF1aXJlKCcuL1JlcXVlc3RvcicpO1xuXG4gICAgZnVuY3Rpb24gcHJ1bmVFbXB0eShvYmopIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBydW5lKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIF8uZm9yT3duKGN1cnJlbnQsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHZhbHVlKSB8fCBfLmlzTnVsbCh2YWx1ZSkgfHwgXy5pc05hTih2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAoXy5pc1N0cmluZyh2YWx1ZSkgJiYgXy5pc0VtcHR5KHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICAoXy5pc09iamVjdCh2YWx1ZSkgJiYgXy5pc0VtcHR5KHBydW5lKHZhbHVlKSkpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGN1cnJlbnRba2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgYW55IGxlZnRvdmVyIHVuZGVmaW5lZCB2YWx1ZXMgZnJvbSB0aGUgZGVsZXRlXG4gICAgICAgICAgICAvLyBvcGVyYXRpb24gb24gYW4gYXJyYXlcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICBfLnB1bGwoY3VycmVudCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICB9KF8uY2xvbmVEZWVwKG9iaikpOyAvLyBkbyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBvYmplY3QsIGNyZWF0ZSBhIGNsb25lIGluc3RlYWRcbiAgICB9XG5cbiAgICBjbGFzcyBUaWxlUmVxdWVzdG9yIGV4dGVuZHMgUmVxdWVzdG9yIHtcbiAgICAgICAgY29uc3RydWN0b3IodXJsLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgc3VwZXIodXJsLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0SGFzaChyZXEpIHtcbiAgICAgICAgICAgIGxldCBjb29yZCA9IHJlcS5jb29yZDtcbiAgICAgICAgICAgIGxldCBoYXNoID0gc3RyaW5naWZ5KHBydW5lRW1wdHkocmVxLnBhcmFtcykpO1xuICAgICAgICAgICAgcmV0dXJuIGAke3JlcS50eXBlfS0ke3JlcS5pbmRleH0tJHtyZXEuc3RvcmV9LSR7Y29vcmQuen0tJHtjb29yZC54fS0ke2Nvb3JkLnl9LSR7aGFzaH1gO1xuICAgICAgICB9XG4gICAgICAgIGdldFVSTChyZXMpIHtcbiAgICAgICAgICAgIGxldCBjb29yZCA9IHJlcy5jb29yZDtcbiAgICAgICAgICAgIHJldHVybiBgdGlsZS8ke3Jlcy50eXBlfS8ke3Jlcy5pbmRleH0vJHtyZXMuc3RvcmV9LyR7Y29vcmQuen0vJHtjb29yZC54fS8ke2Nvb3JkLnl9YDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gVGlsZVJlcXVlc3RvcjtcblxufSgpKTtcbiJdfQ==
