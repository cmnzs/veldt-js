(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.prism = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (coll, iteratee, callback) {
    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, iteratee, callback);
};

var _isArrayLike = require('lodash/isArrayLike');

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _eachOfLimit = require('./eachOfLimit');

var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);

var _doLimit = require('./internal/doLimit');

var _doLimit2 = _interopRequireDefault(_doLimit);

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _once = require('lodash/once');

var _once2 = _interopRequireDefault(_once);

var _onlyOnce = require('./internal/onlyOnce');

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eachOf implementation optimized for array-likes
function eachOfArrayLike(coll, iteratee, callback) {
    callback = (0, _once2.default)(callback || _noop2.default);
    var index = 0,
        completed = 0,
        length = coll.length;
    if (length === 0) {
        callback(null);
    }

    function iteratorCallback(err) {
        if (err) {
            callback(err);
        } else if (++completed === length) {
            callback(null);
        }
    }

    for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
    }
}

// a generic version of eachOf which can handle array, object, and iterator cases.
var eachOfGeneric = (0, _doLimit2.default)(_eachOfLimit2.default, Infinity);

/**
 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
 * to the iteratee.
 *
 * @name eachOf
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEachOf
 * @category Collection
 * @see [async.each]{@link module:Collections.each}
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array. The iteratee is passed a `callback(err)` which must be called once it
 * has completed. If no error has occurred, the callback should be run without
 * arguments or with an explicit `null` argument. Invoked with
 * (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @example
 *
 * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
 * var configs = {};
 *
 * async.forEachOf(obj, function (value, key, callback) {
 *     fs.readFile(__dirname + value, "utf8", function (err, data) {
 *         if (err) return callback(err);
 *         try {
 *             configs[key] = JSON.parse(data);
 *         } catch (e) {
 *             return callback(e);
 *         }
 *         callback();
 *     });
 * }, function (err) {
 *     if (err) console.error(err.message);
 *     // configs is now a map of JSON data
 *     doSomethingWith(configs);
 * });
 */
module.exports = exports['default'];
},{"./eachOfLimit":2,"./internal/doLimit":3,"./internal/onlyOnce":8,"lodash/isArrayLike":45,"lodash/noop":53,"lodash/once":54}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = eachOfLimit;

var _eachOfLimit2 = require('./internal/eachOfLimit');

var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name eachOfLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} iteratee - A function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array. The iteratee is passed a `callback(err)` which must be called once it
 * has completed. If no error has occurred, the callback should be run without
 * arguments or with an explicit `null` argument. Invoked with
 * (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
function eachOfLimit(coll, limit, iteratee, callback) {
  (0, _eachOfLimit3.default)(limit)(coll, iteratee, callback);
}
module.exports = exports['default'];
},{"./internal/eachOfLimit":4}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = doLimit;
function doLimit(fn, limit) {
    return function (iterable, iteratee, callback) {
        return fn(iterable, limit, iteratee, callback);
    };
}
module.exports = exports['default'];
},{}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _eachOfLimit;

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _once = require('./once');

var _once2 = _interopRequireDefault(_once);

var _iterator = require('./iterator');

var _iterator2 = _interopRequireDefault(_iterator);

var _onlyOnce = require('./onlyOnce');

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _eachOfLimit(limit) {
    return function (obj, iteratee, callback) {
        callback = (0, _once2.default)(callback || _noop2.default);
        if (limit <= 0 || !obj) {
            return callback(null);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var running = 0;

        function iterateeCallback(err) {
            running -= 1;
            if (err) {
                done = true;
                callback(err);
            } else if (done && running <= 0) {
                return callback(null);
            } else {
                replenish();
            }
        }

        function replenish() {
            while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                    done = true;
                    if (running <= 0) {
                        callback(null);
                    }
                    return;
                }
                running += 1;
                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
            }
        }

        replenish();
    };
}
module.exports = exports['default'];
},{"./iterator":6,"./once":7,"./onlyOnce":8,"lodash/noop":53}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (coll) {
    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
};

var iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;

module.exports = exports['default'];
},{}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = iterator;

var _isArrayLike = require('lodash/isArrayLike');

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _getIterator = require('./getIterator');

var _getIterator2 = _interopRequireDefault(_getIterator);

var _keys = require('lodash/keys');

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createArrayIterator(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
    };
}

function createES2015Iterator(iterator) {
    var i = -1;
    return function next() {
        var item = iterator.next();
        if (item.done) return null;
        i++;
        return { value: item.value, key: i };
    };
}

function createObjectIterator(obj) {
    var okeys = (0, _keys2.default)(obj);
    var i = -1;
    var len = okeys.length;
    return function next() {
        var key = okeys[++i];
        return i < len ? { value: obj[key], key: key } : null;
    };
}

function iterator(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
    }

    var iterator = (0, _getIterator2.default)(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}
module.exports = exports['default'];
},{"./getIterator":5,"lodash/isArrayLike":45,"lodash/keys":52}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = once;
function once(fn) {
    return function () {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}
module.exports = exports['default'];
},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = onlyOnce;
function onlyOnce(fn) {
    return function () {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}
module.exports = exports['default'];
},{}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _parallel;

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _isArrayLike = require('lodash/isArrayLike');

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _rest = require('lodash/rest');

var _rest2 = _interopRequireDefault(_rest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _parallel(eachfn, tasks, callback) {
    callback = callback || _noop2.default;
    var results = (0, _isArrayLike2.default)(tasks) ? [] : {};

    eachfn(tasks, function (task, key, callback) {
        task((0, _rest2.default)(function (err, args) {
            if (args.length <= 1) {
                args = args[0];
            }
            results[key] = args;
            callback(err);
        }));
    }, function (err) {
        callback(err, results);
    });
}
module.exports = exports['default'];
},{"lodash/isArrayLike":45,"lodash/noop":53,"lodash/rest":55}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parallelLimit;

var _eachOf = require('./eachOf');

var _eachOf2 = _interopRequireDefault(_eachOf);

var _parallel = require('./internal/parallel');

var _parallel2 = _interopRequireDefault(_parallel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Run the `tasks` collection of functions in parallel, without waiting until
 * the previous function has completed. If any of the functions pass an error to
 * its callback, the main `callback` is immediately called with the value of the
 * error. Once the `tasks` have completed, the results are passed to the final
 * `callback` as an array.
 *
 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
 * parallel execution of code.  If your tasks do not use any timers or perform
 * any I/O, they will actually be executed in series.  Any synchronous setup
 * sections for each task will happen one after the other.  JavaScript remains
 * single-threaded.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 * results from {@link async.parallel}.
 *
 * @name parallel
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection containing functions to run.
 * Each function is passed a `callback(err, result)` which it must call on
 * completion with an error `err` (which can be `null`) and an optional `result`
 * value.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 * @example
 * async.parallel([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     // the results array will equal ['one','two'] even though
 *     // the second function had a shorter timeout.
 * });
 *
 * // an example using an object instead of an array
 * async.parallel({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     // results is now equals to: {one: 1, two: 2}
 * });
 */
function parallelLimit(tasks, callback) {
  (0, _parallel2.default)(_eachOf2.default, tasks, callback);
}
module.exports = exports['default'];
},{"./eachOf":1,"./internal/parallel":9}],11:[function(require,module,exports){
(function () {

    'use strict';

    let Texture2D = require('./Texture2D');
    let ImageLoader = require('../util/ImageLoader');
    let Util = require('../util/Util');

    let MAG_FILTERS = {
        NEAREST: true,
        LINEAR: true
    };
    let MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true,
        NEAREST_MIPMAP_NEAREST: true,
        LINEAR_MIPMAP_NEAREST: true,
        NEAREST_MIPMAP_LINEAR: true,
        LINEAR_MIPMAP_LINEAR: true
    };
    let WRAP_MODES = {
        REPEAT: true,
        MIRRORED_REPEAT: true,
        CLAMP_TO_EDGE: true
    };
    let TYPES = {
        UNSIGNED_BYTE: true,
        FLOAT: true
    };
    let FORMATS = {
        RGB: true,
        RGBA: true
    };

    /**
     * The default type for color textures.
     */
    let DEFAULT_TYPE = 'UNSIGNED_BYTE';

    /**
     * The default format for color textures.
     */
    let DEFAULT_FORMAT = 'RGBA';

    /**
     * The default wrap mode for color textures.
     */
    let DEFAULT_WRAP = 'REPEAT';

    /**
     * The default min / mag filter for color textures.
     */
    let DEFAULT_FILTER = 'LINEAR';

    /**
     * The default for whether alpha premultiplying is enabled.
     */
    let DEFAULT_PREMULTIPLY_ALPHA = true;

    /**
     * The default for whether mipmapping is enabled.
     */
    let DEFAULT_MIPMAP = true;

    /**
     * The default for whether invert-y is enabled.
     */
    let DEFAULT_INVERT_Y = true;

    /**
     * @class ColorTexture2D
     * @classdesc A texture class to represent a 2D color texture.
     * @augments Texture2D
     */
    class ColorTexture2D extends Texture2D {

        /**
         * Instantiates a ColorTexture2D object.
         *
         * @param {Object} spec - The specification arguments.
         * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} spec.image - The HTMLImageElement to buffer.
         * @param {String} spec.url - The HTMLImageElement URL to load and buffer.
         * @param {Uint8Array|Float32Array} spec.src - The data to buffer.
         * @param {Number} spec.width - The width of the texture.
         * @param {Number} spec.height - The height of the texture.
         * @param {String} spec.wrap - The wrapping type over both S and T dimension.
         * @param {String} spec.wrapS - The wrapping type over the S dimension.
         * @param {String} spec.wrapT - The wrapping type over the T dimension.
         * @param {String} spec.filter - The min / mag filter used during scaling.
         * @param {String} spec.minFilter - The minification filter used during scaling.
         * @param {String} spec.magFilter - The magnification filter used during scaling.
         * @param {bool} spec.mipMap - Whether or not mip-mapping is enabled.
         * @param {bool} spec.invertY - Whether or not invert-y is enabled.
         * @param {bool} spec.preMultiplyAlpha - Whether or not alpha premultiplying is enabled.
         * @param {String} spec.format - The texture pixel format.
         * @param {String} spec.type - The texture pixel component type.
         * @param {Function} callback - The callback to be executed if the data is loaded asynchronously via a URL.
         */
        constructor(spec = {}, callback = null) {
            // get specific params
            spec.wrapS = spec.wrapS || spec.wrap;
            spec.wrapT = spec.wrapT || spec.wrap;
            spec.minFilter = spec.minFilter || spec.filter;
            spec.magFilter = spec.magFilter || spec.filter;
            // set texture params
            spec.wrapS = WRAP_MODES[spec.wrapS] ? spec.wrapS : DEFAULT_WRAP;
            spec.wrapT = WRAP_MODES[spec.wrapT] ? spec.wrapT : DEFAULT_WRAP;
            spec.minFilter = MIN_FILTERS[spec.minFilter] ? spec.minFilter : DEFAULT_FILTER;
            spec.magFilter = MAG_FILTERS[spec.magFilter] ? spec.magFilter : DEFAULT_FILTER;
            // set other properties
            spec.mipMap = spec.mipMap !== undefined ? spec.mipMap : DEFAULT_MIPMAP;
            spec.invertY = spec.invertY !== undefined ? spec.invertY : DEFAULT_INVERT_Y;
            spec.preMultiplyAlpha = spec.preMultiplyAlpha !== undefined ? spec.preMultiplyAlpha : DEFAULT_PREMULTIPLY_ALPHA;
            // set format
            spec.format = FORMATS[spec.format] ? spec.format : DEFAULT_FORMAT;
            // buffer the texture based on argument type
            if (typeof spec.src === 'string') {
                // request source from url
                spec.type = 'UNSIGNED_BYTE';
                // call base constructor
                super(spec);
                // TODO: put extension handling for arraybuffer / image / video differentiation
                ImageLoader.load({
                    url: spec.src,
                    success: image => {
                        // set to unsigned byte type
                        image = Util.resizeCanvas(spec, image);
                        // now buffer
                        this.bufferData(image, spec.width, spec.height);
                        this.setParameters(this);
                        // execute callback
                        if (callback) {
                            callback(null, this);
                        }
                    },
                    error: err => {
                        if (callback) {
                            callback(err, null);
                        }
                    }
                });
            } else if (Util.isCanvasType(spec.src)) {
                // is image / canvas / video type
                // set to unsigned byte type
                spec.type = 'UNSIGNED_BYTE';
                spec.src = Util.resizeCanvas(spec, spec.src);
                // call base constructor
                super(spec);
            } else {
                // array, arraybuffer, or null
                if (spec.src === undefined || spec.src === null) {
                    // if no data is provided, assume this texture will be rendered
                    // to. In this case disable mipmapping, there is no need and it
                    // will only introduce very peculiar and difficult to discern
                    // rendering phenomena in which the texture 'transforms' at
                    // certain angles / distances to the mipmapped (empty) portions.
                    spec.mipMap = false;
                }
                // buffer from arg
                spec.type = TYPES[spec.type] ? spec.type : DEFAULT_TYPE;
                // call base constructor
                super(spec);
            }
        }
    }

    module.exports = ColorTexture2D;

}());

},{"../util/ImageLoader":26,"../util/Util":27,"./Texture2D":18}],12:[function(require,module,exports){
(function () {

    'use strict';

    let Texture2D = require('./Texture2D');

    let MAG_FILTERS = {
        NEAREST: true,
        LINEAR: true
    };
    let MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true
    };
    let WRAP_MODES = {
        REPEAT: true,
        CLAMP_TO_EDGE: true,
        MIRRORED_REPEAT: true
    };
    let DEPTH_TYPES = {
        UNSIGNED_BYTE: true,
        UNSIGNED_SHORT: true,
        UNSIGNED_INT: true
    };
    let FORMATS = {
        DEPTH_COMPONENT: true,
        DEPTH_STENCIL: true
    };

    /**
     * The default type for depth textures.
     */
    let DEFAULT_TYPE = 'UNSIGNED_INT';

    /**
     * The default format for depth textures.
     */
    let DEFAULT_FORMAT = 'DEPTH_COMPONENT';

    /**
     * The default wrap mode for depth textures.
     */
    let DEFAULT_WRAP = 'CLAMP_TO_EDGE';

    /**
     * The default min / mag filter for depth textures.
     */
    let DEFAULT_FILTER = 'LINEAR';

    /**
     * @class DepthTexture2D
     * @classdesc A texture class to represent a 2D depth texture.
     * @augments Texture2D
     */
    class DepthTexture2D extends Texture2D {

        /**
         * Instantiates a DepthTexture2D object.
         *
         * @param {Object} spec - The specification arguments.
         * @param {Uint8Array|Uint16Array|Uint32Array} spec.src - The data to buffer.
         * @param {Number} spec.width - The width of the texture.
         * @param {Number} spec.height - The height of the texture.
         * @param {String} spec.wrap - The wrapping type over both S and T dimension.
         * @param {String} spec.wrapS - The wrapping type over the S dimension.
         * @param {String} spec.wrapT - The wrapping type over the T dimension.
         * @param {String} spec.filter - The min / mag filter used during scaling.
         * @param {String} spec.minFilter - The minification filter used during scaling.
         * @param {String} spec.magFilter - The magnification filter used during scaling.
         * @param {String} spec.format - The texture pixel format.
         * @param {String} spec.type - The texture pixel component type.
         */
        constructor(spec = {}) {
            // get specific params
            spec.wrapS = spec.wrapS || spec.wrap;
            spec.wrapT = spec.wrapT || spec.wrap;
            spec.minFilter = spec.minFilter || spec.filter;
            spec.magFilter = spec.magFilter || spec.filter;
            // set texture params
            spec.wrapS = WRAP_MODES[spec.wrapS] ? spec.wrapS : DEFAULT_WRAP;
            spec.wrapT = WRAP_MODES[spec.wrapT] ? spec.wrapT : DEFAULT_WRAP;
            spec.minFilter = MIN_FILTERS[spec.minFilter] ? spec.minFilter : DEFAULT_FILTER;
            spec.magFilter = MAG_FILTERS[spec.magFilter] ? spec.magFilter : DEFAULT_FILTER;
            // set mip-mapping and format
            spec.mipMap = false; // disable mip-mapping
            spec.invertY = false; // no need to invert-y
            spec.preMultiplyAlpha = false; // no alpha to pre-multiply
            spec.format = FORMATS[spec.format] ? spec.format : DEFAULT_FORMAT;
            // check if stencil-depth, or just depth
            if (spec.format === 'DEPTH_STENCIL') {
                spec.type = 'UNSIGNED_INT_24_8_WEBGL';
            } else {
                spec.type = DEPTH_TYPES[spec.type] ? spec.type : DEFAULT_TYPE;
            }
            // call base constructor
            super(spec);
        }
    }

    module.exports = DepthTexture2D;

}());

},{"./Texture2D":18}],13:[function(require,module,exports){
(function () {

    'use strict';

    let WebGLContext = require('./WebGLContext');

    let TYPES = {
        UNSIGNED_BYTE: true,
        UNSIGNED_SHORT: true,
        UNSIGNED_INT: true
    };
    let MODES = {
        POINTS: true,
        LINES: true,
        LINE_STRIP: true,
        LINE_LOOP: true,
        TRIANGLES: true,
        TRIANGLE_STRIP: true,
        TRIANGLE_FAN: true
    };
    let BYTES_PER_TYPE = {
        UNSIGNED_BYTE: 1,
        UNSIGNED_SHORT: 2,
        UNSIGNED_INT: 4
    };

    /**
     * The default component type.
     */
    let DEFAULT_TYPE = 'UNSIGNED_SHORT';

    /**
     * The default render mode (primitive type).
     */
    let DEFAULT_MODE = 'TRIANGLES';

    /**
     * The default byte offset to render from.
     */
    let DEFAULT_BYTE_OFFSET = 0;

    /**
     * The default count of indices to render.
     */
    let DEFAULT_COUNT = 0;

    /**
     * @class IndexBuffer
     * @classdesc An index buffer class to hole indexing information.
     */
    class IndexBuffer {

        /**
         * Instantiates an IndexBuffer object.
         *
         * @param {WebGLBuffer|Uint8Array|Uint16Array|Uin32Array|Array|Number} arg - The index data to buffer.
         * @param {Object} options - The rendering options.
         * @param {String} options.mode - The draw mode / primitive type.
         * @param {String} options.byteOffset - The byte offset into the drawn buffer.
         * @param {String} options.count - The number of vertices to draw.
         */
        constructor(arg, options = {}) {
            this.gl = WebGLContext.get();
            this.buffer = null;
            this.type = TYPES[options.type] ? options.type : DEFAULT_TYPE;
            this.mode = MODES[options.mode] ? options.mode : DEFAULT_MODE;
            this.count = (options.count !== undefined) ? options.count : DEFAULT_COUNT;
            this.byteOffset = (options.byteOffset !== undefined) ? options.byteOffset : DEFAULT_BYTE_OFFSET;
            this.byteLength = 0;
            if (arg) {
                if (arg instanceof WebGLBuffer) {
                    // WebGLBuffer argument
                    if (options.byteLength === undefined) {
                        throw 'Argument of type WebGLBuffer` must be complimented with a corresponding `options.byteLength`';
                    }
                    this.byteLength = options.byteLength;
                    this.buffer = arg;
                } else if (Number.isInteger(arg)) {
                    // byte length argument
                    if (options.type === undefined) {
                        throw 'Argument of type `number` must be complimented with a corresponding `options.type`';
                    }
                    this.bufferData(arg);
                } else if (arg instanceof ArrayBuffer) {
                    // ArrayBuffer arg
                    if (options.type === undefined) {
                        throw 'Argument of type `ArrayBuffer` must be complimented with a corresponding `options.type`';
                    }
                    this.bufferData(arg);
                } else {
                    // Array or ArrayBufferView argument
                    this.bufferData(arg);
                }
            } else {
                if (options.type === undefined) {
                    throw 'Empty buffer must be complimented with a corresponding `options.type`';
                }
            }
        }

        /**
         * Upload index data to the GPU.
         *
         * @param {Array|ArrayBuffer|ArrayBufferView|number} arg - The array of data to buffer.
         *
         * @return {IndexBuffer} The index buffer object, for chaining.
         */
        bufferData(arg) {
            let gl = this.gl;
            // cast array to ArrayBufferView based on provided type
            if (Array.isArray(arg)) {
                // check for type
                if (this.type === 'UNSIGNED_INT') {
                    // buffer to uint32
                    arg = new Uint32Array(arg);
                } else if (this.type === 'UNSIGNED_SHORT') {
                    // buffer to uint16
                    arg = new Uint16Array(arg);
                } else {
                    // buffer to uint8
                    arg = new Uint8Array(arg);
                }
            } else {
                // set ensure type corresponds to data
                if (arg instanceof Uint32Array) {
                    this.type = 'UNSIGNED_INT';
                } else if (arg instanceof Uint16Array) {
                    this.type = 'UNSIGNED_SHORT';
                } else if (arg instanceof Uint8Array) {
                    this.type = 'UNSIGNED_BYTE';
                } else if (
                    !(arg instanceof ArrayBuffer) &&
                    !(Number.isInteger(arg))
                    ) {
                    throw 'Argument must be of type `Array`, `ArrayBuffer`, `ArrayBufferView`, or `number`';
                }
            }
            // check that the type is supported by extension
            if (this.type === 'UNSIGNED_INT' &&
                !WebGLContext.checkExtension('OES_element_index_uint')) {
                throw 'Cannot create IndexBuffer of type `UNSIGNED_INT` as extension `OES_element_index_uint` is not supported';
            }
            // don't overwrite the count if it is already set
            if (this.count === DEFAULT_COUNT) {
                if (Number.isInteger(arg)) {
                    this.count = (arg / BYTES_PER_TYPE[this.type]);
                } else {
                    this.count = arg.length;
                }
            }
            // set byte length
            if (Number.isInteger(arg)) {
                this.byteLength = arg;
            } else {
                this.byteLength = arg.byteLength;
            }
            // create buffer if it doesn't exist already
            if (!this.buffer) {
                this.buffer = gl.createBuffer();
            }
            // buffer the data
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arg, gl.STATIC_DRAW);
            return this;
        }

        /**
         * Upload partial index data to the GPU.
         *
         * @param {Array|ArrayBuffer|ArrayBufferView} array - The array of data to buffer.
         * @param {Number} byteOffset - The byte offset at which to buffer.
         *
         * @return {IndexBuffer} The index buffer object, for chaining.
         */
        bufferSubData(array, byteOffset = DEFAULT_BYTE_OFFSET) {
            let gl = this.gl;
            if (!this.buffer) {
                throw 'Buffer has not yet been allocated, allocate with `bufferData`';
            }
            // cast array to ArrayBufferView based on provided type
            if (Array.isArray(array)) {
                // check for type
                if (this.type === 'UNSIGNED_INT') {
                    // buffer to uint32
                    array = new Uint32Array(array);
                } else if (this.type === 'UNSIGNED_SHORT') {
                    // buffer to uint16
                    array = new Uint16Array(array);
                } else {
                    // buffer to uint8
                    array = new Uint8Array(array);
                }
            } else if (
                !(array instanceof Uint8Array) &&
                !(array instanceof Uint16Array) &&
                !(array instanceof Uint32Array) &&
                !(array instanceof ArrayBuffer)) {
                throw 'Argument must be of type `Array`, `ArrayBuffer`, or `ArrayBufferView`';
            }
            // check that we aren't overflowing the buffer
            if (byteOffset + array.byteLength > this.byteLength) {
                throw `Argument of length ${array.byteLength} bytes with ` +
                    `offset of ${byteOffset} bytes overflows the buffer ` +
                    `length of ${this.byteLength} bytes`;
            }
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, byteOffset, array);
            return this;
        }

        /**
         * Execute the draw command for the bound buffer.
         *
         * @param {Object} options - The options to pass to 'drawElements'. Optional.
         * @param {String} options.mode - The draw mode / primitive type.
         * @param {String} options.byteOffset - The byteOffset into the drawn buffer.
         * @param {String} options.count - The number of vertices to draw.
         *
         * @return {IndexBuffer} The index buffer object, for chaining.
         */
        draw(options = {}) {
            let gl = this.gl;
            let mode = gl[options.mode || this.mode];
            let type = gl[this.type];
            let byteOffset = (options.byteOffset !== undefined) ? options.byteOffset : this.byteOffset;
            let count = (options.count !== undefined) ? options.count : this.count;
            if (count === 0) {
                throw 'Attempting to draw with a count of 0';
            }
            // bind buffer
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            // draw elements
            gl.drawElements(mode, count, type, byteOffset);
            // no need to unbind
            return this;
        }
    }

    module.exports = IndexBuffer;

}());

},{"./WebGLContext":23}],14:[function(require,module,exports){
(function () {

    'use strict';

    let WebGLContext = require('./WebGLContext');

    let TEXTURE_TARGETS = {
        TEXTURE_2D: true,
        TEXTURE_CUBE_MAP: true
    };

    let DEPTH_FORMATS = {
        DEPTH_COMPONENT: true,
        DEPTH_STENCIL: true
    };

    /**
     * @class RenderTarget
     * @classdesc A renderTarget class to allow rendering to textures.
     */
    class RenderTarget {

        /**
         * Instantiates a RenderTarget object.
         */
         constructor() {
            this.gl = WebGLContext.get();
            this.framebuffer = this.gl.createFramebuffer();
            this.textures = {};
        }

        /**
         * Binds the renderTarget object.
         *
         * @return {RenderTarget} The renderTarget object, for chaining.
         */
        bind() {
            // bind framebuffer
            let gl = this.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
            return this;
        }

        /**
         * Unbinds the renderTarget object.
         *
         * @return {RenderTarget} The renderTarget object, for chaining.
         */
        unbind() {
            // unbind framebuffer
            let gl = this.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            return this;
        }

        /**
         * Attaches the provided texture to the provided attachment location.
         *
         * @param {Texture2D} texture - The texture to attach.
         * @param {Number} index - The attachment index. (optional)
         * @param {String} target - The texture target type. (optional)
         *
         * @return {RenderTarget} The renderTarget object, for chaining.
         */
        setColorTarget(texture, index, target) {
            let gl = this.gl;
            if (!texture) {
                throw 'Texture argument is missing';
            }
            if (TEXTURE_TARGETS[index] && target === undefined) {
                target = index;
                index = 0;
            }
            if (index === undefined) {
                index = 0;
            } else if (!Number.isInteger(index) || index < 0) {
                throw 'Texture color attachment index is invalid';
            }
            if (target && !TEXTURE_TARGETS[target]) {
                throw 'Texture target is invalid';
            }
            this.textures['color' + index] = texture;
            this.bind();
            gl.framebufferTexture2D(
                gl.FRAMEBUFFER,
                gl['COLOR_ATTACHMENT' + index],
                gl[target || 'TEXTURE_2D'],
                texture.texture,
                0);
            this.unbind();
            return this;
        }

        /**
         * Attaches the provided texture to the provided attachment location.
         *
         * @param {Texture2D} texture - The texture to attach.
         *
         * @return {RenderTarget} The renderTarget object, for chaining.
         */
        setDepthTarget(texture) {
            if (!texture) {
                throw 'Texture argument is missing';
            }
            if (!DEPTH_FORMATS[texture.format]) {
                throw 'Provided texture is not of format `DEPTH_COMPONENT` or `DEPTH_STENCIL`';
            }
            let gl = this.gl;
            this.textures.depth = texture;
            this.bind();
            gl.framebufferTexture2D(
                gl.FRAMEBUFFER,
                gl.DEPTH_ATTACHMENT,
                gl.TEXTURE_2D,
                texture.texture,
                0);
            this.unbind();
            return this;
        }

        /**
         * Resizes the renderTarget and all attached textures by the provided height and width.
         *
         * @param {Number} width - The new width of the renderTarget.
         * @param {Number} height - The new height of the renderTarget.
         *
         * @return {RenderTarget} The renderTarget object, for chaining.
         */
        resize(width, height) {
            if (typeof width !== 'number' || (width <= 0)) {
                throw `Provided \`width\` of ${width} is invalid`;
            }
            if (typeof height !== 'number' || (height <= 0)) {
                throw `Provided \`height\` of ${height} is invalid`;
            }
            let textures = this.textures;
            Object.keys(textures).forEach(key => {
                textures[key].resize(width, height);
            });
            return this;
        }
    }

    module.exports = RenderTarget;

}());

},{"./WebGLContext":23}],15:[function(require,module,exports){
(function () {

    'use strict';

    let VertexPackage = require('../core/VertexPackage');
    let VertexBuffer = require('../core/VertexBuffer');
    let IndexBuffer = require('../core/IndexBuffer');

    /**
     * Iterates over all attribute pointers and throws an exception if an index
     * occurs more than once.
     * @private
     *
     * @param {Array} vertexBuffers - The array of vertexBuffers.
     */
    function checkIndexCollisions(vertexBuffers) {
        let indices = {};
        vertexBuffers.forEach(buffer => {
            Object.keys(buffer.pointers).forEach(index => {
                indices[index] = indices[index] || 0;
                indices[index]++;
            });
        });
        Object.keys(indices).forEach(index => {
            if (indices[index] > 1) {
                throw `More than one attribute pointer exists for index \`${index}\``;
            }
        });
    }

    /**
     * @class Renderable
     * @classdesc A container for one or more VertexBuffers and an optional IndexBuffer.
     */
    class Renderable {

        /**
         * Instantiates an Renderable object.
         *
         * @param {Object} spec - The renderable specification object.
         * @param {Array|Float32Array} spec.vertices - The vertices to interleave and buffer.
         * @param {VertexBuffer} spec.vertexBuffer - An existing vertex buffer.
         * @param {VertexBuffer[]} spec.vertexBuffers - Multiple existing vertex buffers.
         * @param {Array|Uint16Array|Uint32Array} spec.indices - The indices to buffer.
         * @param {IndexBuffer} spec.indexbuffer - An existing index buffer.
         */
        constructor(spec = {}) {
            if (spec.vertexBuffer || spec.vertexBuffers) {
                // use existing vertex buffer
                this.vertexBuffers = spec.vertexBuffers || [spec.vertexBuffer];
            } else if (spec.vertices) {
                // create vertex package
                let vertexPackage = new VertexPackage(spec.vertices);
                // create vertex buffer
                this.vertexBuffers = [new VertexBuffer(vertexPackage)];
            } else {
                this.vertexBuffers = [];
            }
            if (spec.indexBuffer) {
                // use existing index buffer
                this.indexBuffer = spec.indexBuffer;
            } else if (spec.indices) {
                // create index buffer
                this.indexBuffer = new IndexBuffer(spec.indices);
            } else {
                this.indexBuffer = null;
            }
            // check that no attribute indices clash
            checkIndexCollisions(this.vertexBuffers);
        }

        /**
         * Execute the draw command for the underlying buffers.
         *
         * @param {Object} options - The options to pass to 'drawElements'. Optional.
         * @param {String} options.mode - The draw mode / primitive type.
         * @param {String} options.byteOffset - The byteOffset into the drawn buffer.
         * @param {String} options.indexOffset - The indexOffset into the drawn buffer.
         * @param {String} options.count - The number of vertices to draw.
         *
         * @return {Renderable} - The renderable object, for chaining.
         */
        draw(options = {}) {
            // draw the renderable
            if (this.indexBuffer) {
                // use index buffer to draw elements
                // bind vertex buffers and enable attribute pointers
                this.vertexBuffers.forEach(vertexBuffer => {
                    vertexBuffer.bind();
                });
                // draw primitives using index buffer
                this.indexBuffer.draw(options);
                // disable attribute pointers
                this.vertexBuffers.forEach(vertexBuffer => {
                    vertexBuffer.unbind();
                });
                // no advantage to unbinding as there is no stack used
            } else {
                // no index buffer, use draw arrays
                this.vertexBuffers.forEach(vertexBuffer => {
                    vertexBuffer.bind();
                    vertexBuffer.draw(options);
                    vertexBuffer.unbind();
                });
            }
            return this;
        }
    }

    module.exports = Renderable;

}());

},{"../core/IndexBuffer":13,"../core/VertexBuffer":20,"../core/VertexPackage":21}],16:[function(require,module,exports){
(function () {

    'use strict';

    let WebGLContext = require('./WebGLContext');
    let ShaderParser = require('./ShaderParser');
    let Async = require('../util/Async');
    let XHRLoader = require('../util/XHRLoader');

    let UNIFORM_FUNCTIONS = {
        'bool': 'uniform1i',
        'bool[]': 'uniform1iv',
        'float': 'uniform1f',
        'float[]': 'uniform1fv',
        'int': 'uniform1i',
        'int[]': 'uniform1iv',
        'uint': 'uniform1i',
        'uint[]': 'uniform1iv',
        'vec2': 'uniform2fv',
        'vec2[]': 'uniform2fv',
        'ivec2': 'uniform2iv',
        'ivec2[]': 'uniform2iv',
        'vec3': 'uniform3fv',
        'vec3[]': 'uniform3fv',
        'ivec3': 'uniform3iv',
        'ivec3[]': 'uniform3iv',
        'vec4': 'uniform4fv',
        'vec4[]': 'uniform4fv',
        'ivec4': 'uniform4iv',
        'ivec4[]': 'uniform4iv',
        'mat2': 'uniformMatrix2fv',
        'mat2[]': 'uniformMatrix2fv',
        'mat3': 'uniformMatrix3fv',
        'mat3[]': 'uniformMatrix3fv',
        'mat4': 'uniformMatrix4fv',
        'mat4[]': 'uniformMatrix4fv',
        'sampler2D': 'uniform1i',
        'samplerCube': 'uniform1i'
    };

    /**
     * Given a map of existing attributes, find the lowest index that is not
     * already used. If the attribute ordering was already provided, use that
     * instead.
     * @private
     *
     * @param {Object} attributes - The existing attributes object.
     * @param {Object} declaration - The attribute declaration object.
     *
     * @return {Number} The attribute index.
     */
    function getAttributeIndex(attributes, declaration) {
        // check if attribute is already declared, if so, use that index
        if (attributes[declaration.name]) {
            return attributes[declaration.name].index;
        }
        // return next available index
        return Object.keys(attributes).length;
    }

    /**
     * Given vertex and fragment shader source, parses the declarations and appends information pertaining to the uniforms and attribtues declared.
     * @private
     *
     * @param {Shader} shader - The shader object.
     * @param {String} vertSource - The vertex shader source.
     * @param {String} fragSource - The fragment shader source.
     *
     * @return {Object} The attribute and uniform information.
     */
    function setAttributesAndUniforms(shader, vertSource, fragSource) {
        let declarations = ShaderParser.parseDeclarations(
            [vertSource, fragSource],
            ['uniform', 'attribute']);
        // for each declaration in the shader
        declarations.forEach(declaration => {
            // check if its an attribute or uniform
            if (declaration.qualifier === 'attribute') {
                // if attribute, store type and index
                let index = getAttributeIndex(shader.attributes, declaration);
                shader.attributes[declaration.name] = {
                    type: declaration.type,
                    index: index
                };
            } else { // if (declaration.qualifier === 'uniform') {
                // if uniform, store type and buffer function name
                shader.uniforms[declaration.name] = {
                    type: declaration.type,
                    func: UNIFORM_FUNCTIONS[declaration.type + (declaration.count > 1 ? '[]' : '')]
                };
            }
        });
    }

    /**
     * Given a shader source string and shader type, compiles the shader and returns the resulting WebGLShader object.
     * @private
     *
     * @param {WebGLRenderingContext} gl - The webgl rendering context.
     * @param {String} shaderSource - The shader source.
     * @param {String} type - The shader type.
     *
     * @return {WebGLShader} The compiled shader object.
     */
    function compileShader(gl, shaderSource, type) {
        let shader = gl.createShader(gl[type]);
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            throw 'An error occurred compiling the shaders:\n' + gl.getShaderInfoLog(shader);
        }
        return shader;
    }

    /**
     * Binds the attribute locations for the Shader object.
     * @private
     *
     * @param {Shader} shader - The Shader object.
     */
    function bindAttributeLocations(shader) {
        let gl = shader.gl;
        let attributes = shader.attributes;
        Object.keys(attributes).forEach(key => {
            // bind the attribute location
            gl.bindAttribLocation(
                shader.program,
                attributes[key].index,
                key);
        });
    }

    /**
     * Queries the webgl rendering context for the uniform locations.
     * @private
     *
     * @param {Shader} shader - The Shader object.
     */
    function getUniformLocations(shader) {
        let gl = shader.gl;
        let uniforms = shader.uniforms;
        Object.keys(uniforms).forEach(key => {
            // get the uniform location
            let location = gl.getUniformLocation(shader.program, key);
            // check if null, parse may detect uniform that is compiled out
            // due to a preprocessor evaluation.
            // TODO: fix parser so that it evaluates these correctly.
            if (location === null) {
                delete uniforms[key];
            } else {
                uniforms[key].location = location;
            }
        });
    }

    /**
     * Returns a function to load shader source from a url.
     * @private
     *
     * @param {String} url - The url to load the resource from.
     *
     * @return {Function} The function to load the shader source.
     */
    function loadShaderSource(url) {
        return function(done) {
            XHRLoader.load({
                url: url,
                responseType: 'text',
                success: function(res) {
                    done(null, res);
                },
                error: function(err) {
                    done(err, null);
                }
            });
        };
    }

    /**
     * Returns a function to pass through the shader source.
     * @private
     *
     * @param {String} source - The source of the shader.
     *
     * @return {Function} The function to pass through the shader source.
     */
    function passThroughSource(source) {
        return function(done) {
            done(null, source);
        };
    }

    /**
     * Returns a function that takes an array of GLSL source strings and URLs, and resolves them into and array of GLSL source.
     * @private
     *
     * @param {Array} sources - The shader sources.
     *
     * @return {Function} A function to resolve the shader sources.
     */
    function resolveSources(sources) {
        return function(done) {
            let tasks = [];
            sources = sources || [];
            sources = !Array.isArray(sources) ? [sources] : sources;
            sources.forEach(source => {
                if (ShaderParser.isGLSL(source)) {
                    tasks.push(passThroughSource(source));
                } else {
                    tasks.push(loadShaderSource(source));
                }
            });
            Async.parallel(tasks, done);
        };
    }

    /**
     * Creates the shader program object from source strings. This includes:
     *    1) Compiling and linking the shader program.
     *    2) Parsing shader source for attribute and uniform information.
     *    3) Binding attribute locations, by order of delcaration.
     *    4) Querying and storing uniform location.
     * @private
     *
     * @param {Shader} shader - The Shader object.
     * @param {Object} sources - A map containing sources under 'vert' and 'frag' attributes.
     *
     * @return {Shader} The shader object, for chaining.
     */
    function createProgram(shader, sources) {
        let gl = shader.gl;
        let common = sources.common.join('');
        let vert = sources.vert.join('');
        let frag = sources.frag.join('');
        // compile shaders
        let vertexShader = compileShader(gl, common + vert, 'VERTEX_SHADER');
        let fragmentShader = compileShader(gl, common + frag, 'FRAGMENT_SHADER');
        // parse source for attribute and uniforms
        setAttributesAndUniforms(shader, vert, frag);
        // create the shader program
        shader.program = gl.createProgram();
        // attach vertex and fragment shaders
        gl.attachShader(shader.program, vertexShader);
        gl.attachShader(shader.program, fragmentShader);
        // bind vertex attribute locations BEFORE linking
        bindAttributeLocations(shader);
        // link shader
        gl.linkProgram(shader.program);
        // If creating the shader program failed, alert
        if (!gl.getProgramParameter(shader.program, gl.LINK_STATUS)) {
            throw 'An error occured linking the shader:\n' + gl.getProgramInfoLog(shader.program);
        }
        // get shader uniform locations
        getUniformLocations(shader);
    }

    /**
     * @class Shader
     * @classdesc A shader class to assist in compiling and linking webgl shaders, storing attribute and uniform locations, and buffering uniforms.
     */
    class Shader {

        /**
         * Instantiates a Shader object.
         *
         * @param {Object} spec - The shader specification object.
         * @param {String|String[]|Object} spec.common - Sources / URLs to be shared by both vertex and fragment shaders.
         * @param {String|String[]|Object} spec.vert - The vertex shader sources / URLs.
         * @param {String|String[]|Object} spec.frag - The fragment shader sources / URLs.
         * @param {String[]} spec.attributes - The attribute index orderings.
         * @param {Function} callback - The callback function to execute once the shader has been successfully compiled and linked.
         */
        constructor(spec = {}, callback = null) {
            // check source arguments
            if (!spec.vert) {
                throw 'Vertex shader argument `vert` has not been provided';
            }
            if (!spec.frag) {
                throw 'Fragment shader argument `frag` has not been provided';
            }
            this.program = 0;
            this.gl = WebGLContext.get();
            this.version = spec.version || '1.00';
            this.attributes = {};
            this.uniforms = {};
            // if attribute ordering is provided, use those indices
            if (spec.attributes) {
                spec.attributes.forEach((attr, index) => {
                    this.attributes[attr] = {
                        index: index
                    };
                });
            }
            // create the shader
            Async.parallel({
                common: resolveSources(spec.common),
                vert: resolveSources(spec.vert),
                frag: resolveSources(spec.frag),
            }, (err, sources) => {
                if (err) {
                    if (callback) {
                        setTimeout(() => {
                            callback(err, null);
                        });
                    }
                    return;
                }
                // once all shader sources are loaded
                createProgram(this, sources);
                if (callback) {
                    setTimeout(() => {
                        callback(null, this);
                    });
                }
            });
        }

        /**
         * Binds the shader program for use.
         *
         * @return {Shader} The shader object, for chaining.
         */
        use() {
            // use the shader
            this.gl.useProgram(this.program);
            return this;
        }

        /**
         * Buffer a uniform value by name.
         *
         * @param {String} name - The uniform name in the shader source.
         * @param {*} value - The uniform value to buffer.
         *
         * @return {Shader} - The shader object, for chaining.
         */
        setUniform(name, value) {
            let uniform = this.uniforms[name];
            // ensure that the uniform spec exists for the name
            if (!uniform) {
                throw `No uniform found under name \`${name}\``;
            }
            // check value
            if (value === undefined || value === null) {
                // ensure that the uniform argument is defined
                throw `Value passed for uniform \`${name}\` is undefined or null`;
            } else if (typeof value === 'boolean') {
                // convert boolean's to 0 or 1
                // TODO: is this necessary?
                value = value ? 1 : 0;
            }
            // pass the arguments depending on the type
            // TODO: remove string comparions from here...
            if (uniform.type === 'mat2' || uniform.type === 'mat3' || uniform.type === 'mat4') {
                this.gl[uniform.func](uniform.location, false, value);
            } else {
                this.gl[uniform.func](uniform.location, value);
            }
            return this;
        }

        /**
         * Buffer a map of uniform values.
         *
         * @param {Object} uniforms - The map of uniforms keyed by name.
         *
         * @return {Shader} The shader object, for chaining.
         */
        setUniforms(args) {
            Object.keys(args).forEach(name => {
                this.setUniform(name, args[name]);
            });
            return this;
        }
    }

    module.exports = Shader;

}());

},{"../util/Async":25,"../util/XHRLoader":28,"./ShaderParser":17,"./WebGLContext":23}],17:[function(require,module,exports){
(function () {

    'use strict';

    let COMMENTS_REGEXP = /(\/\*([\s\S]*?)\*\/)|(\/\/(.*)$)/gm;
    let ENDLINE_REGEXP = /(\r\n|\n|\r)/gm;
    let WHITESPACE_REGEXP = /\s{2,}/g;
    let BRACKET_WHITESPACE_REGEXP = /(\s*)(\[)(\s*)(\d+)(\s*)(\])(\s*)/g;
    let NAME_COUNT_REGEXP = /([a-zA-Z_][a-zA-Z0-9_]*)(?:\[(\d+)\])?/;
    let PRECISION_REGEX = /\bprecision\s+\w+\s+\w+;/g;
    let INLINE_PRECISION_REGEX = /\b(highp|mediump|lowp)\s+/g;
    let GLSL_REGEXP = /void\s+main\s*\(\s*(void)*\s*\)\s*/mi;
    let PREP_REGEXP = /#([\W\w\s\d])(?:.*\\r?\n)*.*$/gm;

    /**
     * Removes standard comments from the provided string.
     * @private
     *
     * @param {String} str - The string to strip comments from.
     *
     * @return {String} The commentless string.
     */
    function stripComments(str) {
        // regex source: https://github.com/moagrius/stripcomments
        return str.replace(COMMENTS_REGEXP, '');
    }

    /**
     * Removes an precision statements.
     * @private
     *
     * @param {String} source - The unprocessed source code.
     *
     * @return {String} The processed source code.
     */
    function stripPrecision(source) {
        // remove global precision declarations
        source = source.replace(PRECISION_REGEX, '');
        // remove inline precision declarations
        return source.replace(INLINE_PRECISION_REGEX, '');
    }

    /**
     * Converts all whitespace into a single ' ' space character.
     * @private
     *
     * @param {String} str - The string to normalize whitespace from.
     *
     * @return {String} The normalized string.
     */
    function normalizeWhitespace(str) {
        return str.replace(ENDLINE_REGEXP, ' ') // remove line endings
            .replace(WHITESPACE_REGEXP, ' ') // normalize whitespace to single ' '
            .replace(BRACKET_WHITESPACE_REGEXP, '$2$4$6'); // remove whitespace in brackets
    }

    /**
     * Parses the name and count out of a name statement, returning the declaration object.
     * @private
     *
     * @param {String} qualifier - The qualifier string.
     * @param {String} type - The type string.
     * @param {String} entry - The variable declaration string.
     *
     * @return {Object} The declaration object.
     */
    function parseNameAndCount(qualifier, type, entry) {
        // determine name and size of variable
        let matches = entry.match(NAME_COUNT_REGEXP);
        let name = matches[1];
        let count = (matches[2] === undefined) ? 1 : parseInt(matches[2], 10);
        return {
            qualifier: qualifier,
            type: type,
            name: name,
            count: count
        };
    }

    /**
     * Parses a single 'statement'. A 'statement' is considered any sequence of
     * characters followed by a semi-colon. Therefore, a single 'statement' in
     * this sense could contain several comma separated declarations. Returns
     * all resulting declarations.
     * @private
     *
     * @param {String} statement - The statement to parse.
     *
     * @return {Array} The array of parsed declaration objects.
     */
    function parseStatement(statement) {
        // split statement on commas
        //
        // ['uniform mat4 A[10]', 'B', 'C[2]']
        //
        let split = statement.split(',').map(elem => {
            return elem.trim();
        });

        // split declaration header from statement
        //
        // ['uniform', 'mat4', 'A[10]']
        //
        let header = split.shift().split(' ');

        // qualifier is always first element
        //
        // 'uniform'
        //
        let qualifier = header.shift();

        // type will be the second element
        //
        // 'mat4'
        //
        let type = header.shift();

        // last part of header will be the first, and possible only variable name
        //
        // ['A[10]', 'B', 'C[2]']
        //
        let names = header.concat(split);

        // if there are other names after a ',' add them as well
        return names.map(name => {
            return parseNameAndCount(qualifier, type, name);
        });
    }

    /**
     * Splits the source string by semi-colons and constructs an array of
     * declaration objects based on the provided qualifier keywords.
     * @private
     *
     * @param {String} source - The shader source string.
     * @param {String|Array} keywords - The qualifier declaration keywords.
     *
     * @return {Array} The array of qualifier declaration objects.
     */
    function parseSource(source, keywords) {
        // get individual statements (any sequence ending in ;)
        let statements = source.split(';');
        // build regex for parsing statements with targetted keywords
        let keywordStr = keywords.join('|');
        let keywordRegex = new RegExp('\\b(' + keywordStr + ')\\b.*');
        // parse and store global precision statements and any declarations
        let matched = [];
        // for each statement
        statements.forEach(statement => {
            // check for keywords
            //
            // ['uniform float uTime']
            //
            let kmatch = statement.match(keywordRegex);
            if (kmatch) {
                // parse statement and add to array
                matched = matched.concat(parseStatement(kmatch[0]));
            }
        });
        return matched;
    }

    /**
     * Filters out duplicate declarations present between shaders. Currently
     * just removes all # statements.
     * @private
     *
     * @param {Array} declarations - The array of declarations.
     *
     * @return {Array} The filtered array of declarations.
     */
    function filterDuplicatesByName(declarations) {
        // in cases where the same declarations are present in multiple
        // sources, this function will remove duplicates from the results
        let seen = {};
        return declarations.filter(declaration => {
            if (seen[declaration.name]) {
                return false;
            }
            seen[declaration.name] = true;
            return true;
        });
    }

    /**
     * Runs the preprocessor on the glsl code.
     * @private
     *
     * @param {String} source - The unprocessed source code.
     *
     * @return {String} The processed source code.
     */
    function preprocess(source) {
        // TODO: implement this correctly...
        return source.replace(PREP_REGEXP, '');
    }

    module.exports = {

        /**
         * Parses the provided GLSL source, and returns all declaration statements that contain the provided qualifier type. This can be used to extract all attributes and uniform names and types from a shader.
         *
         * For example, when provided a 'uniform' qualifiers, the declaration:
         *
         *     'uniform highp vec3 uSpecularColor;'
         *
         * Would be parsed to:
         *     {
         *         qualifier: 'uniform',
         *         type: 'vec3',
         *         name: 'uSpecularColor',
         *         count: 1
         *     }
         * @param {Array} sources - The shader sources.
         * @param {Array} qualifiers - The qualifiers to extract.
         *
         * @return {Array} The array of qualifier declaration statements.
         */
        parseDeclarations: function(sources = [], qualifiers = []) {
            // if no sources or qualifiers are provided, return empty array
            if (sources.length === 0 || qualifiers.length === 0) {
                return [];
            }
            sources = Array.isArray(sources) ? sources : [sources];
            qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
            // parse out targetted declarations
            let declarations = [];
            sources.forEach(source => {
                // run preprocessor
                source = preprocess(source);
                // remove precision statements
                source = stripPrecision(source);
                // remove comments
                source = stripComments(source);
                // finally, normalize the whitespace
                source = normalizeWhitespace(source);
                // parse out declarations
                declarations = declarations.concat(parseSource(source, qualifiers));
            });
            // remove duplicates and return
            return filterDuplicatesByName(declarations);
        },

        /**
         * Detects based on the existence of a 'void main() {' statement, if the string is glsl source code.
         *
         * @param {String} str - The input string to test.
         *
         * @return {boolean} Whether or not the string is glsl code.
         */
        isGLSL: function(str) {
            return GLSL_REGEXP.test(str);
        }

    };

}());

},{}],18:[function(require,module,exports){
(function () {

    'use strict';

    let WebGLContext = require('./WebGLContext');
    let Util = require('../util/Util');

    let MAG_FILTERS = {
        NEAREST: true,
        LINEAR: true
    };
    let MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true,
        NEAREST_MIPMAP_NEAREST: true,
        LINEAR_MIPMAP_NEAREST: true,
        NEAREST_MIPMAP_LINEAR: true,
        LINEAR_MIPMAP_LINEAR: true
    };
    let NON_MIPMAP_MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true,
    };
    let MIPMAP_MIN_FILTERS = {
        NEAREST_MIPMAP_NEAREST: true,
        LINEAR_MIPMAP_NEAREST: true,
        NEAREST_MIPMAP_LINEAR: true,
        LINEAR_MIPMAP_LINEAR: true
    };
    let WRAP_MODES = {
        REPEAT: true,
        MIRRORED_REPEAT: true,
        CLAMP_TO_EDGE: true
    };
    let DEPTH_TYPES = {
        DEPTH_COMPONENT: true,
        DEPTH_STENCIL: true
    };

    /**
     * The default type for textures.
     */
    let DEFAULT_TYPE = 'UNSIGNED_BYTE';

    /**
     * The default format for textures.
     */
    let DEFAULT_FORMAT = 'RGBA';

    /**
     * The default wrap mode for textures.
     */
    let DEFAULT_WRAP = 'REPEAT';

    /**
     * The default min / mag filter for textures.
     */
    let DEFAULT_FILTER = 'LINEAR';

    /**
     * The default for whether alpha premultiplying is enabled.
     */
    let DEFAULT_PREMULTIPLY_ALPHA = true;

    /**
     * The default for whether mipmapping is enabled.
     */
    let DEFAULT_MIPMAP = true;

    /**
     * The default for whether invert-y is enabled.
     */
    let DEFAULT_INVERT_Y = true;

    /**
     * The default mip-mapping filter suffix.
     */
    let DEFAULT_MIPMAP_MIN_FILTER_SUFFIX = '_MIPMAP_LINEAR';

    /**
     * @class Texture2D
     * @classdesc A texture class to represent a 2D texture.
     */
    class Texture2D {

        /**
         * Instantiates a Texture2D object.
         *
         * @param {Uint8Array|Uint16Array|Uint32Array|Float32Array|ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} spec.src - The data to buffer.
         * @param {Number} spec.width - The width of the texture.
         * @param {Number} spec.height - The height of the texture.
         * @param {String} spec.wrap - The wrapping type over both S and T dimension.
         * @param {String} spec.wrapS - The wrapping type over the S dimension.
         * @param {String} spec.wrapT - The wrapping type over the T dimension.
         * @param {String} spec.filter - The min / mag filter used during scaling.
         * @param {String} spec.minFilter - The minification filter used during scaling.
         * @param {String} spec.magFilter - The magnification filter used during scaling.
         * @param {bool} spec.mipMap - Whether or not mip-mapping is enabled.
         * @param {bool} spec.invertY - Whether or not invert-y is enabled.
         * @param {bool} spec.preMultiplyAlpha - Whether or not alpha premultiplying is enabled.
         * @param {String} spec.format - The texture pixel format.
         * @param {String} spec.type - The texture pixel component type.
         */
        constructor(spec = {}) {
            // get specific params
            spec.wrapS = spec.wrapS || spec.wrap;
            spec.wrapT = spec.wrapT || spec.wrap;
            spec.minFilter = spec.minFilter || spec.filter;
            spec.magFilter = spec.magFilter || spec.filter;
            // set context
            this.gl = WebGLContext.get();
            // empty texture
            this.texture = null;
            // set texture params
            this.wrapS = spec.wrapS || DEFAULT_WRAP;
            this.wrapT = spec.wrapT || DEFAULT_WRAP;
            this.minFilter = spec.minFilter || DEFAULT_FILTER;
            this.magFilter = spec.magFilter || DEFAULT_FILTER;
            // set other properties
            this.mipMap = spec.mipMap !== undefined ? spec.mipMap : DEFAULT_MIPMAP;
            this.invertY = spec.invertY !== undefined ? spec.invertY : DEFAULT_INVERT_Y;
            this.preMultiplyAlpha = spec.preMultiplyAlpha !== undefined ? spec.preMultiplyAlpha : DEFAULT_PREMULTIPLY_ALPHA;
            // set format
            this.format = spec.format || DEFAULT_FORMAT;
            if (DEPTH_TYPES[this.format] && !WebGLContext.checkExtension('WEBGL_depth_texture')) {
                throw `Cannot create Texture2D of format \`${this.format}\` as \`WEBGL_depth_texture\` extension is unsupported`;
            }
            // set type
            this.type = spec.type || DEFAULT_TYPE;
            if (this.type === 'FLOAT' && !WebGLContext.checkExtension('OES_texture_float')) {
                throw `Cannot create Texture2D of type \`FLOAT\` as \`OES_texture_float\` extension is unsupported`;
            }
            // url will not be resolved yet, so don't buffer in that case
            if (typeof spec.src !== 'string') {
                // check size
                if (!Util.isCanvasType(spec.src)) {
                    // if not a canvas type, dimensions MUST be specified
                    if (typeof spec.width !== 'number' || spec.width <= 0) {
                        throw '`width` argument is missing or invalid';
                    }
                    if (typeof spec.height !== 'number' || spec.height <= 0) {
                        throw '`height` argument is missing or invalid';
                    }
                    if (Util.mustBePowerOfTwo(this)) {
                        if (!Util.isPowerOfTwo(spec.width)) {
                            throw `Parameters require a power-of-two texture, yet provided width of \`${spec.width}\` is not a power of two`;
                        }
                        if (!Util.isPowerOfTwo(spec.height)) {
                            throw `Parameters require a power-of-two texture, yet provided height of \`${spec.height}\` is not a power of two`;
                        }
                    }
                }
                // buffer the data
                this.bufferData(spec.src || null, spec.width, spec.height);
                this.setParameters(this);
            }
        }

        /**
         * Binds the texture object to the provided texture unit location.
         *
         * @param {Number} location - The texture unit location index. Defaults to 0.
         *
         * @return {Texture2D} The texture object, for chaining.
         */
        bind(location = 0) {
            if (!Number.isInteger(location) || location < 0) {
                throw `Texture unit location is invalid`;
            }
            // bind texture
            let gl = this.gl;
            gl.activeTexture(gl['TEXTURE' + location]);
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            return this;
        }

        /**
         * Unbinds the texture object.
         *
         * @return {Texture2D} The texture object, for chaining.
         */
        unbind() {
            // unbind texture
            let gl = this.gl;
            gl.bindTexture(gl.TEXTURE_2D, null);
            return this;
        }

        /**
         * Buffer data into the texture.
         *
         * @param {Array|ArrayBufferView|null} data - The data array to buffer.
         * @param {Number} width - The width of the data.
         * @param {Number} height - The height of the data.
         *
         * @return {Texture2D} The texture object, for chaining.
         */
        bufferData(data, width, height) {
            let gl = this.gl;
            // create texture object if it doesn't already exist
            if (!this.texture) {
                this.texture = gl.createTexture();
            }
            // bind texture
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            // invert y if specified
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.invertY);
            // premultiply alpha if specified
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.preMultiplyAlpha);
            // cast array arg
            if (Array.isArray(data)) {
                if (this.type === 'UNSIGNED_SHORT') {
                    data = new Uint16Array(data);
                } else if (this.type === 'UNSIGNED_INT') {
                    data = new Uint32Array(data);
                } else if (this.type === 'FLOAT') {
                    data = new Float32Array(data);
                } else {
                    data = new Uint8Array(data);
                }
            }
            // set ensure type corresponds to data
            if (data instanceof Uint8Array) {
                this.type = 'UNSIGNED_BYTE';
            } else if (data instanceof Uint16Array) {
                this.type = 'UNSIGNED_SHORT';
            } else if (data instanceof Uint32Array) {
                this.type = 'UNSIGNED_INT';
            } else if (data instanceof Float32Array) {
                this.type = 'FLOAT';
            } else if (data && !(data instanceof ArrayBuffer) && !Util.isCanvasType(data)) {
                throw 'Argument must be of type `Array`, `ArrayBuffer`, ' +
                    '`ArrayBufferView`, `ImageData`, `HTMLImageElement`, ' +
                    '`HTMLCanvasElement`, `HTMLVideoElement`, or null';
            }
            if (Util.isCanvasType(data)) {
                // store width and height
                this.width = data.width;
                this.height = data.height;
                // buffer the texture
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0, // mip-map level,
                    gl[this.format], // webgl requires format === internalFormat
                    gl[this.format],
                    gl[this.type],
                    data);
            } else {
                // store width and height
                this.width = width || this.width;
                this.height = height || this.height;
                // buffer the texture data
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0, // mip-map level
                    gl[this.format], // webgl requires format === internalFormat
                    this.width,
                    this.height,
                    0, // border, must be 0
                    gl[this.format],
                    gl[this.type],
                    data);
            }
            // generate mip maps
            if (this.mipMap) {
                gl.generateMipmap(gl.TEXTURE_2D);
            }
            // unbind texture
            gl.bindTexture(gl.TEXTURE_2D, null);
            return this;
        }

        /**
         * Set the texture parameters.
         *
         * @param {Object} params - The parameters by name.
         * @param {String} params.wrap - The wrapping type over both S and T dimension.
         * @param {String} params.wrapS - The wrapping type over the S dimension.
         * @param {String} params.wrapT - The wrapping type over the T dimension.
         * @param {String} params.filter - The min / mag filter used during scaling.
         * @param {String} params.minFilter - The minification filter used during scaling.
         * @param {String} params.magFilter - The magnification filter used during scaling.
         *
         * @return {Texture2D} The texture object, for chaining.
         */
        setParameters(params) {
            let gl = this.gl;
            // bind texture
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            // set wrap S parameter
            let param = params.wrapS || params.wrap;
            if (param) {
                if (WRAP_MODES[param]) {
                    this.wrapS = param;
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl[this.wrapS]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_WRAP_S\``;
                }
            }
            // set wrap T parameter
            param = params.wrapT || params.wrap;
            if (param) {
                if (WRAP_MODES[param]) {
                    this.wrapT = param;
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl[this.wrapT]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_WRAP_T\``;
                }
            }
            // set mag filter parameter
            param = params.magFilter || params.filter;
            if (param) {
                if (MAG_FILTERS[param]) {
                    this.magFilter = param;
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl[this.magFilter]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for 'TEXTURE_MAG_FILTER\``;
                }
            }
            // set min filter parameter
            param = params.minFilter || params.filter;
            if (param) {
                if (this.mipMap) {
                    if (NON_MIPMAP_MIN_FILTERS[param]) {
                        // upgrade to mip-map min filter
                        param += DEFAULT_MIPMAP_MIN_FILTER_SUFFIX;
                    }
                    if (MIPMAP_MIN_FILTERS[param]) {
                        this.minFilter = param;
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl[this.minFilter]);
                    } else  {
                        throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_MIN_FILTER\``;
                    }
                } else {
                    if (MIN_FILTERS[param]) {
                        this.minFilter = param;
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl[this.minFilter]);
                    } else {
                        throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_MIN_FILTER\``;
                    }
                }
            }
            // unbind texture
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            return this;
        }

        /**
         * Resize the underlying texture. This clears the texture data.
         *
         * @param {Number} width - The new width of the texture.
         * @param {Number} height - The new height of the texture.
         *
         * @return {Texture2D} The texture object, for chaining.
         */
        resize(width, height) {
            if (typeof width !== 'number' || (width <= 0)) {
                throw `Provided width of \`${width}\` is invalid`;
            }
            if (typeof height !== 'number' || (height <= 0)) {
                throw `Provided height of \`${height}\` is invalid`;
            }
            this.bufferData(null, width, height);
            return this;
        }
    }

    module.exports = Texture2D;

}());

},{"../util/Util":27,"./WebGLContext":23}],19:[function(require,module,exports){
(function () {

    'use strict';

    let WebGLContext = require('./WebGLContext');
    let Async = require('../util/Async');
    let Util = require('../util/Util');
    let ImageLoader = require('../util/ImageLoader');

    let FACES = [
        '-x', '+x',
        '-y', '+y',
        '-z', '+z'
    ];
    let FACE_TARGETS = {
        '+z': 'TEXTURE_CUBE_MAP_POSITIVE_Z',
        '-z': 'TEXTURE_CUBE_MAP_NEGATIVE_Z',
        '+x': 'TEXTURE_CUBE_MAP_POSITIVE_X',
        '-x': 'TEXTURE_CUBE_MAP_NEGATIVE_X',
        '+y': 'TEXTURE_CUBE_MAP_POSITIVE_Y',
        '-y': 'TEXTURE_CUBE_MAP_NEGATIVE_Y'
    };
    let TARGETS = {
        TEXTURE_CUBE_MAP_POSITIVE_Z: true,
        TEXTURE_CUBE_MAP_NEGATIVE_Z: true,
        TEXTURE_CUBE_MAP_POSITIVE_X: true,
        TEXTURE_CUBE_MAP_NEGATIVE_X: true,
        TEXTURE_CUBE_MAP_POSITIVE_Y: true,
        TEXTURE_CUBE_MAP_NEGATIVE_Y: true
    };
    let MAG_FILTERS = {
        NEAREST: true,
        LINEAR: true
    };
    let MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true,
        NEAREST_MIPMAP_NEAREST: true,
        LINEAR_MIPMAP_NEAREST: true,
        NEAREST_MIPMAP_LINEAR: true,
        LINEAR_MIPMAP_LINEAR: true
    };
    let NON_MIPMAP_MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true,
    };
    let MIPMAP_MIN_FILTERS = {
        NEAREST_MIPMAP_NEAREST: true,
        LINEAR_MIPMAP_NEAREST: true,
        NEAREST_MIPMAP_LINEAR: true,
        LINEAR_MIPMAP_LINEAR: true
    };
    let WRAP_MODES = {
        REPEAT: true,
        MIRRORED_REPEAT: true,
        CLAMP_TO_EDGE: true
    };
    let FORMATS = {
        RGB: true,
        RGBA: true
    };

    /**
     * The default type for textures.
     */
    let DEFAULT_TYPE = 'UNSIGNED_BYTE';

    /**
     * The default format for textures.
     */
    let DEFAULT_FORMAT = 'RGBA';

    /**
     * The default wrap mode for textures.
     */
    let DEFAULT_WRAP = 'CLAMP_TO_EDGE';

    /**
     * The default min / mag filter for textures.
     */
    let DEFAULT_FILTER = 'LINEAR';

    /**
     * The default for whether alpha premultiplying is enabled.
     */
    let DEFAULT_PREMULTIPLY_ALPHA = true;

    /**
     * The default for whether mipmapping is enabled.
     */
    let DEFAULT_MIPMAP = true;

    /**
     * The default for whether invert-y is enabled.
     */
    let DEFAULT_INVERT_Y = true;

    /**
     * The default mip-mapping filter suffix.
     */
    let DEFAULT_MIPMAP_MIN_FILTER_SUFFIX = '_MIPMAP_LINEAR';

    /**
     * Checks the width and height of the cubemap and throws an exception if
     * it does not meet requirements.
     * @private
     *
     * @param {TextureCubeMap} cubeMap - The cube map texture object.
     */
    function checkDimensions(cubeMap) {
        if (typeof cubeMap.width !== 'number' || cubeMap.width <= 0) {
            throw '`width` argument is missing or invalid';
        }
        if (typeof cubeMap.height !== 'number' || cubeMap.height <= 0) {
            throw '`height` argument is missing or invalid';
        }
        if (cubeMap.width !== cubeMap.height) {
            throw 'Provided `width` must be equal to `height`';
        }
        if (Util.mustBePowerOfTwo(cubeMap) && !Util.isPowerOfTwo(cubeMap.width)) {
            throw `Parameters require a power-of-two texture, yet provided size of ${cubeMap.width} is not a power of two`;
        }
    }

    /**
     * Returns a function to load a face from a url.
     * @private
     *
     * @param {TextureCubeMap} cubeMap - The cube map texture object.
     * @param {String} target - The texture target.
     * @param {String} url - The url to load the face from.
     *
     * @return {Function} The loader function.
     */
    function loadFaceURL(cubeMap, target, url) {
        return function(done) {
            // TODO: put extension handling for arraybuffer / image / video differentiation
            ImageLoader.load({
                url: url,
                success: image => {
                    image = Util.resizeCanvas(cubeMap, image);
                    cubeMap.bufferData(target, image);
                    done(null);
                },
                error: err => {
                    done(err, null);
                }
            });
        };
    }

    /**
     * Returns a function to load a face from a canvas type object.
     * @private
     *
     * @param {TextureCubeMap} cubeMap - The cube map texture object.
     * @param {String} target - The texture target.
     * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} canvas - The canvas type object.
     *
     * @return {Function} - The loader function.
     */
    function loadFaceCanvas(cubeMap, target, canvas) {
        return function(done) {
            canvas = Util.resizeCanvas(cubeMap, canvas);
            cubeMap.bufferData(target, canvas);
            done(null);
        };
    }

    /**
     * Returns a function to load a face from an array type object.
     * @private
     *
     * @param {TextureCubeMap} cubeMap - The cube map texture object.
     * @param {String} target - The texture target.
     * @param {Array|ArrayBuffer|ArrayBufferView} arr - The array type object.
     *
     * @return {Function} The loader function.
     */
    function loadFaceArray(cubeMap, target, arr) {
        checkDimensions(cubeMap);
        return function(done) {
            cubeMap.bufferData(target, arr);
            done(null);
        };
    }

    /**
     * @class TextureCubeMap
     * @classdesc A texture class to represent a cube map texture.
     */
    class TextureCubeMap {

        /**
         * Instantiates a TextureCubeMap object.
         *
         * @param {Object} spec - The specification arguments
         * @param {Object} spec.faces - The faces to buffer, under keys '+x', '+y', '+z', '-x', '-y', and '-z'.
         * @param {Number} spec.width - The width of the faces.
         * @param {Number} spec.height - The height of the faces.
         * @param {String} spec.wrap - The wrapping type over both S and T dimension.
         * @param {String} spec.wrapS - The wrapping type over the S dimension.
         * @param {String} spec.wrapT - The wrapping type over the T dimension.
         * @param {String} spec.filter - The min / mag filter used during scaling.
         * @param {String} spec.minFilter - The minification filter used during scaling.
         * @param {String} spec.magFilter - The magnification filter used during scaling.
         * @param {bool} spec.mipMap - Whether or not mip-mapping is enabled.
         * @param {bool} spec.invertY - Whether or not invert-y is enabled.
         * @param {bool} spec.preMultiplyAlpha - Whether or not alpha premultiplying is enabled.
         * @param {String} spec.format - The texture pixel format.
         * @param {String} spec.type - The texture pixel component type.
         */
        constructor(spec = {}, callback = null) {
            this.gl = WebGLContext.get();
            this.texture = null;
            // get specific params
            spec.wrapS = spec.wrapS || spec.wrap;
            spec.wrapT = spec.wrapT || spec.wrap;
            spec.minFilter = spec.minFilter || spec.filter;
            spec.magFilter = spec.magFilter || spec.filter;
            // set texture params
            this.wrapS = WRAP_MODES[spec.wrapS] ? spec.wrapS : DEFAULT_WRAP;
            this.wrapT = WRAP_MODES[spec.wrapT] ? spec.wrapT : DEFAULT_WRAP;
            this.minFilter = MIN_FILTERS[spec.minFilter] ? spec.minFilter : DEFAULT_FILTER;
            this.magFilter = MAG_FILTERS[spec.magFilter] ? spec.magFilter : DEFAULT_FILTER;
            // set other properties
            this.mipMap = spec.mipMap !== undefined ? spec.mipMap : DEFAULT_MIPMAP;
            this.invertY = spec.invertY !== undefined ? spec.invertY : DEFAULT_INVERT_Y;
            this.preMultiplyAlpha = spec.preMultiplyAlpha !== undefined ? spec.preMultiplyAlpha : DEFAULT_PREMULTIPLY_ALPHA;
            // set format and type
            this.format = FORMATS[spec.format] ? spec.format : DEFAULT_FORMAT;
            this.type = spec.type || DEFAULT_TYPE;
            if (this.type === 'FLOAT' && !WebGLContext.checkExtension('OES_texture_float')) {
                throw 'Cannot create Texture2D of type `FLOAT` as `OES_texture_float` extension is unsupported';
            }
            // set dimensions if provided
            this.width = spec.width;
            this.height = spec.height;
            // set buffered faces
            this.bufferedFaces = [];
            // create cube map based on input
            if (spec.faces) {
                let tasks = [];
                FACES.forEach(id => {
                    let face = spec.faces[id];
                    let target = FACE_TARGETS[id];
                    // load based on type
                    if (typeof face === 'string') {
                        // url
                        tasks.push(loadFaceURL(this, target, face));
                    } else if (Util.isCanvasType(face)) {
                        // canvas
                        tasks.push(loadFaceCanvas(this, target, face));
                    } else {
                        // array / arraybuffer or null
                        tasks.push(loadFaceArray(this, target, face));
                    }
                });
                Async.parallel(tasks, err => {
                    if (err) {
                        if (callback) {
                            setTimeout(() => {
                                callback(err, null);
                            });
                        }
                        return;
                    }
                    // set parameters
                    this.setParameters(this);
                    if (callback) {
                        setTimeout(() => {
                            callback(null, this);
                        });
                    }
                });
            } else {
                // null
                checkDimensions(this);
                FACES.forEach(id => {
                    this.bufferData(FACE_TARGETS[id], null);
                });
                // set parameters
                this.setParameters(this);
            }
        }

        /**
         * Binds the texture object to the provided texture unit location.
         *
         * @param {Number} location - The texture unit location index. Defaults to 0.
         *
         * @return {TextureCubeMap} The texture object, for chaining.
         */
        bind(location = 0) {
            if (!Number.isInteger(location) || location < 0) {
                throw 'Texture unit location is invalid';
            }
            // bind cube map texture
            let gl = this.gl;
            gl.activeTexture(gl['TEXTURE' + location]);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
            return this;
        }

        /**
         * Unbinds the texture object.
         *
         * @return {TextureCubeMap} - The texture object, for chaining.
         */
        unbind() {
            // unbind cube map texture
            let gl = this.gl;
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            return this;
        }

        /**
         * Buffer data into the respective cube map face.
         *
         * @param {String} target - The face target.
         * @param {Object|null} data - The face data.
         *
         * @return {TextureCubeMap} The texture object, for chaining.
         */
        bufferData(target, data) {
            if (!TARGETS[target]) {
                throw `Provided \`target\` of ${target}  is invalid`;
            }
            let gl = this.gl;
            // create texture object if it doesn't already exist
            if (!this.texture) {
                this.texture = gl.createTexture();
            }
            // bind texture
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
            // invert y if specified
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.invertY);
            // premultiply alpha if specified
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.preMultiplyAlpha);
            // cast array arg
            if (Array.isArray(data)) {
                if (this.type === 'UNSIGNED_SHORT') {
                    data = new Uint16Array(data);
                } else if (this.type === 'UNSIGNED_INT') {
                    data = new Uint32Array(data);
                } else if (this.type === 'FLOAT') {
                    data = new Float32Array(data);
                } else {
                    data = new Uint8Array(data);
                }
            }
            // set ensure type corresponds to data
            if (data instanceof Uint8Array) {
                this.type = 'UNSIGNED_BYTE';
            } else if (data instanceof Uint16Array) {
                this.type = 'UNSIGNED_SHORT';
            } else if (data instanceof Uint32Array) {
                this.type = 'UNSIGNED_INT';
            } else if (data instanceof Float32Array) {
                this.type = 'FLOAT';
            } else if (data && !(data instanceof ArrayBuffer) && !Util.isCanvasType(data)) {
                throw 'Argument must be of type `Array`, `ArrayBuffer`, ' +
                    '`ArrayBufferView`, `ImageData`, `HTMLImageElement`, ' +
                    '`HTMLCanvasElement`, `HTMLVideoElement`, or null';
            }
            // buffer the data
            if (Util.isCanvasType(data)) {
                // store width and height
                this.width = data.width;
                this.height = data.height;
                // buffer the texture
                gl.texImage2D(
                    gl[target],
                    0, // mip-map level,
                    gl[this.format], // webgl requires format === internalFormat
                    gl[this.format],
                    gl[this.type],
                    data);
            } else {
                // buffer the texture data
                gl.texImage2D(
                    gl[target],
                    0, // mip-map level
                    gl[this.format], // webgl requires format === internalFormat
                    this.width,
                    this.height,
                    0, // border, must be 0
                    gl[this.format],
                    gl[this.type],
                    data);
            }
            // track the face that was buffered
            if (this.bufferedFaces.indexOf(target) < 0) {
                this.bufferedFaces.push(target);
            }
            // if all faces buffered, generate mipmaps
            if (this.mipMap && this.bufferedFaces.length === 6) {
                // only generate mipmaps if all faces are buffered
                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
            }
            // unbind texture
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            return this;
        }

        /**
         * Set the texture parameters.
         *
         * @param {Object} params - The parameters by name.
         * @param {String} params.wrap - The wrapping type over both S and T dimension.
         * @param {String} params.wrapS - The wrapping type over the S dimension.
         * @param {String} params.wrapT - The wrapping type over the T dimension.
         * @param {String} params.filter - The min / mag filter used during scaling.
         * @param {String} params.minFilter - The minification filter used during scaling.
         * @param {String} params.magFilter - The magnification filter used during scaling.
         *
         * @return {TextureCubeMap} The texture object, for chaining.
         */
        setParameters(params) {
            let gl = this.gl;
            // bind texture
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
            // set wrap S parameter
            let param = params.wrapS || params.wrap;
            if (param) {
                if (WRAP_MODES[param]) {
                    this.wrapS = param;
                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl[this.wrapS]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_WRAP_S\``;
                }
            }
            // set wrap T parameter
            param = params.wrapT || params.wrap;
            if (param) {
                if (WRAP_MODES[param]) {
                    this.wrapT = param;
                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl[this.wrapT]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_WRAP_T\``;
                }
            }
            // set mag filter parameter
            param = params.magFilter || params.filter;
            if (param) {
                if (MAG_FILTERS[param]) {
                    this.magFilter = param;
                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl[this.magFilter]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for 'TEXTURE_MAG_FILTER\``;
                }
            }
            // set min filter parameter
            param = params.minFilter || params.filter;
            if (param) {
                if (this.mipMap) {
                    if (NON_MIPMAP_MIN_FILTERS[param]) {
                        // upgrade to mip-map min filter
                        param += DEFAULT_MIPMAP_MIN_FILTER_SUFFIX;
                    }
                    if (MIPMAP_MIN_FILTERS[param]) {
                        this.minFilter = param;
                        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl[this.minFilter]);
                    } else  {
                        throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_MIN_FILTER\``;
                    }
                } else {
                    if (MIN_FILTERS[param]) {
                        this.minFilter = param;
                        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl[this.minFilter]);
                    } else {
                        throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_MIN_FILTER\``;
                    }
                }
            }
            // unbind texture
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            return this;
        }
    }

    module.exports = TextureCubeMap;

}());

},{"../util/Async":25,"../util/ImageLoader":26,"../util/Util":27,"./WebGLContext":23}],20:[function(require,module,exports){
(function () {

    'use strict';

    let WebGLContext = require('./WebGLContext');
    let VertexPackage = require('./VertexPackage');

    let MODES = {
        POINTS: true,
        LINES: true,
        LINE_STRIP: true,
        LINE_LOOP: true,
        TRIANGLES: true,
        TRIANGLE_STRIP: true,
        TRIANGLE_FAN: true
    };
    let TYPES = {
        BYTE: true,
        UNSIGNED_BYTE: true,
        SHORT: true,
        UNSIGNED_SHORT: true,
        FIXED: true,
        FLOAT: true
    };
    let BYTES_PER_TYPE = {
        BYTE: 1,
        UNSIGNED_BYTE: 1,
        SHORT: 2,
        UNSIGNED_SHORT: 2,
        FIXED: 4,
        FLOAT: 4
    };
    let SIZES = {
        1: true,
        2: true,
        3: true,
        4: true
    };

    /**
     * The default attribute point byte offset.
     */
    let DEFAULT_BYTE_OFFSET = 0;

    /**
     * The default render mode (primitive type).
     */
    let DEFAULT_MODE = 'TRIANGLES';

    /**
     * The default index offset to render from.
     */
    let DEFAULT_INDEX_OFFSET = 0;

    /**
     * The default count of indices to render.
     */
    let DEFAULT_COUNT = 0;

    /**
     * Parse the attribute pointers and determine the byte stride of the buffer.
     * @private
     *
     * @param {Object} attributePointers - The attribute pointer map.
     *
     * @return {Number} The byte stride of the buffer.
     */
    function getStride(attributePointers) {
        // if there is only one attribute pointer assigned to this buffer,
        // there is no need for stride, set to default of 0
        let indices = Object.keys(attributePointers);
        if (indices.length === 1) {
            return 0;
        }
        let maxByteOffset = 0;
        let byteSizeSum = 0;
        let byteStride = 0;
        indices.forEach(index => {
            let pointer = attributePointers[index];
            let byteOffset = pointer.byteOffset;
            let size = pointer.size;
            let type = pointer.type;
            // track the sum of each attribute size
            byteSizeSum += size * BYTES_PER_TYPE[type];
            // track the largest offset to determine the byte stride of the buffer
            if (byteOffset > maxByteOffset) {
                maxByteOffset = byteOffset;
                byteStride = byteOffset + (size * BYTES_PER_TYPE[type]);
            }
        });
        // check if the max byte offset is greater than or equal to the the sum of
        // the sizes. If so this buffer is not interleaved and does not need a
        // stride.
        if (maxByteOffset >= byteSizeSum) {
            // TODO: test what stride === 0 does for an interleaved buffer of
            // length === 1.
            return 0;
        }
        return byteStride;
    }

    /**
     * Parse the attribute pointers to ensure they are valid.
     * @private
     *
     * @param {Object} attributePointers - The attribute pointer map.
     *
     * @return {Object} The validated attribute pointer map.
     */
    function getAttributePointers(attributePointers) {
        // parse pointers to ensure they are valid
        let pointers = {};
        Object.keys(attributePointers).forEach(key => {
            let index = parseInt(key, 10);
            // check that key is an valid integer
            if (isNaN(index)) {
                throw `Attribute index \`${key}\` does not represent an integer`;
            }
            let pointer = attributePointers[key];
            let size = pointer.size;
            let type = pointer.type;
            let byteOffset = pointer.byteOffset;
            // check size
            if (!SIZES[size]) {
                throw 'Attribute pointer `size` parameter is invalid, must be one of ' +
                    JSON.stringify(Object.keys(SIZES));
            }
            // check type
            if (!TYPES[type]) {
                throw 'Attribute pointer `type` parameter is invalid, must be one of ' +
                    JSON.stringify(Object.keys(TYPES));
            }
            pointers[index] = {
                size: size,
                type: type,
                byteOffset: (byteOffset !== undefined) ? byteOffset : DEFAULT_BYTE_OFFSET
            };
        });
        return pointers;
    }

    /**
     * @class VertexBuffer
     * @classdesc A vertex buffer object.
     */
    class VertexBuffer {

        /**
         * Instantiates an VertexBuffer object.
         *
         * @param {WebGLBuffer|VertexPackage|Float32Array|Array|Number} arg - The buffer or length of the buffer.
         * @param {Object} attributePointers - The array pointer map, or in the case of a vertex package arg, the options.
         * @param {Object} options - The rendering options.
         * @param {String} options.mode - The draw mode / primitive type.
         * @param {String} options.indexOffset - The index offset into the drawn buffer.
         * @param {String} options.count - The number of indices to draw.
         */
        constructor(arg, attributePointers = {}, options = {}) {
            this.gl = WebGLContext.get();
            this.buffer = null;
            this.mode = MODES[options.mode] ? options.mode : DEFAULT_MODE;
            this.count = (options.count !== undefined) ? options.count : DEFAULT_COUNT;
            this.indexOffset = (options.indexOffset !== undefined) ? options.indexOffset : DEFAULT_INDEX_OFFSET;
            this.byteLength = 0;
            // first, set the attribute pointers
            if (arg && arg.buffer && arg.pointers) {
                // VertexPackage argument, use its attribute pointers
                this.pointers = arg.pointers;
                // shift options arg since there will be no attrib pointers arg
                options = attributePointers;
            } else {
                this.pointers = getAttributePointers(attributePointers);
            }
            // set the byte stride
            this.byteStride = getStride(this.pointers);
            // then buffer the data
            if (arg) {
                if (arg instanceof VertexPackage) {
                    // VertexPackage argument
                    this.bufferData(arg.buffer);
                } else if (arg instanceof WebGLBuffer) {
                    // WebGLBuffer argument
                    if (options.byteLength === undefined) {
                        throw 'Argument of type `WebGLBuffer` must be complimented with a corresponding `options.byteLength`';
                    }
                    this.buffer = arg;
                    this.byteLength = options.byteLength;
                } else {
                    // Array or ArrayBuffer or number argument
                    this.bufferData(arg);
                }
            }
        }

        /**
         * Upload vertex data to the GPU.
         *
         * @param {Array|ArrayBuffer|ArrayBufferView|number} arg - The array of data to buffer, or size of the buffer in bytes.
         *
         * @return {VertexBuffer} The vertex buffer object, for chaining.
         */
        bufferData(arg) {
            let gl = this.gl;
            // ensure argument is valid
            if (Array.isArray(arg)) {
                // cast array into Float32Array
                arg = new Float32Array(arg);
            } else if (
                !(arg instanceof ArrayBuffer) &&
                !(ArrayBuffer.isView(arg)) &&
                !(Number.isInteger(arg))
                ) {
                // if not arraybuffer or a numeric size
                throw 'Argument must be of type `Array`, `ArrayBuffer`, `ArrayBufferView`, or `Number`';
            }
            // set byte length
            if (Number.isInteger(arg)) {
                this.byteLength = arg;
            } else {
                this.byteLength = arg.byteLength;
            }
            // create buffer if it doesn't exist already
            if (!this.buffer) {
                this.buffer = gl.createBuffer();
            }
            // buffer the data
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.bufferData(gl.ARRAY_BUFFER, arg, gl.STATIC_DRAW);
        }

        /**
         * Upload partial vertex data to the GPU.
         *
         * @param {Array|ArrayBuffer|ArrayBufferView} array - The array of data to buffer.
         * @param {Number} byteOffset - The byte offset at which to buffer.
         *
         * @return {VertexBuffer} The vertex buffer object, for chaining.
         */
        bufferSubData(array, byteOffset = DEFAULT_BYTE_OFFSET) {
            let gl = this.gl;
            // ensure the buffer exists
            if (!this.buffer) {
                throw 'Buffer has not yet been allocated, allocate with ' +
                    '`bufferData`';
            }
            // ensure argument is valid
            if (Array.isArray(array)) {
                array = new Float32Array(array);
            } else if (
                !(array instanceof ArrayBuffer) &&
                !ArrayBuffer.isView(array)
                ) {
                throw 'Argument must be of type `Array`, `ArrayBuffer`, ' +
                    'or `ArrayBufferView`';
            }
            // check that we aren't overflowing the buffer
            if (byteOffset + array.byteLength > this.byteLength) {
                throw `Argument of length ${array.byteLength} bytes with ` +
                    `offset of ${byteOffset} bytes overflows the buffer ` +
                    `length of ${this.byteLength} bytes`;
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, byteOffset, array);
            return this;
        }

        /**
         * Binds the vertex buffer object.
         *
         * @return {VertexBuffer} - Returns the vertex buffer object for chaining.
         */
        bind() {
            let gl = this.gl;
            // bind buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            // for each attribute pointer
            Object.keys(this.pointers).forEach(index => {
                let pointer = this.pointers[index];
                // set attribute pointer
                gl.vertexAttribPointer(
                    index,
                    pointer.size,
                    gl[pointer.type],
                    false,
                    this.byteStride,
                    pointer.byteOffset);
                // enable attribute index
                gl.enableVertexAttribArray(index);
            });
            return this;
        }

        /**
         * Unbinds the vertex buffer object.
         *
         * @return {VertexBuffer} The vertex buffer object, for chaining.
         */
        unbind() {
            let gl = this.gl;
            // unbind buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            Object.keys(this.pointers).forEach(index => {
                // disable attribute index
                gl.disableVertexAttribArray(index);
            });
            return this;
        }

        /**
         * Execute the draw command for the bound buffer.
         *
         * @param {Object} options - The options to pass to 'drawArrays'. Optional.
         * @param {String} options.mode - The draw mode / primitive type.
         * @param {String} options.indexOffset - The index offset into the drawn buffer.
         * @param {String} options.count - The number of indices to draw.
         *
         * @return {VertexBuffer} The vertex buffer object, for chaining.
         */
        draw(options = {}) {
            let gl = this.gl;
            let mode = gl[options.mode || this.mode];
            let indexOffset = (options.indexOffset !== undefined) ? options.indexOffset : this.indexOffset;
            let count = (options.count !== undefined) ? options.count : this.count;
            if (count === 0) {
                throw 'Attempting to draw with a count of 0';
            }
            // draw elements
            gl.drawArrays(mode, indexOffset, count);
            return this;
        }
    }

    module.exports = VertexBuffer;

}());

},{"./VertexPackage":21,"./WebGLContext":23}],21:[function(require,module,exports){
(function () {

    'use strict';

    let COMPONENT_TYPE = 'FLOAT';
    let BYTES_PER_COMPONENT = 4;

    /**
     * Removes invalid attribute arguments. A valid argument must be an Array of length > 0 key by a string representing an int.
     * @private
     *
     * @param {Object} attributes - The map of vertex attributes.
     *
     * @return {Array} The valid array of arguments.
     */
    function parseAttributeMap(attributes) {
        let goodAttributes = [];
        Object.keys(attributes).forEach(key => {
            let index = parseFloat(key);
            // check that key is an valid integer
            if (!Number.isInteger(index) || index < 0) {
                throw `Attribute index \`${key}\` does not represent a valid integer`;
            }
            let vertices = attributes[key];
            // ensure attribute is valid
            if (Array.isArray(vertices) && vertices.length > 0) {
                // add attribute data and index
                goodAttributes.push({
                    index: index,
                    data: vertices
                });
            } else {
                throw `Error parsing attribute of index \`${index}\``;
            }
        });
        // sort attributes ascending by index
        goodAttributes.sort((a, b) => {
            return a.index - b.index;
        });
        return goodAttributes;
    }

    /**
     * Returns a component's byte size.
     * @private
     *
     * @param {Object|Array} component - The component to measure.
     *
     * @return {Number} The byte size of the component.
     */
    function getComponentSize(component) {
        // check if array
        if (Array.isArray(component)) {
            return component.length;
        }
        // check if vector
        if (component.x !== undefined) {
            // 1 component vector
            if (component.y !== undefined) {
                // 2 component vector
                if (component.z !== undefined) {
                    // 3 component vector
                    if (component.w !== undefined) {
                        // 4 component vector
                        return 4;
                    }
                    return 3;
                }
                return 2;
            }
            return 1;
        }
        // single component
        return 1;
    }

    /**
     * Calculates the type, size, and offset for each attribute in the attribute array along with the length and stride of the package.
     * @private
     *
     * @param {VertexPackage} vertexPackage - The VertexPackage object.
     * @param {Array} attributes The array of vertex attributes.
     */
    function setPointersAndStride(vertexPackage, attributes) {
        let shortestArray = Number.MAX_VALUE;
        let offset = 0;
        // clear pointers
        vertexPackage.pointers = {};
        // for each attribute
        attributes.forEach(vertices => {
            // set size to number of components in the attribute
            let size = getComponentSize(vertices.data[0]);
            // length of the package will be the shortest attribute array length
            shortestArray = Math.min(shortestArray, vertices.data.length);
            // store pointer under index
            vertexPackage.pointers[vertices.index] = {
                type: COMPONENT_TYPE,
                size: size,
                byteOffset: offset * BYTES_PER_COMPONENT
            };
            // accumulate attribute offset
            offset += size;
        });
        // set stride to total offset
        vertexPackage.stride = offset; // not in bytes
        // set length of package to the shortest attribute array length
        vertexPackage.length = shortestArray;
    }

    /**
     * Fill the arraybuffer with a single component attribute.
     * @private
     *
     * @param {Float32Array} buffer - The arraybuffer to fill.
     * @param {Array} vertices - The vertex attribute array to copy from.
     * @param {Number} length - The length of the buffer to copy from.
     * @param {Number} offset - The offset to the attribute, not in bytes.
     * @param {Number} stride - The stride of the buffer, not in bytes.
     */
    function set1ComponentAttr(buffer, vertices, length, offset, stride) {
        let vertex, i, j;
        for (i=0; i<length; i++) {
            vertex = vertices[i];
            // get the index in the buffer to the particular vertex
            j = offset + (stride * i);
            if (vertex.x !== undefined) {
                buffer[j] = vertex.x;
            } else if (vertex[0] !== undefined) {
                buffer[j] = vertex[0];
            } else {
                buffer[j] = vertex;
            }
        }
    }

    /**
     * Fill the arraybuffer with a double component attribute.
     * @private
     *
     * @param {Float32Array} buffer - The arraybuffer to fill.
     * @param {Array} vertices - The vertex attribute array to copy from.
     * @param {Number} length - The length of the buffer to copy from.
     * @param {Number} offset - The offset to the attribute, not in bytes.
     * @param {Number} stride - The stride of the buffer, not in bytes.
     */
    function set2ComponentAttr(buffer, vertices, length, offset, stride) {
        let vertex, i, j;
        for (i=0; i<length; i++) {
            vertex = vertices[i];
            // get the index in the buffer to the particular vertex
            j = offset + (stride * i);
            buffer[j] = (vertex.x !== undefined) ? vertex.x : vertex[0];
            buffer[j+1] = (vertex.y !== undefined) ? vertex.y : vertex[1];
        }
    }

    /**
     * Fill the arraybuffer with a triple component attribute.
     * @private
     *
     * @param {Float32Array} buffer - The arraybuffer to fill.
     * @param {Array} vertices - The vertex attribute array to copy from.
     * @param {Number} length - The length of the buffer to copy from.
     * @param {Number} offset - The offset to the attribute, not in bytes.
     * @param {Number} stride - The stride of the buffer, not in bytes.
     */
    function set3ComponentAttr(buffer, vertices, length, offset, stride) {
        let vertex, i, j;
        for (i=0; i<length; i++) {
            vertex = vertices[i];
            // get the index in the buffer to the particular vertex
            j = offset + (stride * i);
            buffer[j] = (vertex.x !== undefined) ? vertex.x : vertex[0];
            buffer[j+1] = (vertex.y !== undefined) ? vertex.y : vertex[1];
            buffer[j+2] = (vertex.z !== undefined) ? vertex.z : vertex[2];
        }
    }

    /**
     * Fill the arraybuffer with a quadruple component attribute.
     * @private
     *
     * @param {Float32Array} buffer - The arraybuffer to fill.
     * @param {Array} vertices - The vertex attribute array to copy from.
     * @param {Number} length - The length of the buffer to copy from.
     * @param {Number} offset - The offset to the attribute, not in bytes.
     * @param {Number} stride - The stride of the buffer, not in bytes.
     */
    function set4ComponentAttr(buffer, vertices, length, offset, stride) {
        let vertex, i, j;
        for (i=0; i<length; i++) {
            vertex = vertices[i];
            // get the index in the buffer to the particular vertex
            j = offset + (stride * i);
            buffer[j] = (vertex.x !== undefined) ? vertex.x : vertex[0];
            buffer[j+1] = (vertex.y !== undefined) ? vertex.y : vertex[1];
            buffer[j+2] = (vertex.z !== undefined) ? vertex.z : vertex[2];
            buffer[j+3] = (vertex.w !== undefined) ? vertex.w : vertex[3];
        }
    }

    /**
     * @class VertexPackage
     * @classdesc A vertex package to assist in interleaving vertex data and building the associated vertex attribute pointers.
     */
    class VertexPackage {

        /**
         * Instantiates a VertexPackage object.
          *
         * @param {Object} attributes - The attributes to interleave keyed by index.
         */
        constructor(attributes) {
            if (attributes !== undefined) {
                this.set(attributes);
            } else {
                this.buffer = new Float32Array(0);
                this.pointers = {};
            }
        }

        /**
         * Set the data to be interleaved inside the package. This clears any previously existing data.
         *
         * @param {Object} attributes - The attributes to interleaved, keyed by index.
         *
         * @return {VertexPackage} The vertex package object, for chaining.
         */
        set(attributes) {
            // remove bad attributes
            attributes = parseAttributeMap(attributes);
            // set attribute pointers and stride
            setPointersAndStride(this, attributes);
            // set size of data vector
            let length = this.length;
            let stride = this.stride; // not in bytes
            let pointers = this.pointers;
            let buffer = this.buffer = new Float32Array(length * stride);
            // for each vertex attribute array
            attributes.forEach(vertices => {
                // get the pointer
                let pointer = pointers[vertices.index];
                // get the pointers offset
                let offset = pointer.byteOffset / BYTES_PER_COMPONENT;
                // copy vertex data into arraybuffer
                switch (pointer.size) {
                    case 2:
                        set2ComponentAttr(buffer, vertices.data, length, offset, stride);
                        break;
                    case 3:
                        set3ComponentAttr(buffer, vertices.data, length, offset, stride);
                        break;
                    case 4:
                        set4ComponentAttr(buffer, vertices.data, length, offset, stride);
                        break;
                    default:
                        set1ComponentAttr(buffer, vertices.data, length, offset, stride);
                        break;
                }
            });
            return this;
        }
    }

    module.exports = VertexPackage;

}());

},{}],22:[function(require,module,exports){
(function() {

    'use strict';

    let WebGLContext = require('./WebGLContext');

    /**
     * Bind the viewport to the rendering context.
     *
     * @param {Viewport} viewport - The viewport object.
     * @param {Number} width - The width override.
     * @param {Number} height - The height override.
     * @param {Number} x - The horizontal offset override.
     * @param {Number} y - The vertical offset override.
     */
    function set(viewport, x, y, width, height) {
        let gl = viewport.gl;
        x = (x !== undefined) ? x : viewport.x;
        y = (y !== undefined) ? y : viewport.y;
        width = (width !== undefined) ? width : viewport.width;
        height = (height !== undefined) ? height : viewport.height;
        gl.viewport(x, y, width, height);
    }

    /**
     * @class Viewport
     * @classdesc A viewport class for managing WebGL viewports.
     */
    class Viewport {

        /**
         * Instantiates a Viewport object.
         *
         * @param {Object} spec - The viewport specification object.
         * @param {Number} spec.width - The width of the viewport.
         * @param {Number} spec.height - The height of the viewport.
         */
        constructor(spec = {}) {
            this.gl = WebGLContext.get();
            this.stack = [];
            // set size
            this.resize(
                spec.width || this.gl.canvas.width,
                spec.height || this.gl.canvas.height);
        }

        /**
         * Updates the viewports width and height. This resizes the underlying canvas element.
         *
         * @param {Number} width - The width of the viewport.
         * @param {Number} height - The height of the viewport.
         *
         * @return {Viewport} The viewport object, for chaining.
         */
        resize(width = 0, height = 0) {
            if (typeof width !== 'number' || width <= 0) {
                throw `Provided \`width\` of \`${width}\` is invalid`;
            }
            if (typeof height !== 'number' || height <= 0) {
                throw `Provided \`height\` of \`${height}\` is invalid`;
            }
            this.width = width;
            this.height = height;
            this.gl.canvas.width = width;
            this.gl.canvas.height = height;
            return this;
        }

        /**
         * Sets the viewport dimensions and position. The underlying canvas element is not affected.
         *
         * @param {Number} width - The width override.
         * @param {Number} height - The height override.
         * @param {Number} x - The horizontal offset override.
         * @param {Number} y - The vertical offset override.
         *
         * @return {Viewport} - The viewport object, for chaining.
         */
        push(x = 0, y = 0, width = this.width, height = this.height) {
            if (typeof x !== 'number') {
                throw `Provided \`x\` of \`${x}\` is invalid`;
            }
            if (typeof y !== 'number') {
                throw `Provided \`y\` of \`${y}\` is invalid`;
            }
            if (typeof width !== 'number' || width <= 0) {
                throw `Provided \`width\` of \`${width}\` is invalid`;
            }
            if (typeof height !== 'number' || height <= 0) {
                throw `Provided \`height\` of \`${height}\` is invalid`;
            }
            // push onto stack
            this.stack.push({
                x: x,
                y: y,
                width: width,
                height: height
            });
            // set viewport
            set(this, x, y, width, height);
            return this;
        }

        /**
         * Pops current the viewport object and sets the viewport beneath it.
         *
         * @return {Viewport} The viewport object, for chaining.
         */
        pop() {
            if (this.stack.length === 0) {
                throw 'Viewport stack is empty';
            }
            this.stack.pop();
            if (this.stack.length > 0) {
                let top = this.stack[this.stack.length - 1];
                set(this, top.x, top.y, top.width, top.height);
            } else {
                set(this);
            }
            return this;
        }
    }

    module.exports = Viewport;

}());

},{"./WebGLContext":23}],23:[function(require,module,exports){
(function() {

    'use strict';

    let EXTENSIONS = [
        // ratified
        'OES_texture_float',
        'OES_texture_half_float',
        'WEBGL_lose_context',
        'OES_standard_derivatives',
        'OES_vertex_array_object',
        'WEBGL_debug_renderer_info',
        'WEBGL_debug_shaders',
        'WEBGL_compressed_texture_s3tc',
        'WEBGL_depth_texture',
        'OES_element_index_uint',
        'EXT_texture_filter_anisotropic',
        'EXT_frag_depth',
        'WEBGL_draw_buffers',
        'ANGLE_instanced_arrays',
        'OES_texture_float_linear',
        'OES_texture_half_float_linear',
        'EXT_blend_minmax',
        'EXT_shader_texture_lod',
        // community
        'WEBGL_compressed_texture_atc',
        'WEBGL_compressed_texture_pvrtc',
        'EXT_color_buffer_half_float',
        'WEBGL_color_buffer_float',
        'EXT_sRGB',
        'WEBGL_compressed_texture_etc1',
        'EXT_disjoint_timer_query',
        'EXT_color_buffer_float'
    ];

    let _boundContext = null;
    let _contexts = {};

    /**
     * Returns an rfc4122 version 4 compliant UUID.
     * @private
     *
     * @return {String} - The UUID string.
     */
    function getUUID() {
        let replace = function(c) {
            let r = Math.random() * 16 | 0;
            let v = (c === 'x') ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        };
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, replace);
    }

    /**
     * Returns the id of the HTMLCanvasElement element. If there is no id, it generates one and appends it.
     * @private
     *
     * @param {HTMLCanvasElement} canvas - The Canvas object.
     *
     * @return {String} The Canvas id string.
     */
    function getId(canvas) {
        if (!canvas.id) {
            canvas.id = getUUID();
        }
        return canvas.id;
    }

    /**
     * Returns a Canvas element object from either an existing object, or identification string.
     * @private
     *
     * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas id or selector string.
     *
     * @return {HTMLCanvasElement} The Canvas element object.
     */
    function getCanvas(arg) {
        if (arg instanceof HTMLCanvasElement) {
            return arg;
        } else if (typeof arg === 'string') {
            return document.getElementById(arg) ||
                document.querySelector(arg);
        }
        return null;
    }

    /**
     * Attempts to retrieve a wrapped WebGLRenderingContext.
     * @private
     *
     * @param {HTMLCanvasElement} The Canvas element object to create the context under.
     *
     * @return {Object} The context wrapper.
     */
    function getContextWrapper(arg) {
        if (arg === undefined) {
            if (_boundContext) {
                // return last bound context
                return _boundContext;
            }
        } else {
            let canvas = getCanvas(arg);
            if (canvas) {
                return _contexts[getId(canvas)];
            }
        }
        // no bound context or argument
        return null;
    }

    /**
     * Attempts to load all known extensions for a provided WebGLRenderingContext. Stores the results in the context wrapper for later queries.
     * @private
     *
     * @param {Object} contextWrapper - The context wrapper.
     */
    function loadExtensions(contextWrapper) {
        let gl = contextWrapper.gl;
        EXTENSIONS.forEach(id => {
            contextWrapper.extensions[id] = gl.getExtension(id);
        });
    }

    /**
     * Attempts to create a WebGLRenderingContext and load all extensions.
     * @private
     *
     * @param {HTMLCanvasElement} - The Canvas element object to create the context under.
     * @param {Object}} options - Parameters to the webgl context, only used during instantiation. Optional.
     *
     * @return {Object} The context wrapper.
     */
    function createContextWrapper(canvas, options) {
        let gl = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);
        // wrap context
        let contextWrapper = {
            id: getId(canvas),
            gl: gl,
            extensions: {}
        };
        // load WebGL extensions
        loadExtensions(contextWrapper);
        // add context wrapper to map
        _contexts[getId(canvas)] = contextWrapper;
        // bind the context
        _boundContext = contextWrapper;
        return contextWrapper;
    }

    module.exports = {

        /**
         * Retrieves an existing WebGL context associated with the provided argument and binds it. While bound, the active context will be used implicitly by any instantiated `esper` constructs.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string.
         *
         * @return {WebGLContext} The namespace, used for chaining.
         */
        bind: function(arg) {
            let wrapper = getContextWrapper(arg);
            if (wrapper) {
                _boundContext = wrapper;
                return this;
            }
            throw `No context exists for provided argument '${arg}'`;
        },

        /**
         * Retrieves an existing WebGL context associated with the provided argument. If no context exists, one is created.
         * During creation attempts to load all extensions found at: https://www.khronos.org/registry/webgl/extensions/.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         * @param {Object} options - Parameters to the webgl context, only used during instantiation. Optional.
         *
         * @return {WebGLRenderingContext} The WebGLRenderingContext object.
         */
        get: function(arg, options) {
            let wrapper = getContextWrapper(arg);
            if (wrapper) {
               // return the native WebGLRenderingContext
               return wrapper.gl;
            }
            // get canvas element
            let canvas = getCanvas(arg);
            // try to find or create context
            if (!canvas) {
                throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
            }
            // create context
            return createContextWrapper(canvas, options).gl;
        },

        /**
         * Removes an existing WebGL context object for the provided or currently bound context object.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         * @param {Object}} options - Parameters to the webgl context, only used during instantiation. Optional.
         *
         * @return {WebGLRenderingContext} The WebGLRenderingContext object.
         */
        remove: function(arg) {
            let wrapper = getContextWrapper(arg);
            if (wrapper) {
                // delete the context
                delete _contexts[wrapper.id];
                // remove if currently bound
                if (wrapper === _boundContext) {
                    _boundContext = null;
                }
            } else {
                throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
            }
        },

        /**
         * Returns an array of all supported extensions for the provided or currently bound context object.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         *
         * @return {Array} All supported extensions.
         */
        supportedExtensions: function(arg) {
            let wrapper = getContextWrapper(arg);
            if (wrapper) {
                let extensions = wrapper.extensions;
                let supported = [];
                Object.keys(extensions).forEach(function(key) {
                    if (extensions[key]) {
                        supported.push(key);
                    }
                });
                return supported;
            }
            throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
        },

        /**
         * Returns an array of all unsupported extensions for the provided or currently bound context object.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         *
         * @return {Array} All unsupported extensions.
         */
        unsupportedExtensions: function(arg) {
            let wrapper = getContextWrapper(arg);
            if (wrapper) {
                let extensions = wrapper.extensions;
                let unsupported = [];
                Object.keys(extensions).forEach(function(key) {
                    if (!extensions[key]) {
                        unsupported.push(key);
                    }
                });
                return unsupported;
            }
            throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
        },

        /**
         * Checks if an extension has been successfully loaded for the provided or currently bound context object.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         * @param {String} extension - The extension name.
         *
         * @return {boolean} Whether or not the provided extension has been loaded successfully.
         */
        checkExtension: function(arg, extension) {
            if (!extension) {
                // shift parameters if no canvas arg is provided
                extension = arg;
                arg = undefined;
            }
            let wrapper = getContextWrapper(arg);
            if (wrapper) {
                let extensions = wrapper.extensions;
                return extensions[extension] ? true : false;
            }
            throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
        },

        /**
         * Returns an extension if it has been successfully loaded for the provided or currently bound context object.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         * @param {String} extension - The extension name.
         *
         * @return {boolean} Whether or not the provided extension has been loaded successfully.
         */
        getExtension: function(arg, extension) {
            if (!extension) {
                // shift parameters if no canvas arg is provided
                extension = arg;
                arg = undefined;
            }
            let wrapper = getContextWrapper(arg);
            if (wrapper) {
                let extensions = wrapper.extensions;
                return extensions[extension] || null;
            }
            throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
        }
    };

}());

},{}],24:[function(require,module,exports){
(function () {

    'use strict';

    module.exports = {
        IndexBuffer: require('./core/IndexBuffer'),
        Renderable: require('./core/Renderable'),
        RenderTarget: require('./core/RenderTarget'),
        Shader: require('./core/Shader'),
        Texture2D: require('./core/Texture2D'),
        ColorTexture2D: require('./core/ColorTexture2D'),
        DepthTexture2D: require('./core/DepthTexture2D'),
        TextureCubeMap: require('./core/TextureCubeMap'),
        VertexBuffer: require('./core/VertexBuffer'),
        VertexPackage: require('./core/VertexPackage'),
        Viewport: require('./core/Viewport'),
        WebGLContext: require('./core/WebGLContext')
    };

}());

},{"./core/ColorTexture2D":11,"./core/DepthTexture2D":12,"./core/IndexBuffer":13,"./core/RenderTarget":14,"./core/Renderable":15,"./core/Shader":16,"./core/Texture2D":18,"./core/TextureCubeMap":19,"./core/VertexBuffer":20,"./core/VertexPackage":21,"./core/Viewport":22,"./core/WebGLContext":23}],25:[function(require,module,exports){
(function () {

    'use strict';

    function getIterator(arg) {
        let i = -1;
        let len;
        if (Array.isArray(arg)) {
            len = arg.length;
            return function() {
                i++;
                return i < len ? i : null;
            };
        }
        let keys = Object.keys(arg);
        len = keys.length;
        return function() {
            i++;
            return i < len ? keys[i] : null;
        };
    }

    function once(fn) {
        return function() {
            if (fn === null) {
                return;
            }
            fn.apply(this, arguments);
            fn = null;
        };
    }

    function each(object, iterator, callback) {
        callback = once(callback);
        let key;
        let completed = 0;

        function done(err) {
            completed--;
            if (err) {
                callback(err);
            } else if (key === null && completed <= 0) {
                // check if key is null in case iterator isn't exhausted and done
                // was resolved synchronously.
                callback(null);
            }
        }

        let iter = getIterator(object);
        while ((key = iter()) !== null) {
            completed += 1;
            iterator(object[key], key, done);
        }
        if (completed === 0) {
            callback(null);
        }
    }

    module.exports = {

        /**
         * Execute a set of functions asynchronously, once all have been
         * completed, execute the provided callback function. Jobs may be passed
         * as an array or object. The callback function will be passed the
         * results in the same format as the tasks. All tasks must have accept
         * and execute a callback function upon completion.
         *
         * @param {Array|Object} tasks - The set of functions to execute.
         * @param {Function} callback - The callback function to be executed upon completion.
         */
        parallel: function(tasks, callback) {
            let results = Array.isArray(tasks) ? [] : {};
            each(tasks, function(task, key, done) {
                task(function(err, res) {
                    results[key] = res;
                    done(err);
                });
            }, function(err) {
                callback(err, results);
            });
        }

    };

}());

},{}],26:[function(require,module,exports){
(function() {

    'use strict';

    module.exports = {

        /**
         * Sends an GET request create an Image object.
         *
         * @param {Object} options - The XHR options.
         * @param {String} options.url - The URL for the resource.
         * @param {Function} options.success - The success callback function.
         * @param {Function} options.error - The error callback function.
         */
        load: function (options = {}) {
            let image = new Image();
            image.onload = () => {
                if (options.success) {
                    options.success(image);
                }
            };
            image.onerror = (event) => {
                if (options.error) {
                    let err = 'Unable to load image from URL: `' + event.path[0].currentSrc + '`';
                    options.error(err);
                }
            };
            image.src = options.url;
        }
    };

}());

},{}],27:[function(require,module,exports){
(function () {

    'use strict';

    let Util = {};

    /**
     * Returns true if the argument is one of the WebGL `texImage2D` overridden
     * canvas types.
     *
     * @param {*} arg - The argument to test.
     *
     * @return {bool} - Whether or not it is a canvas type.
     */
    Util.isCanvasType = function(arg) {
        return arg instanceof ImageData ||
            arg instanceof HTMLImageElement ||
            arg instanceof HTMLCanvasElement ||
            arg instanceof HTMLVideoElement;
    };

    /**
     * Returns true if the texture MUST be a power-of-two. Otherwise return false.
     *
     * @param {Object} spec - The texture specification object.
     *
     * @return {bool} - Whether or not the texture must be a power of two.
     */
    Util.mustBePowerOfTwo = function(spec) {
        // According to:
        // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL#Non_power-of-two_textures
        // N-POT textures cannot be used with mipmapping and they must not "REPEAT"
        return spec.mipMap ||
            spec.wrapS === 'REPEAT' ||
            spec.wrapS === 'MIRRORED_REPEAT' ||
            spec.wrapT === 'REPEAT' ||
            spec.wrapT === 'MIRRORED_REPEAT';
    };

    /**
     * Returns true if the provided integer is a power of two.
     *
     * @param {Number} num - The number to test.
     *
     * @return {boolean} - Whether or not the number is a power of two.
     */
    Util.isPowerOfTwo = function(num) {
        return (num !== 0) ? (num & (num - 1)) === 0 : false;
    };

    /**
     * Returns the next highest power of two for a number.
     *
     * Ex.
     *
     *     200 -> 256
     *     256 -> 256
     *     257 -> 512
     *
     * @param {Number} num - The number to modify.
     *
     * @return {Number} - Next highest power of two.
     */
    Util.nextHighestPowerOfTwo = function(num) {
        let i;
        if (num !== 0) {
            num = num-1;
        }
        for (i=1; i<32; i<<=1) {
            num = num | num >> i;
        }
        return num + 1;
    };

    /**
     * If the texture must be a POT, resizes and returns the image.
     * @private
     *
     * @param {Object} spec - The texture specification object.
     * @param {HTMLImageElement} img - The image object.
     *
     * @return {HTMLImageElement|HTMLCanvasElement} - The original image, or the resized canvas element.
     */
    Util.resizeCanvas = function(spec, img) {
        if (!Util.mustBePowerOfTwo(spec) ||
            (Util.isPowerOfTwo(img.width) && Util.isPowerOfTwo(img.height))) {
            return img;
        }
        // create an empty canvas element
        let canvas = document.createElement('canvas');
        canvas.width = Util.nextHighestPowerOfTwo(img.width);
        canvas.height = Util.nextHighestPowerOfTwo(img.height);
        // copy the image contents to the canvas
        let ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);
        return canvas;
    };

    module.exports = Util;

}());

},{}],28:[function(require,module,exports){
(function() {

    'use strict';

    module.exports = {

        /**
         * Sends an XMLHttpRequest GET request to the supplied url.
         *
         * @param {Object} options - The XHR options.
         * @param {String} options.url - The URL for the resource.
         * @param {Function} options.success - The success callback function.
         * @param {Function} options.error - The error callback function.
         * @param {Function} options.responseType - The responseType of the XHR.
         */
        load: function (options) {
            let request = new XMLHttpRequest();
            request.open('GET', options.url, true);
            request.responseType = options.responseType;
            request.onreadystatechange = () => {
                if (request.readyState === 4) {
                    if (request.status === 200) {
                        if (options.success) {
                            options.success(request.response);
                        }
                    } else {
                        if (options.error) {
                            options.error('GET ' + request.responseURL + ' ' + request.status + ' (' + request.statusText + ')');
                        }
                    }
                }
            };
            request.send();
        }
    };

}());

},{}],29:[function(require,module,exports){
var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};

},{"jsonify":30}],30:[function(require,module,exports){
exports.parse = require('./lib/parse');
exports.stringify = require('./lib/stringify');

},{"./lib/parse":31,"./lib/stringify":32}],31:[function(require,module,exports){
var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

},{}],32:[function(require,module,exports){
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

},{}],33:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],34:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":37,"./_isIndex":38,"./isArguments":43,"./isArray":44}],35:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":39,"./_nativeKeys":40}],36:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

module.exports = baseRest;

},{"./_apply":33}],37:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],38:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],39:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],40:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":41}],41:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],42:[function(require,module,exports){
var toInteger = require('./toInteger');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => Allows adding up to 4 contacts to the list.
 */
function before(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

module.exports = before;

},{"./toInteger":57}],43:[function(require,module,exports){
var isArrayLikeObject = require('./isArrayLikeObject');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

module.exports = isArguments;

},{"./isArrayLikeObject":46}],44:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],45:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":47,"./isLength":48}],46:[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":45,"./isObjectLike":50}],47:[function(require,module,exports){
var isObject = require('./isObject');

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

module.exports = isFunction;

},{"./isObject":49}],48:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],49:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],50:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],51:[function(require,module,exports){
var isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

module.exports = isSymbol;

},{"./isObjectLike":50}],52:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":34,"./_baseKeys":35,"./isArrayLike":45}],53:[function(require,module,exports){
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;

},{}],54:[function(require,module,exports){
var before = require('./before');

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */
function once(func) {
  return before(2, func);
}

module.exports = once;

},{"./before":42}],55:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    toInteger = require('./toInteger');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as
 * an array.
 *
 * **Note:** This method is based on the
 * [rest parameter](https://mdn.io/rest_parameters).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.rest(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function rest(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = start === undefined ? start : toInteger(start);
  return baseRest(func, start);
}

module.exports = rest;

},{"./_baseRest":36,"./toInteger":57}],56:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":58}],57:[function(require,module,exports){
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

},{"./toFinite":56}],58:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":49,"./isSymbol":51}],59:[function(require,module,exports){
//! moment.js
//! version : 2.14.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        return Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        var k;
        for (k in obj) {
            // even if its not own property I'd still call it non-empty
            return false;
        }
        return true;
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    function isUndefined(input) {
        return input === void 0;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (utils_hooks__hooks.deprecationHandler != null) {
                utils_hooks__hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (utils_hooks__hooks.deprecationHandler != null) {
            utils_hooks__hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;
    utils_hooks__hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function get_set__set (mom, unit, value) {
        if (mom.isValid()) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function units_month__handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = create_utc__createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return units_month__handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (typeof value !== 'number') {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        //the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function day_of_week__handleStrictParse(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = create_utc__createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = create_utc__createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        ordinalParse: defaultOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    // treat as if there is no base config
                    deprecateSimple('parentLocaleUndefined',
                            'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, parentConfig = baseConfig;
            // MERGE
            if (locales[name] != null) {
                parentConfig = locales[name]._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function locale_locales__listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (isDate(input)) {
            config._d = input;
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!valid__isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = ((string || '').match(matcher) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
            } else if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(matchOffset, this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            delta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
            case 'date':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIOROITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add               = add_subtract__add;
    momentPrototype__proto.calendar          = moment_calendar__calendar;
    momentPrototype__proto.clone             = clone;
    momentPrototype__proto.diff              = diff;
    momentPrototype__proto.endOf             = endOf;
    momentPrototype__proto.format            = format;
    momentPrototype__proto.from              = from;
    momentPrototype__proto.fromNow           = fromNow;
    momentPrototype__proto.to                = to;
    momentPrototype__proto.toNow             = toNow;
    momentPrototype__proto.get               = stringGet;
    momentPrototype__proto.invalidAt         = invalidAt;
    momentPrototype__proto.isAfter           = isAfter;
    momentPrototype__proto.isBefore          = isBefore;
    momentPrototype__proto.isBetween         = isBetween;
    momentPrototype__proto.isSame            = isSame;
    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
    momentPrototype__proto.isValid           = moment_valid__isValid;
    momentPrototype__proto.lang              = lang;
    momentPrototype__proto.locale            = locale;
    momentPrototype__proto.localeData        = localeData;
    momentPrototype__proto.max               = prototypeMax;
    momentPrototype__proto.min               = prototypeMin;
    momentPrototype__proto.parsingFlags      = parsingFlags;
    momentPrototype__proto.set               = stringSet;
    momentPrototype__proto.startOf           = startOf;
    momentPrototype__proto.subtract          = add_subtract__subtract;
    momentPrototype__proto.toArray           = toArray;
    momentPrototype__proto.toObject          = toObject;
    momentPrototype__proto.toDate            = toDate;
    momentPrototype__proto.toISOString       = moment_format__toISOString;
    momentPrototype__proto.toJSON            = toJSON;
    momentPrototype__proto.toString          = toString;
    momentPrototype__proto.unix              = unix;
    momentPrototype__proto.valueOf           = to_type__valueOf;
    momentPrototype__proto.creationData      = creationData;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var prototype__proto = Locale.prototype;

    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto.ordinal         = ordinal;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months            =        localeMonths;
    prototype__proto.monthsShort       =        localeMonthsShort;
    prototype__proto.monthsParse       =        localeMonthsParse;
    prototype__proto.monthsRegex       = monthsRegex;
    prototype__proto.monthsShortRegex  = monthsShortRegex;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    prototype__proto.weekdaysRegex       =        weekdaysRegex;
    prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
    prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = lists__get(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = locale_locales__getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return lists__get(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = lists__get(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function lists__listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function lists__listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function lists__listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function lists__listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes <= 1           && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   <= 1           && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    <= 1           && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  <= 1           && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   <= 1           && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function duration_humanize__getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.14.1';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.now                   = now;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.updateLocale          = updateLocale;
    utils_hooks__hooks.locales               = locale_locales__listLocales;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    utils_hooks__hooks.calendarFormat        = getCalendarFormat;
    utils_hooks__hooks.prototype             = momentPrototype;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],60:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Graph = require('../projection/Graph');

    L.CRS.Graph = L.extend({}, L.CRS, {

        projection: Graph,

        transformation: new L.Transformation(1, 0, 1, 0),

        infinite: false,

        scale: function scale(zoom) {
            return Math.pow(2, zoom);
        },

        zoom: function zoom(scale) {
            return Math.log(scale) / Math.LN2;
        },

        distance: function distance(latlng1, latlng2) {
            var dx = latlng2.lng - latlng1.lng;
            var dy = latlng2.lat - latlng1.lat;
            return Math.sqrt(dx * dx + dy * dy);
        }
    });

    module.exports = L.CRS.Graph;
})();

},{"../projection/Graph":99}],61:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    module.exports = {
        Graph: require('./Graph')
    };
})();

},{"./Graph":60}],62:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    module.exports = {
        Map: require('./map/Map'),
        Projection: require('./projection/exports'),
        CRS: require('./CRS/exports'),
        TileLayer: require('./layer/exports'),
        Renderer: require('./renderer/exports'),
        TileRequestor: require('./request/TileRequestor'),
        MetaRequestor: require('./request/MetaRequestor'),
        ColorRamp: {
            // expose as static method
            getColorRamp: require('./renderer/mixin/ColorRamp').getColorRamp
        }
    };
})();

},{"./CRS/exports":61,"./layer/exports":76,"./map/Map":98,"./projection/exports":100,"./renderer/exports":106,"./renderer/mixin/ColorRamp":107,"./request/MetaRequestor":130,"./request/TileRequestor":132}],63:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var setDateHistogram = function setDateHistogram(field, from, to, interval) {
        if (!field) {
            throw 'DateHistogram `field` is missing from argument';
        }
        if (from === undefined) {
            throw 'DateHistogram `from` are missing from argument';
        }
        if (to === undefined) {
            throw 'DateHistogram `to` are missing from argument';
        }
        this._params.date_histogram = {
            field: field,
            from: from,
            to: to,
            interval: interval
        };
        this.clearExtrema();
        return this;
    };

    var getDateHistogram = function getDateHistogram() {
        return this._params.date_histogram;
    };

    module.exports = {
        setDateHistogram: setDateHistogram,
        getDateHistogram: getDateHistogram
    };
})();

},{}],64:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (!meta.extrema) {
                throw 'Histogram `field` ' + field + ' is not ordinal in meta data';
            }
        } else {
            throw 'Histogram `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setHistogram = function setHistogram(field, interval) {
        if (!field) {
            throw 'Histogram `field` is missing from argument';
        }
        if (!interval) {
            throw 'Histogram `interval` are missing from argument';
        }
        checkField(this._meta[field], field);
        this._params.histogram = {
            field: field,
            interval: interval
        };
        this.clearExtrema();
        return this;
    };

    var getHistogram = function getHistogram() {
        return this._params.histogram;
    };

    module.exports = {
        setHistogram: setHistogram,
        getHistogram: getHistogram
    };
})();

},{}],65:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var METRICS = {
        'min': true,
        'max': true,
        'sum': true,
        'avg': true
    };

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (!meta.extrema) {
                throw 'Metrix `field` ' + field + ' is not ordinal in meta data';
            }
        } else {
            throw 'Metric `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setMetric = function setMetric(field, type) {
        if (!field) {
            throw 'Metric `field` is missing from argument';
        }
        if (!type) {
            throw 'Metric `type` is missing from argument';
        }
        checkField(this._meta[field], field);
        if (!METRICS[type]) {
            throw 'Metric type `' + type + '` is not supported';
        }
        this._params.metric = {
            field: field,
            type: type
        };
        this.clearExtrema();
        return this;
    };

    var getMetric = function getMetric() {
        return this._params.metric;
    };

    module.exports = {
        // tiling
        setMetric: setMetric,
        getMetric: getMetric
    };
})();

},{}],66:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'Terms `field` ' + field + ' is not of type `string` in meta data';
            }
        } else {
            throw 'Terms `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setTerms = function setTerms(field, size) {
        if (!field) {
            throw 'Terms `field` is missing from argument';
        }
        checkField(this._meta[field], field);
        this._params.terms = {
            field: field,
            size: size
        };
        this.clearExtrema();
        return this;
    };

    var getTerms = function getTerms() {
        return this._params.terms;
    };

    module.exports = {
        setTerms: setTerms,
        getTerms: getTerms
    };
})();

},{}],67:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'Terms `field` ' + field + ' is not of type `string` in meta data';
            }
        } else {
            throw 'Terms `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setTermsFilter = function setTermsFilter(field, terms) {
        if (!field) {
            throw 'Terms `field` is missing from argument';
        }
        if (terms === undefined) {
            throw 'Terms `terms` are missing from argument';
        }
        checkField(this._meta[field], field);
        this._params.terms_filter = {
            field: field,
            terms: terms
        };
        this.clearExtrema();
        return this;
    };

    var getTermsFilter = function getTermsFilter() {
        return this._params.terms_filter;
    };

    module.exports = {
        setTermsFilter: setTermsFilter,
        getTermsFilter: getTermsFilter
    };
})();

},{}],68:[function(require,module,exports){
'use strict';

// Provides top hits query functionality. 'size' indicates the number of top
// hits to return, 'include' is the list of fields to include in the returned
// data, 'sort' is the field to use for sort critera, and 'order' is value of
// 'asc' or 'desc' to indicate sort ordering.
(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (!meta.extrema) {
                throw 'Range `field` ' + field + ' is not ordinal in meta data.';
            }
        } else {
            throw 'TopTerms `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setTopHits = function setTopHits(size, include, sort, order) {
        if (sort) {
            checkField(this._meta[sort], sort);
        }
        this._params.top_hits = {
            size: size,
            include: include,
            sort: sort,
            order: order
        };
        this.clearExtrema();
        return this;
    };

    var getTopHits = function getTopHits() {
        return this._params.top_hits;
    };

    // bind point for external controls
    var setSortField = function setSortField(sort) {
        if (!sort) {
            throw 'TopHits `sort` argument is missing';
        }
        checkField(this._meta[sort], sort);
        if (sort !== this._params.top_hits.sort) {
            this._params.top_hits.sort = sort;
            this.clearExtrema();
        }
        return this;
    };

    // bind point for external controls
    var getSortField = function getSortField() {
        return this._params.top_hits.sort;
    };

    module.exports = {
        setTopHits: setTopHits,
        getTopHits: getTopHits,
        setSortField: setSortField,
        getSortField: getSortField
    };
})();

},{}],69:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'TopTerms `field` ' + field + ' is not of type `string` in meta data';
            }
        } else {
            throw 'TopTerms `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setTopTerms = function setTopTerms(field, size) {
        if (!field) {
            throw 'TopTerms `field` is missing from argument';
        }
        checkField(this._meta[field], field);
        this._params.top_terms = {
            field: field,
            size: size
        };
        this.clearExtrema();
        return this;
    };

    var getTopTerms = function getTopTerms() {
        return this._params.top_terms;
    };

    module.exports = {
        setTopTerms: setTopTerms,
        getTopTerms: getTopTerms
    };
})();

},{}],70:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    function mod(n, m) {
        return (n % m + m) % m;
    }

    var Base = L.GridLayer.extend({

        options: {
            tms: false
        },

        getOpacity: function getOpacity() {
            return this.options.opacity;
        },

        show: function show() {
            this._hidden = false;
            this._prevMap.addLayer(this);
        },

        hide: function hide() {
            this._hidden = true;
            this._prevMap = this._map;
            this._map.removeLayer(this);
        },

        isHidden: function isHidden() {
            return this._hidden;
        },

        setBrightness: function setBrightness(brightness) {
            this._brightness = brightness;
            $(this._container).css('-webkit-filter', 'brightness(' + this._brightness * 100 + '%)');
            $(this._container).css('filter', 'brightness(' + this._brightness * 100 + '%)');
        },

        getBrightness: function getBrightness() {
            return this._brightness !== undefined ? this._brightness : 1;
        },

        isTargetLayer: function isTargetLayer(elem) {
            return this._container && this._container === elem || $.contains(this._container, elem);
        },

        _getLayerPointFromLonLat: function _getLayerPointFromLonLat(lonlatPoint, zoom) {
            zoom = zoom !== undefined ? zoom : this._map.getZoom();
            var pixel = this._map.project(lonlatPoint, zoom);
            var pow = Math.pow(2, zoom);
            var tileSize = this.options.tileSize;
            return {
                x: mod(pixel.x, pow * tileSize),
                y: mod(pixel.y, pow * tileSize)
            };
        },

        getLayerPointFromEvent: function getLayerPointFromEvent(e) {
            var lonlat = this._map.mouseEventToLatLng(e);
            return this._getLayerPointFromLonLat(lonlat);
        },

        getTileCoordFromLayerPoint: function getTileCoordFromLayerPoint(layerPoint) {
            var tileSize = this.options.tileSize;
            return {
                x: Math.floor(layerPoint.x / tileSize),
                y: Math.floor(layerPoint.y / tileSize),
                z: this._map.getZoom()
            };
        },

        getBinCoordFromLayerPoint: function getBinCoordFromLayerPoint(layerPoint, res) {
            var tileSize = this.options.tileSize;
            var resolution = res || this.getResolution() || tileSize;
            var tx = mod(layerPoint.x, tileSize);
            var y = this.options.tms ? resolution - layerPoint.y : layerPoint.y;
            var ty = mod(y, tileSize);
            var pixelSize = tileSize / resolution;
            var bx = Math.floor(tx / pixelSize);
            var by = Math.floor(ty / pixelSize);
            return {
                x: bx,
                y: by,
                index: bx + by * resolution,
                size: pixelSize
            };
        },

        _addTile: function _addTile(coords, container) {
            var tilePos = this._getTilePos(coords);
            var key = this._tileCoordsToKey(coords);
            // Override so that we don't pass in wrapped coords here
            var tile = this.createTile(coords, L.bind(this._tileReady, this, coords));
            this._initTile(tile);
            // if createTile is defined with a second argument ("done" callback),
            // we know that tile is async and will be ready later; otherwise
            if (this.createTile.length < 2) {
                // mark tile as ready, but delay one frame for opacity animation to happen
                L.Util.requestAnimFrame(L.bind(this._tileReady, this, coords, null, tile));
            }
            L.DomUtil.setPosition(tile, tilePos);
            // save tile in cache
            this._tiles[key] = {
                el: tile,
                coords: coords,
                current: true
            };
            container.appendChild(tile);
            // @event tileloadstart: TileEvent
            // Fired when a tile is requested and starts loading.
            this.fire('tileloadstart', {
                tile: tile,
                coords: coords
            });
        }
    });

    module.exports = Base;
})();

},{}],71:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    function validToCopy(funcName) {
        return funcName !== 'constructor' && funcName !== 'on' && funcName !== 'off' && funcName[0] !== '_';
    }

    var Composite = L.Class.extend({

        initialize: function initialize() {
            var _this = this;

            var layers = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

            var functions = {};
            // get a list of all functions for each layer
            layers.forEach(function (layer) {
                _.forIn(layer, function (val, key) {
                    if (_.isFunction(val) && validToCopy(key)) {
                        functions[key] = functions[key] || [];
                        functions[key].push(layer);
                    }
                });
            });
            // set properties
            this._layers = layers;
            this._functions = functions;
            this._handlers = {};
            // extend this composite class for each function
            _.forIn(functions, function (layers, func) {
                _this._extend(func);
            });
        },

        on: function on(evt, func) {
            this._layers.forEach(function (layer) {
                layer.on(evt, func);
            });
            this._handlers[evt] = this._handlers[evt] || [];
            this._handlers[evt].push(func);
        },

        off: function off(evt, func) {
            var handlers = this._handlers[evt];
            if (handlers) {
                var index = handlers.indexOf(func);
                if (index !== -1) {
                    this._layers.forEach(function (layer) {
                        layer.off(evt, func);
                    });
                    handlers.splice(index, 1);
                    if (handlers.length === 0) {
                        delete this._handlers[evt];
                    }
                }
            }
        },

        _extend: function _extend(func) {
            var functions = this._functions;
            this[func] = function () {
                var layers = functions[func];
                var layer = void 0,
                    i = void 0;
                var result = void 0;
                for (i = 0; i < layers.length; i++) {
                    layer = layers[i];
                    result = layer[func].apply(layer, arguments);
                    if (result !== undefined && result !== layer) {
                        return result;
                    }
                }
            };
        },

        addSubLayer: function addSubLayer(layer) {
            var _this2 = this;

            var index = this._layers.indexOf(layer);
            if (index !== -1) {
                return;
            }
            var functions = this._functions;
            _.forIn(layer, function (val, key) {
                // if it is a function and valid to copy
                if (_.isFunction(val) && validToCopy(key)) {
                    // add layer to functions
                    functions[key] = functions[key] || [];
                    functions[key].push(layer);
                    if (functions[key].length === 1) {
                        // if a new function, extend the object
                        _this2._extend(key);
                    }
                }
            });
            // add to layers
            this._layers.push(layer);
            // add handlers to layer
            _.forIn(this._handlers, function (handlers, evt) {
                handlers.forEach(function (func) {
                    layer.on(evt, func);
                });
            });
        },

        removeSubLayer: function removeSubLayer(layer) {
            var _this3 = this;

            var index = this._layers.indexOf(layer);
            if (index === -1) {
                return;
            }
            var functions = this._functions;
            // remove all functions used exclusively by this layer
            _.forIn(layer, function (val, key) {
                if (_.isFunction(val) && validToCopy(key)) {
                    var _index = functions[key].indexOf(layer);
                    if (_index !== -1) {
                        // remove from function list
                        functions[key].splice(_index, 1);
                    }
                    // if exclusive owner of function
                    if (functions[key].length === 0) {
                        // no more use for this function, remove it
                        delete functions[key];
                        delete _this3[key];
                    }
                }
            });
            // remove layer
            this._layers.splice(index, 1);
            // remove handlers from layer
            _.forIn(this._handlers, function (handlers, evt) {
                handlers.forEach(function (func) {
                    layer.off(evt, func);
                });
            });
        }
    });

    module.exports = Composite;
})();

},{}],72:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Base = require('./Base');

    var Debug = Base.extend({

        options: {
            unloadInvisibleTiles: true,
            zIndex: 5000
        },

        initialize: function initialize(options) {
            // set renderer
            if (!options.rendererClass) {
                throw 'No `rendererClass` option found.';
            } else {
                // recursively extend
                $.extend(true, this, options.rendererClass);
            }
            // set options
            L.setOptions(this, options);
        },

        createTile: function createTile(coord) {
            // create a <div> element for drawing
            var tile = L.DomUtil.create('div', 'leaflet-tile');
            // draw to it
            this.renderTile(tile, coord);
            // pass tile to callback
            return tile;
        },

        renderTile: function renderTile() {
            // override
        }

    });

    module.exports = Debug;
})();

},{"./Base":70}],73:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Image = L.TileLayer.extend({

        getOpacity: function getOpacity() {
            return this.options.opacity;
        },

        show: function show() {
            this._hidden = false;
            this._prevMap.addLayer(this);
        },

        hide: function hide() {
            this._hidden = true;
            this._prevMap = this._map;
            this._map.removeLayer(this);
        },

        isHidden: function isHidden() {
            return this._hidden;
        },

        setBrightness: function setBrightness(brightness) {
            this._brightness = brightness;
            $(this._container).css('-webkit-filter', 'brightness(' + this._brightness * 100 + '%)');
            $(this._container).css('filter', 'brightness(' + this._brightness * 100 + '%)');
        },

        getBrightness: function getBrightness() {
            return this._brightness !== undefined ? this._brightness : 1;
        }
    });

    module.exports = Image;
})();

},{}],74:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var boolQueryCheck = require('../query/Bool');

    function mod(n, m) {
        return (n % m + m) % m;
    }

    var Live = L.Class.extend({

        options: {
            transform: function transform(val) {
                return val;
            }
        },

        initialize: function initialize(meta) {
            var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            // set renderer
            if (options.rendererClass) {
                var renderer = void 0;
                // recursively extend and initialize
                if (options.rendererClass.prototype) {
                    renderer = new options.rendererClass();
                } else {
                    renderer = options.rendererClass;
                }
                // extend this object
                $.extend(true, this, renderer);
                // copy prototype options property by value, this is important
                this.options = $.extend(true, {}, this.options);
                delete options.rendererClass;
            }
            // set options
            L.setOptions(this, options);
            // set meta
            this._meta = meta;
            // set params
            this._params = {
                binning: {}
            };
            // set extrema / cache
            this._cache = {};
            this.clearExtrema();
        },

        clearExtrema: function clearExtrema() {
            this._extrema = {
                min: Number.MAX_VALUE,
                max: 0
            };
        },

        getExtrema: function getExtrema() {
            return this._extrema;
        },

        updateExtrema: function updateExtrema(data) {
            var extrema = this.extractExtrema(data);
            var changed = false;
            if (extrema.min < this._extrema.min) {
                changed = true;
                this._extrema.min = extrema.min;
            }
            if (extrema.max > this._extrema.max) {
                changed = true;
                this._extrema.max = extrema.max;
            }
            return changed;
        },

        extractExtrema: function extractExtrema(data) {
            return {
                min: _.min(data),
                max: _.max(data)
            };
        },

        setQuery: function setQuery(query) {
            if (!query.must && !query.must_not && !query.should) {
                throw 'Root query must have at least one `must`, `must_not`, or `should` argument.';
            }
            // check that the query is valid
            boolQueryCheck(this._meta, query);
            // set query
            this._params.must = query.must;
            this._params.must_not = query.must_not;
            this._params.should = query.should;
            // cleat extrema
            this.clearExtrema();
        },

        getQuery: function getQuery() {
            return {
                must: this._params.must,
                must_not: this._params.must_not,
                should: this._params.should
            };
        },

        clearQuery: function clearQuery() {
            // clear query
            this._params.must = undefined;
            this._params.must_not = undefined;
            this._params.should = undefined;
            // cleat extrema
            this.clearExtrema();
        },

        getMeta: function getMeta() {
            return this._meta;
        },

        getParams: function getParams() {
            return this._params;
        },

        getNormalizedCoords: function getNormalizedCoords(coords) {
            var pow = Math.pow(2, coords.z);
            return {
                x: mod(coords.x, pow),
                y: mod(coords.y, pow),
                z: coords.z
            };
        },

        cacheKeyFromCoord: function cacheKeyFromCoord(coords, normalize) {
            if (normalize) {
                // leaflet layer x and y may be > n^2, and < 0 in the case
                // of a wraparound. If normalize is true, mod the coords
                coords = this.getNormalizedCoords(coords);
            }
            return coords.z + ':' + coords.x + ':' + coords.y;
        },

        coordFromCacheKey: function coordFromCacheKey(key) {
            var arr = key.split(':');
            return {
                x: parseInt(arr[1], 10),
                y: parseInt(arr[2], 10),
                z: parseInt(arr[0], 10)
            };
        },

        onTileUnload: function onTileUnload(event) {
            var coords = event.coords;
            // respect the TMS setting in the options
            if (this.options.tms) {
                coords = {
                    x: event.coords.x,
                    y: Math.pow(2, event.coords.z) - 1 - event.coords.y,
                    z: event.coords.z
                };
            }
            // cache key from coords
            var key = this.cacheKeyFromCoord(coords);
            // cache key from normalized coords
            var nkey = this.cacheKeyFromCoord(coords, true);
            // get cache entry
            var cached = this._cache[nkey];
            // could the be case where the cache is cleared before tiles are
            // unloaded
            if (!cached) {
                return;
            }
            // remove the tile from the cache
            delete cached.tiles[key];
            // don't remove cache entry unless to tiles use it anymore
            if (_.keys(cached.tiles).length === 0) {
                // get the tile being deleted
                var tile = cached.tiles[key];
                // no more tiles use this cached data, so delete it
                this.fire('cacheunload', {
                    tile: tile,
                    coords: coords,
                    entry: cached
                });
                delete this._cache[nkey];
            }
        },

        _requestTile: function _requestTile(coords, tile, callback) {
            var _this = this;

            // respect the TMS setting in the options
            if (this.options.tms) {
                coords = {
                    x: coords.x,
                    y: Math.pow(2, coords.z) - 1 - coords.y,
                    z: coords.z
                };
            }
            var ncoords = this.getNormalizedCoords(coords);
            // cache key from coords
            var key = this.cacheKeyFromCoord(coords);
            // cache key from normalized coords
            var nkey = this.cacheKeyFromCoord(coords, true);
            // check cache
            var cached = this._cache[nkey];
            if (cached) {
                // add tile under normalize coords
                cached.tiles[key] = tile;
                if (!cached.isPending) {
                    // cache entry already exists
                    this.fire('cachehit', {
                        tile: tile,
                        coords: coords,
                        entry: cached
                    });
                    // execute callback
                    window.requestAnimationFrame(callback);
                } else {
                    // tile is already pending, add callback
                    cached.callbacks.push(callback);
                }
            } else {
                // create a cache entry
                this._cache[nkey] = {
                    isPending: true,
                    tiles: {},
                    data: null,
                    callbacks: [callback]
                };
                // add tile to the cache entry
                this._cache[nkey].tiles[key] = tile;
                // request the tile
                this.requestTile(ncoords, function (data) {
                    var cached = _this._cache[nkey];
                    if (!cached) {
                        // tile is no longer being tracked, ignore
                        return;
                    }
                    // flag as no longer pending
                    cached.isPending = false;
                    // transform and store tile data in cache
                    cached.data = _this.options.transform(data);
                    // execute pending callbacks
                    cached.callbacks.forEach(function (callback) {
                        callback();
                    });
                    cached.callbacks = [];
                    // data is loaded into cache
                    _this.fire('cacheload', {
                        tile: tile,
                        coords: coords,
                        entry: cached
                    });
                    if (cached.data) {
                        // update the extrema
                        if (_this.updateExtrema(cached.data)) {
                            // if extrema changed, fire event
                            _this.fire('extremachange', {
                                tile: tile,
                                coords: coords,
                                entry: cached
                            });
                        }
                    }
                });
            }
        },

        requestTile: function requestTile() {
            // override
        }

    });

    module.exports = Live;
})();

},{"../query/Bool":80}],75:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Base = require('./Base');

    function mod(n, m) {
        return (n % m + m) % m;
    }

    var Pending = Base.extend({

        options: {
            unloadInvisibleTiles: true,
            zIndex: 5000
        },

        initialize: function initialize(options) {
            this._pendingTiles = {};
            // set renderer
            if (!options.rendererClass) {
                throw 'No `rendererClass` option found.';
            } else {
                // recursively extend
                $.extend(true, this, options.rendererClass);
            }
            // set options
            L.setOptions(this, options);
        },

        add: function add(layer) {
            var _this = this;

            layer._incrementHandler = function (tile) {
                _this._increment(tile.coords);
            };
            layer._decrementHandler = function (tile) {
                _this._decrement(tile.coords);
            };
            layer.on('tilestartload', layer._incrementHandler);
            layer.on('tileload', layer._decrementHandler);
            layer.on('tileerror', layer._decrementHandler);
        },

        remove: function remove(layer) {
            layer.off('tilestartload', layer._incrementHandler);
            layer.off('tileload', layer._decrementHandler);
            layer.off('tileerror', layer._decrementHandler);
            layer._incrementHandler = null;
            layer._decrementHandler = null;
        },

        _increment: function _increment(coord) {
            var _this2 = this;

            var hash = this._getTileHash(coord);
            if (this._pendingTiles[hash] === undefined) {
                this._pendingTiles[hash] = 1;
                var tiles = this._getTilesWithHash(hash);
                tiles.forEach(function (tile) {
                    _this2._updateTile(coord, tile);
                });
            } else {
                this._pendingTiles[hash]++;
            }
        },

        _decrement: function _decrement(coord) {
            var _this3 = this;

            var hash = this._getTileHash(coord);
            this._pendingTiles[hash]--;
            if (this._pendingTiles[hash] === 0) {
                delete this._pendingTiles[hash];
                var tiles = this._getTilesWithHash(hash);
                tiles.forEach(function (tile) {
                    _this3._updateTile(coord, tile);
                });
            }
        },

        _getTileClass: function _getTileClass(hash) {
            return 'leaflet-pending-' + hash;
        },

        _getNormalizedCoords: function _getNormalizedCoords(coords) {
            var pow = Math.pow(2, coords.z);
            return {
                x: mod(coords.x, pow),
                y: mod(coords.y, pow),
                z: coords.z
            };
        },

        _getTileHash: function _getTileHash(coords) {
            var ncoords = this._getNormalizedCoords(coords);
            return ncoords.z + '-' + ncoords.x + '-' + ncoords.y;
        },

        _getTilesWithHash: function _getTilesWithHash(hash) {
            var _this4 = this;

            var className = this._getTileClass(hash);
            var tiles = [];
            $(this._container).find('.' + className).each(function () {
                tiles.push(_this4);
            });
            return tiles;
        },

        _updateTile: function _updateTile(coord, tile) {
            // get hash
            var hash = this._getTileHash(coord);
            $(tile).addClass(this._getTileClass(hash) + ' pending');
            if (this._pendingTiles[hash] > 0) {
                this.renderTile(tile, coord);
            } else {
                $(tile).removeClass('pending');
                tile.innerHTML = '';
            }
        },

        createTile: function createTile(coord) {
            // create a <div> element for drawing
            var tile = L.DomUtil.create('div', 'leaflet-tile leaflet-tile-pending');
            // get hash
            this._updateTile(coord, tile);
            // pass tile to callback
            return tile;
        },

        renderTile: function renderTile() {
            // override
        }

    });

    module.exports = Pending;
})();

},{"./Base":70}],76:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    // debug tile layer

    var Debug = require('./core/Debug');

    // pending tile layer
    var Pending = require('./core/Pending');

    // image layer
    var Image = require('./core/Image');

    // composite layer
    var Composite = require('./core/Composite');

    // live layer - base type for extension
    var Live = require('./core/Live');

    // live tile layers
    var Heatmap = require('./type/Heatmap');
    var TopTrails = require('./type/TopTrails');
    var TopCount = require('./type/TopCount');
    var TopFrequency = require('./type/TopFrequency');
    var TopicCount = require('./type/TopicCount');
    var TopicFrequency = require('./type/TopicFrequency');
    var Preview = require('./type/Preview');
    var Macro = require('./type/Macro');
    var Micro = require('./type/Micro');
    var Count = require('./type/Count');
    var Community = require('./type/Community');

    module.exports = {
        Debug: Debug,
        Pending: Pending,
        Image: Image,
        Composite: Composite,
        Live: Live,
        Heatmap: Heatmap,
        TopCount: TopCount,
        TopTrails: TopTrails,
        TopFrequency: TopFrequency,
        TopicCount: TopicCount,
        TopicFrequency: TopicFrequency,
        Preview: Preview,
        Macro: Macro,
        Micro: Micro,
        Count: Count,
        Community: Community
    };
})();

},{"./core/Composite":71,"./core/Debug":72,"./core/Image":73,"./core/Live":74,"./core/Pending":75,"./type/Community":87,"./type/Count":88,"./type/Heatmap":89,"./type/Macro":90,"./type/Micro":91,"./type/Preview":92,"./type/TopCount":93,"./type/TopFrequency":94,"./type/TopTrails":95,"./type/TopicCount":96,"./type/TopicFrequency":97}],77:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DEFAULT_RESOLUTION = 256;

    var Tiling = require('./Tiling');

    var setResolution = function setResolution(resolution) {
        if (resolution !== this._params.binning.resolution) {
            this._params.binning.resolution = resolution;
            this.clearExtrema();
        }
        return this;
    };

    var getResolution = function getResolution() {
        return this._params.binning.resolution || DEFAULT_RESOLUTION;
    };

    module.exports = {
        // tiling
        setXField: Tiling.setXField,
        getXField: Tiling.getXField,
        setYField: Tiling.setYField,
        getYField: Tiling.getYField,
        getLayerPointFromDataPoint: Tiling.getLayerPointFromDataPoint,
        getDataPointFromLayerPoint: Tiling.getDataPointFromLayerPoint,
        DEFAULT_X_FIELD: Tiling.DEFAULT_X_FIELD,
        DEFAULT_Y_FIELD: Tiling.DEFAULT_Y_FIELD,
        DEFAULT_PIXEL_MAX: Tiling.DEFAULT_PIXEL_MAX,
        // binning
        setResolution: setResolution,
        getResolution: getResolution,
        DEFAULT_RESOLUTION: DEFAULT_RESOLUTION
    };
})();

},{"./Tiling":79}],78:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var getTypes = function getTypes() {
        return this._params.elastic ? this._params.elastic.type : undefined;
    };

    var setTypes = function setTypes(types) {
        if (!types) {
            throw 'QueryString `types` are not provided.';
        }
        types = Array.isArray(types) ? types : [types];
        this._params.elastic = {
            types: types
        };
    };

    module.exports = {
        setTypes: setTypes,
        getTypes: getTypes
    };
})();

},{}],79:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var moment = require('moment');

    var DEFAULT_TILE_SIZE = 256;
    var DEFAULT_X_FIELD = 'pixel.x';
    var DEFAULT_Y_FIELD = 'pixel.y';
    var DEFAULT_PIXEL_MIN = 0;
    var DEFAULT_PIXEL_MAX = Math.pow(2, 32);

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.extrema) {
                return true;
            } else {
                throw 'Field `' + field + '` is not ordinal in meta data.';
            }
        } else {
            throw 'Field `' + field + '` is not recognized in meta data.';
        }
        return false;
    };

    var setXField = function setXField(field) {
        if (field !== this._params.binning.x) {
            if (field === DEFAULT_X_FIELD) {
                // reset if default
                this._params.binning.x = DEFAULT_X_FIELD;
                this._params.binning.left = DEFAULT_PIXEL_MIN;
                this._params.binning.right = DEFAULT_PIXEL_MAX;
                this.clearExtrema();
            } else {
                var meta = this._meta[field];
                if (checkField(meta, field)) {
                    this._params.binning.x = field;
                    this._params.binning.left = meta.extrema.min;
                    this._params.binning.right = meta.extrema.max;
                    this.clearExtrema();
                }
            }
        }
        return this;
    };

    var getXField = function getXField() {
        return this._params.binning.x;
    };

    var setYField = function setYField(field) {
        if (field !== this._params.binning.y) {
            if (field === DEFAULT_Y_FIELD) {
                // reset if default
                this._params.binning.y = DEFAULT_Y_FIELD;
                this._params.binning.bottom = DEFAULT_PIXEL_MAX;
                this._params.binning.top = DEFAULT_PIXEL_MIN;
                this.clearExtrema();
            } else {
                var meta = this._meta[field];
                if (checkField(meta, field)) {
                    this._params.binning.y = field;
                    this._params.binning.bottom = meta.extrema.min;
                    this._params.binning.top = meta.extrema.max;
                    this.clearExtrema();
                }
            }
        }
        return this;
    };

    var getYField = function getYField() {
        return this._params.binning.y;
    };

    var getLayerPointFromDataPoint = function getLayerPointFromDataPoint(x, y, zoom) {
        var binning = this._params.binning;
        var tileSize = this.options.tileSize || DEFAULT_TILE_SIZE;
        var pow = Math.pow(2, zoom);
        var extent = tileSize * pow;
        var meta = this.getMeta();

        var left = void 0,
            right = void 0,
            bottom = void 0,
            top = void 0;
        if (meta[binning.x].type === 'date') {
            left = moment(binning.left).valueOf();
            right = moment(binning.right).valueOf();
            x = moment(x).valueOf();
        } else {
            left = binning.left;
            right = binning.right;
        }
        if (meta[binning.y].type === 'date') {
            bottom = moment(binning.bottom).valueOf();
            top = moment(binning.top).valueOf();
            y = moment(y).valueOf();
        } else {
            bottom = binning.bottom;
            top = binning.top;
        }

        var xRange = Math.abs(right - left);
        var yRange = Math.abs(bottom - top);
        var nx = void 0,
            ny = void 0;
        if (left > right) {
            nx = 1 - (x - right) / xRange;
        } else {
            nx = (x - left) / xRange;
        }
        if (top > bottom) {
            ny = 1 - (y - bottom) / yRange;
        } else {
            ny = (y - top) / yRange;
        }
        return {
            x: extent * nx,
            y: extent * ny
        };
    };

    var getDataPointFromLayerPoint = function getDataPointFromLayerPoint(x, y, zoom) {
        var binning = this._params.binning;
        var tileSize = this.options.tileSize || DEFAULT_TILE_SIZE;
        var pow = Math.pow(2, zoom);
        var extent = tileSize * pow;
        var nx = x / extent;
        var ny = y / extent;
        var xRange = Math.abs(binning.right - binning.left);
        var yRange = Math.abs(binning.bottom - binning.top);
        var px = void 0,
            py = void 0;
        if (binning.left > binning.right) {
            px = binning.right + (1 - nx) * xRange;
        } else {
            px = binning.left + nx * xRange;
        }
        if (binning.top > binning.bottom) {
            py = binning.bottom + (1 - ny) * yRange;
        } else {
            py = binning.top + ny * yRange;
        }
        return {
            x: px,
            y: py
        };
    };

    module.exports = {
        setXField: setXField,
        getXField: getXField,
        setYField: setYField,
        getYField: getYField,
        getLayerPointFromDataPoint: getLayerPointFromDataPoint,
        getDataPointFromLayerPoint: getDataPointFromLayerPoint,
        DEFAULT_X_FIELD: DEFAULT_X_FIELD,
        DEFAULT_Y_FIELD: DEFAULT_Y_FIELD,
        DEFAULT_PIXEL_MAX: DEFAULT_PIXEL_MAX
    };
})();

},{"moment":59}],80:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var check = void 0;

    function checkQuery(meta, query) {
        var keys = _.keys(query);
        if (keys.length !== 1) {
            throw 'Bool sub-query must only have a single key, query has multiple keys: `' + JSON.stringify(keys) + '`.';
        }
        var type = keys[0];
        var checkFunc = check[type];
        if (!checkFunc) {
            throw 'Query type `' + type + '` is not recognized.';
        }
        // check query by type
        check[type](meta, query[type]);
    }

    function checkQueries(meta, queries) {
        if (_.isArray(queries)) {
            queries.forEach(function (query) {
                checkQuery(meta, query);
            });
            return queries;
        }
        checkQuery(meta, queries);
        return [queries];
    }

    function checkBool(meta, query) {
        if (!query.must && !query.must_not && !query.should) {
            throw 'Bool must have at least one `must`, `must_not`, or `should` query argument.';
        }
        if (query.must) {
            checkQueries(meta, query.must);
        }
        if (query.must_not) {
            checkQueries(meta, query.must_not);
        }
        if (query.should) {
            checkQueries(meta, query.should);
        }
    }

    check = {
        bool: checkBool,
        exists: require('./Exists'),
        prefix: require('./Prefix'),
        query_string: require('./QueryString'),
        range: require('./Range'),
        terms: require('./Terms'),
        match: require('./Match')
    };

    module.exports = checkBool;
})();

},{"./Exists":81,"./Match":82,"./Prefix":83,"./QueryString":84,"./Range":85,"./Terms":86}],81:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (!meta) {
            throw 'Terms `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'Exists `field` is missing from argument.';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],82:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'Match `field` ' + field + ' is not `string` in meta data.';
            }
        } else {
            throw 'Match `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'Match `field` is missing from argument.';
        }
        if (!query.string) {
            throw 'Match `string` is missing from argument.';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],83:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'Prefix `field` ' + field + ' is not of type `string` in meta data.';
            }
        } else {
            throw 'Prefix `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'Prefix `field` is missing from argument';
        }
        if (query.prefixes === undefined) {
            throw 'Prefix `prefixes` are missing from argument';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],84:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'QueryString `field` ' + field + ' is not `string` in meta data.';
            }
        } else {
            throw 'QueryString `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'QueryString `field` is missing from argument.';
        }
        if (!query.string) {
            throw 'QueryString `string` is missing from argument.';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],85:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (!meta.extrema) {
                throw 'Range `field` ' + field + ' is not ordinal in meta data.';
            }
        } else {
            throw 'Range `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'Range `field` is missing from argument.';
        }
        if (query.from === undefined) {
            throw 'Range `from` is missing from argument.';
        }
        if (query.to === undefined) {
            throw 'Range `to` is missing from argument.';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],86:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'Terms `field` ' + field + ' is not of type `string` in meta data.';
            }
        } else {
            throw 'Terms `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'Terms `field` is missing from argument.';
        }
        if (query.terms === undefined) {
            throw 'Terms `terms` are missing from argument.';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],87:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');

    var Community = Live.extend({

        type: 'community',

        extractExtrema: function extractExtrema() {
            return {
                min: Infinity,
                max: -Infinity
            };
        }
    });

    module.exports = Community;
})();

},{"../core/Live":74}],88:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');

    var Count = Live.extend({

        includes: [
        // params
        Elastic, Tiling],

        type: 'count',

        // extreme not relevant for count tile
        extractExtrema: function extractExtrema() {
            return {
                min: Infinity,
                max: -Infinity
            };
        }
    });

    module.exports = Count;
})();

},{"../core/Live":74,"../param/Elastic":78,"../param/Tiling":79}],89:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Binning = require('../param/Binning');
    var Metric = require('../agg/Metric');

    var Heatmap = Live.extend({

        includes: [
        // params
        Elastic, Binning,
        // aggs
        Metric],

        type: 'heatmap',

        extractExtrema: function extractExtrema(data) {
            var bins = new Float64Array(data);
            return {
                min: _.min(bins),
                max: _.max(bins)
            };
        }

    });

    module.exports = Heatmap;
})();

},{"../agg/Metric":65,"../core/Live":74,"../param/Binning":77,"../param/Elastic":78}],90:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Binning = require('../param/Binning');

    var Macro = Live.extend({

        includes: [
        // params
        Elastic, Binning],

        type: 'macro',

        extractExtrema: function extractExtrema(data) {
            var bins = new Float64Array(data);
            return {
                min: _.min(bins),
                max: _.max(bins)
            };
        }

    });

    module.exports = Macro;
})();

},{"../core/Live":74,"../param/Binning":77,"../param/Elastic":78}],91:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var TopHits = require('../agg/TopHits');

    var Micro = Live.extend({

        includes: [
        // params
        Elastic, Tiling,
        // aggs
        TopHits],

        type: 'micro',

        // extreme not relevant for micro
        extractExtrema: function extractExtrema() {
            return {
                min: Infinity,
                max: -Infinity
            };
        }
    });

    module.exports = Micro;
})();

},{"../agg/TopHits":68,"../core/Live":74,"../param/Elastic":78,"../param/Tiling":79}],92:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Binning = require('../param/Binning');
    var TopHits = require('../agg/TopHits');

    var Preview = Live.extend({

        includes: [
        // params
        Elastic, Binning,
        // aggs
        TopHits],

        type: 'preview',

        // extreme not relevant for preview
        extractExtrema: function extractExtrema() {
            return {
                min: Infinity,
                max: -Infinity
            };
        }
    });

    module.exports = Preview;
})();

},{"../agg/TopHits":68,"../core/Live":74,"../param/Binning":77,"../param/Elastic":78}],93:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var TopTerms = require('../agg/TopTerms');
    var Histogram = require('../agg/Histogram');

    var TopCount = Live.extend({

        includes: [
        // params
        Elastic, Tiling, TopTerms,
        // aggs
        Histogram],

        type: 'top_count'

    });

    module.exports = TopCount;
})();

},{"../agg/Histogram":64,"../agg/TopTerms":69,"../core/Live":74,"../param/Elastic":78,"../param/Tiling":79}],94:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var TopTerms = require('../agg/TopTerms');
    var DateHistogram = require('../agg/DateHistogram');
    var Histogram = require('../agg/Histogram');

    var TopFrequency = Live.extend({

        includes: [
        // params
        Elastic, Tiling,
        // aggs
        TopTerms, DateHistogram, Histogram],

        type: 'top_frequency'

    });

    module.exports = TopFrequency;
})();

},{"../agg/DateHistogram":63,"../agg/Histogram":64,"../agg/TopTerms":69,"../core/Live":74,"../param/Elastic":78,"../param/Tiling":79}],95:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Binning = require('../param/Binning');
    var Terms = require('../agg/Terms');

    var TopTrails = Live.extend({

        includes: [
        // params
        Elastic, Binning,
        // aggs
        Terms],

        type: 'top_trails',

        extractExtrema: function extractExtrema() {
            return {
                min: Infinity,
                max: -Infinity
            };
        }

    });

    module.exports = TopTrails;
})();

},{"../agg/Terms":66,"../core/Live":74,"../param/Binning":77,"../param/Elastic":78}],96:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var TermsFilter = require('../agg/TermsFilter');
    var Histogram = require('../agg/Histogram');

    var TopicCount = Live.extend({

        includes: [
        // params
        Elastic, Tiling,
        // aggs
        TermsFilter, Histogram],

        type: 'topic_count'

    });

    module.exports = TopicCount;
})();

},{"../agg/Histogram":64,"../agg/TermsFilter":67,"../core/Live":74,"../param/Elastic":78,"../param/Tiling":79}],97:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var TermsFilter = require('../agg/TermsFilter');
    var DateHistogram = require('../agg/DateHistogram');
    var Histogram = require('../agg/Histogram');

    var TopicFrequency = Live.extend({

        includes: [
        // params            
        Elastic, Tiling,
        // aggs
        TermsFilter, DateHistogram, Histogram],

        type: 'topic_frequency'

    });

    module.exports = TopicFrequency;
})();

},{"../agg/DateHistogram":63,"../agg/Histogram":64,"../agg/TermsFilter":67,"../core/Live":74,"../param/Elastic":78,"../param/Tiling":79}],98:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var resetMouseCursorStyle = function resetMouseCursorStyle() {
        // we only want this bound ONCE per map
        $(this._container).css('cursor', '');
    };

    var Map = L.Map.extend({

        initialize: function initialize() {
            L.Map.prototype.initialize.apply(this, arguments);
            this.on('mousemove', resetMouseCursorStyle, this);
        }

    });

    module.exports = Map;
})();

},{}],99:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    // cartesian projection in (0,0), (256, 256) coordinate space

    L.Projection.Graph = {

        project: function project(latlng) {
            return new L.Point(latlng.lng, latlng.lat);
        },

        unproject: function unproject(point) {
            return new L.LatLng(point.y, point.x);
        },

        bounds: L.bounds([0, 0], [256, 256])
    };

    module.exports = L.Projection.Graph;
})();

},{}],100:[function(require,module,exports){
arguments[4][61][0].apply(exports,arguments)
},{"./Graph":99,"dup":61}],101:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DOM = require('./DOM');

    var Canvas = DOM.extend({

        onAdd: function onAdd(map) {
            DOM.prototype.onAdd.call(this, map);
            // handlers
            map.on('click', this.onClick, this);
            map.on('mousemove', this.onMouseMove, this);
        },

        onRemove: function onRemove(map) {
            // handlers
            map.off('click', this.onClick, this);
            map.off('mousemove', this.onMouseMove, this);
            DOM.prototype.onRemove.call(this, map);
        },

        createTile: function createTile(coords, done) {
            var tile = L.DomUtil.create('canvas', 'leaflet-tile');
            tile.style['pointer-events'] = 'all';
            tile.width = this.options.tileSize;
            tile.height = this.options.tileSize;
            this._requestTile(coords, tile, function () {
                done(null, tile);
            });
            return tile;
        },

        clearTiles: function clearTiles() {
            var tileSize = this.options.tileSize;
            _.forIn(this._tiles, function (tile) {
                var ctx = tile.el.getContext('2d');
                ctx.clearRect(0, 0, tileSize, tileSize);
            });
        },

        onMouseMove: function onMouseMove() {
            // override
        },

        onClick: function onClick() {
            // override
        }

    });

    module.exports = Canvas;
})();

},{"./DOM":102}],102:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Base = require('../../layer/core/Base');

    var DOM = Base.extend({

        onAdd: function onAdd(map) {
            L.GridLayer.prototype.onAdd.call(this, map);
            map.on('zoomstart', this.clearExtrema, this);
            this.on('tileunload', this.onTileUnload, this);
            this.on('cacheload', this.onCacheLoad, this);
            this.on('cachehit', this.onCacheHit, this);
            this.on('cacheunload', this.onCacheUnload, this);
            this.on('extremachange', this.onExtremaChange, this);
        },

        onRemove: function onRemove(map) {
            L.GridLayer.prototype.onRemove.call(this, map);
            map.off('zoomstart', this.clearExtrema, this);
            this.off('tileunload', this.onTileUnload, this);
            this.off('cacheload', this.onCacheLoad, this);
            this.off('cachehit', this.onCacheHit, this);
            this.off('cacheunload', this.onCacheUnload, this);
            this.off('extremachange', this.onExtremaChange, this);
        },

        onCacheHit: function onCacheHit(event) {
            var cached = event.entry;
            var tile = event.tile;
            var coords = event.coords;
            // data exists, render only this tile
            if (cached.data) {
                this.renderTile(tile, cached.data, coords);
            }
        },

        onCacheLoad: function onCacheLoad(event) {
            var _this = this;

            // same extrema, we are good to render the tiles. In
            // the case of a map with wraparound, we may have
            // multiple tiles dependent on the response, so iterate
            // over each tile and draw it.
            var cached = event.entry;
            var coords = event.coords;
            if (cached.data) {
                _.forIn(cached.tiles, function (tile) {
                    _this.renderTile(tile, cached.data, coords);
                });
            }
        },

        onExtremaChange: function onExtremaChange() {
            var _this2 = this;

            // redraw all tiles
            _.forIn(this._cache, function (cached) {
                _.forIn(cached.tiles, function (tile, key) {
                    if (cached.data) {
                        _this2.renderTile(tile, cached.data, _this2.coordFromCacheKey(key));
                    }
                });
            });
        },

        onCacheUnload: function onCacheUnload() {
            // override
        },

        createTile: function createTile() {
            // override
        },

        renderTile: function renderTile() {
            // override
        }
    });

    module.exports = DOM;
})();

},{"../../layer/core/Base":70}],103:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DOM = require('./DOM');

    var HTML = DOM.extend({

        onAdd: function onAdd(map) {
            var _this = this;

            DOM.prototype.onAdd.call(this, map);
            // handlers
            map.on('click', this.onClick, this);
            $(this._container).on('mousemove', function (event) {
                _this.onMouseMove(event);
            });
            $(this._container).on('mouseover', function (event) {
                _this.onMouseOver(event);
            });
            $(this._container).on('mouseout', function (event) {
                _this.onMouseOut(event);
            });
        },

        onRemove: function onRemove(map) {
            // handlers
            map.off('click', this.onClick, this);
            $(this._container).off('mousemove');
            $(this._container).off('mouseover');
            $(this._container).off('mouseout');
            DOM.prototype.onRemove.call(this, map);
        },

        createTile: function createTile(coords, done) {
            var tile = L.DomUtil.create('div', 'leaflet-tile leaflet-html-tile');
            tile.width = this.options.tileSize;
            tile.height = this.options.tileSize;
            this._requestTile(coords, tile, function () {
                done(null, tile);
            });
            return tile;
        },

        onMouseMove: function onMouseMove() {
            // override
        },

        onMouseOver: function onMouseOver() {
            // override
        },

        onMouseOut: function onMouseOut() {
            // override
        },

        onClick: function onClick() {
            // override
        }

    });

    module.exports = HTML;
})();

},{"./DOM":102}],104:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Base = require('../../layer/core/Base');

    var NO_OP = function NO_OP() {};

    var Overlay = Base.extend({

        options: {
            zIndex: 1
        },

        onAdd: function onAdd(map) {
            this.on('tileunload', this.onTileUnload, this);
            this.on('cacheload', this.onCacheLoad, this);
            this.on('cachehit', this.onCacheHit, this);
            this.on('cacheunload', this.onCacheUnload, this);
            this.on('extremachange', this.onExtremaChange, this);
            this._tiles = {};
            this._initContainer();
            // add event handlers
            map.on('click', this.onClick, this);
            map.on('mousemove', this.onMouseMove, this);
            this._resetView();
            this._update();
        },

        onRemove: function onRemove(map) {
            // remove layer
            this._removeAllTiles();
            L.DomUtil.remove(this._container);
            map._removeZoomLimit(this);
            this._tileZoom = null;
            // remove handlers
            this.off('tileunload', this.onTileUnload, this);
            this.off('cacheload', this.onCacheLoad, this);
            this.off('cachehit', this.onCacheHit, this);
            this.off('cacheunload', this.onCacheUnload, this);
            this.off('extremachange', this.onExtremaChange, this);
            map.off('click', this.onClick, this);
            map.off('mousemove', this.onMouseMove, this);
        },

        // No-op these functions
        _updateOpacity: NO_OP,
        _initTile: NO_OP,
        _updateLevels: NO_OP,
        _removeTilesAtZoom: NO_OP,
        _setZoomTransforms: NO_OP,

        _initContainer: function _initContainer() {
            if (!this._container) {
                this._container = document.createElement('canvas');
                this._container.className += 'leaflet-layer leaflet-zoom-animated';
            }
            this._updateZIndex();
            this.getPane().appendChild(this._container);
        },

        _pruneTiles: function _pruneTiles() {
            var _this = this;

            if (!this._map) {
                return;
            }
            var zoom = this._map.getZoom();
            if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
                this._removeAllTiles();
                return;
            }
            _.forIn(this._tiles, function (tile) {
                tile.retain = tile.current;
            });
            _.forIn(this._tiles, function (tile) {
                if (tile.current && !tile.active) {
                    var coords = tile.coords;
                    if (!_this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                        _this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
                    }
                }
            });
            _.forIn(this._tiles, function (tile, key) {
                if (!tile.retain) {
                    _this._removeTile(key);
                }
            });
        },

        _removeAllTiles: function _removeAllTiles() {
            var _this2 = this;

            _.forIn(this._tiles, function (tile, key) {
                _this2._removeTile(key);
            });
        },

        _invalidateAll: function _invalidateAll() {
            this._removeAllTiles();
            this._tileZoom = null;
        },

        _setView: function _setView(center, zoom, noPrune, noUpdate) {
            var tileZoom = Math.round(zoom);
            if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {
                tileZoom = undefined;
            }
            var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
            if (!noUpdate || tileZoomChanged) {
                this._tileZoom = tileZoom;
                if (this._abortLoading) {
                    this._abortLoading();
                }
                this._resetGrid();
                if (tileZoom !== undefined) {
                    this._update(center);
                }
                if (!noPrune) {
                    this._pruneTiles();
                }
            }
            this._setZoomTransform(center, zoom);
        },

        _setZoomTransform: function _setZoomTransform(center, zoom) {
            var currentCenter = this._map.getCenter();
            var currentZoom = this._map.getZoom();
            var scale = this._map.getZoomScale(zoom, currentZoom);
            var position = L.DomUtil.getPosition(this._container);
            var viewHalf = this._map.getSize().multiplyBy(0.5);
            var currentCenterPoint = this._map.project(currentCenter, zoom);
            var destCenterPoint = this._map.project(center, zoom);
            var centerOffset = destCenterPoint.subtract(currentCenterPoint);
            var topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);
            if (L.Browser.any3d) {
                L.DomUtil.setTransform(this._container, topLeftOffset, scale);
            } else {
                L.DomUtil.setPosition(this._container, topLeftOffset);
            }
        },

        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function _update(center) {
            var map = this._map;
            if (!map) {
                return;
            }
            var zoom = map.getZoom();
            if (center === undefined) {
                center = map.getCenter();
            }
            if (this._tileZoom === undefined) {
                // if out of minzoom/maxzoom
                return;
            }
            var pixelBounds = this._getTiledPixelBounds(center),
                tileRange = this._pxBoundsToTileRange(pixelBounds),
                tileCenter = tileRange.getCenter(),
                queue = [];

            _.forIn(this._tiles, function (tile) {
                tile.current = false;
            });
            // _update just loads more tiles. If the tile zoom level differs too much
            // from the map's, let _setView reset levels and prune old tiles.
            if (Math.abs(zoom - this._tileZoom) > 1) {
                this._setView(center, zoom);
                return;
            }
            // create a queue of coordinates to load tiles from
            var i = void 0,
                j = void 0;
            for (j = tileRange.min.y; j <= tileRange.max.y; j++) {
                for (i = tileRange.min.x; i <= tileRange.max.x; i++) {
                    var coords = new L.Point(i, j);
                    coords.z = this._tileZoom;

                    if (!this._isValidTile(coords)) {
                        continue;
                    }

                    var tile = this._tiles[this._tileCoordsToKey(coords)];
                    if (tile) {
                        tile.current = true;
                    } else {
                        queue.push(coords);
                    }
                }
            }
            // sort tile queue to load tiles in order of their distance to center
            queue.sort(function (a, b) {
                return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
            });
            if (queue.length !== 0) {
                // if its the first batch of tiles to load
                if (!this._loading) {
                    this._loading = true;
                    // @event loading: Event
                    // Fired when the grid layer starts loading tiles
                    this.fire('loading');
                }
                for (i = 0; i < queue.length; i++) {
                    this._addTile(queue[i]);
                }
            }
        },

        _removeTile: function _removeTile(key) {
            var tile = this._tiles[key];
            if (!tile) {
                return;
            }
            delete this._tiles[key];
            // @event tileunload: TileEvent
            // Fired when a tile is removed (e.g. when a tile goes off the screen).
            this.fire('tileunload', {
                coords: this._keyToTileCoords(key)
            });
        },

        createTile: function createTile(coords, done) {
            var tile = {
                coords: coords,
                current: true
            };
            this._requestTile(coords, tile, function () {
                done(null, tile);
            });
            return tile;
        },

        _addTile: function _addTile(coords) {

            var tile = this.createTile(coords, L.bind(this._tileReady, this, coords));
            var key = this._tileCoordsToKey(coords);
            this._tiles[key] = tile;

            // @event tileloadstart: TileEvent
            // Fired when a tile is requested and starts loading.
            this.fire('tileloadstart', {
                coords: coords
            });
        },

        _tileReady: function _tileReady(coords, err, tile) {
            if (!this._map) {
                return;
            }
            if (err) {
                // @event tileerror: TileErrorEvent
                // Fired when there is an error loading a tile.
                this.fire('tileerror', {
                    error: err,
                    tile: tile,
                    coords: coords
                });
            }
            // tile loaded
            tile.loaded = +new Date();
            tile.active = true;
            this._pruneTiles();

            // @event tileload: TileEvent
            // Fired when a tile loads.
            this.fire('tileload', {
                coords: coords,
                tile: tile
            });

            if (this._noTilesToLoad()) {
                this._loading = false;
                // @event load: Event
                // Fired when the grid layer loaded all visible tiles.
                this.fire('load');
                if (L.Browser.ielt9 || !this._map._fadeAnimated) {
                    L.Util.requestAnimFrame(this._pruneTiles, this);
                } else {
                    // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
                    // to trigger a pruning.
                    setTimeout(L.bind(this._pruneTiles, this), 250);
                }
            }
        },

        onCacheHit: function onCacheHit() {
            // override
        },

        onCacheLoad: function onCacheLoad() {
            // override
        },

        onExtremaChange: function onExtremaChange() {
            // override
        },

        onCacheUnload: function onCacheUnload() {
            // override
        },

        onMouseMove: function onMouseMove() {
            // override
        },

        onClick: function onClick() {
            // override
        }

    });

    module.exports = Overlay;
})();

},{"../../layer/core/Base":70}],105:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var esper = require('esper');
    var Overlay = require('./Overlay');

    var WebGL = Overlay.extend({

        onAdd: function onAdd(map) {
            Overlay.prototype.onAdd.call(this, map);
            map.on('zoomstart', this.onZoomStart, this);
            map.on('zoomend', this.onZoomEnd, this);
        },

        onRemove: function onRemove(map) {
            Overlay.prototype.onRemove.call(this, map);
            map.off('zoomstart', this.onZoomStart, this);
            map.off('zoomend', this.onZoomEnd, this);
        },

        onZoomStart: function onZoomStart() {
            this._isZooming = true;
        },

        onZoomEnd: function onZoomEnd() {
            this._isZooming = false;
            if (this._initialized) {
                var gl = this._gl;
                gl.clear(gl.COLOR_BUFFER_BIT);
                this.renderFrame();
            }
        },

        _initContainer: function _initContainer() {
            Overlay.prototype._initContainer.call(this);
            if (!this._gl) {
                this._initGL();
            } else {
                this._draw();
            }
            this._isZooming = false;
        },

        onWebGLInit: function onWebGLInit(done) {
            done(null);
        },

        _initGL: function _initGL() {
            var _this = this;

            var gl = this._gl = esper.WebGLContext.get(this._container);
            // handle missing context
            if (!gl) {
                throw 'Unable to acquire a WebGL context';
            }
            // init the webgl state
            gl.clearColor(0, 0, 0, 0);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            gl.disable(gl.DEPTH_TEST);
            // get map size
            var size = this._map.getSize();
            var devicePixelRatio = window.devicePixelRatio;
            // set viewport size
            this._viewport = new esper.Viewport({
                width: size.x * devicePixelRatio,
                height: size.y * devicePixelRatio
            });
            // set canvas size
            this._gl.canvas.style.width = size.x + 'px';
            this._gl.canvas.style.height = size.y + 'px';
            // webgl init callback
            this.onWebGLInit(function (err) {
                if (err) {
                    console.error(err);
                    return;
                }
                // flag as ready
                _this._initialized = true;
                // start draw loop
                _this._draw();
            });
        },

        getTranslationMatrix: function getTranslationMatrix(x, y, z) {
            var mat = new Float32Array(16);
            mat[0] = 1;
            mat[1] = 0;
            mat[2] = 0;
            mat[3] = 0;
            mat[4] = 0;
            mat[5] = 1;
            mat[6] = 0;
            mat[7] = 0;
            mat[8] = 0;
            mat[9] = 0;
            mat[10] = 1;
            mat[11] = 0;
            mat[12] = x;
            mat[13] = y;
            mat[14] = z;
            mat[15] = 1;
            return mat;
        },

        getOrthoMatrix: function getOrthoMatrix(left, right, bottom, top, near, far) {
            var mat = new Float32Array(16);
            mat[0] = 2 / (right - left);
            mat[1] = 0;
            mat[2] = 0;
            mat[3] = 0;
            mat[4] = 0;
            mat[5] = 2 / (top - bottom);
            mat[6] = 0;
            mat[7] = 0;
            mat[8] = 0;
            mat[9] = 0;
            mat[10] = -2 / (far - near);
            mat[11] = 0;
            mat[12] = -((right + left) / (right - left));
            mat[13] = -((top + bottom) / (top - bottom));
            mat[14] = -((far + near) / (far - near));
            mat[15] = 1;
            return mat;
        },

        _positionContainer: function _positionContainer() {
            var size = this._map.getSize();
            var devicePixelRatio = window.devicePixelRatio;
            // set viewport size
            this._viewport.resize(size.x * devicePixelRatio, size.y * devicePixelRatio);
            // set canvas size
            this._gl.canvas.style.width = size.x + 'px';
            this._gl.canvas.style.height = size.y + 'px';
            // re-position container
            var topLeft = this._map.containerPointToLayerPoint([0, 0]);
            L.DomUtil.setPosition(this._container, topLeft);
        },

        _draw: function _draw() {
            if (this._map && this._initialized) {
                if (!this.isHidden()) {
                    // re-position canvas
                    if (!this._isZooming) {
                        // position the container and resize viewport
                        this._positionContainer();
                        // clear buffer
                        var gl = this._gl;
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        // draw the frame
                        this.renderFrame();
                    }
                }
                requestAnimationFrame(this._draw.bind(this));
            }
        },

        renderFrame: function renderFrame() {
            // implement this
        }

    });

    module.exports = WebGL;
})();

},{"./Overlay":104,"esper":24}],106:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Core = {
        HTML: require('./core/HTML'),
        WebGL: require('./core/WebGL'),
        Canvas: require('./core/Canvas')
    };

    // canvas renderers
    var Canvas = {
        Heatmap: require('./type/canvas/Heatmap'),
        TopTrails: require('./type/canvas/TopTrails'),
        Preview: require('./type/canvas/Preview')
    };

    // html renderers
    var HTML = {
        Empty: require('./type/html/Empty'),
        Heatmap: require('./type/html/Heatmap'),
        Ring: require('./type/html/Ring'),
        WordCloud: require('./type/html/WordCloud'),
        WordHistogram: require('./type/html/WordHistogram'),
        Community: require('./type/html/Community'),
        CommunityLabel: require('./type/html/CommunityLabel')
    };

    // webgl renderers
    var WebGL = {
        Heatmap: require('./type/webgl/Heatmap'),
        Point: require('./type/webgl/Point')
    };

    // pending layer renderers
    var Pending = {
        DelayedBlink: require('./type/pending/DelayedBlink'),
        DelayedSpin: require('./type/pending/DelayedSpin'),
        Blink: require('./type/pending/Blink'),
        Spin: require('./type/pending/Spin'),
        BlinkSpin: require('./type/pending/BlinkSpin')
    };

    // pending layer renderers
    var Debug = {
        Coord: require('./type/debug/Coord')
    };

    module.exports = {
        Core: Core,
        HTML: HTML,
        Canvas: Canvas,
        WebGL: WebGL,
        Debug: Debug,
        Pending: Pending
    };
})();

},{"./core/Canvas":101,"./core/HTML":103,"./core/WebGL":105,"./type/canvas/Heatmap":111,"./type/canvas/Preview":112,"./type/canvas/TopTrails":113,"./type/debug/Coord":114,"./type/html/Community":115,"./type/html/CommunityLabel":116,"./type/html/Empty":117,"./type/html/Heatmap":118,"./type/html/Ring":119,"./type/html/WordCloud":120,"./type/html/WordHistogram":121,"./type/pending/Blink":122,"./type/pending/BlinkSpin":123,"./type/pending/DelayedBlink":124,"./type/pending/DelayedSpin":125,"./type/pending/Spin":126,"./type/webgl/Heatmap":127,"./type/webgl/Point":128}],107:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var NUM_GRADIENT_STEPS = 100;

    function rgb2lab(rgb) {
        var r = rgb[0] > 0.04045 ? Math.pow((rgb[0] + 0.055) / 1.055, 2.4) : rgb[0] / 12.92;
        var g = rgb[1] > 0.04045 ? Math.pow((rgb[1] + 0.055) / 1.055, 2.4) : rgb[1] / 12.92;
        var b = rgb[2] > 0.04045 ? Math.pow((rgb[2] + 0.055) / 1.055, 2.4) : rgb[2] / 12.92;
        //Observer. = 2°, Illuminant = D65
        var x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;
        var y = r * 0.2126729 + g * 0.7151522 + b * 0.0721750;
        var z = r * 0.0193339 + g * 0.1191920 + b * 0.9503041;
        x = x / 0.95047; // Observer= 2°, Illuminant= D65
        y = y / 1.00000;
        z = z / 1.08883;
        x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 16 / 116;
        y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787037 * y + 16 / 116;
        z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787037 * z + 16 / 116;
        return [116 * y - 16, 500 * (x - y), 200 * (y - z), rgb[3]];
    }

    function lab2rgb(lab) {
        var y = (lab[0] + 16) / 116;
        var x = y + lab[1] / 500;
        var z = y - lab[2] / 200;
        x = x > 0.206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
        y = y > 0.206893034 ? y * y * y : (y - 4 / 29) / 7.787037;
        z = z > 0.206893034 ? z * z * z : (z - 4 / 29) / 7.787037;
        x = x * 0.95047; // Observer= 2°, Illuminant= D65
        y = y * 1.00000;
        z = z * 1.08883;
        var r = x * 3.2404542 + y * -1.5371385 + z * -0.4985314;
        var g = x * -0.9692660 + y * 1.8760108 + z * 0.0415560;
        var b = x * 0.0556434 + y * -0.2040259 + z * 1.0572252;
        r = r > 0.00304 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : 12.92 * r;
        g = g > 0.00304 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : 12.92 * g;
        b = b > 0.00304 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : 12.92 * b;
        return [Math.max(Math.min(r, 1), 0), Math.max(Math.min(g, 1), 0), Math.max(Math.min(b, 1), 0), lab[3]];
    }

    function distance(c1, c2) {
        return Math.sqrt((c1[0] - c2[0]) * (c1[0] - c2[0]) + (c1[1] - c2[1]) * (c1[1] - c2[1]) + (c1[2] - c2[2]) * (c1[2] - c2[2]) + (c1[3] - c2[3]) * (c1[3] - c2[3]));
    }

    var buildFlatLookupTable = function buildFlatLookupTable(color) {
        var output = [];
        for (var i = 0; i < NUM_GRADIENT_STEPS; i++) {
            output.push(color[0]);
            output.push(color[1]);
            output.push(color[2]);
            output.push(color[3]);
        }
        return output;
    };

    // Interpolate between a set of colors using even perceptual distance and interpolation in CIE L*a*b* space
    var buildPerceptualLookupTable = function buildPerceptualLookupTable(baseColors) {
        var buffer = new ArrayBuffer(NUM_GRADIENT_STEPS * 4 * 4);
        var outputGradient = new Float32Array(buffer);
        // Calculate perceptual spread in L*a*b* space
        var labs = _.map(baseColors, function (color) {
            return rgb2lab([color[0] / 255, color[1] / 255, color[2] / 255, color[3] / 255]);
        });
        var distances = _.map(labs, function (color, index, colors) {
            return index > 0 ? distance(color, colors[index - 1]) : 0;
        });
        // Calculate cumulative distances in [0,1]
        var totalDistance = _.reduce(distances, function (a, b) {
            return a + b;
        }, 0);
        distances = _.map(distances, function (d) {
            return d / totalDistance;
        });
        var distanceTraversed = 0;
        var key = 0;
        var progress = void 0;
        var stepProgress = void 0;
        var rgb = void 0;
        for (var i = 0; i < NUM_GRADIENT_STEPS; i++) {
            progress = i / (NUM_GRADIENT_STEPS - 1);
            if (progress > distanceTraversed + distances[key + 1] && key + 1 < labs.length - 1) {
                key += 1;
                distanceTraversed += distances[key];
            }
            stepProgress = (progress - distanceTraversed) / distances[key + 1];
            rgb = lab2rgb([labs[key][0] + (labs[key + 1][0] - labs[key][0]) * stepProgress, labs[key][1] + (labs[key + 1][1] - labs[key][1]) * stepProgress, labs[key][2] + (labs[key + 1][2] - labs[key][2]) * stepProgress, labs[key][3] + (labs[key + 1][3] - labs[key][3]) * stepProgress]);
            outputGradient[i * 4] = rgb[0];
            outputGradient[i * 4 + 1] = rgb[1];
            outputGradient[i * 4 + 2] = rgb[2];
            outputGradient[i * 4 + 3] = rgb[3];
        }
        return outputGradient;
    };

    var COOL = buildPerceptualLookupTable([[0x04, 0x20, 0x40, 0x50], [0x08, 0x40, 0x81, 0x7f], [0x08, 0x68, 0xac, 0xff], [0x2b, 0x8c, 0xbe, 0xff], [0x4e, 0xb3, 0xd3, 0xff], [0x7b, 0xcc, 0xc4, 0xff], [0xa8, 0xdd, 0xb5, 0xff], [0xcc, 0xeb, 0xc5, 0xff], [0xe0, 0xf3, 0xdb, 0xff], [0xf7, 0xfc, 0xf0, 0xff]]);

    var HOT = buildPerceptualLookupTable([[0x40, 0x00, 0x13, 0x50], [0x80, 0x00, 0x26, 0x7f], [0xbd, 0x00, 0x26, 0xff], [0xe3, 0x1a, 0x1c, 0xff], [0xfc, 0x4e, 0x2a, 0xff], [0xfd, 0x8d, 0x3c, 0xff], [0xfe, 0xb2, 0x4c, 0xff], [0xfe, 0xd9, 0x76, 0xff], [0xff, 0xed, 0xa0, 0xff]]);

    var VERDANT = buildPerceptualLookupTable([[0x00, 0x40, 0x26, 0x50], [0x00, 0x5a, 0x32, 0x7f], [0x23, 0x84, 0x43, 0xff], [0x41, 0xab, 0x5d, 0xff], [0x78, 0xc6, 0x79, 0xff], [0xad, 0xdd, 0x8e, 0xff], [0xd9, 0xf0, 0xa3, 0xff], [0xf7, 0xfc, 0xb9, 0xff], [0xff, 0xff, 0xe5, 0xff]]);

    var SPECTRAL = buildPerceptualLookupTable([[0x26, 0x1a, 0x40, 0x50], [0x44, 0x2f, 0x72, 0x7f], [0xe1, 0x2b, 0x02, 0xff], [0x02, 0xdc, 0x01, 0xff], [0xff, 0xd2, 0x02, 0xff], [0xff, 0xff, 0xff, 0xff]]);

    var TEMPERATURE = buildPerceptualLookupTable([[0x00, 0x16, 0x40, 0x50], [0x00, 0x39, 0x66, 0x7f], [0x31, 0x3d, 0x66, 0xff], [0xe1, 0x2b, 0x02, 0xff], [0xff, 0xd2, 0x02, 0xff], [0xff, 0xff, 0xff, 0xff]]);

    var GREYSCALE = buildPerceptualLookupTable([[0x00, 0x00, 0x00, 0x7f], [0x40, 0x40, 0x40, 0xff], [0xff, 0xff, 0xff, 0xff]]);

    var POLAR_HOT = buildPerceptualLookupTable([[0xff, 0x44, 0x00, 0xff], [0xbd, 0xbd, 0xbd, 0xb0]]);

    var POLAR_COLD = buildPerceptualLookupTable([[0xbd, 0xbd, 0xbd, 0xb0], [0x32, 0xa5, 0xf9, 0xff]]);

    var FIRE = buildPerceptualLookupTable([[0x96, 0x00, 0x00, 0x96], [0xff, 0xff, 0x32, 0xff]]);

    var FLAT = buildFlatLookupTable([0xff, 0xff, 0xff, 0xff]);

    var buildLookupFunction = function buildLookupFunction(RAMP) {
        return function (scaledValue, inColor) {
            var index = Math.floor(scaledValue * (NUM_GRADIENT_STEPS - 1));
            inColor[0] = RAMP[index * 4];
            inColor[1] = RAMP[index * 4 + 1];
            inColor[2] = RAMP[index * 4 + 2];
            inColor[3] = RAMP[index * 4 + 3];
            return inColor;
        };
    };

    var concat = function concat(a, b) {
        var combined = new Float32Array(a.length + b.length);
        combined.set(a, 0);
        combined.set(b, a.length);
        return combined;
    };

    var ColorTables = {
        cool: COOL,
        hot: HOT,
        verdant: VERDANT,
        spectral: SPECTRAL,
        temperature: TEMPERATURE,
        grey: GREYSCALE,
        polar: concat(POLAR_HOT, POLAR_COLD),
        flat: FLAT
    };

    var ColorRamp = {
        cool: buildLookupFunction(COOL),
        hot: buildLookupFunction(HOT),
        verdant: buildLookupFunction(VERDANT),
        spectral: buildLookupFunction(SPECTRAL),
        temperature: buildLookupFunction(TEMPERATURE),
        grey: buildLookupFunction(GREYSCALE),
        fire: buildLookupFunction(FIRE),
        polar: buildLookupFunction(concat(POLAR_HOT, POLAR_COLD)),
        flat: buildLookupFunction(FLAT)
    };

    var setColorRamp = function setColorRamp(type, baseColors) {
        var func = ColorRamp[type.toLowerCase()];
        if (func) {
            this._colorRamp = func;
        } else if (baseColors) {
            ColorRamp[type.toLowerCase()] = buildLookupFunction(buildPerceptualLookupTable(baseColors));
            this._colorRamp = ColorRamp[type.toLowerCase()];
        }
        this._colorRampType = type.toLowerCase();
        return this;
    };

    var getColorRamp = function getColorRamp(type) {
        return this._colorRamp || ColorRamp[type.toLowerCase()];
    };

    var getColorRampTable = function getColorRampTable() {
        return ColorTables[this._colorRampType];
    };

    var initialize = function initialize() {
        this._colorRamp = ColorRamp.verdant;
        this._colorRampType = 'verdant';
    };

    module.exports = {
        initialize: initialize,
        setColorRamp: setColorRamp,
        getColorRamp: getColorRamp,
        getColorRampTable: getColorRampTable,
        NUM_GRADIENT_STEPS: NUM_GRADIENT_STEPS
    };
})();

},{}],108:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var TILE_SIZE = 256;

    function fract(f) {
        return f % 1;
    }

    function mod(n, m) {
        return (n % m + m) % m;
    }

    function getHash(lx, ly, radius) {
        var diameter = radius * 2;
        var xHash = Math.floor(lx / diameter);
        var yHash = Math.floor(ly / diameter);
        return xHash + ':' + yHash;
    }

    function getHashes(lx, ly, radius, zoom) {
        var diameter = radius * 2;
        var numCells = Math.ceil(Math.pow(2, zoom) * TILE_SIZE / diameter);
        var x = lx / diameter;
        var y = ly / diameter;
        var fx = fract(x);
        var fy = fract(y);
        var px = fx > 0.5;
        var nx = fx < 0.5;
        var py = fy > 0.5;
        var ny = fy < 0.5;
        var cx = Math.floor(x);
        var cy = Math.floor(y);
        var cells = [[cx, cy]];
        if (px) {
            cells.push([cx + 1, cy]);
        }
        if (py) {
            cells.push([cx, cy + 1]);
        }
        if (nx) {
            cells.push([cx - 1, cy]);
        }
        if (ny) {
            cells.push([cx, cy - 1]);
        }
        if (nx && ny) {
            cells.push([cx - 1, cy - 1]);
        }
        if (px && py) {
            cells.push([cx + 1, cy + 1]);
        }
        if (nx && py) {
            cells.push([cx - 1, cy + 1]);
        }
        if (px && ny) {
            cells.push([cx + 1, cy - 1]);
        }
        // return hashes
        return cells.map(function (cell) {
            // mod the cell coords if they overflow
            cell[0] = mod(cell[0], numCells);
            cell[1] = mod(cell[1], numCells);
            // hash
            return cell[0] + ':' + cell[1];
        });
    }

    function circleCollision(point, origin, radius, zoom) {
        var dim = Math.pow(2, zoom) * TILE_SIZE;
        var p = void 0,
            o = void 0;
        // check cases where the point is near the opposing horizontal extrema
        // of the map and ensure that the distance calculated is the shortest
        if (point.x < radius && dim - origin.x < radius) {
            p = point;
            o = {
                x: origin.x - dim,
                y: origin.y
            };
        } else if (dim - point.x < radius && origin.x < radius) {
            p = {
                x: point.x - dim,
                y: point.y
            };
            o = origin;
        } else {
            p = point;
            o = origin;
        }
        var dx = p.x - o.x;
        var dy = p.y - o.y;
        var distSqr = dx * dx + dy * dy;
        if (distSqr < radius * radius) {
            return true;
        }
        return false;
    }

    function initialize() {
        this.clearHash();
    }

    function clearHash() {
        this._spatialHash = {};
    }

    function addPoint(point, radius, zoom) {
        // spatial hash key
        var x = point.x;
        var y = point.y;
        var hashes = getHashes(x, y, radius, zoom);
        // add pixel to hash
        var i = void 0;
        for (i = 0; i < hashes.length; i++) {
            var hash = hashes[i];
            this._spatialHash[hash] = this._spatialHash[hash] || [];
            this._spatialHash[hash].push(point);
        }
    }

    function removePoint(point, radius, zoom) {
        // spatial hash key
        var hashes = getHashes(point.x, point.y, radius, zoom);
        // add pixel to hash
        var i = void 0;
        for (i = 0; i < hashes.length; i++) {
            var hash = hashes[i];
            var points = this._spatialHash[hash];
            if (points) {
                var index = points.indexOf(point);
                if (index >= 0) {
                    points.splice(index, 1);
                }
            }
        }
    }

    function pick(point, radius, zoom) {
        var hash = getHash(point.x, point.y, radius);
        // get points in bin
        var points = this._spatialHash[hash];
        if (points) {
            // find first intersecting point in the bin
            var p = void 0,
                i = void 0;
            for (i = 0; i < points.length; i++) {
                p = points[i];
                // check for collision
                if (circleCollision(point, p, radius, zoom)) {
                    // return first point
                    return p;
                }
            }
        }
    }

    module.exports = {
        initialize: initialize,
        clearHash: clearHash,
        addPoint: addPoint,
        removePoint: removePoint,
        pick: pick
    };
})();

},{}],109:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var SIGMOID_SCALE = 0.15;

    // log10

    function log10Transform(val, min, max) {
        var logMin = Math.log10(min || 1);
        var logMax = Math.log10(max || 1);
        var logVal = Math.log10(val || 1);
        return (logVal - logMin) / (logMax - logMin || 1);
    }

    function inverseLog10Transform(nval, min, max) {
        var logMin = Math.log10(min || 1);
        var logMax = Math.log10(max || 1);
        return Math.pow(10, nval * logMax - nval * logMin + logMin);
    }

    // sigmoid

    function sigmoidTransform(val, min, max) {
        var absMin = Math.abs(min);
        var absMax = Math.abs(max);
        var distance = Math.max(absMin, absMax);
        var scaledVal = val / (SIGMOID_SCALE * distance);
        return 1 / (1 + Math.exp(-scaledVal));
    }

    function inverseSigmoidTransform(nval, min, max) {
        var absMin = Math.abs(min);
        var absMax = Math.abs(max);
        var distance = Math.max(absMin, absMax);
        if (nval === 0) {
            return -distance;
        }
        if (nval === 1) {
            return distance;
        }
        return Math.log(1 / nval - 1) * -(SIGMOID_SCALE * distance);
    }

    // linear

    function linearTransform(val, min, max) {
        var range = max - min;
        if (range === 0) {
            return 1;
        }
        return (val - min) / range;
    }

    function inverseLinearTransform(nval, min, max) {
        var range = max - min;
        if (range === 0) {
            return 1;
        }
        return min + nval * range;
    }

    var Transform = {
        linear: linearTransform,
        log10: log10Transform,
        sigmoid: sigmoidTransform
    };

    var Inverse = {
        linear: inverseLinearTransform,
        log10: inverseLog10Transform,
        sigmoid: inverseSigmoidTransform
    };

    var initialize = function initialize() {
        this._range = {
            min: 0,
            max: 1
        };
        this._transformFunc = log10Transform;
        this._inverseFunc = inverseLog10Transform;
    };

    var setTransformFunc = function setTransformFunc(type) {
        var func = type.toLowerCase();
        this._transformFunc = Transform[func];
        this._transformType = type;
        this._inverseFunc = Inverse[func];
    };

    var setValueRange = function setValueRange(range) {
        this._range.min = range.min;
        this._range.max = range.max;
    };

    var getValueRange = function getValueRange() {
        return this._range;
    };

    var getTransformEnum = function getTransformEnum() {
        if (this._transformType === 'linear') {
            return 1;
        } else if (this._transformType === 'sigmoid') {
            return 2;
        }
        return 0;
    };

    var interpolateToRange = function interpolateToRange(nval) {
        // interpolate between the filter range
        var rMin = this._range.min;
        var rMax = this._range.max;
        var rval = (nval - rMin) / (rMax - rMin);
        // ensure output is [0:1]
        return Math.max(0, Math.min(1, rval));
    };

    var transformValue = function transformValue(val) {
        // clamp the value between the extreme (shouldn't be necessary)
        var min = this._extrema.min;
        var max = this._extrema.max;
        var clamped = Math.max(Math.min(val, max), min);
        // normalize the value
        if (min !== max) {
            return this._transformFunc(clamped, min, max);
        }
        // if min === max, always return 1
        return 1;
    };

    var untransformValue = function untransformValue(nval) {
        var min = this._extrema.min;
        var max = this._extrema.max;
        // clamp the value between the extreme (shouldn't be necessary)
        var clamped = Math.max(Math.min(nval, 1), 0);
        // unnormalize the value
        if (min !== max) {
            return this._inverseFunc(clamped, min, max);
        }
        // if min === max, always return 1
        return 1;
    };

    module.exports = {
        initialize: initialize,
        setTransformFunc: setTransformFunc,
        setValueRange: setValueRange,
        getValueRange: getValueRange,
        getTransformEnum: getTransformEnum,
        transformValue: transformValue,
        untransformValue: untransformValue,
        interpolateToRange: interpolateToRange
    };
})();

},{}],110:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var POSITIVE = '1';
    var NEUTRAL = '0';
    var NEGATIVE = '-1';

    function getClassFunc(min, max) {
        min = min !== undefined ? min : -1;
        max = max !== undefined ? max : 1;
        var positive = [0.25 * max, 0.5 * max, 0.75 * max];
        var negative = [-0.25 * min, -0.5 * min, -0.75 * min];
        return function (sentiment) {
            var prefix = void 0;
            var range = void 0;
            if (sentiment < 0) {
                prefix = 'neg-';
                range = negative;
            } else {
                prefix = 'pos-';
                range = positive;
            }
            var abs = Math.abs(sentiment);
            if (abs > range[2]) {
                return prefix + '4';
            } else if (abs > range[1]) {
                return prefix + '3';
            } else if (abs > range[0]) {
                return prefix + '2';
            }
            return prefix + '1';
        };
    }

    function getTotal(count) {
        if (!count) {
            return 0;
        }
        var pos = count[POSITIVE] ? count[POSITIVE] : 0;
        var neu = count[NEUTRAL] ? count[NEUTRAL] : 0;
        var neg = count[NEGATIVE] ? count[NEGATIVE] : 0;
        return pos + neu + neg;
    }

    function getAvg(count) {
        if (!count) {
            return 0;
        }
        var pos = count[POSITIVE] ? count[POSITIVE] : 0;
        var neu = count[NEUTRAL] ? count[NEUTRAL] : 0;
        var neg = count[NEGATIVE] ? count[NEGATIVE] : 0;
        var total = pos + neu + neg;
        return total !== 0 ? (pos - neg) / total : 0;
    }

    module.exports = {
        getClassFunc: getClassFunc,
        getTotal: getTotal,
        getAvg: getAvg
    };
})();

},{}],111:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Canvas = require('../../core/Canvas');
    var ColorRamp = require('../../mixin/ColorRamp');
    var ValueTransform = require('../../mixin/ValueTransform');

    var Heatmap = Canvas.extend({

        includes: [
        // mixins
        ColorRamp, ValueTransform],

        initialize: function initialize() {
            ColorRamp.initialize.apply(this, arguments);
            ValueTransform.initialize.apply(this, arguments);
        },

        renderCanvas: function renderCanvas(bins, resolution, ramp) {
            var canvas = document.createElement('canvas');
            canvas.height = resolution;
            canvas.width = resolution;
            var ctx = canvas.getContext('2d');
            var imageData = ctx.getImageData(0, 0, resolution, resolution);
            var data = imageData.data;
            var color = [0, 0, 0, 0];
            var nval = void 0,
                rval = void 0,
                bin = void 0,
                i = void 0;
            for (i = 0; i < bins.length; i++) {
                bin = bins[i];
                if (bin === 0) {
                    color[0] = 0;
                    color[1] = 0;
                    color[2] = 0;
                    color[3] = 0;
                } else {
                    nval = this.transformValue(bin);
                    rval = this.interpolateToRange(nval);
                    ramp(rval, color);
                }
                data[i * 4] = Math.round(color[0] * 255);
                data[i * 4 + 1] = Math.round(color[1] * 255);
                data[i * 4 + 2] = Math.round(color[2] * 255);
                data[i * 4 + 3] = Math.round(color[3] * 255);
            }
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        },

        renderTile: function renderTile(canvas, data) {
            if (!data) {
                return;
            }
            var bins = new Float64Array(data);
            var resolution = Math.sqrt(bins.length);
            var ramp = this.getColorRamp();
            var tileCanvas = this.renderCanvas(bins, resolution, ramp);
            var ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(tileCanvas, 0, 0, resolution, resolution, 0, 0, canvas.width, canvas.height);
        }

    });

    module.exports = Heatmap;
})();

},{"../../core/Canvas":101,"../../mixin/ColorRamp":107,"../../mixin/ValueTransform":109}],112:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

(function () {

    'use strict';

    var Canvas = require('../../core/Canvas');

    var Preview = Canvas.extend({

        options: {
            lineWidth: 1,
            lineColor: '#fff'
        },

        highlighted: false,

        _drawHighlight: function _drawHighlight(canvas, x, y, size) {
            var ctx = canvas.getContext('2d');
            ctx.beginPath();
            ctx.fillStyle = this.options.fillColor;
            ctx.rect(x * size, y * size, size, size);
            ctx.lineWidth = this.options.lineWidth;
            ctx.strokeStyle = this.options.lineColor;
            ctx.stroke();
        },

        onMouseMove: function onMouseMove(e) {
            var _this = this;

            var target = e.originalEvent.target;
            if (this.highlighted) {
                // clear existing highlight
                this.clearTiles();
            }
            // get layer coord
            var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
            // get tile coord
            var coord = this.getTileCoordFromLayerPoint(layerPoint);
            // get cache key
            var nkey = this.cacheKeyFromCoord(coord, true);
            // get cache entry
            var cached = this._cache[nkey];
            if (cached && cached.data) {
                var _ret = function () {
                    // get bin coordinate
                    var bin = _this.getBinCoordFromLayerPoint(layerPoint);
                    // get bin data entry
                    var data = cached.data[bin.index];
                    if (data) {
                        // for each tile relying on that data
                        _.forIn(cached.tiles, function (tile) {
                            _this._drawHighlight(tile, bin.x, bin.y, bin.size);
                        });
                        var collision = {
                            value: data,
                            x: coord.x,
                            y: coord.z,
                            z: coord.z,
                            bx: bin.x,
                            by: bin.y,
                            type: 'preview',
                            layer: _this
                        };
                        if (!_this.highlighted) {
                            // execute callback
                            _this.fire('mouseover', {
                                elem: target,
                                value: collision
                            });
                        }
                        // flag as highlighted
                        _this.highlighted = collision;
                        // set cursor
                        $(_this._map._container).css('cursor', 'pointer');
                        return {
                            v: void 0
                        };
                    }
                }();

                if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
            }
            // mouse out
            if (this.highlighted) {
                this.fire('mouseout', {
                    elem: target,
                    value: this.highlighted
                });
            }
            // clear highlighted flag
            this.highlighted = null;
        }

    });

    module.exports = Preview;
})();

},{"../../core/Canvas":101}],113:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Canvas = require('../../core/Canvas');
    var ColorRamp = require('../../mixin/ColorRamp');
    var ValueTransform = require('../../mixin/ValueTransform');

    var TopTrails = Canvas.extend({

        includes: [
        // mixins
        ColorRamp, ValueTransform],

        options: {
            selectedColor: [255, 100, 255, 255],
            highlightedColor: [200, 0, 255, 255],
            downSampleFactor: 8
        },

        highlighted: null,

        selected: null,

        initialize: function initialize() {
            ColorRamp.initialize.apply(this, arguments);
            ValueTransform.initialize.apply(this, arguments);
        },

        clearHighlight: function clearHighlight() {
            if (this.highlighted) {
                this.highlighted = null;
                this.clearTiles();
            }
        },

        clearSelection: function clearSelection() {
            if (this.selected) {
                this.selected = null;
                this.clearTiles();
            }
        },

        setSelection: function setSelection(value) {
            this.clearSelection();
            this.selected = value;
        },

        setHighlight: function setHighlight(value) {
            this.clearHighlight();
            this.highlighted = value;
        },

        onClick: function onClick(e) {
            var target = e.originalEvent.target;
            var bin = this._getBinData(e);
            if (bin) {
                // execute callback
                this.fire('click', {
                    elem: target,
                    value: bin
                });
                // flag as selected
                this.setSelection(bin);
                this._highlightTrails();
                return;
            }
            // clear selected flag
            this.clearSelection();
            this._highlightTrails();
        },

        onMouseMove: function onMouseMove(e) {
            var target = e.originalEvent.target;
            var bin = this._getBinData(e);
            if (bin) {
                // execute callback
                if (!this.highlighted) {
                    this.fire('mouseover', {
                        elem: target,
                        value: bin
                    });
                }
                // flag as highlighted
                this.setHighlight(bin);
                this._highlightTrails();
                // set cursor
                $(this._map._container).css('cursor', 'pointer');
                // exit early
                return;
            }
            // mouse out
            if (this.highlighted) {
                this.fire('mouseout', {
                    elem: target,
                    value: this.highlighted
                });
            }
            this.clearHighlight();
            this._highlightTrails();
        },

        _getBinData: function _getBinData(e) {
            // get layer coord
            var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
            // get tile coord
            var coord = this.getTileCoordFromLayerPoint(layerPoint);
            // get cache key
            var nkey = this.cacheKeyFromCoord(coord, true);
            // get cache entry
            var cached = this._cache[nkey];
            if (cached && cached.pixels) {
                // get bin coordinate
                var bin = this.getBinCoordFromLayerPoint(layerPoint);
                // downsample the bin res
                var x = Math.floor(bin.x / this.options.downSampleFactor);
                var y = Math.floor(bin.y / this.options.downSampleFactor);
                // if hits a pixel
                if (cached.pixels[x] && cached.pixels[x][y]) {
                    var ids = Object.keys(cached.pixels[x][y]);
                    // take first entry
                    var id = ids[0];
                    // create collision object
                    var collision = {
                        value: id,
                        x: coord.x,
                        y: coord.z,
                        z: coord.z,
                        bx: bin.x,
                        by: bin.y,
                        type: 'top-trails',
                        layer: this
                    };
                    return collision;
                }
            }
            return null;
        },

        _highlightTrailsForData: function _highlightTrailsForData(cached) {
            var _this = this;

            var selected = this.selected;
            var highlighted = this.highlighted;
            if (cached.data) {
                (function () {
                    var trail = void 0;
                    if (selected) {
                        trail = cached.trails[selected.value];
                        if (trail) {
                            // for each tile relying on that data
                            _.forIn(cached.tiles, function (tile) {
                                _this._renderTrail(tile, trail, _this.options.selectedColor);
                            });
                        }
                    }
                    if (highlighted) {
                        trail = cached.trails[highlighted.value];
                        if (trail) {
                            _.forIn(cached.tiles, function (tile) {
                                _this._renderTrail(tile, trail, _this.options.highlightedColor);
                            });
                        }
                    }
                })();
            }
        },

        _highlightTrails: function _highlightTrails() {
            var _this2 = this;

            _.forIn(this._cache, function (cached) {
                _this2._highlightTrailsForData(cached);
            });
        },

        _renderTrail: function _renderTrail(canvas, pixels, color) {
            var resolution = this.getResolution();
            var highlight = document.createElement('canvas');
            highlight.height = resolution;
            highlight.width = resolution;
            var highlightCtx = highlight.getContext('2d');
            var imageData = highlightCtx.getImageData(0, 0, resolution, resolution);
            var data = imageData.data;
            var pixel = void 0,
                x = void 0,
                y = void 0,
                i = void 0,
                j = void 0;
            for (i = 0; i < pixels.length; i++) {
                pixel = pixels[i];
                x = pixel[0];
                y = pixel[1];
                j = x + resolution * y;
                data[j * 4] = color[0];
                data[j * 4 + 1] = color[1];
                data[j * 4 + 2] = color[2];
                data[j * 4 + 3] = color[3];
            }
            highlightCtx.putImageData(imageData, 0, 0);
            // draw to tile
            var ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(highlight, 0, 0, resolution, resolution, 0, 0, canvas.width, canvas.height);
        },

        renderTile: function renderTile(container, data, coord) {
            if (!data) {
                return;
            }
            // modify cache entry
            var nkey = this.cacheKeyFromCoord(coord, true);
            var cached = this._cache[nkey];
            if (cached.trails) {
                // trails already added, exit early
                return;
            }
            var trails = cached.trails = {};
            var pixels = cached.pixels = {};
            var ids = Object.keys(data);
            var bins = void 0,
                bin = void 0;
            var id = void 0,
                i = void 0,
                j = void 0;
            var rx = void 0,
                ry = void 0,
                x = void 0,
                y = void 0;
            for (i = 0; i < ids.length; i++) {
                id = ids[i];
                bins = data[id];
                for (j = 0; j < bins.length; j++) {
                    bin = bins[j];
                    // down sample the pixel to make interaction easier
                    rx = Math.floor(bin[0] / this.options.downSampleFactor);
                    ry = Math.floor(bin[1] / this.options.downSampleFactor);
                    pixels[rx] = pixels[rx] || {};
                    pixels[rx][ry] = pixels[rx][ry] || {};
                    pixels[rx][ry][id] = true;
                    // add pixel under the trail at correct resolution
                    x = bin[0];
                    y = bin[1];
                    trails[id] = trails[id] || [];
                    trails[id].push([x, y]);
                }
            }
            // make sure to highlight selected trails in the tile
            this._highlightTrailsForData(cached);
        }

    });

    module.exports = TopTrails;
})();

},{"../../core/Canvas":101,"../../mixin/ColorRamp":107,"../../mixin/ValueTransform":109}],114:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    module.exports = {

        renderTile: function renderTile(elem, coord) {
            $(elem).empty();
            $(elem).append('<div style="top:0; left:0;">' + coord.z + ', ' + coord.x + ', ' + coord.y + '</div>');
        }

    };
})();

},{}],115:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');

    var Community = HTML.extend({

        _getBinCoordFromCartesian: function _getBinCoordFromCartesian(px, py, zoom) {
            // Coords are named lon/lat, but are actually in the range [0, 255].
            // The Leaflet map is setup to use a custom projection to reflect this on
            // creation.
            var layerPt = this._getLayerPointFromLonLat({
                'lon': px,
                'lat': py
            }, zoom);
            var res = this.getBinCoordFromLayerPoint(layerPt, 256);
            return res;
        },

        // render community rings
        renderTile: function renderTile(container, data, coord) {
            var _this = this;

            if (!data) {
                return;
            }
            var dataView = new DataView(data);
            var decoder = new TextDecoder('utf-8');
            var decodedString = decoder.decode(dataView);
            var jsonObj = JSON.parse(decodedString);

            var divs = $();
            _.forEach(jsonObj.communities, function (community) {
                if (community.numNodes > 1) {
                    var div = _this._createRingDiv(community.radius, community.coords, coord.z, 'community-ring');
                    div.data('name', community.metadata);
                    div.data('count', community.numNodes);
                    divs = divs.add(div);
                }
            });
            $(container).append(divs);
        },

        // forward community metadata string to app level mousemove handler when pointer is
        // over a community ring
        onMouseOver: function onMouseOver(e) {
            var target = $(e.originalEvent.target);
            var value = { name: target.data('name'), count: target.data('count') };
            if (!value) {
                value = {};
            }
            this.fire('mouseover', {
                elem: e.originalEvent.target,
                value: value,
                type: 'community',
                layer: this
            });
        },

        // forward cleared string to app level mousemove handler when pointer moves off
        // a community ring
        onMouseOut: function onMouseOut(e) {
            this.fire('mouseout', {
                elem: e.originalEvent.target,
                type: 'community',
                layer: this
            });
        },

        _createRingDiv: function _createRingDiv(communityRadius, communityCoords, zoomLevel, className) {
            var radius = Math.max(4, communityRadius * Math.pow(2, zoomLevel));
            var offset = radius / 2;
            var binCoord = this._getBinCoordFromCartesian(communityCoords[0], communityCoords[1], zoomLevel);
            var left = binCoord.x;
            var top = binCoord.y;

            return $('\n                <div class="' + className + '" style="\n                    left: ' + (left - offset) + 'px;\n                    top: ' + (top - offset) + 'px;\n                    width: ' + radius + 'px;\n                    height: ' + radius + 'px;">\n                </div>\n                ');
        }
    });

    module.exports = Community;
})();

},{"../../core/HTML":103}],116:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');

    var CommunityLabel = HTML.extend({

        options: {
            labelScale: 1.0,
            labelMaxLength: 200,
            labelThreshold: [[0, 5000], [10, 100], [14, 10], [16, 0]]
        },

        initialize: function initialize() {
            var _this = this;

            // expand thresholds for lookups during rendering
            this.labelThreshold = [];
            if (this.options.labelThreshold.length === 1) {
                this.labelThreshold = this.options.labelThreshold;
            } else {
                _.forEach(_.dropRight(this.options.labelThreshold, 1), function (v, i) {
                    var next = _this.options.labelThreshold[i + 1];
                    var step = next[0] - v[0];
                    _this.labelThreshold = _this.labelThreshold.concat(_.zip(_.range(v[0], next[0]), _.fill(Array(step), v[1])));
                });
                this.labelThreshold.push(_.last(this.options.labelThreshold));
            }
        },

        // render community rings
        renderTile: function renderTile(container, data, coord) {
            var _this2 = this;

            if (!data) {
                return;
            }
            var dataView = new DataView(data);
            var decoder = new TextDecoder('utf-8');
            var decodedString = decoder.decode(dataView);
            var jsonObj = JSON.parse(decodedString);

            var divs = $();
            _.forEach(jsonObj.communities, function (community) {
                var idx = _.clamp(coord.z, 0, _this2.labelThreshold.length - 1);
                if (community.numNodes > _this2.labelThreshold[idx][1]) {
                    var div = _this2._createLabelDiv(community.coords, community.radius, coord.z, community.metadata, 'community-label');
                    div.data('name', community.metadata);
                    div.data('count', community.numNodes);
                    divs = divs.add(div);
                }
            });
            $(container).append(divs);
        },

        // forward community metadata string to app level mousemove handler when pointer is
        // over a community ring
        onMouseOver: function onMouseOver(e) {
            var target = $(e.originalEvent.target);
            var value = { name: target.data('name'), count: target.data('count') };
            if (!value) {
                value = {};
            }
            this.fire('mouseover', {
                elem: e.originalEvent.target,
                value: value,
                type: 'community-labels',
                layer: this
            });
        },

        // forward cleared string to app level mousemove handler when pointer moves off
        // a community ring
        onMouseOut: function onMouseOut(e) {
            this.fire('mouseout', {
                elem: e.originalEvent.target,
                type: 'community-labels',
                layer: this
            });
        },

        _getBinCoordFromCartesian: function _getBinCoordFromCartesian(px, py, zoom) {
            // Coords are named lon/lat, but are actually in the range [0, 255].
            // The Leaflet map is setup to use a custom projection to reflect this on
            // creation.
            var layerPt = this._getLayerPointFromLonLat({
                'lon': px,
                'lat': py
            }, zoom);
            var res = this.getBinCoordFromLayerPoint(layerPt, 256);
            return res;
        },

        _createLabelDiv: function _createLabelDiv(communityCoords, communityRadius, zoomLevel, label, className) {
            var radius = Math.max(16, communityRadius * Math.pow(2, zoomLevel));
            var binCoord = this._getBinCoordFromCartesian(communityCoords[0], communityCoords[1], zoomLevel);
            var left = binCoord.x - this.options.labelMaxLength / 2;
            var top = binCoord.y - radius / 2;
            return $('\n                <div class="' + className + ' ' + radius + '" style="\n                    left: ' + left + 'px;\n                    top: ' + top + 'px;\n                    line-height: ' + radius + 'px;">' + label + '</div>\n                ');
        }
    });

    module.exports = CommunityLabel;
})();

},{"../../core/HTML":103}],117:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');

    var Empty = HTML.extend({});

    module.exports = Empty;
})();

},{"../../core/HTML":103}],118:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');
    var ColorRamp = require('../../mixin/ColorRamp');
    var ValueTransform = require('../../mixin/ValueTransform');

    var Heatmap = HTML.extend({

        includes: [
        // mixins
        ColorRamp, ValueTransform],

        initialize: function initialize() {
            ColorRamp.initialize.apply(this, arguments);
            ValueTransform.initialize.apply(this, arguments);
        },

        onMouseOver: function onMouseOver(e) {
            var target = $(e.originalEvent.target);
            var value = target.attr('data-value');
            if (value) {
                var $parent = target.parents('.leaflet-html-tile');
                this.fire('mouseover', {
                    elem: e.originalEvent.target,
                    value: parseInt(value, 10),
                    x: parseInt($parent.attr('data-x'), 10),
                    y: parseInt($parent.attr('data-y'), 10),
                    z: this._map.getZoom(),
                    bx: parseInt(target.attr('data-bx'), 10),
                    by: parseInt(target.attr('data-by'), 10),
                    type: 'heatmap',
                    layer: this
                });
            }
        },

        onMouseOut: function onMouseOut(e) {
            var target = $(e.originalEvent.target);
            var value = target.attr('data-value');
            if (value) {
                var $parent = target.parents('.leaflet-html-tile');
                this.fire('mouseout', {
                    elem: e.originalEvent.target,
                    value: parseInt(value, 10),
                    x: parseInt($parent.attr('data-x'), 10),
                    y: parseInt($parent.attr('data-y'), 10),
                    z: this._map.getZoom(),
                    bx: parseInt(target.attr('data-bx'), 10),
                    by: parseInt(target.attr('data-by'), 10),
                    type: 'heatmap',
                    layer: this
                });
            }
        },

        onClick: function onClick(e) {
            // un-select any prev selected pixel
            $('.heatmap-pixel').removeClass('highlight');
            // get target
            var target = $(e.originalEvent.target);
            if (!this.isTargetLayer(e.originalEvent.target)) {
                // this layer is not the target
                return;
            }
            if (target.hasClass('heatmap-pixel')) {
                target.addClass('highlight');
            }
            var value = target.attr('data-value');
            if (value) {
                var $parent = target.parents('.leaflet-html-tile');
                this.fire('click', {
                    elem: e.originalEvent.target,
                    value: parseInt(value, 10),
                    x: parseInt($parent.attr('data-x'), 10),
                    y: parseInt($parent.attr('data-y'), 10),
                    z: this._map.getZoom(),
                    bx: parseInt(target.attr('data-bx'), 10),
                    by: parseInt(target.attr('data-by'), 10),
                    type: 'heatmap',
                    layer: this
                });
            }
        },

        renderTile: function renderTile(container, data) {
            if (!data) {
                return;
            }
            var bins = new Float64Array(data);
            var resolution = Math.sqrt(bins.length);
            var ramp = this.getColorRamp();
            var pixelSize = this.options.tileSize / resolution;
            var color = [0, 0, 0, 0];
            var html = '';
            var nval = void 0,
                rval = void 0,
                bin = void 0;
            var left = void 0,
                top = void 0;
            var i = void 0;
            for (i = 0; i < bins.length; i++) {
                bin = bins[i];
                if (bin === 0) {
                    continue;
                } else {
                    left = i % resolution;
                    top = Math.floor(i / resolution);
                    nval = this.transformValue(bin);
                    rval = this.interpolateToRange(nval);
                    ramp(rval, color);
                }
                var r = Math.round(color[0] * 255);
                var g = Math.round(color[1] * 255);
                var b = Math.round(color[2] * 255);
                var a = color[3];
                var rgba = 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';
                html += '\n                    <div class="heatmap-pixel"\n                        data-value="' + bin + '"\n                        data-bx="' + left + '"\n                        data-by="' + top + '"\n                        style="\n                            height: ' + pixelSize + 'px;\n                            width: ' + pixelSize + 'px;\n                            left: ' + left * pixelSize + 'px;\n                            top: ' + top * pixelSize + 'px;\n                            background-color: ' + rgba + ';">\n                    </div>\n                    ';
            }
            container.innerHTML = html;
        }

    });

    module.exports = Heatmap;
})();

},{"../../core/HTML":103,"../../mixin/ColorRamp":107,"../../mixin/ValueTransform":109}],119:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');
    var ValueTransform = require('../../mixin/ValueTransform');

    var Heatmap = HTML.extend({

        includes: [
        // mixins
        ValueTransform],

        initialize: function initialize() {
            ValueTransform.initialize.apply(this, arguments);
        },

        onClick: function onClick(e) {
            var target = $(e.originalEvent.target);
            $('.heatmap-ring').removeClass('highlight');
            if (!this.isTargetLayer(e.originalEvent.target)) {
                // this layer is not the target
                return;
            }
            if (target.hasClass('heatmap-ring')) {
                target.addClass('highlight');
            }
        },

        renderTile: function renderTile(container, data) {
            var _this = this;

            if (!data) {
                return;
            }
            var bins = new Float64Array(data);
            var resolution = Math.sqrt(bins.length);
            var binSize = this.options.tileSize / resolution;
            var html = '';
            bins.forEach(function (bin, index) {
                if (!bin) {
                    return;
                }
                var percent = _this.transformValue(bin);
                var radius = percent * binSize;
                var offset = (binSize - radius) / 2;
                var left = index % resolution * binSize;
                var top = Math.floor(index / resolution) * binSize;
                html += '\n                    <div class="heatmap-ring" style="\n                        left: ' + (left + offset) + 'px;\n                        top: ' + (top + offset) + 'px;\n                        width: ' + radius + 'px;\n                        height: ' + radius + 'px;">\n                    </div>\n                    ';
            });
            container.innerHTML = html;
        }

    });

    module.exports = Heatmap;
})();

},{"../../core/HTML":103,"../../mixin/ValueTransform":109}],120:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');
    var ValueTransform = require('../../mixin/ValueTransform');
    var sentiment = require('../../sentiment/Sentiment');
    var sentimentFunc = sentiment.getClassFunc(-1, 1);

    var VERTICAL_OFFSET = 24;
    var HORIZONTAL_OFFSET = 10;
    var NUM_ATTEMPTS = 1;

    /**
     * Given an initial position, return a new position, incrementally spiralled
     * outwards.
     */
    var spiralPosition = function spiralPosition(pos) {
        var pi2 = 2 * Math.PI;
        var circ = pi2 * pos.radius;
        var inc = pos.arcLength > circ / 10 ? circ / 10 : pos.arcLength;
        var da = inc / pos.radius;
        var nt = pos.t + da;
        if (nt > pi2) {
            nt = nt % pi2;
            pos.radius = pos.radius + pos.radiusInc;
        }
        pos.t = nt;
        pos.x = pos.radius * Math.cos(nt);
        pos.y = pos.radius * Math.sin(nt);
        return pos;
    };

    /**
     *  Returns true if bounding box a intersects bounding box b
     */
    var intersectTest = function intersectTest(a, b) {
        return Math.abs(a.x - b.x) * 2 < a.width + b.width && Math.abs(a.y - b.y) * 2 < a.height + b.height;
    };

    /**
     *  Returns true if bounding box a is not fully contained inside bounding box b
     */
    var overlapTest = function overlapTest(a, b) {
        return a.x + a.width / 2 > b.x + b.width / 2 || a.x - a.width / 2 < b.x - b.width / 2 || a.y + a.height / 2 > b.y + b.height / 2 || a.y - a.height / 2 < b.y - b.height / 2;
    };

    /**
     * Check if a word intersects another word, or is not fully contained in the
     * tile bounding box
     */
    var intersectWord = function intersectWord(position, word, cloud, bb) {
        var box = {
            x: position.x,
            y: position.y,
            height: word.height,
            width: word.width
        };
        var i = void 0;
        for (i = 0; i < cloud.length; i++) {
            if (intersectTest(box, cloud[i])) {
                return true;
            }
        }
        // make sure it doesn't intersect the border;
        if (overlapTest(box, bb)) {
            // if it hits a border, increment collision count
            // and extend arc length
            position.collisions++;
            position.arcLength = position.radius;
            return true;
        }
        return false;
    };

    var WordCloud = HTML.extend({

        includes: [
        // mixins
        ValueTransform],

        options: {
            maxNumWords: 15,
            minFontSize: 10,
            maxFontSize: 20
        },

        initialize: function initialize() {
            ValueTransform.initialize.apply(this, arguments);
        },

        clearSelection: function clearSelection() {
            $(this._container).removeClass('highlight');
            this.highlight = null;
        },

        setHighlight: function setHighlight(word) {
            this.clearSelection();
            // Highlight selected word
            $(this._container).addClass('highlight');
            $('.word-cloud-label[data-word="' + word + '"]').addClass('highlight');
            this.highlight = word;
        },

        onMouseOver: function onMouseOver(e) {
            var target = $(e.originalEvent.target);
            $('.word-cloud-label').removeClass('hover');
            var word = target.attr('data-word');
            if (word) {
                // highlight all instances of the word
                $('.word-cloud-label[data-word="' + word + '"]').addClass('hover');
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('mouseout', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-cloud',
                        layer: this
                    });
                }
            }
        },

        onMouseOut: function onMouseOut(e) {
            var target = $(e.originalEvent.target);
            $('.word-cloud-label').removeClass('hover');
            var word = target.attr('data-word');
            if (word) {
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('mouseover', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-cloud',
                        layer: this
                    });
                }
            }
        },

        onClick: function onClick(e) {
            // un-select any prev selected words
            $('.word-cloud-label').removeClass('highlight');
            $(this._container).removeClass('highlight');
            // get target
            var target = $(e.originalEvent.target);
            if (!this.isTargetLayer(e.originalEvent.target)) {
                // this layer is not the target
                return;
            }
            var word = target.attr('data-word');
            if (word) {
                this.setHighlight(word);
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('click', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-cloud',
                        layer: this
                    });
                }
            } else {
                this.clearSelection();
            }
        },

        _measureWords: function _measureWords(wordCounts) {
            var _this = this;

            // sort words by frequency
            wordCounts = wordCounts.sort(function (a, b) {
                return b.count - a.count;
            }).slice(0, this.options.maxNumWords);
            // build measurement html
            var $html = $('<div style="height:256px; width:256px;"></div>');
            var minFontSize = this.options.minFontSize;
            var maxFontSize = this.options.maxFontSize;
            wordCounts.forEach(function (word) {
                word.percent = _this.transformValue(word.count);
                word.fontSize = minFontSize + word.percent * (maxFontSize - minFontSize);
                $html.append('\n                    <div class="word-cloud-label" style="\n                        visibility:hidden;\n                        font-size: ' + word.fontSize + 'px;">' + word.text + '</div>;\n                    ');
            });
            // append measurements
            $('body').append($html);
            $html.children().each(function (index, elem) {
                wordCounts[index].width = elem.offsetWidth;
                wordCounts[index].height = elem.offsetHeight;
            });
            $html.remove();
            return wordCounts;
        },

        _createWordCloud: function _createWordCloud(wordCounts) {
            var tileSize = this.options.tileSize;
            var boundingBox = {
                width: tileSize - HORIZONTAL_OFFSET * 2,
                height: tileSize - VERTICAL_OFFSET * 2,
                x: 0,
                y: 0
            };
            var cloud = [];
            // sort words by frequency
            wordCounts = this._measureWords(wordCounts);
            // assemble word cloud
            wordCounts.forEach(function (wordCount) {
                // starting spiral position
                var pos = {
                    radius: 1,
                    radiusInc: 5,
                    arcLength: 10,
                    x: 0,
                    y: 0,
                    t: 0,
                    collisions: 0
                };
                // spiral outwards to find position
                while (pos.collisions < NUM_ATTEMPTS) {
                    // increment position in a spiral
                    pos = spiralPosition(pos);
                    // test for intersection
                    if (!intersectWord(pos, wordCount, cloud, boundingBox)) {
                        cloud.push({
                            text: wordCount.text,
                            fontSize: wordCount.fontSize,
                            percent: Math.round(wordCount.percent * 100 / 10) * 10, // round to nearest 10
                            x: pos.x,
                            y: pos.y,
                            width: wordCount.width,
                            height: wordCount.height,
                            sentiment: wordCount.sentiment,
                            avg: wordCount.avg
                        });
                        break;
                    }
                }
            });
            return cloud;
        },

        extractExtrema: function extractExtrema(data) {
            var sums = _.map(data, function (count) {
                if (_.isNumber(count)) {
                    return count;
                }
                return sentiment.getTotal(count);
            });
            return {
                min: _.min(sums),
                max: _.max(sums)
            };
        },

        renderTile: function renderTile(container, data) {
            if (!data || _.isEmpty(data)) {
                return;
            }
            var highlight = this.highlight;
            var wordCounts = _.map(data, function (count, key) {
                if (_.isNumber(count)) {
                    return {
                        count: count,
                        text: key
                    };
                }
                var total = sentiment.getTotal(count);
                var avg = sentiment.getAvg(count);
                return {
                    count: total,
                    text: key,
                    avg: avg,
                    sentiment: sentimentFunc(avg)
                };
            });
            // exit early if no words
            if (wordCounts.length === 0) {
                return;
            }
            // genereate the cloud
            var cloud = this._createWordCloud(wordCounts);
            // build html elements
            var halfSize = this.options.tileSize / 2;
            var html = '';
            cloud.forEach(function (word) {
                // create classes
                var classNames = ['word-cloud-label', 'word-cloud-label-' + word.percent, word.text === highlight ? 'highlight' : '', word.sentiment ? word.sentiment : ''].join(' ');
                // create styles
                var styles = ['font-size: ' + word.fontSize + 'px', 'left: ' + (halfSize + word.x - word.width / 2) + 'px', 'top: ' + (halfSize + word.y - word.height / 2) + 'px', 'width: ' + word.width + 'px', 'height: ' + word.height + 'px'].join(';');
                // create html for entry
                html += '\n                    <div class="' + classNames + '"\n                        style="' + styles + '"\n                        data-sentiment="' + word.avg + '"\n                        data-word="' + word.text + '">' + word.text + '</div>\n                    ';
            });
            container.innerHTML = html;
        }

    });

    module.exports = WordCloud;
})();

},{"../../core/HTML":103,"../../mixin/ValueTransform":109,"../../sentiment/Sentiment":110}],121:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');
    var ValueTransform = require('../../mixin/ValueTransform');
    var sentiment = require('../../sentiment/Sentiment');
    var sentimentFunc = sentiment.getClassFunc(-1, 1);

    var isSingleValue = function isSingleValue(count) {
        // single values are never null, and always numbers
        return count !== null && _.isNumber(count);
    };

    var extractCount = function extractCount(count) {
        if (isSingleValue(count)) {
            return count;
        }
        return sentiment.getTotal(count);
    };

    var extractSentimentClass = function extractSentimentClass(avg) {
        if (avg !== undefined) {
            return sentimentFunc(avg);
        }
        return '';
    };

    var extractFrequency = function extractFrequency(count) {
        if (isSingleValue(count)) {
            return {
                count: count
            };
        }
        return {
            count: sentiment.getTotal(count),
            avg: sentiment.getAvg(count)
        };
    };

    var extractAvg = function extractAvg(frequencies) {
        if (frequencies[0].avg === undefined) {
            return;
        }
        var sum = _.sumBy(frequencies, function (frequency) {
            return frequency.avg;
        });
        return sum / frequencies.length;
    };

    var extractValues = function extractValues(data, key) {
        var frequencies = _.map(data, extractFrequency);
        var avg = extractAvg(frequencies);
        var max = _.maxBy(frequencies, function (val) {
            return val.count;
        }).count;
        var total = _.sumBy(frequencies, function (val) {
            return val.count;
        });
        return {
            topic: key,
            frequencies: frequencies,
            max: max,
            total: total,
            avg: avg
        };
    };

    var WordHistogram = HTML.extend({

        includes: [
        // mixins
        ValueTransform],

        options: {
            maxNumWords: 8,
            minFontSize: 16,
            maxFontSize: 22
        },

        initialize: function initialize() {
            ValueTransform.initialize.apply(this, arguments);
        },

        clearSelection: function clearSelection() {
            $(this._container).removeClass('highlight');
            this.highlight = null;
        },

        setHighlight: function setHighlight(word) {
            this.clearSelection();
            // Highlight selected word
            $(this._container).addClass('highlight');
            $('.word-histogram-entry[data-word="' + word + '"]').addClass('highlight');
            this.highlight = word;
        },

        onMouseOver: function onMouseOver(e) {
            var target = $(e.originalEvent.target);
            $('.word-histogram-entry').removeClass('hover');
            var word = target.attr('data-word');
            if (word) {
                $('.word-histogram-entry[data-word="' + word + '"]').addClass('hover');
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('mouseover', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-histogram',
                        layer: this
                    });
                }
            }
        },

        onMouseOut: function onMouseOut(e) {
            var target = $(e.originalEvent.target);
            $('.word-histogram-entry').removeClass('hover');
            var word = target.attr('data-word');
            if (word) {
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('mouseout', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-histogram',
                        layer: this
                    });
                }
            }
        },

        onClick: function onClick(e) {
            // un-select and prev selected histogram
            $('.word-histogram-entry').removeClass('highlight');
            $(this._container).removeClass('highlight');
            // get target
            var target = $(e.originalEvent.target);
            if (!this.isTargetLayer(e.originalEvent.target)) {
                // this layer is not the target
                return;
            }
            var word = target.attr('data-word');
            if (word) {
                this.setHighlight(word);
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('mouseover', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-histogram',
                        layer: this
                    });
                }
            } else {
                this.clearSelection();
            }
        },

        extractExtrema: function extractExtrema(data) {
            var sums = _.map(data, function (counts) {
                return _.sumBy(counts, extractCount);
            });
            return {
                min: _.min(sums),
                max: _.max(sums)
            };
        },

        renderTile: function renderTile(container, data) {
            var _this = this;

            if (!data || _.isEmpty(data)) {
                return;
            }
            var highlight = this.highlight;
            // convert object to array
            var values = _.map(data, extractValues).sort(function (a, b) {
                return b.total - a.total;
            });
            // get number of entries
            var numEntries = Math.min(values.length, this.options.maxNumWords);
            var $html = $('<div class="word-histograms" style="display:inline-block;"></div>');
            var totalHeight = 0;
            var minFontSize = this.options.minFontSize;
            var maxFontSize = this.options.maxFontSize;
            values.slice(0, numEntries).forEach(function (value) {
                var topic = value.topic;
                var frequencies = value.frequencies;
                var max = value.max;
                var total = value.total;
                var avg = value.avg;
                var sentimentClass = extractSentimentClass(avg);
                var highlightClass = topic === highlight ? 'highlight' : '';
                // scale the height based on level min / max
                var percent = _this.transformValue(total);
                var percentLabel = Math.round(percent * 100 / 10) * 10;
                var height = minFontSize + percent * (maxFontSize - minFontSize);
                totalHeight += height;
                // create container 'entry' for chart and hashtag
                var $entry = $('\n                    <div class="word-histogram-entry ' + highlightClass + '"\n                        data-sentiment="' + avg + '"\n                        data-word="' + topic + '"\n                        style="height:' + height + 'px;">\n                    </div>\n                    ');
                // create chart
                var $chart = $('\n                    <div class="word-histogram-left"\n                        data-sentiment="' + avg + '"\n                        data-word="' + topic + '">\n                    </div>\n                    ');
                var barWidth = 'calc(' + 100 / frequencies.length + '%)';
                // create bars
                frequencies.forEach(function (frequency) {
                    var count = frequency.count;
                    var avg = frequency.avg;
                    var sentimentClass = extractSentimentClass(avg);
                    // get the percent relative to the highest count in the tile
                    var relativePercent = max !== 0 ? count / max * 100 : 0;
                    // make invisible if zero count
                    var visibility = relativePercent === 0 ? 'hidden' : '';
                    // Get the style class of the bar
                    var percentLabel = Math.round(relativePercent / 10) * 10;
                    var barClasses = ['word-histogram-bar', 'word-histogram-bar-' + percentLabel, sentimentClass + '-fill'].join(' ');
                    var barHeight = void 0;
                    var barTop = void 0;
                    // ensure there is at least a single pixel of color
                    if (relativePercent / 100 * height < 3) {
                        barHeight = '3px';
                        barTop = 'calc(100% - 3px)';
                    } else {
                        barHeight = relativePercent + '%';
                        barTop = '(100 - relativePercent)%';
                    }
                    // create bar
                    $chart.append('\n                        <div class="' + barClasses + '"\n                            data-word="' + topic + '"\n                            style="\n                            visibility: ' + visibility + ';\n                            width: ' + barWidth + ';\n                            height: ' + barHeight + ';\n                            top: ' + barTop + ';">\n                        </div>\n                        ');
                });
                $entry.append($chart);
                var topicClasses = ['word-histogram-label', 'word-histogram-label-' + percentLabel, sentimentClass].join(' ');
                // create tag label
                var $topic = $('\n                    <div class="word-histogram-right">\n                        <div class="' + topicClasses + '"\n                            data-sentiment="' + avg + '"\n                            data-word="' + topic + '"\n                        style="\n                            font-size: ' + height + 'px;\n                            line-height: ' + height + 'px;\n                            height: ' + height + 'px;">' + topic + '</div>\n                    </div>\n                    ');
                $entry.append($topic);
                $html.append($entry);
            });
            $html.css('top', this.options.tileSize / 2 - totalHeight / 2);
            container.innerHTML = $html[0].outerHTML;
        }
    });

    module.exports = WordHistogram;
})();

},{"../../core/HTML":103,"../../mixin/ValueTransform":109,"../../sentiment/Sentiment":110}],122:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DELAY = 1200;

    module.exports = {

        renderTile: function renderTile(elem) {
            var delay = -(Math.random() * DELAY);
            elem.innerHTML = '<div class="blinking blinking-tile" style="animation-delay:' + delay + 'ms"></div>';
        }

    };
})();

},{}],123:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DELAY = 1200;

    module.exports = {

        renderTile: function renderTile(elem) {
            var delay = -(Math.random() * DELAY);
            elem.innerHTML = '\n                <div class="vertical-centered-box blinking" style="animation-delay: ' + delay + 'ms">\n                    <div class="content">\n                        <div class="loader-circle"></div>\n                        <div class="loader-line-mask" style="animation-delay: ' + delay + 'ms">\n                            <div class="loader-line"></div>\n                        </div>\n                    </div>\n                </div>\n                ';
        }

    };
})();

},{}],124:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DELAY = 1200;

    module.exports = {

        renderTile: function renderTile(elem) {
            setTimeout(function () {
                var delay = -(Math.random() * DELAY);
                if ($(elem).hasClass('pending')) {
                    elem.innerHTML = '<div class="blinking blinking-tile" style="animation-delay: ' + delay + 'ms"></div>';
                }
            }, DELAY);
        }

    };
})();

},{}],125:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DELAY = 1200;

    module.exports = {

        renderTile: function renderTile(elem) {
            setTimeout(function () {
                var delay = -(Math.random() * DELAY);
                if ($(elem).hasClass('pending')) {
                    elem.innerHTML = '\n                        <div class="vertical-centered-box" style="animation-delay: ' + delay + 'ms">\n                            <div class="content">\n                                <div class="loader-circle"></div>\n                                <div class="loader-line-mask" style="animation-delay: ' + delay + 'ms">\n                                    <div class="loader-line"></div>\n                                </div>\n                            </div>\n                        </div>\n                        ';
                }
            }, DELAY);
        }

    };
})();

},{}],126:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DELAY = 1200;

    module.exports = {

        renderTile: function renderTile(elem) {
            var delay = -(Math.random() * DELAY);
            elem.innerHTML = '\n                <div class="vertical-centered-box" style="animation-delay: ' + delay + 'ms">\n                    <div class="content">\n                        <div class="loader-circle"></div>\n                        <div class="loader-line-mask" style="animation-delay: ' + delay + 'ms">\n                            <div class="loader-line"></div>\n                        </div>\n                    </div>\n                </div>\n                ';
        }

    };
})();

},{}],127:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var esper = require('esper');
    var WebGL = require('../../core/WebGL');
    var ColorRamp = require('../../mixin/ColorRamp');
    var ValueTransform = require('../../mixin/ValueTransform');
    var Shaders = require('./Shaders');

    var TILE_SIZE = 256;

    function encode(enc, val) {
        enc[0] = val / 16777216.0 & 0xFF;
        enc[1] = val / 65536.0 & 0xFF;
        enc[2] = val / 256.0 & 0xFF;
        enc[3] = val & 0xFF;
        return enc;
    }

    var Heatmap = WebGL.extend({

        includes: [
        // mixins
        ColorRamp, ValueTransform],

        onWebGLInit: function onWebGLInit(done) {
            // ensure we use the correct context
            esper.WebGLContext.bind(this._container);
            // quad vertices
            var vertices = new Float32Array([
            // positions
            0, -TILE_SIZE, TILE_SIZE, -TILE_SIZE, TILE_SIZE, 0, 0, -TILE_SIZE, TILE_SIZE, 0, 0, 0,
            // uvs
            0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1]);
            // quad buffer
            this._quadBuffer = new esper.VertexBuffer(vertices, {
                0: {
                    size: 2,
                    type: 'FLOAT',
                    byteOffset: 0
                },
                1: {
                    size: 2,
                    type: 'FLOAT',
                    byteOffset: 2 * 6 * 4
                }
            }, {
                count: 6
            });
            // load shader
            this._shader = new esper.Shader({
                vert: Shaders.heatmap.vert,
                frag: Shaders.heatmap.frag
            }, function (err) {
                if (err) {
                    done(err);
                }
                done(null);
            });
        },

        initialize: function initialize() {
            ColorRamp.initialize.apply(this, arguments);
            ValueTransform.initialize.apply(this, arguments);
        },

        onCacheLoad: function onCacheLoad(event) {
            var cached = event.entry;
            var coords = event.coords;
            if (cached.data && cached.data.byteLength > 0) {
                this.bufferTileTexture(cached, coords);
            }
        },

        onExtremaChange: function onExtremaChange() {
            var _this = this;

            _.forIn(this._cache, function (cached) {
                if (cached.data && cached.data.byteLength > 0) {
                    _this.bufferTileTexture(cached);
                }
            });
        },

        bufferTileTexture: function bufferTileTexture(cached) {
            var data = new Float64Array(cached.data);
            var resolution = Math.sqrt(data.length);
            var bins = new Uint8Array(data.length * 4);
            var enc = [0, 0, 0, 0];
            var bin = void 0,
                i = void 0;
            var sum = 0;
            for (i = 0; i < data.length; i++) {
                bin = data[i];
                sum += bin;
                encode(enc, bin);
                bins[i * 4] = enc[0];
                bins[i * 4 + 1] = enc[1];
                bins[i * 4 + 2] = enc[2];
                bins[i * 4 + 3] = enc[3];
            }
            if (sum > 0) {
                // ensure we use the correct context
                esper.WebGLContext.bind(this._container);
                // create the texture
                cached.texture = new esper.Texture2D({
                    height: resolution,
                    width: resolution,
                    src: bins,
                    format: 'RGBA',
                    type: 'UNSIGNED_BYTE',
                    wrap: 'CLAMP_TO_EDGE',
                    filter: 'NEAREST',
                    invertY: true
                });
            }
        },

        getProjectionMatrix: function getProjectionMatrix() {
            var bounds = this._map.getPixelBounds();
            var dim = Math.pow(2, this._map.getZoom()) * TILE_SIZE;
            return this.getOrthoMatrix(bounds.min.x, bounds.max.x, dim - bounds.max.y, dim - bounds.min.y, -1, 1);
        },

        renderTiles: function renderTiles() {
            var _this2 = this;

            var buffer = this._quadBuffer;
            var shader = this._shader;
            var zoom = this._map.getZoom();
            var dim = Math.pow(2, zoom) * TILE_SIZE;
            // bind buffer
            buffer.bind();
            // for each tile
            _.forIn(this._cache, function (cached) {
                if (!cached.texture) {
                    return;
                }
                // bind tile texture to texture unit 0
                cached.texture.bind(0);
                _.forIn(cached.tiles, function (tile, key) {
                    // find the tiles position from its key
                    var coords = _this2.coordFromCacheKey(key);
                    // NOTE: we have to check here if the tiles are stale or not
                    if (coords.z !== zoom) {
                        return;
                    }
                    var x = TILE_SIZE * coords.x;
                    var y = _this2.options.tms ? TILE_SIZE * (coords.y + 1) : dim - TILE_SIZE * coords.y;
                    // create model matrix
                    var model = _this2.getTranslationMatrix(x, y, 0);
                    shader.setUniform('uModelMatrix', model);
                    // draw the tile
                    buffer.draw();
                });
                // unbind texture
                cached.texture.unbind();
            });
            // unbind buffer
            buffer.unbind();
        },

        renderFrame: function renderFrame() {
            // setup
            this._viewport.push();
            this._shader.use();
            // set uniforms
            this._shader.setUniform('uProjectionMatrix', this.getProjectionMatrix());
            this._shader.setUniform('uOpacity', this.getOpacity());
            this._shader.setUniform('uRangeMin', this.getValueRange().min);
            this._shader.setUniform('uRangeMax', this.getValueRange().max);
            this._shader.setUniform('uMin', this.getExtrema().min);
            this._shader.setUniform('uMax', this.getExtrema().max);
            this._shader.setUniform('uTransformType', this.getTransformEnum());
            this._shader.setUniform('uTextureSampler', 0);
            this._shader.setUniform('uRamp', this.getColorRampTable());
            // draw
            this.renderTiles();
            // teardown
            this._viewport.pop();
        }

    });

    module.exports = Heatmap;
})();

},{"../../core/WebGL":105,"../../mixin/ColorRamp":107,"../../mixin/ValueTransform":109,"./Shaders":129,"esper":24}],128:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var esper = require('esper');
    var parallel = require('async/parallel');
    var WebGL = require('../../core/WebGL');
    var SpatialHash = require('../../mixin/SpatialHash');
    var Shaders = require('./Shaders');

    var TILE_SIZE = 256;
    var COMPONENT_BYTE_SIZE = 2;
    var COMPONENTS_PER_POINT = 4; // encoding two uint32's across xy/zw
    var MAX_TILES = 128;
    var MAX_POINTS_PER_TILE = 256 * 256;
    var MAX_TILE_BYTE_SIZE = MAX_POINTS_PER_TILE * COMPONENTS_PER_POINT * COMPONENT_BYTE_SIZE;
    var MAX_BUFFER_BYTE_SIZE = MAX_TILES * MAX_TILE_BYTE_SIZE;

    var NUM_SLICES = 64;
    var POINT_RADIUS = 8;
    var POINT_RADIUS_INC = 2;

    var POSITIONS_INDEX = 0;
    var OFFSETS_INDEX = 1;

    function encodePoint(arraybuffer, index, x, y) {
        arraybuffer[index] = x >> 16;
        arraybuffer[index + 1] = x & 0x0000FFFF;
        arraybuffer[index + 2] = y >> 16;
        arraybuffer[index + 3] = y & 0x0000FFFF;
    }

    function applyJitter(point, maxDist) {
        var angle = Math.random() * (Math.PI * 2);
        var dist = Math.random() * maxDist;
        point.x += Math.Floor(Math.cos(angle) * dist);
        point.y += Math.Floor(Math.sin(angle) * dist);
    }

    function createCircleOutlineBuffer(numSegments) {
        var theta = 2 * Math.PI / numSegments;
        var radius = 1.0;
        // precalculate sine and cosine
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        var t = void 0;
        // start at angle = 0
        var x = radius;
        var y = 0;
        var positions = new Float32Array(numSegments * 2);
        for (var i = 0; i < numSegments; i++) {
            positions[i * 2] = x;
            positions[i * 2 + 1] = y;
            // apply the rotation
            t = x;
            x = c * x - s * y;
            y = s * t + c * y;
        }
        var pointers = {};
        pointers[POSITIONS_INDEX] = {
            size: 2,
            type: 'FLOAT'
        };
        var options = {
            mode: 'LINE_LOOP',
            count: positions.length / 2
        };
        return new esper.VertexBuffer(positions, pointers, options);
    }

    function createCircleFillBuffer(numSegments) {
        var theta = 2 * Math.PI / numSegments;
        var radius = 1.0;
        // precalculate sine and cosine
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        var t = void 0;
        // start at angle = 0
        var x = radius;
        var y = 0;
        var positions = new Float32Array((numSegments + 2) * 2);
        positions[0] = 0;
        positions[1] = 0;
        positions[positions.length - 2] = radius;
        positions[positions.length - 1] = 0;
        for (var i = 0; i < numSegments; i++) {
            positions[(i + 1) * 2] = x;
            positions[(i + 1) * 2 + 1] = y;
            // apply the rotation
            t = x;
            x = c * x - s * y;
            y = s * t + c * y;
        }

        var pointers = {};
        pointers[POSITIONS_INDEX] = {
            size: 2,
            type: 'FLOAT'
        };
        var options = {
            mode: 'TRIANGLE_FAN',
            count: positions.length / 2
        };
        return new esper.VertexBuffer(positions, pointers, options);
    }

    var Point = WebGL.extend({

        includes: [
        // mixins
        SpatialHash],

        options: {
            pointOutline: 1,
            pointOutlineColor: [0.0, 0.0, 0.0, 1.0],
            pointFillColor: [0.2, 0.15, 0.4, 0.5],
            pointRadius: POINT_RADIUS,
            selectedOutlineColor: [0.0, 0.0, 0.0, 1.0],
            selectedFillColor: [0.8, 0.4, 0.2, 0.5],
            selectedRadius: POINT_RADIUS + POINT_RADIUS_INC,
            highlightedOutlineColor: [0.0, 0.0, 0.0, 1.0],
            highlightedFillColor: [0.3, 0.25, 0.5, 0.5],
            highlightedRadius: POINT_RADIUS + POINT_RADIUS_INC,
            blending: true,
            jitter: true,
            jitterDistance: 10
        },

        initialize: function initialize() {
            SpatialHash.initialize.apply(this, arguments);
        },

        onWebGLInit: function onWebGLInit(done) {
            var _this = this;

            // ensure we use the correct context
            esper.WebGLContext.bind(this._container);
            // create the circle vertexbuffer
            this._circleFillBuffer = createCircleFillBuffer(NUM_SLICES);
            this._circleOutlineBuffer = createCircleOutlineBuffer(NUM_SLICES);
            // create the root offset buffer
            this._offsetBuffer = new esper.VertexBuffer(MAX_BUFFER_BYTE_SIZE);
            // get the extension for hardware instancing
            this._ext = esper.WebGLContext.getExtension('ANGLE_instanced_arrays');
            if (!this._ext) {
                throw 'ANGLE_instanced_arrays WebGL extension is not supported';
            }
            // clear the chunks
            this.initChunks();
            // load shaders
            parallel({
                instanced: function instanced(done) {
                    var shader = new esper.Shader({
                        vert: Shaders.instancedPoint.vert,
                        frag: Shaders.instancedPoint.frag
                    }, function (err) {
                        if (err) {
                            done(err, null);
                        }
                        done(null, shader);
                    });
                },
                individual: function individual(done) {
                    var shader = new esper.Shader({
                        vert: Shaders.point.vert,
                        frag: Shaders.point.frag
                    }, function (err) {
                        if (err) {
                            done(err, null);
                        }
                        done(null, shader);
                    });
                }
            }, function (err, shaders) {
                if (err) {
                    done(err);
                }
                _this._instancedShader = shaders.instanced;
                _this._individualShader = shaders.individual;
                done(null);
            });
        },

        getCollisionRadius: function getCollisionRadius() {
            return this.options.pointRadius + this.options.pointOutline;
        },

        onAdd: function onAdd(map) {
            WebGL.prototype.onAdd.call(this, map);
            map.on('zoomend', this.onZoomEnd, this);
        },

        onRemove: function onRemove(map) {
            WebGL.prototype.onRemove.call(this, map);
            map.off('zoomend', this.onZoomEnd, this);
        },

        onZoomStart: function onZoomStart() {
            this.clearHash();
            WebGL.prototype.onZoomStart.apply(this, arguments);
        },

        initChunks: function initChunks() {
            // ensure we use the correct context
            esper.WebGLContext.bind(this._container);
            // allocate available chunks
            this._availableChunks = new Array(MAX_TILES);
            for (var i = 0; i < MAX_TILES; i++) {
                var byteOffset = i * MAX_TILE_BYTE_SIZE;
                this._availableChunks[i] = {
                    byteOffset: byteOffset,
                    count: 0,
                    vertexBuffer: new esper.VertexBuffer(this._offsetBuffer.buffer, {
                        1: {
                            size: 4,
                            type: 'UNSIGNED_SHORT',
                            byteOffset: byteOffset
                        }
                    }, {
                        mode: 'POINTS',
                        byteLength: MAX_BUFFER_BYTE_SIZE
                    })
                };
            }
            this._usedChunks = {};
        },

        onMouseMove: function onMouseMove(e) {
            var target = e.originalEvent.target;
            var layerPixel = this.getLayerPointFromEvent(e.originalEvent);
            var radius = this.getCollisionRadius();
            var zoom = this._map.getZoom();
            var collision = this.pick(layerPixel, radius, zoom);
            var size = Math.pow(2, zoom);
            if (collision) {
                // mimic mouseover / mouseout events
                if (this.highlighted) {
                    if (this.highlighted.value !== collision) {
                        // new collision
                        // execute mouseout for old
                        this.fire('mouseout', {
                            elem: target,
                            value: this.highlighted.value
                        });
                        // execute mouseover for new
                        this.fire('mouseover', {
                            elem: target,
                            value: collision
                        });
                    }
                } else {
                    // no previous collision, execute mouseover
                    this.fire('mouseover', {
                        elem: target,
                        value: collision
                    });
                }
                // use collision point to find tile
                var coord = this.getTileCoordFromLayerPoint(collision);
                var hash = this.cacheKeyFromCoord(coord);
                // flag as highlighted
                this.highlighted = {
                    tiles: this._cache[hash].tiles,
                    value: collision,
                    point: [collision.x, size * TILE_SIZE - collision.y]
                };
                // set cursor
                $(this._map._container).css('cursor', 'pointer');
                return;
            }
            // mouse out
            if (this.highlighted) {
                this.fire('mouseout', {
                    elem: target,
                    value: this.highlighted.value
                });
            }
            // clear highlighted flag
            this.highlighted = null;
        },

        onClick: function onClick(e) {
            var target = e.originalEvent.target;
            var layerPixel = this.getLayerPointFromEvent(e.originalEvent);
            var radius = this.getCollisionRadius();
            var zoom = this._map.getZoom();
            var size = Math.pow(2, zoom);
            var collision = this.pick(layerPixel, radius, zoom);
            if (collision) {
                // use collision point to find tile
                var coord = this.getTileCoordFromLayerPoint(collision);
                var hash = this.cacheKeyFromCoord(coord);
                // flag as selected
                this.selected = {
                    tiles: this._cache[hash].tiles,
                    value: collision,
                    point: [collision.x, size * TILE_SIZE - collision.y]
                };
                this.fire('click', {
                    elem: target,
                    value: collision
                });
            } else {
                this.selected = null;
            }
        },

        addTileToBuffer: function addTileToBuffer(coords, data, count) {
            if (this._availableChunks.length === 0) {
                console.warn('No available chunks remaining to buffer data');
                return;
            }
            // get an available chunk
            var chunk = this._availableChunks.pop();
            // set count
            chunk.count = count;
            // buffer the data into the physical chunk
            this._offsetBuffer.bufferSubData(data, chunk.byteOffset);
            // flag as used
            var ncoords = this.getNormalizedCoords(coords);
            var hash = this.cacheKeyFromCoord(ncoords);
            this._usedChunks[hash] = chunk;
        },

        removeTileFromBuffer: function removeTileFromBuffer(coords) {
            var ncoords = this.getNormalizedCoords(coords);
            var hash = this.cacheKeyFromCoord(ncoords);
            var chunk = this._usedChunks[hash];
            // clear the count
            chunk.count = 0;
            delete this._usedChunks[hash];
            // add as a new available chunk
            this._availableChunks.push(chunk);
            // no need to actually unbuffer the data
        },

        onCacheLoad: function onCacheLoad(event) {
            var cached = event.entry;
            var coords = event.coords;
            if (cached.data && cached.data.length > 0) {
                // convert x / y to tile pixels
                var data = cached.data;
                var xField = this.getXField();
                var yField = this.getYField();
                var zoom = coords.z;
                var size = Math.pow(2, zoom);
                var radius = this.getCollisionRadius();
                var numBytes = data.length * COMPONENT_BYTE_SIZE * COMPONENTS_PER_POINT;
                var buffer = new ArrayBuffer(Math.min(numBytes, MAX_TILE_BYTE_SIZE));
                var positions = new Uint16Array(buffer);
                var count = 0;
                var numDatum = Math.min(data.length, MAX_POINTS_PER_TILE);
                var points = [];
                var collisions = {};
                var i = void 0;
                // calc pixel locations
                for (i = 0; i < numDatum; i++) {
                    var hit = data[i];
                    var x = _.get(hit, xField);
                    var y = _.get(hit, yField);
                    if (x !== undefined && y !== undefined) {
                        // get position in layer
                        var layerPoint = this.getLayerPointFromDataPoint(x, y, zoom);
                        // create pixel
                        var point = {
                            x: layerPoint.x,
                            y: layerPoint.y,
                            data: hit
                        };
                        var hash = point.x + ':' + point.y;
                        if (this.options.jitter) {
                            if (collisions[hash]) {
                                applyJitter(point, this.options.jitterDistance);
                            }
                            collisions[hash] = true;
                        }
                        // store point
                        points.push(point);

                        // encode the point into the buffer
                        encodePoint(positions, i * 4, point.x, size * TILE_SIZE - point.y);

                        // add point to spatial hash
                        this.addPoint(point, radius, zoom);
                        // increment count
                        count++;
                    }
                }
                if (count > 0) {
                    // store points in the cache
                    cached.points = points;
                    // buffer the data
                    this.addTileToBuffer(coords, positions, count);
                }
            }
        },

        onCacheUnload: function onCacheUnload(event) {
            var _this2 = this;

            var cached = event.entry;
            var coords = event.coords;
            if (cached.points) {
                (function () {
                    //cached.data && cached.data.length > 0) {
                    _this2.removeTileFromBuffer(coords);
                    var radius = _this2.getCollisionRadius();
                    cached.points.forEach(function (point) {
                        _this2.removePoint(point, radius, coords.z);
                    });
                    cached.points = null;
                })();
            }
        },

        getWrapAroundOffset: function getWrapAroundOffset(coords) {
            var size = Math.pow(2, this._map.getZoom());
            // create model matrix
            var xWrap = Math.floor(coords.x / size);
            var yWrap = Math.floor(coords.y / size);
            return [size * TILE_SIZE * xWrap, size * TILE_SIZE * yWrap];
        },

        getProjectionMatrix: function getProjectionMatrix() {
            var size = this._map.getSize();
            return this.getOrthoMatrix(0, size.x, 0, size.y, -1, 1);
        },

        getViewOffset: function getViewOffset() {
            var bounds = this._map.getPixelBounds();
            var dim = Math.pow(2, this._map.getZoom()) * TILE_SIZE;
            return [bounds.min.x, dim - bounds.max.y];
        },

        drawInstanced: function drawInstanced(buffer, color, radius) {
            var _this3 = this;

            var gl = this._gl;
            var ext = this._ext;
            var shader = this._instancedShader;
            var cache = this._cache;
            var zoom = this._map.getZoom();
            if (this.options.blending) {
                // enable blending
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            }
            // use shader
            shader.use();
            // set uniforms
            shader.setUniform('uColor', color);
            shader.setUniform('uProjectionMatrix', this.getProjectionMatrix());
            shader.setUniform('uOpacity', this.getOpacity());
            shader.setUniform('uScale', radius);
            // calc view offset
            var viewOffset = this.getViewOffset();
            // binds the buffer to instance
            buffer.bind();
            // enable instancing
            ext.vertexAttribDivisorANGLE(OFFSETS_INDEX, 1);
            // for each allocated chunk
            _.forIn(this._usedChunks, function (chunk, hash) {
                // for each tile referring to the data
                var cached = cache[hash];
                if (cached) {
                    // bind the chunk's buffer
                    chunk.vertexBuffer.bind();
                    // render for each tile
                    _.keys(cached.tiles).forEach(function (hash) {
                        var coords = _this3.coordFromCacheKey(hash);
                        if (coords.z !== zoom) {
                            // NOTE: we have to check here if the tiles are stale or not
                            return;
                        }
                        // upload view offset
                        var offset = _this3.getWrapAroundOffset(coords);
                        var totalOffset = [viewOffset[0] - offset[0], viewOffset[1] - offset[1]];
                        shader.setUniform('uViewOffset', totalOffset);
                        // draw the istances
                        ext.drawArraysInstancedANGLE(gl[buffer.mode], 0, buffer.count, chunk.count);
                    });
                    // unbind
                    chunk.vertexBuffer.unbind();
                }
            });
            // disable instancing
            ext.vertexAttribDivisorANGLE(OFFSETS_INDEX, 0);
            // unbind buffer
            buffer.unbind();
        },

        drawIndividual: function drawIndividual(buffer, color, radius, tiles, point) {
            var _this4 = this;

            // draw selected points
            var gl = this._gl;
            var shader = this._individualShader;
            var zoom = this._map.getZoom();
            // bind the buffer
            buffer.bind();
            // disable blending
            gl.disable(gl.BLEND);
            // use shader
            shader.use();
            // use uniform for offset
            shader.setUniform('uProjectionMatrix', this.getProjectionMatrix());
            shader.setUniform('uOpacity', this.getOpacity());
            shader.setUniform('uScale', radius);
            // view offset
            var viewOffset = this.getViewOffset();
            _.forIn(tiles, function (tile) {
                if (tile.coords.z !== zoom) {
                    // NOTE: we have to check here if the tiles are stale or not
                    return;
                }
                // upload view offset
                var offset = _this4.getWrapAroundOffset(tile.coords);
                var totalOffset = [viewOffset[0] - offset[0], viewOffset[1] - offset[1]];
                shader.setUniform('uViewOffset', totalOffset);
                shader.setUniform('uOffset', point);
                shader.setUniform('uColor', color);
                buffer.draw();
            });
            // unbind the buffer
            buffer.unbind();
        },

        renderFrame: function renderFrame() {
            // setup
            var gl = this._gl;
            var viewport = this._viewport;
            viewport.push();

            // draw instanced points

            // draw instanced fill
            this.drawInstanced(this._circleFillBuffer, this.options.pointFillColor, this.options.pointRadius);
            // draw instanced outlines
            gl.lineWidth(this.options.pointOutline);
            this.drawInstanced(this._circleOutlineBuffer, this.options.pointOutlineColor, this.options.pointRadius);

            // draw individual points

            if (this.highlighted) {
                // draw individual fill
                this.drawIndividual(this._circleFillBuffer, this.options.highlightedFillColor, this.options.highlightedRadius, this.highlighted.tiles, this.highlighted.point);
                // draw individual outline
                gl.lineWidth(this.options.pointOutline);
                this.drawIndividual(this._circleOutlineBuffer, this.options.highlightedOutlineColor, this.options.highlightedRadius, this.highlighted.tiles, this.highlighted.point);
            }

            if (this.selected) {
                // draw individual fill
                this.drawIndividual(this._circleFillBuffer, this.options.selectedFillColor, this.options.selectedRadius, this.selected.tiles, this.selected.point);
                // draw individual outline
                gl.lineWidth(this.options.pointOutline);
                this.drawIndividual(this._circleOutlineBuffer, this.options.selectedOutlineColor, this.options.selectedRadius, this.selected.tiles, this.selected.point);
            }

            // teardown
            viewport.pop();
        }

    });

    module.exports = Point;
})();

},{"../../core/WebGL":105,"../../mixin/SpatialHash":108,"./Shaders":129,"async/parallel":10,"esper":24}],129:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var ColorRamp = require('../../mixin/ColorRamp');

    /**
     * precision
     */
    var precision = '\n        precision highp float;\n        precision highp int;\n        ';

    /**
     * decode float
     */
    var decodeRGBAToFloat = '\n        float decodeRGBAToFloat(vec4 v) {\n            return (v.x * 255.0 * 16777216.0) +\n                (v.y * 255.0 * 65536.0) +\n                (v.z * 255.0 * 256.0) +\n                v.w * 255.0;\n        }\n        ';

    var decodeUint16ToUint32 = '\n        int decodeUint16ToUint32(float a, float b) {\n            return int(a * 65536.0) + int(b);\n        }\n        ';

    /**
     * transforms
     */

    // log10
    var log10Transform = '\n        float log10(float val) {\n            return log(val) / log(10.0);\n        }\n        float log10Transform(float val, float minVal, float maxVal) {\n            if (minVal < 1.0) { minVal = 1.0; }\n            if (maxVal < 1.0) { maxVal = 1.0; }\n            if (val < 1.0) { val = 1.0; }\n            float logMin = log10(minVal);\n            float logMax = log10(maxVal);\n            float logVal = log10(val);\n            float range = logMax - logMin;\n            if (range == 0.0) { range = 1.0; }\n            return (logVal - logMin) / range;\n        }\n        ';

    // sigmoid
    var sigmoidTransform = '\n        float sigmoidTransform(float val, float minVal, float maxVal) {\n            minVal = abs(minVal);\n            maxVal = abs(maxVal);\n            float dist = max(minVal, maxVal);\n            float SIGMOID_SCALE = 0.15;\n            float scaledVal = val / (SIGMOID_SCALE * dist);\n            return 1.0 / (1.0 + exp(-scaledVal));\n        }\n        ';

    // linear
    var linearTransform = '\n        float linearTransform(float val, float minVal, float maxVal) {\n            float range = maxVal - minVal;\n            if (range == 0.0) { range = 1.0; }\n            return (val - minVal) / range;\n        }\n        ';

    var transform = log10Transform + sigmoidTransform + linearTransform + '\n        #define LOG_TRANSFORM 0\n        #define LINEAR_TRANSFORM 1\n        #define SIGMOID_TRANSFORM 2\n        uniform int uTransformType;\n        uniform float uMin;\n        uniform float uMax;\n        float transform(float val) {\n            if (val < uMin) { val = uMin; }\n            if (val > uMax) { val = uMax; }\n            if (uTransformType == LINEAR_TRANSFORM) {\n                return linearTransform(val, uMin, uMax);\n            } else if (uTransformType == SIGMOID_TRANSFORM) {\n                return sigmoidTransform(val, uMin, uMax);\n            }\n            return log10Transform(val, uMin, uMax);\n        }\n        ';

    /**
     * Color ramp
     */
    var colorRamp = '\n        #define RAMP_VALUES ' + ColorRamp.NUM_GRADIENT_STEPS + '\n        uniform vec4 uRamp[RAMP_VALUES];\n        vec4 colorRamp(float value) {\n            float maxIndex = float(RAMP_VALUES - 1);\n            int index = int(value * maxIndex);\n            // NOTE: I REALLY don\'t like this, but it seems to be the only way\n            // to index the uRamp array\n            for (int i=0; i<RAMP_VALUES; i++) {\n                if (i == index) {\n                    return uRamp[i];\n                }\n            }\n            return vec4(1.0, 0.0, 1.0, 1.0);\n        }\n        ';

    /**
     * Value Range
     */
    var valueRange = '\n        uniform float uRangeMin;\n        uniform float uRangeMax;\n        float interpolateToRange(float nval) {\n            float rval = (nval - uRangeMin) / (uRangeMax - uRangeMin);\n            if (rval > 1.0) {\n                rval = 1.0;\n            } else if (rval < 0.0) {\n                rval = 0.0;\n            }\n            return rval;\n        }\n        ';

    /**
     * heatmap shader
     */
    var heatmap = {
        vert: precision + '\n            attribute vec2 aPosition;\n            attribute vec2 aTextureCoord;\n            uniform mat4 uProjectionMatrix;\n            uniform mat4 uModelMatrix;\n            varying vec2 vTextureCoord;\n            void main() {\n                vTextureCoord = aTextureCoord;\n                gl_Position = uProjectionMatrix * uModelMatrix * vec4(aPosition, 0.0, 1.0);\n            }\n            ',
        frag: precision + decodeRGBAToFloat + transform + colorRamp + valueRange + '\n            uniform sampler2D uTextureSampler;\n            uniform float uOpacity;\n            varying vec2 vTextureCoord;\n            void main() {\n                vec4 enc = texture2D(uTextureSampler, vTextureCoord);\n                float count = decodeRGBAToFloat(enc);\n                if (count == 0.0) {\n                    discard;\n                }\n                float nval = transform(count);\n                float rval = interpolateToRange(nval);\n                vec4 color = colorRamp(rval);\n                gl_FragColor = vec4(color.rgb, color.a * uOpacity);\n            }\n            '
    };

    /**
     * instanced point shader
     */
    var instancedPoint = {
        vert: precision + decodeUint16ToUint32 + '\n            attribute vec2 aPosition;\n            attribute vec4 aOffset;\n            uniform ivec2 uViewOffset;\n            uniform float uScale;\n            uniform mat4 uProjectionMatrix;\n            void main() {\n                ivec2 iOffset = ivec2(\n                    decodeUint16ToUint32(aOffset.x, aOffset.y),\n                    decodeUint16ToUint32(aOffset.z, aOffset.w));\n                vec2 mPosition = uScale * aPosition + vec2(iOffset - uViewOffset);\n                gl_Position = uProjectionMatrix * vec4(mPosition, 0.0, 1.0);\n            }\n            ',
        frag: precision + '\n            uniform float uOpacity;\n            uniform vec4 uColor;\n            void main() {\n                gl_FragColor = vec4(uColor.rgb, uColor.a * uOpacity);\n            }\n            '
    };

    var point = {
        vert: precision + '\n            attribute vec2 aPosition;\n            uniform ivec2 uOffset;\n            uniform ivec2 uViewOffset;\n            uniform float uScale;\n            uniform mat4 uProjectionMatrix;\n            void main() {\n                vec2 mPosition = uScale * aPosition + vec2(uOffset - uViewOffset);\n                gl_Position = uProjectionMatrix * vec4(mPosition, 0.0, 1.0);\n            }\n            ',
        frag: precision + '\n            uniform float uOpacity;\n            uniform vec4 uColor;\n            void main() {\n                gl_FragColor = vec4(uColor.rgb, uColor.a * uOpacity);\n            }\n            '
    };

    module.exports = {

        /**
         * heatmap shader
         */
        heatmap: heatmap,

        /**
         * instanced point shader
         */
        instancedPoint: instancedPoint,

        /**
         * point shader
         */
        point: point

    };
})();

},{"../../mixin/ColorRamp":107}],130:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

(function () {

    'use strict';

    var Requestor = require('./Requestor');

    var MetaRequestor = function (_Requestor) {
        _inherits(MetaRequestor, _Requestor);

        function MetaRequestor(url, callback) {
            _classCallCheck(this, MetaRequestor);

            return _possibleConstructorReturn(this, (MetaRequestor.__proto__ || Object.getPrototypeOf(MetaRequestor)).call(this, url, callback));
        }

        _createClass(MetaRequestor, [{
            key: 'getHash',
            value: function getHash(req) {
                return req.type + '-' + req.index + '-' + req.store;
            }
        }, {
            key: 'getURL',
            value: function getURL(res) {
                return 'meta/' + res.type + '/' + res.endpoint + '/' + res.index + '/' + res.store;
            }
        }]);

        return MetaRequestor;
    }(Requestor);

    module.exports = MetaRequestor;
})();

},{"./Requestor":131}],131:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function () {

    'use strict';

    var RETRY_INTERVAL = 5000;

    function getHost() {
        var loc = window.location;
        var new_uri = void 0;
        if (loc.protocol === 'https:') {
            new_uri = 'wss:';
        } else {
            new_uri = 'ws:';
        }
        return new_uri + '//' + loc.host + loc.pathname;
    }

    function establishConnection(requestor, callback) {
        requestor.socket = new WebSocket(getHost() + requestor.url);
        // on open
        requestor.socket.onopen = function () {
            requestor.isOpen = true;
            console.log('Websocket connection established');
            callback.apply(this, arguments);
        };
        // on message
        requestor.socket.onmessage = function (event) {
            var res = JSON.parse(event.data);
            var hash = requestor.getHash(res);
            var request = requestor.requests[hash];
            delete requestor.requests[hash];
            if (res.success) {
                request.resolve(requestor.getURL(res), res);
            } else {
                request.reject(res);
            }
        };
        // on close
        requestor.socket.onclose = function () {
            // log close only if connection was ever open
            if (requestor.isOpen) {
                console.warn('Websocket connection closed, attempting to re-connect in', RETRY_INTERVAL);
            }
            requestor.socket = null;
            requestor.isOpen = false;
            // reject all pending requests
            Object.keys(requestor.requests).forEach(function (key) {
                requestor.requests[key].reject();
            });
            // clear request map
            requestor.requests = {};
            // attempt to re-establish connection
            setTimeout(function () {
                establishConnection(requestor, function () {
                    // once connection is re-established, send pending requests
                    requestor.pending.forEach(function (req) {
                        requestor.get(req);
                    });
                    requestor.pending = [];
                });
            }, RETRY_INTERVAL);
        };
    }

    var Requestor = function () {
        function Requestor(url, callback) {
            _classCallCheck(this, Requestor);

            this.url = url;
            this.requests = {};
            this.pending = [];
            this.isOpen = false;
            establishConnection(this, callback);
        }

        _createClass(Requestor, [{
            key: 'getHash',
            value: function getHash() {
                // override
            }
        }, {
            key: 'getURL',
            value: function getURL() {
                // override
            }
        }, {
            key: 'get',
            value: function get(req) {
                if (!this.isOpen) {
                    // if no connection, add request to pending queue
                    this.pending.push(req);
                    return;
                }
                var hash = this.getHash(req);
                var request = this.requests[hash];
                if (request) {
                    return request.promise();
                }
                request = this.requests[hash] = $.Deferred();
                this.socket.send(JSON.stringify(req));
                return request.promise();
            }
        }, {
            key: 'close',
            value: function close() {
                this.socket.onclose = null;
                this.socket.close();
                this.socket = null;
            }
        }]);

        return Requestor;
    }();

    module.exports = Requestor;
})();

},{}],132:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

(function () {

    'use strict';

    var stringify = require('json-stable-stringify');
    var Requestor = require('./Requestor');

    function pruneEmpty(obj) {
        return function prune(current) {
            _.forOwn(current, function (value, key) {
                if (_.isUndefined(value) || _.isNull(value) || _.isNaN(value) || _.isString(value) && _.isEmpty(value) || _.isObject(value) && _.isEmpty(prune(value))) {
                    delete current[key];
                }
            });
            // remove any leftover undefined values from the delete
            // operation on an array
            if (_.isArray(current)) {
                _.pull(current, undefined);
            }
            return current;
        }(_.cloneDeep(obj)); // do not modify the original object, create a clone instead
    }

    var TileRequestor = function (_Requestor) {
        _inherits(TileRequestor, _Requestor);

        function TileRequestor(url, callback) {
            _classCallCheck(this, TileRequestor);

            return _possibleConstructorReturn(this, (TileRequestor.__proto__ || Object.getPrototypeOf(TileRequestor)).call(this, url, callback));
        }

        _createClass(TileRequestor, [{
            key: 'getHash',
            value: function getHash(req) {
                var coord = req.coord;
                var hash = stringify(pruneEmpty(req.params));
                return req.type + '-' + req.index + '-' + req.store + '-' + coord.z + '-' + coord.x + '-' + coord.y + '-' + hash;
            }
        }, {
            key: 'getURL',
            value: function getURL(res) {
                var coord = res.coord;
                return 'tile/' + res.type + '/' + res.index + '/' + res.store + '/' + coord.z + '/' + coord.x + '/' + coord.y;
            }
        }]);

        return TileRequestor;
    }(Requestor);

    module.exports = TileRequestor;
})();

},{"./Requestor":131,"json-stable-stringify":29}]},{},[62])(62)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvZWFjaE9mLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL2VhY2hPZkxpbWl0LmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL2RvTGltaXQuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvZWFjaE9mTGltaXQuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvZ2V0SXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvb25jZS5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9vbmx5T25jZS5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9wYXJhbGxlbC5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9wYXJhbGxlbC5qcyIsIm5vZGVfbW9kdWxlcy9lc3Blci9zcmMvY29yZS9Db2xvclRleHR1cmUyRC5qcyIsIm5vZGVfbW9kdWxlcy9lc3Blci9zcmMvY29yZS9EZXB0aFRleHR1cmUyRC5qcyIsIm5vZGVfbW9kdWxlcy9lc3Blci9zcmMvY29yZS9JbmRleEJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9lc3Blci9zcmMvY29yZS9SZW5kZXJUYXJnZXQuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvUmVuZGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9lc3Blci9zcmMvY29yZS9TaGFkZXIuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvU2hhZGVyUGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL2VzcGVyL3NyYy9jb3JlL1RleHR1cmUyRC5qcyIsIm5vZGVfbW9kdWxlcy9lc3Blci9zcmMvY29yZS9UZXh0dXJlQ3ViZU1hcC5qcyIsIm5vZGVfbW9kdWxlcy9lc3Blci9zcmMvY29yZS9WZXJ0ZXhCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvVmVydGV4UGFja2FnZS5qcyIsIm5vZGVfbW9kdWxlcy9lc3Blci9zcmMvY29yZS9WaWV3cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9lc3Blci9zcmMvY29yZS9XZWJHTENvbnRleHQuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2V4cG9ydHMuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL3V0aWwvQXN5bmMuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL3V0aWwvSW1hZ2VMb2FkZXIuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL3V0aWwvVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9lc3Blci9zcmMvdXRpbC9YSFJMb2FkZXIuanMiLCJub2RlX21vZHVsZXMvanNvbi1zdGFibGUtc3RyaW5naWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzb24tc3RhYmxlLXN0cmluZ2lmeS9ub2RlX21vZHVsZXMvanNvbmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXN0YWJsZS1zdHJpbmdpZnkvbm9kZV9tb2R1bGVzL2pzb25pZnkvbGliL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL2pzb24tc3RhYmxlLXN0cmluZ2lmeS9ub2RlX21vZHVsZXMvanNvbmlmeS9saWIvc3RyaW5naWZ5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVzdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9iZWZvcmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbm9vcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvb25jZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvcmVzdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9GaW5pdGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3RvSW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9OdW1iZXIuanMiLCJub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcyIsInNjcmlwdHMvQ1JTL0dyYXBoLmpzIiwic2NyaXB0cy9DUlMvZXhwb3J0cy5qcyIsInNjcmlwdHMvZXhwb3J0cy5qcyIsInNjcmlwdHMvbGF5ZXIvYWdnL0RhdGVIaXN0b2dyYW0uanMiLCJzY3JpcHRzL2xheWVyL2FnZy9IaXN0b2dyYW0uanMiLCJzY3JpcHRzL2xheWVyL2FnZy9NZXRyaWMuanMiLCJzY3JpcHRzL2xheWVyL2FnZy9UZXJtcy5qcyIsInNjcmlwdHMvbGF5ZXIvYWdnL1Rlcm1zRmlsdGVyLmpzIiwic2NyaXB0cy9sYXllci9hZ2cvVG9wSGl0cy5qcyIsInNjcmlwdHMvbGF5ZXIvYWdnL1RvcFRlcm1zLmpzIiwic2NyaXB0cy9sYXllci9jb3JlL0Jhc2UuanMiLCJzY3JpcHRzL2xheWVyL2NvcmUvQ29tcG9zaXRlLmpzIiwic2NyaXB0cy9sYXllci9jb3JlL0RlYnVnLmpzIiwic2NyaXB0cy9sYXllci9jb3JlL0ltYWdlLmpzIiwic2NyaXB0cy9sYXllci9jb3JlL0xpdmUuanMiLCJzY3JpcHRzL2xheWVyL2NvcmUvUGVuZGluZy5qcyIsInNjcmlwdHMvbGF5ZXIvZXhwb3J0cy5qcyIsInNjcmlwdHMvbGF5ZXIvcGFyYW0vQmlubmluZy5qcyIsInNjcmlwdHMvbGF5ZXIvcGFyYW0vRWxhc3RpYy5qcyIsInNjcmlwdHMvbGF5ZXIvcGFyYW0vVGlsaW5nLmpzIiwic2NyaXB0cy9sYXllci9xdWVyeS9Cb29sLmpzIiwic2NyaXB0cy9sYXllci9xdWVyeS9FeGlzdHMuanMiLCJzY3JpcHRzL2xheWVyL3F1ZXJ5L01hdGNoLmpzIiwic2NyaXB0cy9sYXllci9xdWVyeS9QcmVmaXguanMiLCJzY3JpcHRzL2xheWVyL3F1ZXJ5L1F1ZXJ5U3RyaW5nLmpzIiwic2NyaXB0cy9sYXllci9xdWVyeS9SYW5nZS5qcyIsInNjcmlwdHMvbGF5ZXIvcXVlcnkvVGVybXMuanMiLCJzY3JpcHRzL2xheWVyL3R5cGUvQ29tbXVuaXR5LmpzIiwic2NyaXB0cy9sYXllci90eXBlL0NvdW50LmpzIiwic2NyaXB0cy9sYXllci90eXBlL0hlYXRtYXAuanMiLCJzY3JpcHRzL2xheWVyL3R5cGUvTWFjcm8uanMiLCJzY3JpcHRzL2xheWVyL3R5cGUvTWljcm8uanMiLCJzY3JpcHRzL2xheWVyL3R5cGUvUHJldmlldy5qcyIsInNjcmlwdHMvbGF5ZXIvdHlwZS9Ub3BDb3VudC5qcyIsInNjcmlwdHMvbGF5ZXIvdHlwZS9Ub3BGcmVxdWVuY3kuanMiLCJzY3JpcHRzL2xheWVyL3R5cGUvVG9wVHJhaWxzLmpzIiwic2NyaXB0cy9sYXllci90eXBlL1RvcGljQ291bnQuanMiLCJzY3JpcHRzL2xheWVyL3R5cGUvVG9waWNGcmVxdWVuY3kuanMiLCJzY3JpcHRzL21hcC9NYXAuanMiLCJzY3JpcHRzL3Byb2plY3Rpb24vR3JhcGguanMiLCJzY3JpcHRzL3JlbmRlcmVyL2NvcmUvQ2FudmFzLmpzIiwic2NyaXB0cy9yZW5kZXJlci9jb3JlL0RPTS5qcyIsInNjcmlwdHMvcmVuZGVyZXIvY29yZS9IVE1MLmpzIiwic2NyaXB0cy9yZW5kZXJlci9jb3JlL092ZXJsYXkuanMiLCJzY3JpcHRzL3JlbmRlcmVyL2NvcmUvV2ViR0wuanMiLCJzY3JpcHRzL3JlbmRlcmVyL2V4cG9ydHMuanMiLCJzY3JpcHRzL3JlbmRlcmVyL21peGluL0NvbG9yUmFtcC5qcyIsInNjcmlwdHMvcmVuZGVyZXIvbWl4aW4vU3BhdGlhbEhhc2guanMiLCJzY3JpcHRzL3JlbmRlcmVyL21peGluL1ZhbHVlVHJhbnNmb3JtLmpzIiwic2NyaXB0cy9yZW5kZXJlci9zZW50aW1lbnQvU2VudGltZW50LmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL2NhbnZhcy9IZWF0bWFwLmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL2NhbnZhcy9QcmV2aWV3LmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL2NhbnZhcy9Ub3BUcmFpbHMuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvZGVidWcvQ29vcmQuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvaHRtbC9Db21tdW5pdHkuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvaHRtbC9Db21tdW5pdHlMYWJlbC5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS9odG1sL0VtcHR5LmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL2h0bWwvSGVhdG1hcC5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS9odG1sL1JpbmcuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvaHRtbC9Xb3JkQ2xvdWQuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvaHRtbC9Xb3JkSGlzdG9ncmFtLmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL3BlbmRpbmcvQmxpbmsuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvcGVuZGluZy9CbGlua1NwaW4uanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvcGVuZGluZy9EZWxheWVkQmxpbmsuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvcGVuZGluZy9EZWxheWVkU3Bpbi5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS9wZW5kaW5nL1NwaW4uanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvd2ViZ2wvSGVhdG1hcC5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS93ZWJnbC9Qb2ludC5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS93ZWJnbC9TaGFkZXJzLmpzIiwic2NyaXB0cy9yZXF1ZXN0L01ldGFSZXF1ZXN0b3IuanMiLCJzY3JpcHRzL3JlcXVlc3QvUmVxdWVzdG9yLmpzIiwic2NyaXB0cy9yZXF1ZXN0L1RpbGVSZXF1ZXN0b3IuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsbUlDLGFBQVc7O0FBRVI7O0FBRUEsUUFBSSxRQUFRLFFBQVEscUJBQVIsQ0FBWjs7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OztBQUFBO0FBQUEsTUF5Qm9CLFNBekJwQjs7QUF3Q1IsV0FBTyxPQUFQLEdBQWlCLGFBQWpCO0FBRUgsQ0ExQ0EsR0FBRCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciBlYWNoT2ZJbXBsZW1lbnRhdGlvbiA9ICgwLCBfaXNBcnJheUxpa2UyLmRlZmF1bHQpKGNvbGwpID8gZWFjaE9mQXJyYXlMaWtlIDogZWFjaE9mR2VuZXJpYztcbiAgICBlYWNoT2ZJbXBsZW1lbnRhdGlvbihjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spO1xufTtcblxudmFyIF9pc0FycmF5TGlrZSA9IHJlcXVpcmUoJ2xvZGFzaC9pc0FycmF5TGlrZScpO1xuXG52YXIgX2lzQXJyYXlMaWtlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQXJyYXlMaWtlKTtcblxudmFyIF9lYWNoT2ZMaW1pdCA9IHJlcXVpcmUoJy4vZWFjaE9mTGltaXQnKTtcblxudmFyIF9lYWNoT2ZMaW1pdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoT2ZMaW1pdCk7XG5cbnZhciBfZG9MaW1pdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvZG9MaW1pdCcpO1xuXG52YXIgX2RvTGltaXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9MaW1pdCk7XG5cbnZhciBfbm9vcCA9IHJlcXVpcmUoJ2xvZGFzaC9ub29wJyk7XG5cbnZhciBfbm9vcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub29wKTtcblxudmFyIF9vbmNlID0gcmVxdWlyZSgnbG9kYXNoL29uY2UnKTtcblxudmFyIF9vbmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29uY2UpO1xuXG52YXIgX29ubHlPbmNlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9vbmx5T25jZScpO1xuXG52YXIgX29ubHlPbmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29ubHlPbmNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gZWFjaE9mIGltcGxlbWVudGF0aW9uIG9wdGltaXplZCBmb3IgYXJyYXktbGlrZXNcbmZ1bmN0aW9uIGVhY2hPZkFycmF5TGlrZShjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9ICgwLCBfb25jZTIuZGVmYXVsdCkoY2FsbGJhY2sgfHwgX25vb3AyLmRlZmF1bHQpO1xuICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgIGNvbXBsZXRlZCA9IDAsXG4gICAgICAgIGxlbmd0aCA9IGNvbGwubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlcmF0b3JDYWxsYmFjayhlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSBlbHNlIGlmICgrK2NvbXBsZXRlZCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBpdGVyYXRlZShjb2xsW2luZGV4XSwgaW5kZXgsICgwLCBfb25seU9uY2UyLmRlZmF1bHQpKGl0ZXJhdG9yQ2FsbGJhY2spKTtcbiAgICB9XG59XG5cbi8vIGEgZ2VuZXJpYyB2ZXJzaW9uIG9mIGVhY2hPZiB3aGljaCBjYW4gaGFuZGxlIGFycmF5LCBvYmplY3QsIGFuZCBpdGVyYXRvciBjYXNlcy5cbnZhciBlYWNoT2ZHZW5lcmljID0gKDAsIF9kb0xpbWl0Mi5kZWZhdWx0KShfZWFjaE9mTGltaXQyLmRlZmF1bHQsIEluZmluaXR5KTtcblxuLyoqXG4gKiBMaWtlIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSwgZXhjZXB0IHRoYXQgaXQgcGFzc2VzIHRoZSBrZXkgKG9yIGluZGV4KSBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50XG4gKiB0byB0aGUgaXRlcmF0ZWUuXG4gKlxuICogQG5hbWUgZWFjaE9mXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgZm9yRWFjaE9mXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHNlZSBbYXN5bmMuZWFjaF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaFxuICogaXRlbSBpbiBgY29sbGAuIFRoZSBga2V5YCBpcyB0aGUgaXRlbSdzIGtleSwgb3IgaW5kZXggaW4gdGhlIGNhc2Ugb2YgYW5cbiAqIGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVycilgIHdoaWNoIG11c3QgYmUgY2FsbGVkIG9uY2UgaXRcbiAqIGhhcyBjb21wbGV0ZWQuIElmIG5vIGVycm9yIGhhcyBvY2N1cnJlZCwgdGhlIGNhbGxiYWNrIHNob3VsZCBiZSBydW4gd2l0aG91dFxuICogYXJndW1lbnRzIG9yIHdpdGggYW4gZXhwbGljaXQgYG51bGxgIGFyZ3VtZW50LiBJbnZva2VkIHdpdGhcbiAqIChpdGVtLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmogPSB7ZGV2OiBcIi9kZXYuanNvblwiLCB0ZXN0OiBcIi90ZXN0Lmpzb25cIiwgcHJvZDogXCIvcHJvZC5qc29uXCJ9O1xuICogdmFyIGNvbmZpZ3MgPSB7fTtcbiAqXG4gKiBhc3luYy5mb3JFYWNoT2Yob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5yZWFkRmlsZShfX2Rpcm5hbWUgKyB2YWx1ZSwgXCJ1dGY4XCIsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAqICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gKiAgICAgICAgIHRyeSB7XG4gKiAgICAgICAgICAgICBjb25maWdzW2tleV0gPSBKU09OLnBhcnNlKGRhdGEpO1xuICogICAgICAgICB9IGNhdGNoIChlKSB7XG4gKiAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gKiAgICAgICAgIH1cbiAqICAgICAgICAgY2FsbGJhY2soKTtcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBpZiAoZXJyKSBjb25zb2xlLmVycm9yKGVyci5tZXNzYWdlKTtcbiAqICAgICAvLyBjb25maWdzIGlzIG5vdyBhIG1hcCBvZiBKU09OIGRhdGFcbiAqICAgICBkb1NvbWV0aGluZ1dpdGgoY29uZmlncyk7XG4gKiB9KTtcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZWFjaE9mTGltaXQ7XG5cbnZhciBfZWFjaE9mTGltaXQyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9lYWNoT2ZMaW1pdCcpO1xuXG52YXIgX2VhY2hPZkxpbWl0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2hPZkxpbWl0Mik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BlYWNoT2ZgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgZWFjaE9mTGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmVhY2hPZl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn1cbiAqIEBhbGlhcyBmb3JFYWNoT2ZMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoXG4gKiBpdGVtIGluIGBjb2xsYC4gVGhlIGBrZXlgIGlzIHRoZSBpdGVtJ3Mga2V5LCBvciBpbmRleCBpbiB0aGUgY2FzZSBvZiBhblxuICogYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyKWAgd2hpY2ggbXVzdCBiZSBjYWxsZWQgb25jZSBpdFxuICogaGFzIGNvbXBsZXRlZC4gSWYgbm8gZXJyb3IgaGFzIG9jY3VycmVkLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGJlIHJ1biB3aXRob3V0XG4gKiBhcmd1bWVudHMgb3Igd2l0aCBhbiBleHBsaWNpdCBgbnVsbGAgYXJndW1lbnQuIEludm9rZWQgd2l0aFxuICogKGl0ZW0sIGtleSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqL1xuZnVuY3Rpb24gZWFjaE9mTGltaXQoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAoMCwgX2VhY2hPZkxpbWl0My5kZWZhdWx0KShsaW1pdCkoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBkb0xpbWl0O1xuZnVuY3Rpb24gZG9MaW1pdChmbiwgbGltaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZuKGl0ZXJhYmxlLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbiAgICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBfZWFjaE9mTGltaXQ7XG5cbnZhciBfbm9vcCA9IHJlcXVpcmUoJ2xvZGFzaC9ub29wJyk7XG5cbnZhciBfbm9vcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub29wKTtcblxudmFyIF9vbmNlID0gcmVxdWlyZSgnLi9vbmNlJyk7XG5cbnZhciBfb25jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vbmNlKTtcblxudmFyIF9pdGVyYXRvciA9IHJlcXVpcmUoJy4vaXRlcmF0b3InKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfb25seU9uY2UgPSByZXF1aXJlKCcuL29ubHlPbmNlJyk7XG5cbnZhciBfb25seU9uY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb25seU9uY2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZWFjaE9mTGltaXQobGltaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gKDAsIF9vbmNlMi5kZWZhdWx0KShjYWxsYmFjayB8fCBfbm9vcDIuZGVmYXVsdCk7XG4gICAgICAgIGlmIChsaW1pdCA8PSAwIHx8ICFvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dEVsZW0gPSAoMCwgX2l0ZXJhdG9yMi5kZWZhdWx0KShvYmopO1xuICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgICB2YXIgcnVubmluZyA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gaXRlcmF0ZWVDYWxsYmFjayhlcnIpIHtcbiAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkb25lICYmIHJ1bm5pbmcgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXBsZW5pc2goKSB7XG4gICAgICAgICAgICB3aGlsZSAocnVubmluZyA8IGxpbWl0ICYmICFkb25lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBuZXh0RWxlbSgpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTtcbiAgICAgICAgICAgICAgICBpdGVyYXRlZShlbGVtLnZhbHVlLCBlbGVtLmtleSwgKDAsIF9vbmx5T25jZTIuZGVmYXVsdCkoaXRlcmF0ZWVDYWxsYmFjaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoY29sbCkge1xuICAgIHJldHVybiBpdGVyYXRvclN5bWJvbCAmJiBjb2xsW2l0ZXJhdG9yU3ltYm9sXSAmJiBjb2xsW2l0ZXJhdG9yU3ltYm9sXSgpO1xufTtcblxudmFyIGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXRlcmF0b3I7XG5cbnZhciBfaXNBcnJheUxpa2UgPSByZXF1aXJlKCdsb2Rhc2gvaXNBcnJheUxpa2UnKTtcblxudmFyIF9pc0FycmF5TGlrZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0FycmF5TGlrZSk7XG5cbnZhciBfZ2V0SXRlcmF0b3IgPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yJyk7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IpO1xuXG52YXIgX2tleXMgPSByZXF1aXJlKCdsb2Rhc2gva2V5cycpO1xuXG52YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5SXRlcmF0b3IoY29sbCkge1xuICAgIHZhciBpID0gLTE7XG4gICAgdmFyIGxlbiA9IGNvbGwubGVuZ3RoO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICByZXR1cm4gKytpIDwgbGVuID8geyB2YWx1ZTogY29sbFtpXSwga2V5OiBpIH0gOiBudWxsO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVTMjAxNUl0ZXJhdG9yKGl0ZXJhdG9yKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVtLmRvbmUpIHJldHVybiBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtLnZhbHVlLCBrZXk6IGkgfTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RJdGVyYXRvcihvYmopIHtcbiAgICB2YXIgb2tleXMgPSAoMCwgX2tleXMyLmRlZmF1bHQpKG9iaik7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gb2tleXMubGVuZ3RoO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIga2V5ID0gb2tleXNbKytpXTtcbiAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyB7IHZhbHVlOiBvYmpba2V5XSwga2V5OiBrZXkgfSA6IG51bGw7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaXRlcmF0b3IoY29sbCkge1xuICAgIGlmICgoMCwgX2lzQXJyYXlMaWtlMi5kZWZhdWx0KShjb2xsKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQXJyYXlJdGVyYXRvcihjb2xsKTtcbiAgICB9XG5cbiAgICB2YXIgaXRlcmF0b3IgPSAoMCwgX2dldEl0ZXJhdG9yMi5kZWZhdWx0KShjb2xsKTtcbiAgICByZXR1cm4gaXRlcmF0b3IgPyBjcmVhdGVFUzIwMTVJdGVyYXRvcihpdGVyYXRvcikgOiBjcmVhdGVPYmplY3RJdGVyYXRvcihjb2xsKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBvbmNlO1xuZnVuY3Rpb24gb25jZShmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChmbiA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICB2YXIgY2FsbEZuID0gZm47XG4gICAgICAgIGZuID0gbnVsbDtcbiAgICAgICAgY2FsbEZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBvbmx5T25jZTtcbmZ1bmN0aW9uIG9ubHlPbmNlKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGZuID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuXCIpO1xuICAgICAgICB2YXIgY2FsbEZuID0gZm47XG4gICAgICAgIGZuID0gbnVsbDtcbiAgICAgICAgY2FsbEZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gX3BhcmFsbGVsO1xuXG52YXIgX25vb3AgPSByZXF1aXJlKCdsb2Rhc2gvbm9vcCcpO1xuXG52YXIgX25vb3AyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbm9vcCk7XG5cbnZhciBfaXNBcnJheUxpa2UgPSByZXF1aXJlKCdsb2Rhc2gvaXNBcnJheUxpa2UnKTtcblxudmFyIF9pc0FycmF5TGlrZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0FycmF5TGlrZSk7XG5cbnZhciBfcmVzdCA9IHJlcXVpcmUoJ2xvZGFzaC9yZXN0Jyk7XG5cbnZhciBfcmVzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZXN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3BhcmFsbGVsKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBfbm9vcDIuZGVmYXVsdDtcbiAgICB2YXIgcmVzdWx0cyA9ICgwLCBfaXNBcnJheUxpa2UyLmRlZmF1bHQpKHRhc2tzKSA/IFtdIDoge307XG5cbiAgICBlYWNoZm4odGFza3MsIGZ1bmN0aW9uICh0YXNrLCBrZXksIGNhbGxiYWNrKSB7XG4gICAgICAgIHRhc2soKDAsIF9yZXN0Mi5kZWZhdWx0KShmdW5jdGlvbiAoZXJyLCBhcmdzKSB7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0c1trZXldID0gYXJncztcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pKTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJhbGxlbExpbWl0O1xuXG52YXIgX2VhY2hPZiA9IHJlcXVpcmUoJy4vZWFjaE9mJyk7XG5cbnZhciBfZWFjaE9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2hPZik7XG5cbnZhciBfcGFyYWxsZWwgPSByZXF1aXJlKCcuL2ludGVybmFsL3BhcmFsbGVsJyk7XG5cbnZhciBfcGFyYWxsZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyYWxsZWwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFJ1biB0aGUgYHRhc2tzYCBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyBpbiBwYXJhbGxlbCwgd2l0aG91dCB3YWl0aW5nIHVudGlsXG4gKiB0aGUgcHJldmlvdXMgZnVuY3Rpb24gaGFzIGNvbXBsZXRlZC4gSWYgYW55IG9mIHRoZSBmdW5jdGlvbnMgcGFzcyBhbiBlcnJvciB0b1xuICogaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGVcbiAqIGVycm9yLiBPbmNlIHRoZSBgdGFza3NgIGhhdmUgY29tcGxldGVkLCB0aGUgcmVzdWx0cyBhcmUgcGFzc2VkIHRvIHRoZSBmaW5hbFxuICogYGNhbGxiYWNrYCBhcyBhbiBhcnJheS5cbiAqXG4gKiAqKk5vdGU6KiogYHBhcmFsbGVsYCBpcyBhYm91dCBraWNraW5nLW9mZiBJL08gdGFza3MgaW4gcGFyYWxsZWwsIG5vdCBhYm91dFxuICogcGFyYWxsZWwgZXhlY3V0aW9uIG9mIGNvZGUuICBJZiB5b3VyIHRhc2tzIGRvIG5vdCB1c2UgYW55IHRpbWVycyBvciBwZXJmb3JtXG4gKiBhbnkgSS9PLCB0aGV5IHdpbGwgYWN0dWFsbHkgYmUgZXhlY3V0ZWQgaW4gc2VyaWVzLiAgQW55IHN5bmNocm9ub3VzIHNldHVwXG4gKiBzZWN0aW9ucyBmb3IgZWFjaCB0YXNrIHdpbGwgaGFwcGVuIG9uZSBhZnRlciB0aGUgb3RoZXIuICBKYXZhU2NyaXB0IHJlbWFpbnNcbiAqIHNpbmdsZS10aHJlYWRlZC5cbiAqXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHVzZSBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gRWFjaCBwcm9wZXJ0eSB3aWxsXG4gKiBiZSBydW4gYXMgYSBmdW5jdGlvbiBhbmQgdGhlIHJlc3VsdHMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZpbmFsIGBjYWxsYmFja2BcbiAqIGFzIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5LiBUaGlzIGNhbiBiZSBhIG1vcmUgcmVhZGFibGUgd2F5IG9mIGhhbmRsaW5nXG4gKiByZXN1bHRzIGZyb20ge0BsaW5rIGFzeW5jLnBhcmFsbGVsfS5cbiAqXG4gKiBAbmFtZSBwYXJhbGxlbFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IHRhc2tzIC0gQSBjb2xsZWN0aW9uIGNvbnRhaW5pbmcgZnVuY3Rpb25zIHRvIHJ1bi5cbiAqIEVhY2ggZnVuY3Rpb24gaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVyciwgcmVzdWx0KWAgd2hpY2ggaXQgbXVzdCBjYWxsIG9uXG4gKiBjb21wbGV0aW9uIHdpdGggYW4gZXJyb3IgYGVycmAgKHdoaWNoIGNhbiBiZSBgbnVsbGApIGFuZCBhbiBvcHRpb25hbCBgcmVzdWx0YFxuICogdmFsdWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZVxuICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS4gVGhpcyBmdW5jdGlvbiBnZXRzIGEgcmVzdWx0cyBhcnJheVxuICogKG9yIG9iamVjdCkgY29udGFpbmluZyBhbGwgdGhlIHJlc3VsdCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSB0YXNrIGNhbGxiYWNrcy5cbiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEBleGFtcGxlXG4gKiBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogXSxcbiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrXG4gKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyB0aGUgcmVzdWx0cyBhcnJheSB3aWxsIGVxdWFsIFsnb25lJywndHdvJ10gZXZlbiB0aG91Z2hcbiAqICAgICAvLyB0aGUgc2Vjb25kIGZ1bmN0aW9uIGhhZCBhIHNob3J0ZXIgdGltZW91dC5cbiAqIH0pO1xuICpcbiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqIGFzeW5jLnBhcmFsbGVsKHtcbiAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDIpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGVxdWFscyB0bzoge29uZTogMSwgdHdvOiAyfVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHBhcmFsbGVsTGltaXQodGFza3MsIGNhbGxiYWNrKSB7XG4gICgwLCBfcGFyYWxsZWwyLmRlZmF1bHQpKF9lYWNoT2YyLmRlZmF1bHQsIHRhc2tzLCBjYWxsYmFjayk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIoZnVuY3Rpb24gKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IFRleHR1cmUyRCA9IHJlcXVpcmUoJy4vVGV4dHVyZTJEJyk7XG4gICAgbGV0IEltYWdlTG9hZGVyID0gcmVxdWlyZSgnLi4vdXRpbC9JbWFnZUxvYWRlcicpO1xuICAgIGxldCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyk7XG5cbiAgICBsZXQgTUFHX0ZJTFRFUlMgPSB7XG4gICAgICAgIE5FQVJFU1Q6IHRydWUsXG4gICAgICAgIExJTkVBUjogdHJ1ZVxuICAgIH07XG4gICAgbGV0IE1JTl9GSUxURVJTID0ge1xuICAgICAgICBORUFSRVNUOiB0cnVlLFxuICAgICAgICBMSU5FQVI6IHRydWUsXG4gICAgICAgIE5FQVJFU1RfTUlQTUFQX05FQVJFU1Q6IHRydWUsXG4gICAgICAgIExJTkVBUl9NSVBNQVBfTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTkVBUkVTVF9NSVBNQVBfTElORUFSOiB0cnVlLFxuICAgICAgICBMSU5FQVJfTUlQTUFQX0xJTkVBUjogdHJ1ZVxuICAgIH07XG4gICAgbGV0IFdSQVBfTU9ERVMgPSB7XG4gICAgICAgIFJFUEVBVDogdHJ1ZSxcbiAgICAgICAgTUlSUk9SRURfUkVQRUFUOiB0cnVlLFxuICAgICAgICBDTEFNUF9UT19FREdFOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgVFlQRVMgPSB7XG4gICAgICAgIFVOU0lHTkVEX0JZVEU6IHRydWUsXG4gICAgICAgIEZMT0FUOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgRk9STUFUUyA9IHtcbiAgICAgICAgUkdCOiB0cnVlLFxuICAgICAgICBSR0JBOiB0cnVlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHR5cGUgZm9yIGNvbG9yIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX1RZUEUgPSAnVU5TSUdORURfQllURSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3JtYXQgZm9yIGNvbG9yIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX0ZPUk1BVCA9ICdSR0JBJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHdyYXAgbW9kZSBmb3IgY29sb3IgdGV4dHVyZXMuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfV1JBUCA9ICdSRVBFQVQnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgbWluIC8gbWFnIGZpbHRlciBmb3IgY29sb3IgdGV4dHVyZXMuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfRklMVEVSID0gJ0xJTkVBUic7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3Igd2hldGhlciBhbHBoYSBwcmVtdWx0aXBseWluZyBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX1BSRU1VTFRJUExZX0FMUEhBID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZvciB3aGV0aGVyIG1pcG1hcHBpbmcgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9NSVBNQVAgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZm9yIHdoZXRoZXIgaW52ZXJ0LXkgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9JTlZFUlRfWSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgQ29sb3JUZXh0dXJlMkRcbiAgICAgKiBAY2xhc3NkZXNjIEEgdGV4dHVyZSBjbGFzcyB0byByZXByZXNlbnQgYSAyRCBjb2xvciB0ZXh0dXJlLlxuICAgICAqIEBhdWdtZW50cyBUZXh0dXJlMkRcbiAgICAgKi9cbiAgICBjbGFzcyBDb2xvclRleHR1cmUyRCBleHRlbmRzIFRleHR1cmUyRCB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3RhbnRpYXRlcyBhIENvbG9yVGV4dHVyZTJEIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNwZWMgLSBUaGUgc3BlY2lmaWNhdGlvbiBhcmd1bWVudHMuXG4gICAgICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gc3BlYy5pbWFnZSAtIFRoZSBIVE1MSW1hZ2VFbGVtZW50IHRvIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMudXJsIC0gVGhlIEhUTUxJbWFnZUVsZW1lbnQgVVJMIHRvIGxvYWQgYW5kIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtVaW50OEFycmF5fEZsb2F0MzJBcnJheX0gc3BlYy5zcmMgLSBUaGUgZGF0YSB0byBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcGVjLndpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3BlYy5oZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy53cmFwIC0gVGhlIHdyYXBwaW5nIHR5cGUgb3ZlciBib3RoIFMgYW5kIFQgZGltZW5zaW9uLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy53cmFwUyAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgdGhlIFMgZGltZW5zaW9uLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy53cmFwVCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgdGhlIFQgZGltZW5zaW9uLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy5maWx0ZXIgLSBUaGUgbWluIC8gbWFnIGZpbHRlciB1c2VkIGR1cmluZyBzY2FsaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy5taW5GaWx0ZXIgLSBUaGUgbWluaWZpY2F0aW9uIGZpbHRlciB1c2VkIGR1cmluZyBzY2FsaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy5tYWdGaWx0ZXIgLSBUaGUgbWFnbmlmaWNhdGlvbiBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtib29sfSBzcGVjLm1pcE1hcCAtIFdoZXRoZXIgb3Igbm90IG1pcC1tYXBwaW5nIGlzIGVuYWJsZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gc3BlYy5pbnZlcnRZIC0gV2hldGhlciBvciBub3QgaW52ZXJ0LXkgaXMgZW5hYmxlZC5cbiAgICAgICAgICogQHBhcmFtIHtib29sfSBzcGVjLnByZU11bHRpcGx5QWxwaGEgLSBXaGV0aGVyIG9yIG5vdCBhbHBoYSBwcmVtdWx0aXBseWluZyBpcyBlbmFibGVkLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy5mb3JtYXQgLSBUaGUgdGV4dHVyZSBwaXhlbCBmb3JtYXQuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLnR5cGUgLSBUaGUgdGV4dHVyZSBwaXhlbCBjb21wb25lbnQgdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgaWYgdGhlIGRhdGEgaXMgbG9hZGVkIGFzeW5jaHJvbm91c2x5IHZpYSBhIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHNwZWMgPSB7fSwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBnZXQgc3BlY2lmaWMgcGFyYW1zXG4gICAgICAgICAgICBzcGVjLndyYXBTID0gc3BlYy53cmFwUyB8fCBzcGVjLndyYXA7XG4gICAgICAgICAgICBzcGVjLndyYXBUID0gc3BlYy53cmFwVCB8fCBzcGVjLndyYXA7XG4gICAgICAgICAgICBzcGVjLm1pbkZpbHRlciA9IHNwZWMubWluRmlsdGVyIHx8IHNwZWMuZmlsdGVyO1xuICAgICAgICAgICAgc3BlYy5tYWdGaWx0ZXIgPSBzcGVjLm1hZ0ZpbHRlciB8fCBzcGVjLmZpbHRlcjtcbiAgICAgICAgICAgIC8vIHNldCB0ZXh0dXJlIHBhcmFtc1xuICAgICAgICAgICAgc3BlYy53cmFwUyA9IFdSQVBfTU9ERVNbc3BlYy53cmFwU10gPyBzcGVjLndyYXBTIDogREVGQVVMVF9XUkFQO1xuICAgICAgICAgICAgc3BlYy53cmFwVCA9IFdSQVBfTU9ERVNbc3BlYy53cmFwVF0gPyBzcGVjLndyYXBUIDogREVGQVVMVF9XUkFQO1xuICAgICAgICAgICAgc3BlYy5taW5GaWx0ZXIgPSBNSU5fRklMVEVSU1tzcGVjLm1pbkZpbHRlcl0gPyBzcGVjLm1pbkZpbHRlciA6IERFRkFVTFRfRklMVEVSO1xuICAgICAgICAgICAgc3BlYy5tYWdGaWx0ZXIgPSBNQUdfRklMVEVSU1tzcGVjLm1hZ0ZpbHRlcl0gPyBzcGVjLm1hZ0ZpbHRlciA6IERFRkFVTFRfRklMVEVSO1xuICAgICAgICAgICAgLy8gc2V0IG90aGVyIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHNwZWMubWlwTWFwID0gc3BlYy5taXBNYXAgIT09IHVuZGVmaW5lZCA/IHNwZWMubWlwTWFwIDogREVGQVVMVF9NSVBNQVA7XG4gICAgICAgICAgICBzcGVjLmludmVydFkgPSBzcGVjLmludmVydFkgIT09IHVuZGVmaW5lZCA/IHNwZWMuaW52ZXJ0WSA6IERFRkFVTFRfSU5WRVJUX1k7XG4gICAgICAgICAgICBzcGVjLnByZU11bHRpcGx5QWxwaGEgPSBzcGVjLnByZU11bHRpcGx5QWxwaGEgIT09IHVuZGVmaW5lZCA/IHNwZWMucHJlTXVsdGlwbHlBbHBoYSA6IERFRkFVTFRfUFJFTVVMVElQTFlfQUxQSEE7XG4gICAgICAgICAgICAvLyBzZXQgZm9ybWF0XG4gICAgICAgICAgICBzcGVjLmZvcm1hdCA9IEZPUk1BVFNbc3BlYy5mb3JtYXRdID8gc3BlYy5mb3JtYXQgOiBERUZBVUxUX0ZPUk1BVDtcbiAgICAgICAgICAgIC8vIGJ1ZmZlciB0aGUgdGV4dHVyZSBiYXNlZCBvbiBhcmd1bWVudCB0eXBlXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMuc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3Qgc291cmNlIGZyb20gdXJsXG4gICAgICAgICAgICAgICAgc3BlYy50eXBlID0gJ1VOU0lHTkVEX0JZVEUnO1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgYmFzZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIHN1cGVyKHNwZWMpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHB1dCBleHRlbnNpb24gaGFuZGxpbmcgZm9yIGFycmF5YnVmZmVyIC8gaW1hZ2UgLyB2aWRlbyBkaWZmZXJlbnRpYXRpb25cbiAgICAgICAgICAgICAgICBJbWFnZUxvYWRlci5sb2FkKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBzcGVjLnNyYyxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogaW1hZ2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHRvIHVuc2lnbmVkIGJ5dGUgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBVdGlsLnJlc2l6ZUNhbnZhcyhzcGVjLCBpbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3cgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlckRhdGEoaW1hZ2UsIHNwZWMud2lkdGgsIHNwZWMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVycyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbC5pc0NhbnZhc1R5cGUoc3BlYy5zcmMpKSB7XG4gICAgICAgICAgICAgICAgLy8gaXMgaW1hZ2UgLyBjYW52YXMgLyB2aWRlbyB0eXBlXG4gICAgICAgICAgICAgICAgLy8gc2V0IHRvIHVuc2lnbmVkIGJ5dGUgdHlwZVxuICAgICAgICAgICAgICAgIHNwZWMudHlwZSA9ICdVTlNJR05FRF9CWVRFJztcbiAgICAgICAgICAgICAgICBzcGVjLnNyYyA9IFV0aWwucmVzaXplQ2FudmFzKHNwZWMsIHNwZWMuc3JjKTtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIGJhc2UgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICBzdXBlcihzcGVjKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYXJyYXksIGFycmF5YnVmZmVyLCBvciBudWxsXG4gICAgICAgICAgICAgICAgaWYgKHNwZWMuc3JjID09PSB1bmRlZmluZWQgfHwgc3BlYy5zcmMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gZGF0YSBpcyBwcm92aWRlZCwgYXNzdW1lIHRoaXMgdGV4dHVyZSB3aWxsIGJlIHJlbmRlcmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvLiBJbiB0aGlzIGNhc2UgZGlzYWJsZSBtaXBtYXBwaW5nLCB0aGVyZSBpcyBubyBuZWVkIGFuZCBpdFxuICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIG9ubHkgaW50cm9kdWNlIHZlcnkgcGVjdWxpYXIgYW5kIGRpZmZpY3VsdCB0byBkaXNjZXJuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbmRlcmluZyBwaGVub21lbmEgaW4gd2hpY2ggdGhlIHRleHR1cmUgJ3RyYW5zZm9ybXMnIGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gYW5nbGVzIC8gZGlzdGFuY2VzIHRvIHRoZSBtaXBtYXBwZWQgKGVtcHR5KSBwb3J0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgc3BlYy5taXBNYXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYnVmZmVyIGZyb20gYXJnXG4gICAgICAgICAgICAgICAgc3BlYy50eXBlID0gVFlQRVNbc3BlYy50eXBlXSA/IHNwZWMudHlwZSA6IERFRkFVTFRfVFlQRTtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIGJhc2UgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICBzdXBlcihzcGVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ29sb3JUZXh0dXJlMkQ7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IFRleHR1cmUyRCA9IHJlcXVpcmUoJy4vVGV4dHVyZTJEJyk7XG5cbiAgICBsZXQgTUFHX0ZJTFRFUlMgPSB7XG4gICAgICAgIE5FQVJFU1Q6IHRydWUsXG4gICAgICAgIExJTkVBUjogdHJ1ZVxuICAgIH07XG4gICAgbGV0IE1JTl9GSUxURVJTID0ge1xuICAgICAgICBORUFSRVNUOiB0cnVlLFxuICAgICAgICBMSU5FQVI6IHRydWVcbiAgICB9O1xuICAgIGxldCBXUkFQX01PREVTID0ge1xuICAgICAgICBSRVBFQVQ6IHRydWUsXG4gICAgICAgIENMQU1QX1RPX0VER0U6IHRydWUsXG4gICAgICAgIE1JUlJPUkVEX1JFUEVBVDogdHJ1ZVxuICAgIH07XG4gICAgbGV0IERFUFRIX1RZUEVTID0ge1xuICAgICAgICBVTlNJR05FRF9CWVRFOiB0cnVlLFxuICAgICAgICBVTlNJR05FRF9TSE9SVDogdHJ1ZSxcbiAgICAgICAgVU5TSUdORURfSU5UOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgRk9STUFUUyA9IHtcbiAgICAgICAgREVQVEhfQ09NUE9ORU5UOiB0cnVlLFxuICAgICAgICBERVBUSF9TVEVOQ0lMOiB0cnVlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHR5cGUgZm9yIGRlcHRoIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX1RZUEUgPSAnVU5TSUdORURfSU5UJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZvcm1hdCBmb3IgZGVwdGggdGV4dHVyZXMuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfRk9STUFUID0gJ0RFUFRIX0NPTVBPTkVOVCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCB3cmFwIG1vZGUgZm9yIGRlcHRoIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX1dSQVAgPSAnQ0xBTVBfVE9fRURHRSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBtaW4gLyBtYWcgZmlsdGVyIGZvciBkZXB0aCB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9GSUxURVIgPSAnTElORUFSJztcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBEZXB0aFRleHR1cmUyRFxuICAgICAqIEBjbGFzc2Rlc2MgQSB0ZXh0dXJlIGNsYXNzIHRvIHJlcHJlc2VudCBhIDJEIGRlcHRoIHRleHR1cmUuXG4gICAgICogQGF1Z21lbnRzIFRleHR1cmUyRFxuICAgICAqL1xuICAgIGNsYXNzIERlcHRoVGV4dHVyZTJEIGV4dGVuZHMgVGV4dHVyZTJEIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFudGlhdGVzIGEgRGVwdGhUZXh0dXJlMkQgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlYyAtIFRoZSBzcGVjaWZpY2F0aW9uIGFyZ3VtZW50cy5cbiAgICAgICAgICogQHBhcmFtIHtVaW50OEFycmF5fFVpbnQxNkFycmF5fFVpbnQzMkFycmF5fSBzcGVjLnNyYyAtIFRoZSBkYXRhIHRvIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWMud2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHRleHR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcGVjLmhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIHRleHR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLndyYXAgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIGJvdGggUyBhbmQgVCBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLndyYXBTIC0gVGhlIHdyYXBwaW5nIHR5cGUgb3ZlciB0aGUgUyBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLndyYXBUIC0gVGhlIHdyYXBwaW5nIHR5cGUgb3ZlciB0aGUgVCBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLmZpbHRlciAtIFRoZSBtaW4gLyBtYWcgZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLm1pbkZpbHRlciAtIFRoZSBtaW5pZmljYXRpb24gZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLm1hZ0ZpbHRlciAtIFRoZSBtYWduaWZpY2F0aW9uIGZpbHRlciB1c2VkIGR1cmluZyBzY2FsaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy5mb3JtYXQgLSBUaGUgdGV4dHVyZSBwaXhlbCBmb3JtYXQuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLnR5cGUgLSBUaGUgdGV4dHVyZSBwaXhlbCBjb21wb25lbnQgdHlwZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHNwZWMgPSB7fSkge1xuICAgICAgICAgICAgLy8gZ2V0IHNwZWNpZmljIHBhcmFtc1xuICAgICAgICAgICAgc3BlYy53cmFwUyA9IHNwZWMud3JhcFMgfHwgc3BlYy53cmFwO1xuICAgICAgICAgICAgc3BlYy53cmFwVCA9IHNwZWMud3JhcFQgfHwgc3BlYy53cmFwO1xuICAgICAgICAgICAgc3BlYy5taW5GaWx0ZXIgPSBzcGVjLm1pbkZpbHRlciB8fCBzcGVjLmZpbHRlcjtcbiAgICAgICAgICAgIHNwZWMubWFnRmlsdGVyID0gc3BlYy5tYWdGaWx0ZXIgfHwgc3BlYy5maWx0ZXI7XG4gICAgICAgICAgICAvLyBzZXQgdGV4dHVyZSBwYXJhbXNcbiAgICAgICAgICAgIHNwZWMud3JhcFMgPSBXUkFQX01PREVTW3NwZWMud3JhcFNdID8gc3BlYy53cmFwUyA6IERFRkFVTFRfV1JBUDtcbiAgICAgICAgICAgIHNwZWMud3JhcFQgPSBXUkFQX01PREVTW3NwZWMud3JhcFRdID8gc3BlYy53cmFwVCA6IERFRkFVTFRfV1JBUDtcbiAgICAgICAgICAgIHNwZWMubWluRmlsdGVyID0gTUlOX0ZJTFRFUlNbc3BlYy5taW5GaWx0ZXJdID8gc3BlYy5taW5GaWx0ZXIgOiBERUZBVUxUX0ZJTFRFUjtcbiAgICAgICAgICAgIHNwZWMubWFnRmlsdGVyID0gTUFHX0ZJTFRFUlNbc3BlYy5tYWdGaWx0ZXJdID8gc3BlYy5tYWdGaWx0ZXIgOiBERUZBVUxUX0ZJTFRFUjtcbiAgICAgICAgICAgIC8vIHNldCBtaXAtbWFwcGluZyBhbmQgZm9ybWF0XG4gICAgICAgICAgICBzcGVjLm1pcE1hcCA9IGZhbHNlOyAvLyBkaXNhYmxlIG1pcC1tYXBwaW5nXG4gICAgICAgICAgICBzcGVjLmludmVydFkgPSBmYWxzZTsgLy8gbm8gbmVlZCB0byBpbnZlcnQteVxuICAgICAgICAgICAgc3BlYy5wcmVNdWx0aXBseUFscGhhID0gZmFsc2U7IC8vIG5vIGFscGhhIHRvIHByZS1tdWx0aXBseVxuICAgICAgICAgICAgc3BlYy5mb3JtYXQgPSBGT1JNQVRTW3NwZWMuZm9ybWF0XSA/IHNwZWMuZm9ybWF0IDogREVGQVVMVF9GT1JNQVQ7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBzdGVuY2lsLWRlcHRoLCBvciBqdXN0IGRlcHRoXG4gICAgICAgICAgICBpZiAoc3BlYy5mb3JtYXQgPT09ICdERVBUSF9TVEVOQ0lMJykge1xuICAgICAgICAgICAgICAgIHNwZWMudHlwZSA9ICdVTlNJR05FRF9JTlRfMjRfOF9XRUJHTCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwZWMudHlwZSA9IERFUFRIX1RZUEVTW3NwZWMudHlwZV0gPyBzcGVjLnR5cGUgOiBERUZBVUxUX1RZUEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjYWxsIGJhc2UgY29uc3RydWN0b3JcbiAgICAgICAgICAgIHN1cGVyKHNwZWMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEZXB0aFRleHR1cmUyRDtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgV2ViR0xDb250ZXh0ID0gcmVxdWlyZSgnLi9XZWJHTENvbnRleHQnKTtcblxuICAgIGxldCBUWVBFUyA9IHtcbiAgICAgICAgVU5TSUdORURfQllURTogdHJ1ZSxcbiAgICAgICAgVU5TSUdORURfU0hPUlQ6IHRydWUsXG4gICAgICAgIFVOU0lHTkVEX0lOVDogdHJ1ZVxuICAgIH07XG4gICAgbGV0IE1PREVTID0ge1xuICAgICAgICBQT0lOVFM6IHRydWUsXG4gICAgICAgIExJTkVTOiB0cnVlLFxuICAgICAgICBMSU5FX1NUUklQOiB0cnVlLFxuICAgICAgICBMSU5FX0xPT1A6IHRydWUsXG4gICAgICAgIFRSSUFOR0xFUzogdHJ1ZSxcbiAgICAgICAgVFJJQU5HTEVfU1RSSVA6IHRydWUsXG4gICAgICAgIFRSSUFOR0xFX0ZBTjogdHJ1ZVxuICAgIH07XG4gICAgbGV0IEJZVEVTX1BFUl9UWVBFID0ge1xuICAgICAgICBVTlNJR05FRF9CWVRFOiAxLFxuICAgICAgICBVTlNJR05FRF9TSE9SVDogMixcbiAgICAgICAgVU5TSUdORURfSU5UOiA0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGNvbXBvbmVudCB0eXBlLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX1RZUEUgPSAnVU5TSUdORURfU0hPUlQnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgcmVuZGVyIG1vZGUgKHByaW1pdGl2ZSB0eXBlKS5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9NT0RFID0gJ1RSSUFOR0xFUyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBieXRlIG9mZnNldCB0byByZW5kZXIgZnJvbS5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9CWVRFX09GRlNFVCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBjb3VudCBvZiBpbmRpY2VzIHRvIHJlbmRlci5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9DT1VOVCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgSW5kZXhCdWZmZXJcbiAgICAgKiBAY2xhc3NkZXNjIEFuIGluZGV4IGJ1ZmZlciBjbGFzcyB0byBob2xlIGluZGV4aW5nIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIEluZGV4QnVmZmVyIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFudGlhdGVzIGFuIEluZGV4QnVmZmVyIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtXZWJHTEJ1ZmZlcnxVaW50OEFycmF5fFVpbnQxNkFycmF5fFVpbjMyQXJyYXl8QXJyYXl8TnVtYmVyfSBhcmcgLSBUaGUgaW5kZXggZGF0YSB0byBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHJlbmRlcmluZyBvcHRpb25zLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5tb2RlIC0gVGhlIGRyYXcgbW9kZSAvIHByaW1pdGl2ZSB0eXBlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5ieXRlT2Zmc2V0IC0gVGhlIGJ5dGUgb2Zmc2V0IGludG8gdGhlIGRyYXduIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuY291bnQgLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHRvIGRyYXcuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihhcmcsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgdGhpcy5nbCA9IFdlYkdMQ29udGV4dC5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFRZUEVTW29wdGlvbnMudHlwZV0gPyBvcHRpb25zLnR5cGUgOiBERUZBVUxUX1RZUEU7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBNT0RFU1tvcHRpb25zLm1vZGVdID8gb3B0aW9ucy5tb2RlIDogREVGQVVMVF9NT0RFO1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IChvcHRpb25zLmNvdW50ICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5jb3VudCA6IERFRkFVTFRfQ09VTlQ7XG4gICAgICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgPSAob3B0aW9ucy5ieXRlT2Zmc2V0ICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5ieXRlT2Zmc2V0IDogREVGQVVMVF9CWVRFX09GRlNFVDtcbiAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIFdlYkdMQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlYkdMQnVmZmVyIGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0FyZ3VtZW50IG9mIHR5cGUgV2ViR0xCdWZmZXJgIG11c3QgYmUgY29tcGxpbWVudGVkIHdpdGggYSBjb3JyZXNwb25kaW5nIGBvcHRpb25zLmJ5dGVMZW5ndGhgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSBvcHRpb25zLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gYXJnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzSW50ZWdlcihhcmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ5dGUgbGVuZ3RoIGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0FyZ3VtZW50IG9mIHR5cGUgYG51bWJlcmAgbXVzdCBiZSBjb21wbGltZW50ZWQgd2l0aCBhIGNvcnJlc3BvbmRpbmcgYG9wdGlvbnMudHlwZWAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyRGF0YShhcmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJyYXlCdWZmZXIgYXJnXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0FyZ3VtZW50IG9mIHR5cGUgYEFycmF5QnVmZmVyYCBtdXN0IGJlIGNvbXBsaW1lbnRlZCB3aXRoIGEgY29ycmVzcG9uZGluZyBgb3B0aW9ucy50eXBlYCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJEYXRhKGFyZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJyYXkgb3IgQXJyYXlCdWZmZXJWaWV3IGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyRGF0YShhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdFbXB0eSBidWZmZXIgbXVzdCBiZSBjb21wbGltZW50ZWQgd2l0aCBhIGNvcnJlc3BvbmRpbmcgYG9wdGlvbnMudHlwZWAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGxvYWQgaW5kZXggZGF0YSB0byB0aGUgR1BVLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld3xudW1iZXJ9IGFyZyAtIFRoZSBhcnJheSBvZiBkYXRhIHRvIGJ1ZmZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7SW5kZXhCdWZmZXJ9IFRoZSBpbmRleCBidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBidWZmZXJEYXRhKGFyZykge1xuICAgICAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIC8vIGNhc3QgYXJyYXkgdG8gQXJyYXlCdWZmZXJWaWV3IGJhc2VkIG9uIHByb3ZpZGVkIHR5cGVcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgdHlwZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdVTlNJR05FRF9JTlQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciB0byB1aW50MzJcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gbmV3IFVpbnQzMkFycmF5KGFyZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdVTlNJR05FRF9TSE9SVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnVmZmVyIHRvIHVpbnQxNlxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBuZXcgVWludDE2QXJyYXkoYXJnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBidWZmZXIgdG8gdWludDhcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gbmV3IFVpbnQ4QXJyYXkoYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNldCBlbnN1cmUgdHlwZSBjb3JyZXNwb25kcyB0byBkYXRhXG4gICAgICAgICAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdVTlNJR05FRF9JTlQnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgVWludDE2QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ1VOU0lHTkVEX1NIT1JUJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ1VOU0lHTkVEX0JZVEUnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICEoYXJnIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpICYmXG4gICAgICAgICAgICAgICAgICAgICEoTnVtYmVyLmlzSW50ZWdlcihhcmcpKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0FyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBgQXJyYXlgLCBgQXJyYXlCdWZmZXJgLCBgQXJyYXlCdWZmZXJWaWV3YCwgb3IgYG51bWJlcmAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgdGhlIHR5cGUgaXMgc3VwcG9ydGVkIGJ5IGV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ1VOU0lHTkVEX0lOVCcgJiZcbiAgICAgICAgICAgICAgICAhV2ViR0xDb250ZXh0LmNoZWNrRXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQ2Fubm90IGNyZWF0ZSBJbmRleEJ1ZmZlciBvZiB0eXBlIGBVTlNJR05FRF9JTlRgIGFzIGV4dGVuc2lvbiBgT0VTX2VsZW1lbnRfaW5kZXhfdWludGAgaXMgbm90IHN1cHBvcnRlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBvdmVyd3JpdGUgdGhlIGNvdW50IGlmIGl0IGlzIGFscmVhZHkgc2V0XG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudCA9PT0gREVGQVVMVF9DT1VOVCkge1xuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGFyZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IChhcmcgLyBCWVRFU19QRVJfVFlQRVt0aGlzLnR5cGVdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gYXJnLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgYnl0ZSBsZW5ndGhcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGFyZykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSBhcmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGFyZy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY3JlYXRlIGJ1ZmZlciBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHlcbiAgICAgICAgICAgIGlmICghdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYnVmZmVyIHRoZSBkYXRhXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XG4gICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBhcmcsIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwbG9hZCBwYXJ0aWFsIGluZGV4IGRhdGEgdG8gdGhlIEdQVS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9IGFycmF5IC0gVGhlIGFycmF5IG9mIGRhdGEgdG8gYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gYnl0ZU9mZnNldCAtIFRoZSBieXRlIG9mZnNldCBhdCB3aGljaCB0byBidWZmZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0luZGV4QnVmZmVyfSBUaGUgaW5kZXggYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgYnVmZmVyU3ViRGF0YShhcnJheSwgYnl0ZU9mZnNldCA9IERFRkFVTFRfQllURV9PRkZTRVQpIHtcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0J1ZmZlciBoYXMgbm90IHlldCBiZWVuIGFsbG9jYXRlZCwgYWxsb2NhdGUgd2l0aCBgYnVmZmVyRGF0YWAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2FzdCBhcnJheSB0byBBcnJheUJ1ZmZlclZpZXcgYmFzZWQgb24gcHJvdmlkZWQgdHlwZVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHR5cGVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnVU5TSUdORURfSU5UJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBidWZmZXIgdG8gdWludDMyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KGFycmF5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ1VOU0lHTkVEX1NIT1JUJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBidWZmZXIgdG8gdWludDE2XG4gICAgICAgICAgICAgICAgICAgIGFycmF5ID0gbmV3IFVpbnQxNkFycmF5KGFycmF5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBidWZmZXIgdG8gdWludDhcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAhKGFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkgJiZcbiAgICAgICAgICAgICAgICAhKGFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkpICYmXG4gICAgICAgICAgICAgICAgIShhcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSAmJlxuICAgICAgICAgICAgICAgICEoYXJyYXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGBBcnJheWAsIGBBcnJheUJ1ZmZlcmAsIG9yIGBBcnJheUJ1ZmZlclZpZXdgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgd2UgYXJlbid0IG92ZXJmbG93aW5nIHRoZSBidWZmZXJcbiAgICAgICAgICAgIGlmIChieXRlT2Zmc2V0ICsgYXJyYXkuYnl0ZUxlbmd0aCA+IHRoaXMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IGBBcmd1bWVudCBvZiBsZW5ndGggJHthcnJheS5ieXRlTGVuZ3RofSBieXRlcyB3aXRoIGAgK1xuICAgICAgICAgICAgICAgICAgICBgb2Zmc2V0IG9mICR7Ynl0ZU9mZnNldH0gYnl0ZXMgb3ZlcmZsb3dzIHRoZSBidWZmZXIgYCArXG4gICAgICAgICAgICAgICAgICAgIGBsZW5ndGggb2YgJHt0aGlzLmJ5dGVMZW5ndGh9IGJ5dGVzYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ5dGVPZmZzZXQsIGFycmF5KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4ZWN1dGUgdGhlIGRyYXcgY29tbWFuZCBmb3IgdGhlIGJvdW5kIGJ1ZmZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvICdkcmF3RWxlbWVudHMnLiBPcHRpb25hbC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubW9kZSAtIFRoZSBkcmF3IG1vZGUgLyBwcmltaXRpdmUgdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYnl0ZU9mZnNldCAtIFRoZSBieXRlT2Zmc2V0IGludG8gdGhlIGRyYXduIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuY291bnQgLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHRvIGRyYXcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0luZGV4QnVmZmVyfSBUaGUgaW5kZXggYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgZHJhdyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICBsZXQgbW9kZSA9IGdsW29wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGVdO1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBnbFt0aGlzLnR5cGVdO1xuICAgICAgICAgICAgbGV0IGJ5dGVPZmZzZXQgPSAob3B0aW9ucy5ieXRlT2Zmc2V0ICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5ieXRlT2Zmc2V0IDogdGhpcy5ieXRlT2Zmc2V0O1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gKG9wdGlvbnMuY291bnQgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmNvdW50IDogdGhpcy5jb3VudDtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdBdHRlbXB0aW5nIHRvIGRyYXcgd2l0aCBhIGNvdW50IG9mIDAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmluZCBidWZmZXJcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgIC8vIGRyYXcgZWxlbWVudHNcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhtb2RlLCBjb3VudCwgdHlwZSwgYnl0ZU9mZnNldCk7XG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIHVuYmluZFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEluZGV4QnVmZmVyO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBXZWJHTENvbnRleHQgPSByZXF1aXJlKCcuL1dlYkdMQ29udGV4dCcpO1xuXG4gICAgbGV0IFRFWFRVUkVfVEFSR0VUUyA9IHtcbiAgICAgICAgVEVYVFVSRV8yRDogdHJ1ZSxcbiAgICAgICAgVEVYVFVSRV9DVUJFX01BUDogdHJ1ZVxuICAgIH07XG5cbiAgICBsZXQgREVQVEhfRk9STUFUUyA9IHtcbiAgICAgICAgREVQVEhfQ09NUE9ORU5UOiB0cnVlLFxuICAgICAgICBERVBUSF9TVEVOQ0lMOiB0cnVlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBSZW5kZXJUYXJnZXRcbiAgICAgKiBAY2xhc3NkZXNjIEEgcmVuZGVyVGFyZ2V0IGNsYXNzIHRvIGFsbG93IHJlbmRlcmluZyB0byB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICBjbGFzcyBSZW5kZXJUYXJnZXQge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYSBSZW5kZXJUYXJnZXQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5nbCA9IFdlYkdMQ29udGV4dC5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVidWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQmluZHMgdGhlIHJlbmRlclRhcmdldCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1JlbmRlclRhcmdldH0gVGhlIHJlbmRlclRhcmdldCBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGJpbmQoKSB7XG4gICAgICAgICAgICAvLyBiaW5kIGZyYW1lYnVmZmVyXG4gICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuYmluZHMgdGhlIHJlbmRlclRhcmdldCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1JlbmRlclRhcmdldH0gVGhlIHJlbmRlclRhcmdldCBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHVuYmluZCgpIHtcbiAgICAgICAgICAgIC8vIHVuYmluZCBmcmFtZWJ1ZmZlclxuICAgICAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2hlcyB0aGUgcHJvdmlkZWQgdGV4dHVyZSB0byB0aGUgcHJvdmlkZWQgYXR0YWNobWVudCBsb2NhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtUZXh0dXJlMkR9IHRleHR1cmUgLSBUaGUgdGV4dHVyZSB0byBhdHRhY2guXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBhdHRhY2htZW50IGluZGV4LiAob3B0aW9uYWwpXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXQgLSBUaGUgdGV4dHVyZSB0YXJnZXQgdHlwZS4gKG9wdGlvbmFsKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtSZW5kZXJUYXJnZXR9IFRoZSByZW5kZXJUYXJnZXQgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDb2xvclRhcmdldCh0ZXh0dXJlLCBpbmRleCwgdGFyZ2V0KSB7XG4gICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgaWYgKCF0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1RleHR1cmUgYXJndW1lbnQgaXMgbWlzc2luZyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVEVYVFVSRV9UQVJHRVRTW2luZGV4XSAmJiB0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcihpbmRleCkgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1RleHR1cmUgY29sb3IgYXR0YWNobWVudCBpbmRleCBpcyBpbnZhbGlkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQgJiYgIVRFWFRVUkVfVEFSR0VUU1t0YXJnZXRdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1RleHR1cmUgdGFyZ2V0IGlzIGludmFsaWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlc1snY29sb3InICsgaW5kZXhdID0gdGV4dHVyZTtcbiAgICAgICAgICAgIHRoaXMuYmluZCgpO1xuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICAgICAgICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICAgICAgICAgICAgZ2xbJ0NPTE9SX0FUVEFDSE1FTlQnICsgaW5kZXhdLFxuICAgICAgICAgICAgICAgIGdsW3RhcmdldCB8fCAnVEVYVFVSRV8yRCddLFxuICAgICAgICAgICAgICAgIHRleHR1cmUudGV4dHVyZSxcbiAgICAgICAgICAgICAgICAwKTtcbiAgICAgICAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2hlcyB0aGUgcHJvdmlkZWQgdGV4dHVyZSB0byB0aGUgcHJvdmlkZWQgYXR0YWNobWVudCBsb2NhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtUZXh0dXJlMkR9IHRleHR1cmUgLSBUaGUgdGV4dHVyZSB0byBhdHRhY2guXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1JlbmRlclRhcmdldH0gVGhlIHJlbmRlclRhcmdldCBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHNldERlcHRoVGFyZ2V0KHRleHR1cmUpIHtcbiAgICAgICAgICAgIGlmICghdGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdUZXh0dXJlIGFyZ3VtZW50IGlzIG1pc3NpbmcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFERVBUSF9GT1JNQVRTW3RleHR1cmUuZm9ybWF0XSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdQcm92aWRlZCB0ZXh0dXJlIGlzIG5vdCBvZiBmb3JtYXQgYERFUFRIX0NPTVBPTkVOVGAgb3IgYERFUFRIX1NURU5DSUxgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVzLmRlcHRoID0gdGV4dHVyZTtcbiAgICAgICAgICAgIHRoaXMuYmluZCgpO1xuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICAgICAgICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICAgICAgICAgICAgZ2wuREVQVEhfQVRUQUNITUVOVCxcbiAgICAgICAgICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICAgICAgICAgIHRleHR1cmUudGV4dHVyZSxcbiAgICAgICAgICAgICAgICAwKTtcbiAgICAgICAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNpemVzIHRoZSByZW5kZXJUYXJnZXQgYW5kIGFsbCBhdHRhY2hlZCB0ZXh0dXJlcyBieSB0aGUgcHJvdmlkZWQgaGVpZ2h0IGFuZCB3aWR0aC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIG5ldyB3aWR0aCBvZiB0aGUgcmVuZGVyVGFyZ2V0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHJlbmRlclRhcmdldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7UmVuZGVyVGFyZ2V0fSBUaGUgcmVuZGVyVGFyZ2V0IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICdudW1iZXInIHx8ICh3aWR0aCA8PSAwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGBQcm92aWRlZCBcXGB3aWR0aFxcYCBvZiAke3dpZHRofSBpcyBpbnZhbGlkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAnbnVtYmVyJyB8fCAoaGVpZ2h0IDw9IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIFxcYGhlaWdodFxcYCBvZiAke2hlaWdodH0gaXMgaW52YWxpZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGV4dHVyZXMgPSB0aGlzLnRleHR1cmVzO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGV4dHVyZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlc1trZXldLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJlbmRlclRhcmdldDtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgVmVydGV4UGFja2FnZSA9IHJlcXVpcmUoJy4uL2NvcmUvVmVydGV4UGFja2FnZScpO1xuICAgIGxldCBWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuLi9jb3JlL1ZlcnRleEJ1ZmZlcicpO1xuICAgIGxldCBJbmRleEJ1ZmZlciA9IHJlcXVpcmUoJy4uL2NvcmUvSW5kZXhCdWZmZXInKTtcblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgYWxsIGF0dHJpYnV0ZSBwb2ludGVycyBhbmQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBhbiBpbmRleFxuICAgICAqIG9jY3VycyBtb3JlIHRoYW4gb25jZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmVydGV4QnVmZmVycyAtIFRoZSBhcnJheSBvZiB2ZXJ0ZXhCdWZmZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrSW5kZXhDb2xsaXNpb25zKHZlcnRleEJ1ZmZlcnMpIHtcbiAgICAgICAgbGV0IGluZGljZXMgPSB7fTtcbiAgICAgICAgdmVydGV4QnVmZmVycy5mb3JFYWNoKGJ1ZmZlciA9PiB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhidWZmZXIucG9pbnRlcnMpLmZvckVhY2goaW5kZXggPT4ge1xuICAgICAgICAgICAgICAgIGluZGljZXNbaW5kZXhdID0gaW5kaWNlc1tpbmRleF0gfHwgMDtcbiAgICAgICAgICAgICAgICBpbmRpY2VzW2luZGV4XSsrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3Qua2V5cyhpbmRpY2VzKS5mb3JFYWNoKGluZGV4ID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRpY2VzW2luZGV4XSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgTW9yZSB0aGFuIG9uZSBhdHRyaWJ1dGUgcG9pbnRlciBleGlzdHMgZm9yIGluZGV4IFxcYCR7aW5kZXh9XFxgYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFJlbmRlcmFibGVcbiAgICAgKiBAY2xhc3NkZXNjIEEgY29udGFpbmVyIGZvciBvbmUgb3IgbW9yZSBWZXJ0ZXhCdWZmZXJzIGFuZCBhbiBvcHRpb25hbCBJbmRleEJ1ZmZlci5cbiAgICAgKi9cbiAgICBjbGFzcyBSZW5kZXJhYmxlIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFudGlhdGVzIGFuIFJlbmRlcmFibGUgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlYyAtIFRoZSByZW5kZXJhYmxlIHNwZWNpZmljYXRpb24gb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fEZsb2F0MzJBcnJheX0gc3BlYy52ZXJ0aWNlcyAtIFRoZSB2ZXJ0aWNlcyB0byBpbnRlcmxlYXZlIGFuZCBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7VmVydGV4QnVmZmVyfSBzcGVjLnZlcnRleEJ1ZmZlciAtIEFuIGV4aXN0aW5nIHZlcnRleCBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7VmVydGV4QnVmZmVyW119IHNwZWMudmVydGV4QnVmZmVycyAtIE11bHRpcGxlIGV4aXN0aW5nIHZlcnRleCBidWZmZXJzLlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fFVpbnQxNkFycmF5fFVpbnQzMkFycmF5fSBzcGVjLmluZGljZXMgLSBUaGUgaW5kaWNlcyB0byBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7SW5kZXhCdWZmZXJ9IHNwZWMuaW5kZXhidWZmZXIgLSBBbiBleGlzdGluZyBpbmRleCBidWZmZXIuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihzcGVjID0ge30pIHtcbiAgICAgICAgICAgIGlmIChzcGVjLnZlcnRleEJ1ZmZlciB8fCBzcGVjLnZlcnRleEJ1ZmZlcnMpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgZXhpc3RpbmcgdmVydGV4IGJ1ZmZlclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGV4QnVmZmVycyA9IHNwZWMudmVydGV4QnVmZmVycyB8fCBbc3BlYy52ZXJ0ZXhCdWZmZXJdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzcGVjLnZlcnRpY2VzKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHZlcnRleCBwYWNrYWdlXG4gICAgICAgICAgICAgICAgbGV0IHZlcnRleFBhY2thZ2UgPSBuZXcgVmVydGV4UGFja2FnZShzcGVjLnZlcnRpY2VzKTtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdmVydGV4IGJ1ZmZlclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGV4QnVmZmVycyA9IFtuZXcgVmVydGV4QnVmZmVyKHZlcnRleFBhY2thZ2UpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BlYy5pbmRleEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBleGlzdGluZyBpbmRleCBidWZmZXJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4QnVmZmVyID0gc3BlYy5pbmRleEJ1ZmZlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BlYy5pbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGluZGV4IGJ1ZmZlclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBuZXcgSW5kZXhCdWZmZXIoc3BlYy5pbmRpY2VzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayB0aGF0IG5vIGF0dHJpYnV0ZSBpbmRpY2VzIGNsYXNoXG4gICAgICAgICAgICBjaGVja0luZGV4Q29sbGlzaW9ucyh0aGlzLnZlcnRleEJ1ZmZlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4ZWN1dGUgdGhlIGRyYXcgY29tbWFuZCBmb3IgdGhlIHVuZGVybHlpbmcgYnVmZmVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvICdkcmF3RWxlbWVudHMnLiBPcHRpb25hbC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubW9kZSAtIFRoZSBkcmF3IG1vZGUgLyBwcmltaXRpdmUgdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYnl0ZU9mZnNldCAtIFRoZSBieXRlT2Zmc2V0IGludG8gdGhlIGRyYXduIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuaW5kZXhPZmZzZXQgLSBUaGUgaW5kZXhPZmZzZXQgaW50byB0aGUgZHJhd24gYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5jb3VudCAtIFRoZSBudW1iZXIgb2YgdmVydGljZXMgdG8gZHJhdy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7UmVuZGVyYWJsZX0gLSBUaGUgcmVuZGVyYWJsZSBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGRyYXcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAvLyBkcmF3IHRoZSByZW5kZXJhYmxlXG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBpbmRleCBidWZmZXIgdG8gZHJhdyBlbGVtZW50c1xuICAgICAgICAgICAgICAgIC8vIGJpbmQgdmVydGV4IGJ1ZmZlcnMgYW5kIGVuYWJsZSBhdHRyaWJ1dGUgcG9pbnRlcnNcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlcnMuZm9yRWFjaCh2ZXJ0ZXhCdWZmZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXIuYmluZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGRyYXcgcHJpbWl0aXZlcyB1c2luZyBpbmRleCBidWZmZXJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4QnVmZmVyLmRyYXcob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgLy8gZGlzYWJsZSBhdHRyaWJ1dGUgcG9pbnRlcnNcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlcnMuZm9yRWFjaCh2ZXJ0ZXhCdWZmZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXIudW5iaW5kKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gbm8gYWR2YW50YWdlIHRvIHVuYmluZGluZyBhcyB0aGVyZSBpcyBubyBzdGFjayB1c2VkXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vIGluZGV4IGJ1ZmZlciwgdXNlIGRyYXcgYXJyYXlzXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJzLmZvckVhY2godmVydGV4QnVmZmVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyLmJpbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyLmRyYXcob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlci51bmJpbmQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJhYmxlO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBXZWJHTENvbnRleHQgPSByZXF1aXJlKCcuL1dlYkdMQ29udGV4dCcpO1xuICAgIGxldCBTaGFkZXJQYXJzZXIgPSByZXF1aXJlKCcuL1NoYWRlclBhcnNlcicpO1xuICAgIGxldCBBc3luYyA9IHJlcXVpcmUoJy4uL3V0aWwvQXN5bmMnKTtcbiAgICBsZXQgWEhSTG9hZGVyID0gcmVxdWlyZSgnLi4vdXRpbC9YSFJMb2FkZXInKTtcblxuICAgIGxldCBVTklGT1JNX0ZVTkNUSU9OUyA9IHtcbiAgICAgICAgJ2Jvb2wnOiAndW5pZm9ybTFpJyxcbiAgICAgICAgJ2Jvb2xbXSc6ICd1bmlmb3JtMWl2JyxcbiAgICAgICAgJ2Zsb2F0JzogJ3VuaWZvcm0xZicsXG4gICAgICAgICdmbG9hdFtdJzogJ3VuaWZvcm0xZnYnLFxuICAgICAgICAnaW50JzogJ3VuaWZvcm0xaScsXG4gICAgICAgICdpbnRbXSc6ICd1bmlmb3JtMWl2JyxcbiAgICAgICAgJ3VpbnQnOiAndW5pZm9ybTFpJyxcbiAgICAgICAgJ3VpbnRbXSc6ICd1bmlmb3JtMWl2JyxcbiAgICAgICAgJ3ZlYzInOiAndW5pZm9ybTJmdicsXG4gICAgICAgICd2ZWMyW10nOiAndW5pZm9ybTJmdicsXG4gICAgICAgICdpdmVjMic6ICd1bmlmb3JtMml2JyxcbiAgICAgICAgJ2l2ZWMyW10nOiAndW5pZm9ybTJpdicsXG4gICAgICAgICd2ZWMzJzogJ3VuaWZvcm0zZnYnLFxuICAgICAgICAndmVjM1tdJzogJ3VuaWZvcm0zZnYnLFxuICAgICAgICAnaXZlYzMnOiAndW5pZm9ybTNpdicsXG4gICAgICAgICdpdmVjM1tdJzogJ3VuaWZvcm0zaXYnLFxuICAgICAgICAndmVjNCc6ICd1bmlmb3JtNGZ2JyxcbiAgICAgICAgJ3ZlYzRbXSc6ICd1bmlmb3JtNGZ2JyxcbiAgICAgICAgJ2l2ZWM0JzogJ3VuaWZvcm00aXYnLFxuICAgICAgICAnaXZlYzRbXSc6ICd1bmlmb3JtNGl2JyxcbiAgICAgICAgJ21hdDInOiAndW5pZm9ybU1hdHJpeDJmdicsXG4gICAgICAgICdtYXQyW10nOiAndW5pZm9ybU1hdHJpeDJmdicsXG4gICAgICAgICdtYXQzJzogJ3VuaWZvcm1NYXRyaXgzZnYnLFxuICAgICAgICAnbWF0M1tdJzogJ3VuaWZvcm1NYXRyaXgzZnYnLFxuICAgICAgICAnbWF0NCc6ICd1bmlmb3JtTWF0cml4NGZ2JyxcbiAgICAgICAgJ21hdDRbXSc6ICd1bmlmb3JtTWF0cml4NGZ2JyxcbiAgICAgICAgJ3NhbXBsZXIyRCc6ICd1bmlmb3JtMWknLFxuICAgICAgICAnc2FtcGxlckN1YmUnOiAndW5pZm9ybTFpJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIG1hcCBvZiBleGlzdGluZyBhdHRyaWJ1dGVzLCBmaW5kIHRoZSBsb3dlc3QgaW5kZXggdGhhdCBpcyBub3RcbiAgICAgKiBhbHJlYWR5IHVzZWQuIElmIHRoZSBhdHRyaWJ1dGUgb3JkZXJpbmcgd2FzIGFscmVhZHkgcHJvdmlkZWQsIHVzZSB0aGF0XG4gICAgICogaW5zdGVhZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBUaGUgZXhpc3RpbmcgYXR0cmlidXRlcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlY2xhcmF0aW9uIC0gVGhlIGF0dHJpYnV0ZSBkZWNsYXJhdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhdHRyaWJ1dGUgaW5kZXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlSW5kZXgoYXR0cmlidXRlcywgZGVjbGFyYXRpb24pIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgYXR0cmlidXRlIGlzIGFscmVhZHkgZGVjbGFyZWQsIGlmIHNvLCB1c2UgdGhhdCBpbmRleFxuICAgICAgICBpZiAoYXR0cmlidXRlc1tkZWNsYXJhdGlvbi5uYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXNbZGVjbGFyYXRpb24ubmFtZV0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIG5leHQgYXZhaWxhYmxlIGluZGV4XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXIgc291cmNlLCBwYXJzZXMgdGhlIGRlY2xhcmF0aW9ucyBhbmQgYXBwZW5kcyBpbmZvcm1hdGlvbiBwZXJ0YWluaW5nIHRvIHRoZSB1bmlmb3JtcyBhbmQgYXR0cmlidHVlcyBkZWNsYXJlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTaGFkZXJ9IHNoYWRlciAtIFRoZSBzaGFkZXIgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2ZXJ0U291cmNlIC0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmcmFnU291cmNlIC0gVGhlIGZyYWdtZW50IHNoYWRlciBzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBhdHRyaWJ1dGUgYW5kIHVuaWZvcm0gaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0QXR0cmlidXRlc0FuZFVuaWZvcm1zKHNoYWRlciwgdmVydFNvdXJjZSwgZnJhZ1NvdXJjZSkge1xuICAgICAgICBsZXQgZGVjbGFyYXRpb25zID0gU2hhZGVyUGFyc2VyLnBhcnNlRGVjbGFyYXRpb25zKFxuICAgICAgICAgICAgW3ZlcnRTb3VyY2UsIGZyYWdTb3VyY2VdLFxuICAgICAgICAgICAgWyd1bmlmb3JtJywgJ2F0dHJpYnV0ZSddKTtcbiAgICAgICAgLy8gZm9yIGVhY2ggZGVjbGFyYXRpb24gaW4gdGhlIHNoYWRlclxuICAgICAgICBkZWNsYXJhdGlvbnMuZm9yRWFjaChkZWNsYXJhdGlvbiA9PiB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBpdHMgYW4gYXR0cmlidXRlIG9yIHVuaWZvcm1cbiAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbi5xdWFsaWZpZXIgPT09ICdhdHRyaWJ1dGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgYXR0cmlidXRlLCBzdG9yZSB0eXBlIGFuZCBpbmRleFxuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGdldEF0dHJpYnV0ZUluZGV4KHNoYWRlci5hdHRyaWJ1dGVzLCBkZWNsYXJhdGlvbik7XG4gICAgICAgICAgICAgICAgc2hhZGVyLmF0dHJpYnV0ZXNbZGVjbGFyYXRpb24ubmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGRlY2xhcmF0aW9uLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBpZiAoZGVjbGFyYXRpb24ucXVhbGlmaWVyID09PSAndW5pZm9ybScpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB1bmlmb3JtLCBzdG9yZSB0eXBlIGFuZCBidWZmZXIgZnVuY3Rpb24gbmFtZVxuICAgICAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtc1tkZWNsYXJhdGlvbi5uYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZGVjbGFyYXRpb24udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuYzogVU5JRk9STV9GVU5DVElPTlNbZGVjbGFyYXRpb24udHlwZSArIChkZWNsYXJhdGlvbi5jb3VudCA+IDEgPyAnW10nIDogJycpXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc2hhZGVyIHNvdXJjZSBzdHJpbmcgYW5kIHNoYWRlciB0eXBlLCBjb21waWxlcyB0aGUgc2hhZGVyIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgV2ViR0xTaGFkZXIgb2JqZWN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgd2ViZ2wgcmVuZGVyaW5nIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNoYWRlclNvdXJjZSAtIFRoZSBzaGFkZXIgc291cmNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHNoYWRlciB0eXBlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7V2ViR0xTaGFkZXJ9IFRoZSBjb21waWxlZCBzaGFkZXIgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBpbGVTaGFkZXIoZ2wsIHNoYWRlclNvdXJjZSwgdHlwZSkge1xuICAgICAgICBsZXQgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsW3R5cGVdKTtcbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgICAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgICAgICAgdGhyb3cgJ0FuIGVycm9yIG9jY3VycmVkIGNvbXBpbGluZyB0aGUgc2hhZGVyczpcXG4nICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZHMgdGhlIGF0dHJpYnV0ZSBsb2NhdGlvbnMgZm9yIHRoZSBTaGFkZXIgb2JqZWN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NoYWRlcn0gc2hhZGVyIC0gVGhlIFNoYWRlciBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZEF0dHJpYnV0ZUxvY2F0aW9ucyhzaGFkZXIpIHtcbiAgICAgICAgbGV0IGdsID0gc2hhZGVyLmdsO1xuICAgICAgICBsZXQgYXR0cmlidXRlcyA9IHNoYWRlci5hdHRyaWJ1dGVzO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAvLyBiaW5kIHRoZSBhdHRyaWJ1dGUgbG9jYXRpb25cbiAgICAgICAgICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbihcbiAgICAgICAgICAgICAgICBzaGFkZXIucHJvZ3JhbSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0uaW5kZXgsXG4gICAgICAgICAgICAgICAga2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVlcmllcyB0aGUgd2ViZ2wgcmVuZGVyaW5nIGNvbnRleHQgZm9yIHRoZSB1bmlmb3JtIGxvY2F0aW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTaGFkZXJ9IHNoYWRlciAtIFRoZSBTaGFkZXIgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFVuaWZvcm1Mb2NhdGlvbnMoc2hhZGVyKSB7XG4gICAgICAgIGxldCBnbCA9IHNoYWRlci5nbDtcbiAgICAgICAgbGV0IHVuaWZvcm1zID0gc2hhZGVyLnVuaWZvcm1zO1xuICAgICAgICBPYmplY3Qua2V5cyh1bmlmb3JtcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSB1bmlmb3JtIGxvY2F0aW9uXG4gICAgICAgICAgICBsZXQgbG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyLnByb2dyYW0sIGtleSk7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBudWxsLCBwYXJzZSBtYXkgZGV0ZWN0IHVuaWZvcm0gdGhhdCBpcyBjb21waWxlZCBvdXRcbiAgICAgICAgICAgIC8vIGR1ZSB0byBhIHByZXByb2Nlc3NvciBldmFsdWF0aW9uLlxuICAgICAgICAgICAgLy8gVE9ETzogZml4IHBhcnNlciBzbyB0aGF0IGl0IGV2YWx1YXRlcyB0aGVzZSBjb3JyZWN0bHkuXG4gICAgICAgICAgICBpZiAobG9jYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdW5pZm9ybXNba2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybXNba2V5XS5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gbG9hZCBzaGFkZXIgc291cmNlIGZyb20gYSB1cmwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBUaGUgdXJsIHRvIGxvYWQgdGhlIHJlc291cmNlIGZyb20uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGZ1bmN0aW9uIHRvIGxvYWQgdGhlIHNoYWRlciBzb3VyY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9hZFNoYWRlclNvdXJjZSh1cmwpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIFhIUkxvYWRlci5sb2FkKHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZShudWxsLCByZXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkb25lKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHBhc3MgdGhyb3VnaCB0aGUgc2hhZGVyIHNvdXJjZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2YgdGhlIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgZnVuY3Rpb24gdG8gcGFzcyB0aHJvdWdoIHRoZSBzaGFkZXIgc291cmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhc3NUaHJvdWdoU291cmNlKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgZG9uZShudWxsLCBzb3VyY2UpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIGFycmF5IG9mIEdMU0wgc291cmNlIHN0cmluZ3MgYW5kIFVSTHMsIGFuZCByZXNvbHZlcyB0aGVtIGludG8gYW5kIGFycmF5IG9mIEdMU0wgc291cmNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VzIC0gVGhlIHNoYWRlciBzb3VyY2VzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgc2hhZGVyIHNvdXJjZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZXMoc291cmNlcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgbGV0IHRhc2tzID0gW107XG4gICAgICAgICAgICBzb3VyY2VzID0gc291cmNlcyB8fCBbXTtcbiAgICAgICAgICAgIHNvdXJjZXMgPSAhQXJyYXkuaXNBcnJheShzb3VyY2VzKSA/IFtzb3VyY2VzXSA6IHNvdXJjZXM7XG4gICAgICAgICAgICBzb3VyY2VzLmZvckVhY2goc291cmNlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoU2hhZGVyUGFyc2VyLmlzR0xTTChzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzLnB1c2gocGFzc1Rocm91Z2hTb3VyY2Uoc291cmNlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaChsb2FkU2hhZGVyU291cmNlKHNvdXJjZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgQXN5bmMucGFyYWxsZWwodGFza3MsIGRvbmUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHNoYWRlciBwcm9ncmFtIG9iamVjdCBmcm9tIHNvdXJjZSBzdHJpbmdzLiBUaGlzIGluY2x1ZGVzOlxuICAgICAqICAgIDEpIENvbXBpbGluZyBhbmQgbGlua2luZyB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAgICogICAgMikgUGFyc2luZyBzaGFkZXIgc291cmNlIGZvciBhdHRyaWJ1dGUgYW5kIHVuaWZvcm0gaW5mb3JtYXRpb24uXG4gICAgICogICAgMykgQmluZGluZyBhdHRyaWJ1dGUgbG9jYXRpb25zLCBieSBvcmRlciBvZiBkZWxjYXJhdGlvbi5cbiAgICAgKiAgICA0KSBRdWVyeWluZyBhbmQgc3RvcmluZyB1bmlmb3JtIGxvY2F0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NoYWRlcn0gc2hhZGVyIC0gVGhlIFNoYWRlciBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZXMgLSBBIG1hcCBjb250YWluaW5nIHNvdXJjZXMgdW5kZXIgJ3ZlcnQnIGFuZCAnZnJhZycgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NoYWRlcn0gVGhlIHNoYWRlciBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9ncmFtKHNoYWRlciwgc291cmNlcykge1xuICAgICAgICBsZXQgZ2wgPSBzaGFkZXIuZ2w7XG4gICAgICAgIGxldCBjb21tb24gPSBzb3VyY2VzLmNvbW1vbi5qb2luKCcnKTtcbiAgICAgICAgbGV0IHZlcnQgPSBzb3VyY2VzLnZlcnQuam9pbignJyk7XG4gICAgICAgIGxldCBmcmFnID0gc291cmNlcy5mcmFnLmpvaW4oJycpO1xuICAgICAgICAvLyBjb21waWxlIHNoYWRlcnNcbiAgICAgICAgbGV0IHZlcnRleFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGNvbW1vbiArIHZlcnQsICdWRVJURVhfU0hBREVSJyk7XG4gICAgICAgIGxldCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGNvbW1vbiArIGZyYWcsICdGUkFHTUVOVF9TSEFERVInKTtcbiAgICAgICAgLy8gcGFyc2Ugc291cmNlIGZvciBhdHRyaWJ1dGUgYW5kIHVuaWZvcm1zXG4gICAgICAgIHNldEF0dHJpYnV0ZXNBbmRVbmlmb3JtcyhzaGFkZXIsIHZlcnQsIGZyYWcpO1xuICAgICAgICAvLyBjcmVhdGUgdGhlIHNoYWRlciBwcm9ncmFtXG4gICAgICAgIHNoYWRlci5wcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgICAgICAvLyBhdHRhY2ggdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihzaGFkZXIucHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHNoYWRlci5wcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgICAgIC8vIGJpbmQgdmVydGV4IGF0dHJpYnV0ZSBsb2NhdGlvbnMgQkVGT1JFIGxpbmtpbmdcbiAgICAgICAgYmluZEF0dHJpYnV0ZUxvY2F0aW9ucyhzaGFkZXIpO1xuICAgICAgICAvLyBsaW5rIHNoYWRlclxuICAgICAgICBnbC5saW5rUHJvZ3JhbShzaGFkZXIucHJvZ3JhbSk7XG4gICAgICAgIC8vIElmIGNyZWF0aW5nIHRoZSBzaGFkZXIgcHJvZ3JhbSBmYWlsZWQsIGFsZXJ0XG4gICAgICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihzaGFkZXIucHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICAgICAgICB0aHJvdyAnQW4gZXJyb3Igb2NjdXJlZCBsaW5raW5nIHRoZSBzaGFkZXI6XFxuJyArIGdsLmdldFByb2dyYW1JbmZvTG9nKHNoYWRlci5wcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgc2hhZGVyIHVuaWZvcm0gbG9jYXRpb25zXG4gICAgICAgIGdldFVuaWZvcm1Mb2NhdGlvbnMoc2hhZGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgU2hhZGVyXG4gICAgICogQGNsYXNzZGVzYyBBIHNoYWRlciBjbGFzcyB0byBhc3Npc3QgaW4gY29tcGlsaW5nIGFuZCBsaW5raW5nIHdlYmdsIHNoYWRlcnMsIHN0b3JpbmcgYXR0cmlidXRlIGFuZCB1bmlmb3JtIGxvY2F0aW9ucywgYW5kIGJ1ZmZlcmluZyB1bmlmb3Jtcy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaGFkZXIge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYSBTaGFkZXIgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlYyAtIFRoZSBzaGFkZXIgc3BlY2lmaWNhdGlvbiBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfE9iamVjdH0gc3BlYy5jb21tb24gLSBTb3VyY2VzIC8gVVJMcyB0byBiZSBzaGFyZWQgYnkgYm90aCB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfE9iamVjdH0gc3BlYy52ZXJ0IC0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlcyAvIFVSTHMuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfE9iamVjdH0gc3BlYy5mcmFnIC0gVGhlIGZyYWdtZW50IHNoYWRlciBzb3VyY2VzIC8gVVJMcy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gc3BlYy5hdHRyaWJ1dGVzIC0gVGhlIGF0dHJpYnV0ZSBpbmRleCBvcmRlcmluZ3MuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgc2hhZGVyIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBjb21waWxlZCBhbmQgbGlua2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3Ioc3BlYyA9IHt9LCBjYWxsYmFjayA9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHNvdXJjZSBhcmd1bWVudHNcbiAgICAgICAgICAgIGlmICghc3BlYy52ZXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1ZlcnRleCBzaGFkZXIgYXJndW1lbnQgYHZlcnRgIGhhcyBub3QgYmVlbiBwcm92aWRlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNwZWMuZnJhZykge1xuICAgICAgICAgICAgICAgIHRocm93ICdGcmFnbWVudCBzaGFkZXIgYXJndW1lbnQgYGZyYWdgIGhhcyBub3QgYmVlbiBwcm92aWRlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0gPSAwO1xuICAgICAgICAgICAgdGhpcy5nbCA9IFdlYkdMQ29udGV4dC5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbiA9IHNwZWMudmVyc2lvbiB8fCAnMS4wMCc7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMgPSB7fTtcbiAgICAgICAgICAgIC8vIGlmIGF0dHJpYnV0ZSBvcmRlcmluZyBpcyBwcm92aWRlZCwgdXNlIHRob3NlIGluZGljZXNcbiAgICAgICAgICAgIGlmIChzcGVjLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBzcGVjLmF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0ciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHNoYWRlclxuICAgICAgICAgICAgQXN5bmMucGFyYWxsZWwoe1xuICAgICAgICAgICAgICAgIGNvbW1vbjogcmVzb2x2ZVNvdXJjZXMoc3BlYy5jb21tb24pLFxuICAgICAgICAgICAgICAgIHZlcnQ6IHJlc29sdmVTb3VyY2VzKHNwZWMudmVydCksXG4gICAgICAgICAgICAgICAgZnJhZzogcmVzb2x2ZVNvdXJjZXMoc3BlYy5mcmFnKSxcbiAgICAgICAgICAgIH0sIChlcnIsIHNvdXJjZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb25jZSBhbGwgc2hhZGVyIHNvdXJjZXMgYXJlIGxvYWRlZFxuICAgICAgICAgICAgICAgIGNyZWF0ZVByb2dyYW0odGhpcywgc291cmNlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmRzIHRoZSBzaGFkZXIgcHJvZ3JhbSBmb3IgdXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTaGFkZXJ9IFRoZSBzaGFkZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICB1c2UoKSB7XG4gICAgICAgICAgICAvLyB1c2UgdGhlIHNoYWRlclxuICAgICAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWZmZXIgYSB1bmlmb3JtIHZhbHVlIGJ5IG5hbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIHVuaWZvcm0gbmFtZSBpbiB0aGUgc2hhZGVyIHNvdXJjZS5cbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB1bmlmb3JtIHZhbHVlIHRvIGJ1ZmZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7U2hhZGVyfSAtIFRoZSBzaGFkZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRVbmlmb3JtKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbbmFtZV07XG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgdW5pZm9ybSBzcGVjIGV4aXN0cyBmb3IgdGhlIG5hbWVcbiAgICAgICAgICAgIGlmICghdW5pZm9ybSkge1xuICAgICAgICAgICAgICAgIHRocm93IGBObyB1bmlmb3JtIGZvdW5kIHVuZGVyIG5hbWUgXFxgJHtuYW1lfVxcYGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayB2YWx1ZVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgdW5pZm9ybSBhcmd1bWVudCBpcyBkZWZpbmVkXG4gICAgICAgICAgICAgICAgdGhyb3cgYFZhbHVlIHBhc3NlZCBmb3IgdW5pZm9ybSBcXGAke25hbWV9XFxgIGlzIHVuZGVmaW5lZCBvciBudWxsYDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGJvb2xlYW4ncyB0byAwIG9yIDFcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwYXNzIHRoZSBhcmd1bWVudHMgZGVwZW5kaW5nIG9uIHRoZSB0eXBlXG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgc3RyaW5nIGNvbXBhcmlvbnMgZnJvbSBoZXJlLi4uXG4gICAgICAgICAgICBpZiAodW5pZm9ybS50eXBlID09PSAnbWF0MicgfHwgdW5pZm9ybS50eXBlID09PSAnbWF0MycgfHwgdW5pZm9ybS50eXBlID09PSAnbWF0NCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdsW3VuaWZvcm0uZnVuY10odW5pZm9ybS5sb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nbFt1bmlmb3JtLmZ1bmNdKHVuaWZvcm0ubG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1ZmZlciBhIG1hcCBvZiB1bmlmb3JtIHZhbHVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1zIC0gVGhlIG1hcCBvZiB1bmlmb3JtcyBrZXllZCBieSBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTaGFkZXJ9IFRoZSBzaGFkZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRVbmlmb3JtcyhhcmdzKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhcmdzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VW5pZm9ybShuYW1lLCBhcmdzW25hbWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNoYWRlcjtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAoKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgQ09NTUVOVFNfUkVHRVhQID0gLyhcXC9cXCooW1xcc1xcU10qPylcXCpcXC8pfChcXC9cXC8oLiopJCkvZ207XG4gICAgbGV0IEVORExJTkVfUkVHRVhQID0gLyhcXHJcXG58XFxufFxccikvZ207XG4gICAgbGV0IFdISVRFU1BBQ0VfUkVHRVhQID0gL1xcc3syLH0vZztcbiAgICBsZXQgQlJBQ0tFVF9XSElURVNQQUNFX1JFR0VYUCA9IC8oXFxzKikoXFxbKShcXHMqKShcXGQrKShcXHMqKShcXF0pKFxccyopL2c7XG4gICAgbGV0IE5BTUVfQ09VTlRfUkVHRVhQID0gLyhbYS16QS1aX11bYS16QS1aMC05X10qKSg/OlxcWyhcXGQrKVxcXSk/LztcbiAgICBsZXQgUFJFQ0lTSU9OX1JFR0VYID0gL1xcYnByZWNpc2lvblxccytcXHcrXFxzK1xcdys7L2c7XG4gICAgbGV0IElOTElORV9QUkVDSVNJT05fUkVHRVggPSAvXFxiKGhpZ2hwfG1lZGl1bXB8bG93cClcXHMrL2c7XG4gICAgbGV0IEdMU0xfUkVHRVhQID0gL3ZvaWRcXHMrbWFpblxccypcXChcXHMqKHZvaWQpKlxccypcXClcXHMqL21pO1xuICAgIGxldCBQUkVQX1JFR0VYUCA9IC8jKFtcXFdcXHdcXHNcXGRdKSg/Oi4qXFxcXHI/XFxuKSouKiQvZ207XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHN0YW5kYXJkIGNvbW1lbnRzIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gc3RyaXAgY29tbWVudHMgZnJvbS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGNvbW1lbnRsZXNzIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpcENvbW1lbnRzKHN0cikge1xuICAgICAgICAvLyByZWdleCBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb2Fncml1cy9zdHJpcGNvbW1lbnRzXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShDT01NRU5UU19SRUdFWFAsICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIHByZWNpc2lvbiBzdGF0ZW1lbnRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIHVucHJvY2Vzc2VkIHNvdXJjZSBjb2RlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcHJvY2Vzc2VkIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmlwUHJlY2lzaW9uKHNvdXJjZSkge1xuICAgICAgICAvLyByZW1vdmUgZ2xvYmFsIHByZWNpc2lvbiBkZWNsYXJhdGlvbnNcbiAgICAgICAgc291cmNlID0gc291cmNlLnJlcGxhY2UoUFJFQ0lTSU9OX1JFR0VYLCAnJyk7XG4gICAgICAgIC8vIHJlbW92ZSBpbmxpbmUgcHJlY2lzaW9uIGRlY2xhcmF0aW9uc1xuICAgICAgICByZXR1cm4gc291cmNlLnJlcGxhY2UoSU5MSU5FX1BSRUNJU0lPTl9SRUdFWCwgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCB3aGl0ZXNwYWNlIGludG8gYSBzaW5nbGUgJyAnIHNwYWNlIGNoYXJhY3Rlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gbm9ybWFsaXplIHdoaXRlc3BhY2UgZnJvbS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIG5vcm1hbGl6ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVdoaXRlc3BhY2Uoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShFTkRMSU5FX1JFR0VYUCwgJyAnKSAvLyByZW1vdmUgbGluZSBlbmRpbmdzXG4gICAgICAgICAgICAucmVwbGFjZShXSElURVNQQUNFX1JFR0VYUCwgJyAnKSAvLyBub3JtYWxpemUgd2hpdGVzcGFjZSB0byBzaW5nbGUgJyAnXG4gICAgICAgICAgICAucmVwbGFjZShCUkFDS0VUX1dISVRFU1BBQ0VfUkVHRVhQLCAnJDIkNCQ2Jyk7IC8vIHJlbW92ZSB3aGl0ZXNwYWNlIGluIGJyYWNrZXRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBuYW1lIGFuZCBjb3VudCBvdXQgb2YgYSBuYW1lIHN0YXRlbWVudCwgcmV0dXJuaW5nIHRoZSBkZWNsYXJhdGlvbiBvYmplY3QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBxdWFsaWZpZXIgLSBUaGUgcXVhbGlmaWVyIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW50cnkgLSBUaGUgdmFyaWFibGUgZGVjbGFyYXRpb24gc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVjbGFyYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlTmFtZUFuZENvdW50KHF1YWxpZmllciwgdHlwZSwgZW50cnkpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIG5hbWUgYW5kIHNpemUgb2YgdmFyaWFibGVcbiAgICAgICAgbGV0IG1hdGNoZXMgPSBlbnRyeS5tYXRjaChOQU1FX0NPVU5UX1JFR0VYUCk7XG4gICAgICAgIGxldCBuYW1lID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgbGV0IGNvdW50ID0gKG1hdGNoZXNbMl0gPT09IHVuZGVmaW5lZCkgPyAxIDogcGFyc2VJbnQobWF0Y2hlc1syXSwgMTApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcXVhbGlmaWVyOiBxdWFsaWZpZXIsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGNvdW50OiBjb3VudFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHNpbmdsZSAnc3RhdGVtZW50Jy4gQSAnc3RhdGVtZW50JyBpcyBjb25zaWRlcmVkIGFueSBzZXF1ZW5jZSBvZlxuICAgICAqIGNoYXJhY3RlcnMgZm9sbG93ZWQgYnkgYSBzZW1pLWNvbG9uLiBUaGVyZWZvcmUsIGEgc2luZ2xlICdzdGF0ZW1lbnQnIGluXG4gICAgICogdGhpcyBzZW5zZSBjb3VsZCBjb250YWluIHNldmVyYWwgY29tbWEgc2VwYXJhdGVkIGRlY2xhcmF0aW9ucy4gUmV0dXJuc1xuICAgICAqIGFsbCByZXN1bHRpbmcgZGVjbGFyYXRpb25zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RhdGVtZW50IC0gVGhlIHN0YXRlbWVudCB0byBwYXJzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgYXJyYXkgb2YgcGFyc2VkIGRlY2xhcmF0aW9uIG9iamVjdHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnQoc3RhdGVtZW50KSB7XG4gICAgICAgIC8vIHNwbGl0IHN0YXRlbWVudCBvbiBjb21tYXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gWyd1bmlmb3JtIG1hdDQgQVsxMF0nLCAnQicsICdDWzJdJ11cbiAgICAgICAgLy9cbiAgICAgICAgbGV0IHNwbGl0ID0gc3RhdGVtZW50LnNwbGl0KCcsJykubWFwKGVsZW0gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0udHJpbSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzcGxpdCBkZWNsYXJhdGlvbiBoZWFkZXIgZnJvbSBzdGF0ZW1lbnRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gWyd1bmlmb3JtJywgJ21hdDQnLCAnQVsxMF0nXVxuICAgICAgICAvL1xuICAgICAgICBsZXQgaGVhZGVyID0gc3BsaXQuc2hpZnQoKS5zcGxpdCgnICcpO1xuXG4gICAgICAgIC8vIHF1YWxpZmllciBpcyBhbHdheXMgZmlyc3QgZWxlbWVudFxuICAgICAgICAvL1xuICAgICAgICAvLyAndW5pZm9ybSdcbiAgICAgICAgLy9cbiAgICAgICAgbGV0IHF1YWxpZmllciA9IGhlYWRlci5zaGlmdCgpO1xuXG4gICAgICAgIC8vIHR5cGUgd2lsbCBiZSB0aGUgc2Vjb25kIGVsZW1lbnRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gJ21hdDQnXG4gICAgICAgIC8vXG4gICAgICAgIGxldCB0eXBlID0gaGVhZGVyLnNoaWZ0KCk7XG5cbiAgICAgICAgLy8gbGFzdCBwYXJ0IG9mIGhlYWRlciB3aWxsIGJlIHRoZSBmaXJzdCwgYW5kIHBvc3NpYmxlIG9ubHkgdmFyaWFibGUgbmFtZVxuICAgICAgICAvL1xuICAgICAgICAvLyBbJ0FbMTBdJywgJ0InLCAnQ1syXSddXG4gICAgICAgIC8vXG4gICAgICAgIGxldCBuYW1lcyA9IGhlYWRlci5jb25jYXQoc3BsaXQpO1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBvdGhlciBuYW1lcyBhZnRlciBhICcsJyBhZGQgdGhlbSBhcyB3ZWxsXG4gICAgICAgIHJldHVybiBuYW1lcy5tYXAobmFtZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOYW1lQW5kQ291bnQocXVhbGlmaWVyLCB0eXBlLCBuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIHRoZSBzb3VyY2Ugc3RyaW5nIGJ5IHNlbWktY29sb25zIGFuZCBjb25zdHJ1Y3RzIGFuIGFycmF5IG9mXG4gICAgICogZGVjbGFyYXRpb24gb2JqZWN0cyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgcXVhbGlmaWVyIGtleXdvcmRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIHNoYWRlciBzb3VyY2Ugc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBrZXl3b3JkcyAtIFRoZSBxdWFsaWZpZXIgZGVjbGFyYXRpb24ga2V5d29yZHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGFycmF5IG9mIHF1YWxpZmllciBkZWNsYXJhdGlvbiBvYmplY3RzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlU291cmNlKHNvdXJjZSwga2V5d29yZHMpIHtcbiAgICAgICAgLy8gZ2V0IGluZGl2aWR1YWwgc3RhdGVtZW50cyAoYW55IHNlcXVlbmNlIGVuZGluZyBpbiA7KVxuICAgICAgICBsZXQgc3RhdGVtZW50cyA9IHNvdXJjZS5zcGxpdCgnOycpO1xuICAgICAgICAvLyBidWlsZCByZWdleCBmb3IgcGFyc2luZyBzdGF0ZW1lbnRzIHdpdGggdGFyZ2V0dGVkIGtleXdvcmRzXG4gICAgICAgIGxldCBrZXl3b3JkU3RyID0ga2V5d29yZHMuam9pbignfCcpO1xuICAgICAgICBsZXQga2V5d29yZFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXFxcXGIoJyArIGtleXdvcmRTdHIgKyAnKVxcXFxiLionKTtcbiAgICAgICAgLy8gcGFyc2UgYW5kIHN0b3JlIGdsb2JhbCBwcmVjaXNpb24gc3RhdGVtZW50cyBhbmQgYW55IGRlY2xhcmF0aW9uc1xuICAgICAgICBsZXQgbWF0Y2hlZCA9IFtdO1xuICAgICAgICAvLyBmb3IgZWFjaCBzdGF0ZW1lbnRcbiAgICAgICAgc3RhdGVtZW50cy5mb3JFYWNoKHN0YXRlbWVudCA9PiB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3Iga2V5d29yZHNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBbJ3VuaWZvcm0gZmxvYXQgdVRpbWUnXVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGxldCBrbWF0Y2ggPSBzdGF0ZW1lbnQubWF0Y2goa2V5d29yZFJlZ2V4KTtcbiAgICAgICAgICAgIGlmIChrbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSBzdGF0ZW1lbnQgYW5kIGFkZCB0byBhcnJheVxuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBtYXRjaGVkLmNvbmNhdChwYXJzZVN0YXRlbWVudChrbWF0Y2hbMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbHRlcnMgb3V0IGR1cGxpY2F0ZSBkZWNsYXJhdGlvbnMgcHJlc2VudCBiZXR3ZWVuIHNoYWRlcnMuIEN1cnJlbnRseVxuICAgICAqIGp1c3QgcmVtb3ZlcyBhbGwgIyBzdGF0ZW1lbnRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkZWNsYXJhdGlvbnMgLSBUaGUgYXJyYXkgb2YgZGVjbGFyYXRpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBmaWx0ZXJlZCBhcnJheSBvZiBkZWNsYXJhdGlvbnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyRHVwbGljYXRlc0J5TmFtZShkZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgLy8gaW4gY2FzZXMgd2hlcmUgdGhlIHNhbWUgZGVjbGFyYXRpb25zIGFyZSBwcmVzZW50IGluIG11bHRpcGxlXG4gICAgICAgIC8vIHNvdXJjZXMsIHRoaXMgZnVuY3Rpb24gd2lsbCByZW1vdmUgZHVwbGljYXRlcyBmcm9tIHRoZSByZXN1bHRzXG4gICAgICAgIGxldCBzZWVuID0ge307XG4gICAgICAgIHJldHVybiBkZWNsYXJhdGlvbnMuZmlsdGVyKGRlY2xhcmF0aW9uID0+IHtcbiAgICAgICAgICAgIGlmIChzZWVuW2RlY2xhcmF0aW9uLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VlbltkZWNsYXJhdGlvbi5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgcHJlcHJvY2Vzc29yIG9uIHRoZSBnbHNsIGNvZGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgLSBUaGUgdW5wcm9jZXNzZWQgc291cmNlIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBwcm9jZXNzZWQgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJlcHJvY2Vzcyhzb3VyY2UpIHtcbiAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHRoaXMgY29ycmVjdGx5Li4uXG4gICAgICAgIHJldHVybiBzb3VyY2UucmVwbGFjZShQUkVQX1JFR0VYUCwgJycpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgdGhlIHByb3ZpZGVkIEdMU0wgc291cmNlLCBhbmQgcmV0dXJucyBhbGwgZGVjbGFyYXRpb24gc3RhdGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlIHByb3ZpZGVkIHF1YWxpZmllciB0eXBlLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGV4dHJhY3QgYWxsIGF0dHJpYnV0ZXMgYW5kIHVuaWZvcm0gbmFtZXMgYW5kIHR5cGVzIGZyb20gYSBzaGFkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBleGFtcGxlLCB3aGVuIHByb3ZpZGVkIGEgJ3VuaWZvcm0nIHF1YWxpZmllcnMsIHRoZSBkZWNsYXJhdGlvbjpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICd1bmlmb3JtIGhpZ2hwIHZlYzMgdVNwZWN1bGFyQ29sb3I7J1xuICAgICAgICAgKlxuICAgICAgICAgKiBXb3VsZCBiZSBwYXJzZWQgdG86XG4gICAgICAgICAqICAgICB7XG4gICAgICAgICAqICAgICAgICAgcXVhbGlmaWVyOiAndW5pZm9ybScsXG4gICAgICAgICAqICAgICAgICAgdHlwZTogJ3ZlYzMnLFxuICAgICAgICAgKiAgICAgICAgIG5hbWU6ICd1U3BlY3VsYXJDb2xvcicsXG4gICAgICAgICAqICAgICAgICAgY291bnQ6IDFcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlcyAtIFRoZSBzaGFkZXIgc291cmNlcy5cbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gcXVhbGlmaWVycyAtIFRoZSBxdWFsaWZpZXJzIHRvIGV4dHJhY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgYXJyYXkgb2YgcXVhbGlmaWVyIGRlY2xhcmF0aW9uIHN0YXRlbWVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBwYXJzZURlY2xhcmF0aW9uczogZnVuY3Rpb24oc291cmNlcyA9IFtdLCBxdWFsaWZpZXJzID0gW10pIHtcbiAgICAgICAgICAgIC8vIGlmIG5vIHNvdXJjZXMgb3IgcXVhbGlmaWVycyBhcmUgcHJvdmlkZWQsIHJldHVybiBlbXB0eSBhcnJheVxuICAgICAgICAgICAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAwIHx8IHF1YWxpZmllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlcyA9IEFycmF5LmlzQXJyYXkoc291cmNlcykgPyBzb3VyY2VzIDogW3NvdXJjZXNdO1xuICAgICAgICAgICAgcXVhbGlmaWVycyA9IEFycmF5LmlzQXJyYXkocXVhbGlmaWVycykgPyBxdWFsaWZpZXJzIDogW3F1YWxpZmllcnNdO1xuICAgICAgICAgICAgLy8gcGFyc2Ugb3V0IHRhcmdldHRlZCBkZWNsYXJhdGlvbnNcbiAgICAgICAgICAgIGxldCBkZWNsYXJhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHNvdXJjZXMuZm9yRWFjaChzb3VyY2UgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHJ1biBwcmVwcm9jZXNzb3JcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBwcmVwcm9jZXNzKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHByZWNpc2lvbiBzdGF0ZW1lbnRzXG4gICAgICAgICAgICAgICAgc291cmNlID0gc3RyaXBQcmVjaXNpb24oc291cmNlKTtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgY29tbWVudHNcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBzdHJpcENvbW1lbnRzKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgLy8gZmluYWxseSwgbm9ybWFsaXplIHRoZSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgc291cmNlID0gbm9ybWFsaXplV2hpdGVzcGFjZShzb3VyY2UpO1xuICAgICAgICAgICAgICAgIC8vIHBhcnNlIG91dCBkZWNsYXJhdGlvbnNcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnMgPSBkZWNsYXJhdGlvbnMuY29uY2F0KHBhcnNlU291cmNlKHNvdXJjZSwgcXVhbGlmaWVycykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgZHVwbGljYXRlcyBhbmQgcmV0dXJuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyRHVwbGljYXRlc0J5TmFtZShkZWNsYXJhdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlY3RzIGJhc2VkIG9uIHRoZSBleGlzdGVuY2Ugb2YgYSAndm9pZCBtYWluKCkgeycgc3RhdGVtZW50LCBpZiB0aGUgc3RyaW5nIGlzIGdsc2wgc291cmNlIGNvZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBUaGUgaW5wdXQgc3RyaW5nIHRvIHRlc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBzdHJpbmcgaXMgZ2xzbCBjb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNHTFNMOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBHTFNMX1JFR0VYUC50ZXN0KHN0cik7XG4gICAgICAgIH1cblxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IFdlYkdMQ29udGV4dCA9IHJlcXVpcmUoJy4vV2ViR0xDb250ZXh0Jyk7XG4gICAgbGV0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcblxuICAgIGxldCBNQUdfRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgTUlOX0ZJTFRFUlMgPSB7XG4gICAgICAgIE5FQVJFU1Q6IHRydWUsXG4gICAgICAgIExJTkVBUjogdHJ1ZSxcbiAgICAgICAgTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSX01JUE1BUF9ORUFSRVNUOiB0cnVlLFxuICAgICAgICBORUFSRVNUX01JUE1BUF9MSU5FQVI6IHRydWUsXG4gICAgICAgIExJTkVBUl9NSVBNQVBfTElORUFSOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgTk9OX01JUE1BUF9NSU5fRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSOiB0cnVlLFxuICAgIH07XG4gICAgbGV0IE1JUE1BUF9NSU5fRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSX01JUE1BUF9ORUFSRVNUOiB0cnVlLFxuICAgICAgICBORUFSRVNUX01JUE1BUF9MSU5FQVI6IHRydWUsXG4gICAgICAgIExJTkVBUl9NSVBNQVBfTElORUFSOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgV1JBUF9NT0RFUyA9IHtcbiAgICAgICAgUkVQRUFUOiB0cnVlLFxuICAgICAgICBNSVJST1JFRF9SRVBFQVQ6IHRydWUsXG4gICAgICAgIENMQU1QX1RPX0VER0U6IHRydWVcbiAgICB9O1xuICAgIGxldCBERVBUSF9UWVBFUyA9IHtcbiAgICAgICAgREVQVEhfQ09NUE9ORU5UOiB0cnVlLFxuICAgICAgICBERVBUSF9TVEVOQ0lMOiB0cnVlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHR5cGUgZm9yIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX1RZUEUgPSAnVU5TSUdORURfQllURSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3JtYXQgZm9yIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX0ZPUk1BVCA9ICdSR0JBJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHdyYXAgbW9kZSBmb3IgdGV4dHVyZXMuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfV1JBUCA9ICdSRVBFQVQnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgbWluIC8gbWFnIGZpbHRlciBmb3IgdGV4dHVyZXMuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfRklMVEVSID0gJ0xJTkVBUic7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3Igd2hldGhlciBhbHBoYSBwcmVtdWx0aXBseWluZyBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX1BSRU1VTFRJUExZX0FMUEhBID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZvciB3aGV0aGVyIG1pcG1hcHBpbmcgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9NSVBNQVAgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZm9yIHdoZXRoZXIgaW52ZXJ0LXkgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9JTlZFUlRfWSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBtaXAtbWFwcGluZyBmaWx0ZXIgc3VmZml4LlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX01JUE1BUF9NSU5fRklMVEVSX1NVRkZJWCA9ICdfTUlQTUFQX0xJTkVBUic7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgVGV4dHVyZTJEXG4gICAgICogQGNsYXNzZGVzYyBBIHRleHR1cmUgY2xhc3MgdG8gcmVwcmVzZW50IGEgMkQgdGV4dHVyZS5cbiAgICAgKi9cbiAgICBjbGFzcyBUZXh0dXJlMkQge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYSBUZXh0dXJlMkQgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl8VWludDE2QXJyYXl8VWludDMyQXJyYXl8RmxvYXQzMkFycmF5fEltYWdlRGF0YXxIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IHNwZWMuc3JjIC0gVGhlIGRhdGEgdG8gYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3BlYy53aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWMuaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgYm90aCBTIGFuZCBUIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcFMgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIHRoZSBTIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcFQgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIHRoZSBUIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMuZmlsdGVyIC0gVGhlIG1pbiAvIG1hZyBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMubWluRmlsdGVyIC0gVGhlIG1pbmlmaWNhdGlvbiBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMubWFnRmlsdGVyIC0gVGhlIG1hZ25pZmljYXRpb24gZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gc3BlYy5taXBNYXAgLSBXaGV0aGVyIG9yIG5vdCBtaXAtbWFwcGluZyBpcyBlbmFibGVkLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2x9IHNwZWMuaW52ZXJ0WSAtIFdoZXRoZXIgb3Igbm90IGludmVydC15IGlzIGVuYWJsZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gc3BlYy5wcmVNdWx0aXBseUFscGhhIC0gV2hldGhlciBvciBub3QgYWxwaGEgcHJlbXVsdGlwbHlpbmcgaXMgZW5hYmxlZC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMuZm9ybWF0IC0gVGhlIHRleHR1cmUgcGl4ZWwgZm9ybWF0LlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy50eXBlIC0gVGhlIHRleHR1cmUgcGl4ZWwgY29tcG9uZW50IHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihzcGVjID0ge30pIHtcbiAgICAgICAgICAgIC8vIGdldCBzcGVjaWZpYyBwYXJhbXNcbiAgICAgICAgICAgIHNwZWMud3JhcFMgPSBzcGVjLndyYXBTIHx8IHNwZWMud3JhcDtcbiAgICAgICAgICAgIHNwZWMud3JhcFQgPSBzcGVjLndyYXBUIHx8IHNwZWMud3JhcDtcbiAgICAgICAgICAgIHNwZWMubWluRmlsdGVyID0gc3BlYy5taW5GaWx0ZXIgfHwgc3BlYy5maWx0ZXI7XG4gICAgICAgICAgICBzcGVjLm1hZ0ZpbHRlciA9IHNwZWMubWFnRmlsdGVyIHx8IHNwZWMuZmlsdGVyO1xuICAgICAgICAgICAgLy8gc2V0IGNvbnRleHRcbiAgICAgICAgICAgIHRoaXMuZ2wgPSBXZWJHTENvbnRleHQuZ2V0KCk7XG4gICAgICAgICAgICAvLyBlbXB0eSB0ZXh0dXJlXG4gICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgICAgICAgICAgLy8gc2V0IHRleHR1cmUgcGFyYW1zXG4gICAgICAgICAgICB0aGlzLndyYXBTID0gc3BlYy53cmFwUyB8fCBERUZBVUxUX1dSQVA7XG4gICAgICAgICAgICB0aGlzLndyYXBUID0gc3BlYy53cmFwVCB8fCBERUZBVUxUX1dSQVA7XG4gICAgICAgICAgICB0aGlzLm1pbkZpbHRlciA9IHNwZWMubWluRmlsdGVyIHx8IERFRkFVTFRfRklMVEVSO1xuICAgICAgICAgICAgdGhpcy5tYWdGaWx0ZXIgPSBzcGVjLm1hZ0ZpbHRlciB8fCBERUZBVUxUX0ZJTFRFUjtcbiAgICAgICAgICAgIC8vIHNldCBvdGhlciBwcm9wZXJ0aWVzXG4gICAgICAgICAgICB0aGlzLm1pcE1hcCA9IHNwZWMubWlwTWFwICE9PSB1bmRlZmluZWQgPyBzcGVjLm1pcE1hcCA6IERFRkFVTFRfTUlQTUFQO1xuICAgICAgICAgICAgdGhpcy5pbnZlcnRZID0gc3BlYy5pbnZlcnRZICE9PSB1bmRlZmluZWQgPyBzcGVjLmludmVydFkgOiBERUZBVUxUX0lOVkVSVF9ZO1xuICAgICAgICAgICAgdGhpcy5wcmVNdWx0aXBseUFscGhhID0gc3BlYy5wcmVNdWx0aXBseUFscGhhICE9PSB1bmRlZmluZWQgPyBzcGVjLnByZU11bHRpcGx5QWxwaGEgOiBERUZBVUxUX1BSRU1VTFRJUExZX0FMUEhBO1xuICAgICAgICAgICAgLy8gc2V0IGZvcm1hdFxuICAgICAgICAgICAgdGhpcy5mb3JtYXQgPSBzcGVjLmZvcm1hdCB8fCBERUZBVUxUX0ZPUk1BVDtcbiAgICAgICAgICAgIGlmIChERVBUSF9UWVBFU1t0aGlzLmZvcm1hdF0gJiYgIVdlYkdMQ29udGV4dC5jaGVja0V4dGVuc2lvbignV0VCR0xfZGVwdGhfdGV4dHVyZScpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYENhbm5vdCBjcmVhdGUgVGV4dHVyZTJEIG9mIGZvcm1hdCBcXGAke3RoaXMuZm9ybWF0fVxcYCBhcyBcXGBXRUJHTF9kZXB0aF90ZXh0dXJlXFxgIGV4dGVuc2lvbiBpcyB1bnN1cHBvcnRlZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgdHlwZVxuICAgICAgICAgICAgdGhpcy50eXBlID0gc3BlYy50eXBlIHx8IERFRkFVTFRfVFlQRTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdGTE9BVCcgJiYgIVdlYkdMQ29udGV4dC5jaGVja0V4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGBDYW5ub3QgY3JlYXRlIFRleHR1cmUyRCBvZiB0eXBlIFxcYEZMT0FUXFxgIGFzIFxcYE9FU190ZXh0dXJlX2Zsb2F0XFxgIGV4dGVuc2lvbiBpcyB1bnN1cHBvcnRlZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1cmwgd2lsbCBub3QgYmUgcmVzb2x2ZWQgeWV0LCBzbyBkb24ndCBidWZmZXIgaW4gdGhhdCBjYXNlXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMuc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHNpemVcbiAgICAgICAgICAgICAgICBpZiAoIVV0aWwuaXNDYW52YXNUeXBlKHNwZWMuc3JjKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgYSBjYW52YXMgdHlwZSwgZGltZW5zaW9ucyBNVVNUIGJlIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMud2lkdGggIT09ICdudW1iZXInIHx8IHNwZWMud2lkdGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ2B3aWR0aGAgYXJndW1lbnQgaXMgbWlzc2luZyBvciBpbnZhbGlkJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMuaGVpZ2h0ICE9PSAnbnVtYmVyJyB8fCBzcGVjLmhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnYGhlaWdodGAgYXJndW1lbnQgaXMgbWlzc2luZyBvciBpbnZhbGlkJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbC5tdXN0QmVQb3dlck9mVHdvKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVV0aWwuaXNQb3dlck9mVHdvKHNwZWMud2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgYFBhcmFtZXRlcnMgcmVxdWlyZSBhIHBvd2VyLW9mLXR3byB0ZXh0dXJlLCB5ZXQgcHJvdmlkZWQgd2lkdGggb2YgXFxgJHtzcGVjLndpZHRofVxcYCBpcyBub3QgYSBwb3dlciBvZiB0d29gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFVdGlsLmlzUG93ZXJPZlR3byhzcGVjLmhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBgUGFyYW1ldGVycyByZXF1aXJlIGEgcG93ZXItb2YtdHdvIHRleHR1cmUsIHlldCBwcm92aWRlZCBoZWlnaHQgb2YgXFxgJHtzcGVjLmhlaWdodH1cXGAgaXMgbm90IGEgcG93ZXIgb2YgdHdvYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBidWZmZXIgdGhlIGRhdGFcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlckRhdGEoc3BlYy5zcmMgfHwgbnVsbCwgc3BlYy53aWR0aCwgc3BlYy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVycyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kcyB0aGUgdGV4dHVyZSBvYmplY3QgdG8gdGhlIHByb3ZpZGVkIHRleHR1cmUgdW5pdCBsb2NhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGxvY2F0aW9uIC0gVGhlIHRleHR1cmUgdW5pdCBsb2NhdGlvbiBpbmRleC4gRGVmYXVsdHMgdG8gMC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VGV4dHVyZTJEfSBUaGUgdGV4dHVyZSBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGJpbmQobG9jYXRpb24gPSAwKSB7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobG9jYXRpb24pIHx8IGxvY2F0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IGBUZXh0dXJlIHVuaXQgbG9jYXRpb24gaXMgaW52YWxpZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsWydURVhUVVJFJyArIGxvY2F0aW9uXSk7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5iaW5kcyB0aGUgdGV4dHVyZSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1RleHR1cmUyRH0gVGhlIHRleHR1cmUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICB1bmJpbmQoKSB7XG4gICAgICAgICAgICAvLyB1bmJpbmQgdGV4dHVyZVxuICAgICAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQnVmZmVyIGRhdGEgaW50byB0aGUgdGV4dHVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlclZpZXd8bnVsbH0gZGF0YSAtIFRoZSBkYXRhIGFycmF5IHRvIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VGV4dHVyZTJEfSBUaGUgdGV4dHVyZSBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGJ1ZmZlckRhdGEoZGF0YSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0ZXh0dXJlIG9iamVjdCBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3RcbiAgICAgICAgICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmluZCB0ZXh0dXJlXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICAgICAgLy8gaW52ZXJ0IHkgaWYgc3BlY2lmaWVkXG4gICAgICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0aGlzLmludmVydFkpO1xuICAgICAgICAgICAgLy8gcHJlbXVsdGlwbHkgYWxwaGEgaWYgc3BlY2lmaWVkXG4gICAgICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRoaXMucHJlTXVsdGlwbHlBbHBoYSk7XG4gICAgICAgICAgICAvLyBjYXN0IGFycmF5IGFyZ1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnVU5TSUdORURfU0hPUlQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDE2QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdVTlNJR05FRF9JTlQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDMyQXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdGTE9BVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBlbnN1cmUgdHlwZSBjb3JyZXNwb25kcyB0byBkYXRhXG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnVU5TSUdORURfQllURSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdVTlNJR05FRF9TSE9SVCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50MzJBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdVTlNJR05FRF9JTlQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ0ZMT0FUJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSAmJiAhKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgJiYgIVV0aWwuaXNDYW52YXNUeXBlKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0FyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBgQXJyYXlgLCBgQXJyYXlCdWZmZXJgLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2BBcnJheUJ1ZmZlclZpZXdgLCBgSW1hZ2VEYXRhYCwgYEhUTUxJbWFnZUVsZW1lbnRgLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2BIVE1MQ2FudmFzRWxlbWVudGAsIGBIVE1MVmlkZW9FbGVtZW50YCwgb3IgbnVsbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVXRpbC5pc0NhbnZhc1R5cGUoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IGRhdGEud2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBkYXRhLmhlaWdodDtcbiAgICAgICAgICAgICAgICAvLyBidWZmZXIgdGhlIHRleHR1cmVcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICAgICAgICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICAgICAgICAgICAgICAwLCAvLyBtaXAtbWFwIGxldmVsLFxuICAgICAgICAgICAgICAgICAgICBnbFt0aGlzLmZvcm1hdF0sIC8vIHdlYmdsIHJlcXVpcmVzIGZvcm1hdCA9PT0gaW50ZXJuYWxGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy5mb3JtYXRdLFxuICAgICAgICAgICAgICAgICAgICBnbFt0aGlzLnR5cGVdLFxuICAgICAgICAgICAgICAgICAgICBkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCB0aGlzLndpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciB0aGUgdGV4dHVyZSBkYXRhXG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICAgICAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgICAgICAgICAgICAgMCwgLy8gbWlwLW1hcCBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBnbFt0aGlzLmZvcm1hdF0sIC8vIHdlYmdsIHJlcXVpcmVzIGZvcm1hdCA9PT0gaW50ZXJuYWxGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIDAsIC8vIGJvcmRlciwgbXVzdCBiZSAwXG4gICAgICAgICAgICAgICAgICAgIGdsW3RoaXMuZm9ybWF0XSxcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy50eXBlXSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBtaXAgbWFwc1xuICAgICAgICAgICAgaWYgKHRoaXMubWlwTWFwKSB7XG4gICAgICAgICAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1bmJpbmQgdGV4dHVyZVxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHRleHR1cmUgcGFyYW1ldGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGJ5IG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMud3JhcCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgYm90aCBTIGFuZCBUIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy53cmFwUyAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgdGhlIFMgZGltZW5zaW9uLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLndyYXBUIC0gVGhlIHdyYXBwaW5nIHR5cGUgb3ZlciB0aGUgVCBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuZmlsdGVyIC0gVGhlIG1pbiAvIG1hZyBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5taW5GaWx0ZXIgLSBUaGUgbWluaWZpY2F0aW9uIGZpbHRlciB1c2VkIGR1cmluZyBzY2FsaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm1hZ0ZpbHRlciAtIFRoZSBtYWduaWZpY2F0aW9uIGZpbHRlciB1c2VkIGR1cmluZyBzY2FsaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtUZXh0dXJlMkR9IFRoZSB0ZXh0dXJlIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICAvLyBiaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgICAvLyBzZXQgd3JhcCBTIHBhcmFtZXRlclxuICAgICAgICAgICAgbGV0IHBhcmFtID0gcGFyYW1zLndyYXBTIHx8IHBhcmFtcy53cmFwO1xuICAgICAgICAgICAgaWYgKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKFdSQVBfTU9ERVNbcGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JhcFMgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2xbdGhpcy53cmFwU10pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGBUZXh0dXJlIHBhcmFtZXRlciBcXGAke3BhcmFtfVxcYCBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgXFxgVEVYVFVSRV9XUkFQX1NcXGBgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCB3cmFwIFQgcGFyYW1ldGVyXG4gICAgICAgICAgICBwYXJhbSA9IHBhcmFtcy53cmFwVCB8fCBwYXJhbXMud3JhcDtcbiAgICAgICAgICAgIGlmIChwYXJhbSkge1xuICAgICAgICAgICAgICAgIGlmIChXUkFQX01PREVTW3BhcmFtXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBUID0gcGFyYW07XG4gICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsW3RoaXMud3JhcFRdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIFxcYFRFWFRVUkVfV1JBUF9UXFxgYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgbWFnIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgICAgICAgIHBhcmFtID0gcGFyYW1zLm1hZ0ZpbHRlciB8fCBwYXJhbXMuZmlsdGVyO1xuICAgICAgICAgICAgaWYgKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1BR19GSUxURVJTW3BhcmFtXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hZ0ZpbHRlciA9IHBhcmFtO1xuICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2xbdGhpcy5tYWdGaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yICdURVhUVVJFX01BR19GSUxURVJcXGBgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBtaW4gZmlsdGVyIHBhcmFtZXRlclxuICAgICAgICAgICAgcGFyYW0gPSBwYXJhbXMubWluRmlsdGVyIHx8IHBhcmFtcy5maWx0ZXI7XG4gICAgICAgICAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taXBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE5PTl9NSVBNQVBfTUlOX0ZJTFRFUlNbcGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGdyYWRlIHRvIG1pcC1tYXAgbWluIGZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0gKz0gREVGQVVMVF9NSVBNQVBfTUlOX0ZJTFRFUl9TVUZGSVg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKE1JUE1BUF9NSU5fRklMVEVSU1twYXJhbV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluRmlsdGVyID0gcGFyYW07XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2xbdGhpcy5taW5GaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIFxcYFRFWFRVUkVfTUlOX0ZJTFRFUlxcYGA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTUlOX0ZJTFRFUlNbcGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbkZpbHRlciA9IHBhcmFtO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsW3RoaXMubWluRmlsdGVyXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIFxcYFRFWFRVUkVfTUlOX0ZJTFRFUlxcYGA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1bmJpbmQgdGV4dHVyZVxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZSB0aGUgdW5kZXJseWluZyB0ZXh0dXJlLiBUaGlzIGNsZWFycyB0aGUgdGV4dHVyZSBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgbmV3IHdpZHRoIG9mIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHRleHR1cmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1RleHR1cmUyRH0gVGhlIHRleHR1cmUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ251bWJlcicgfHwgKHdpZHRoIDw9IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIHdpZHRoIG9mIFxcYCR7d2lkdGh9XFxgIGlzIGludmFsaWRgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICdudW1iZXInIHx8IChoZWlnaHQgPD0gMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgUHJvdmlkZWQgaGVpZ2h0IG9mIFxcYCR7aGVpZ2h0fVxcYCBpcyBpbnZhbGlkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyRGF0YShudWxsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlMkQ7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IFdlYkdMQ29udGV4dCA9IHJlcXVpcmUoJy4vV2ViR0xDb250ZXh0Jyk7XG4gICAgbGV0IEFzeW5jID0gcmVxdWlyZSgnLi4vdXRpbC9Bc3luYycpO1xuICAgIGxldCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyk7XG4gICAgbGV0IEltYWdlTG9hZGVyID0gcmVxdWlyZSgnLi4vdXRpbC9JbWFnZUxvYWRlcicpO1xuXG4gICAgbGV0IEZBQ0VTID0gW1xuICAgICAgICAnLXgnLCAnK3gnLFxuICAgICAgICAnLXknLCAnK3knLFxuICAgICAgICAnLXonLCAnK3onXG4gICAgXTtcbiAgICBsZXQgRkFDRV9UQVJHRVRTID0ge1xuICAgICAgICAnK3onOiAnVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aJyxcbiAgICAgICAgJy16JzogJ1RFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWicsXG4gICAgICAgICcreCc6ICdURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gnLFxuICAgICAgICAnLXgnOiAnVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YJyxcbiAgICAgICAgJyt5JzogJ1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWScsXG4gICAgICAgICcteSc6ICdURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1knXG4gICAgfTtcbiAgICBsZXQgVEFSR0VUUyA9IHtcbiAgICAgICAgVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aOiB0cnVlLFxuICAgICAgICBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1o6IHRydWUsXG4gICAgICAgIFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWDogdHJ1ZSxcbiAgICAgICAgVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YOiB0cnVlLFxuICAgICAgICBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1k6IHRydWUsXG4gICAgICAgIFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWTogdHJ1ZVxuICAgIH07XG4gICAgbGV0IE1BR19GSUxURVJTID0ge1xuICAgICAgICBORUFSRVNUOiB0cnVlLFxuICAgICAgICBMSU5FQVI6IHRydWVcbiAgICB9O1xuICAgIGxldCBNSU5fRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSOiB0cnVlLFxuICAgICAgICBORUFSRVNUX01JUE1BUF9ORUFSRVNUOiB0cnVlLFxuICAgICAgICBMSU5FQVJfTUlQTUFQX05FQVJFU1Q6IHRydWUsXG4gICAgICAgIE5FQVJFU1RfTUlQTUFQX0xJTkVBUjogdHJ1ZSxcbiAgICAgICAgTElORUFSX01JUE1BUF9MSU5FQVI6IHRydWVcbiAgICB9O1xuICAgIGxldCBOT05fTUlQTUFQX01JTl9GSUxURVJTID0ge1xuICAgICAgICBORUFSRVNUOiB0cnVlLFxuICAgICAgICBMSU5FQVI6IHRydWUsXG4gICAgfTtcbiAgICBsZXQgTUlQTUFQX01JTl9GSUxURVJTID0ge1xuICAgICAgICBORUFSRVNUX01JUE1BUF9ORUFSRVNUOiB0cnVlLFxuICAgICAgICBMSU5FQVJfTUlQTUFQX05FQVJFU1Q6IHRydWUsXG4gICAgICAgIE5FQVJFU1RfTUlQTUFQX0xJTkVBUjogdHJ1ZSxcbiAgICAgICAgTElORUFSX01JUE1BUF9MSU5FQVI6IHRydWVcbiAgICB9O1xuICAgIGxldCBXUkFQX01PREVTID0ge1xuICAgICAgICBSRVBFQVQ6IHRydWUsXG4gICAgICAgIE1JUlJPUkVEX1JFUEVBVDogdHJ1ZSxcbiAgICAgICAgQ0xBTVBfVE9fRURHRTogdHJ1ZVxuICAgIH07XG4gICAgbGV0IEZPUk1BVFMgPSB7XG4gICAgICAgIFJHQjogdHJ1ZSxcbiAgICAgICAgUkdCQTogdHJ1ZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCB0eXBlIGZvciB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9UWVBFID0gJ1VOU0lHTkVEX0JZVEUnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZm9ybWF0IGZvciB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9GT1JNQVQgPSAnUkdCQSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCB3cmFwIG1vZGUgZm9yIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX1dSQVAgPSAnQ0xBTVBfVE9fRURHRSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBtaW4gLyBtYWcgZmlsdGVyIGZvciB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9GSUxURVIgPSAnTElORUFSJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZvciB3aGV0aGVyIGFscGhhIHByZW11bHRpcGx5aW5nIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfUFJFTVVMVElQTFlfQUxQSEEgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZm9yIHdoZXRoZXIgbWlwbWFwcGluZyBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX01JUE1BUCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3Igd2hldGhlciBpbnZlcnQteSBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX0lOVkVSVF9ZID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IG1pcC1tYXBwaW5nIGZpbHRlciBzdWZmaXguXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfTUlQTUFQX01JTl9GSUxURVJfU1VGRklYID0gJ19NSVBNQVBfTElORUFSJztcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY3ViZW1hcCBhbmQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZlxuICAgICAqIGl0IGRvZXMgbm90IG1lZXQgcmVxdWlyZW1lbnRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RleHR1cmVDdWJlTWFwfSBjdWJlTWFwIC0gVGhlIGN1YmUgbWFwIHRleHR1cmUgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrRGltZW5zaW9ucyhjdWJlTWFwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3ViZU1hcC53aWR0aCAhPT0gJ251bWJlcicgfHwgY3ViZU1hcC53aWR0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyAnYHdpZHRoYCBhcmd1bWVudCBpcyBtaXNzaW5nIG9yIGludmFsaWQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY3ViZU1hcC5oZWlnaHQgIT09ICdudW1iZXInIHx8IGN1YmVNYXAuaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93ICdgaGVpZ2h0YCBhcmd1bWVudCBpcyBtaXNzaW5nIG9yIGludmFsaWQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdWJlTWFwLndpZHRoICE9PSBjdWJlTWFwLmhlaWdodCkge1xuICAgICAgICAgICAgdGhyb3cgJ1Byb3ZpZGVkIGB3aWR0aGAgbXVzdCBiZSBlcXVhbCB0byBgaGVpZ2h0YCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWwubXVzdEJlUG93ZXJPZlR3byhjdWJlTWFwKSAmJiAhVXRpbC5pc1Bvd2VyT2ZUd28oY3ViZU1hcC53aWR0aCkpIHtcbiAgICAgICAgICAgIHRocm93IGBQYXJhbWV0ZXJzIHJlcXVpcmUgYSBwb3dlci1vZi10d28gdGV4dHVyZSwgeWV0IHByb3ZpZGVkIHNpemUgb2YgJHtjdWJlTWFwLndpZHRofSBpcyBub3QgYSBwb3dlciBvZiB0d29gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIGxvYWQgYSBmYWNlIGZyb20gYSB1cmwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VGV4dHVyZUN1YmVNYXB9IGN1YmVNYXAgLSBUaGUgY3ViZSBtYXAgdGV4dHVyZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldCAtIFRoZSB0ZXh0dXJlIHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gVGhlIHVybCB0byBsb2FkIHRoZSBmYWNlIGZyb20uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGxvYWRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkRmFjZVVSTChjdWJlTWFwLCB0YXJnZXQsIHVybCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgLy8gVE9ETzogcHV0IGV4dGVuc2lvbiBoYW5kbGluZyBmb3IgYXJyYXlidWZmZXIgLyBpbWFnZSAvIHZpZGVvIGRpZmZlcmVudGlhdGlvblxuICAgICAgICAgICAgSW1hZ2VMb2FkZXIubG9hZCh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogaW1hZ2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IFV0aWwucmVzaXplQ2FudmFzKGN1YmVNYXAsIGltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgY3ViZU1hcC5idWZmZXJEYXRhKHRhcmdldCwgaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICBkb25lKG51bGwpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gbG9hZCBhIGZhY2UgZnJvbSBhIGNhbnZhcyB0eXBlIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtUZXh0dXJlQ3ViZU1hcH0gY3ViZU1hcCAtIFRoZSBjdWJlIG1hcCB0ZXh0dXJlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0IC0gVGhlIHRleHR1cmUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gY2FudmFzIC0gVGhlIGNhbnZhcyB0eXBlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIFRoZSBsb2FkZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9hZEZhY2VDYW52YXMoY3ViZU1hcCwgdGFyZ2V0LCBjYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGNhbnZhcyA9IFV0aWwucmVzaXplQ2FudmFzKGN1YmVNYXAsIGNhbnZhcyk7XG4gICAgICAgICAgICBjdWJlTWFwLmJ1ZmZlckRhdGEodGFyZ2V0LCBjYW52YXMpO1xuICAgICAgICAgICAgZG9uZShudWxsKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gbG9hZCBhIGZhY2UgZnJvbSBhbiBhcnJheSB0eXBlIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtUZXh0dXJlQ3ViZU1hcH0gY3ViZU1hcCAtIFRoZSBjdWJlIG1hcCB0ZXh0dXJlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0IC0gVGhlIHRleHR1cmUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBhcnIgLSBUaGUgYXJyYXkgdHlwZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGxvYWRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkRmFjZUFycmF5KGN1YmVNYXAsIHRhcmdldCwgYXJyKSB7XG4gICAgICAgIGNoZWNrRGltZW5zaW9ucyhjdWJlTWFwKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGN1YmVNYXAuYnVmZmVyRGF0YSh0YXJnZXQsIGFycik7XG4gICAgICAgICAgICBkb25lKG51bGwpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBUZXh0dXJlQ3ViZU1hcFxuICAgICAqIEBjbGFzc2Rlc2MgQSB0ZXh0dXJlIGNsYXNzIHRvIHJlcHJlc2VudCBhIGN1YmUgbWFwIHRleHR1cmUuXG4gICAgICovXG4gICAgY2xhc3MgVGV4dHVyZUN1YmVNYXAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYSBUZXh0dXJlQ3ViZU1hcCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIC0gVGhlIHNwZWNpZmljYXRpb24gYXJndW1lbnRzXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjLmZhY2VzIC0gVGhlIGZhY2VzIHRvIGJ1ZmZlciwgdW5kZXIga2V5cyAnK3gnLCAnK3knLCAnK3onLCAnLXgnLCAnLXknLCBhbmQgJy16Jy5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWMud2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGZhY2VzLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3BlYy5oZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBmYWNlcy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgYm90aCBTIGFuZCBUIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcFMgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIHRoZSBTIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcFQgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIHRoZSBUIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMuZmlsdGVyIC0gVGhlIG1pbiAvIG1hZyBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMubWluRmlsdGVyIC0gVGhlIG1pbmlmaWNhdGlvbiBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMubWFnRmlsdGVyIC0gVGhlIG1hZ25pZmljYXRpb24gZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gc3BlYy5taXBNYXAgLSBXaGV0aGVyIG9yIG5vdCBtaXAtbWFwcGluZyBpcyBlbmFibGVkLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2x9IHNwZWMuaW52ZXJ0WSAtIFdoZXRoZXIgb3Igbm90IGludmVydC15IGlzIGVuYWJsZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gc3BlYy5wcmVNdWx0aXBseUFscGhhIC0gV2hldGhlciBvciBub3QgYWxwaGEgcHJlbXVsdGlwbHlpbmcgaXMgZW5hYmxlZC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMuZm9ybWF0IC0gVGhlIHRleHR1cmUgcGl4ZWwgZm9ybWF0LlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy50eXBlIC0gVGhlIHRleHR1cmUgcGl4ZWwgY29tcG9uZW50IHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihzcGVjID0ge30sIGNhbGxiYWNrID0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5nbCA9IFdlYkdMQ29udGV4dC5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBnZXQgc3BlY2lmaWMgcGFyYW1zXG4gICAgICAgICAgICBzcGVjLndyYXBTID0gc3BlYy53cmFwUyB8fCBzcGVjLndyYXA7XG4gICAgICAgICAgICBzcGVjLndyYXBUID0gc3BlYy53cmFwVCB8fCBzcGVjLndyYXA7XG4gICAgICAgICAgICBzcGVjLm1pbkZpbHRlciA9IHNwZWMubWluRmlsdGVyIHx8IHNwZWMuZmlsdGVyO1xuICAgICAgICAgICAgc3BlYy5tYWdGaWx0ZXIgPSBzcGVjLm1hZ0ZpbHRlciB8fCBzcGVjLmZpbHRlcjtcbiAgICAgICAgICAgIC8vIHNldCB0ZXh0dXJlIHBhcmFtc1xuICAgICAgICAgICAgdGhpcy53cmFwUyA9IFdSQVBfTU9ERVNbc3BlYy53cmFwU10gPyBzcGVjLndyYXBTIDogREVGQVVMVF9XUkFQO1xuICAgICAgICAgICAgdGhpcy53cmFwVCA9IFdSQVBfTU9ERVNbc3BlYy53cmFwVF0gPyBzcGVjLndyYXBUIDogREVGQVVMVF9XUkFQO1xuICAgICAgICAgICAgdGhpcy5taW5GaWx0ZXIgPSBNSU5fRklMVEVSU1tzcGVjLm1pbkZpbHRlcl0gPyBzcGVjLm1pbkZpbHRlciA6IERFRkFVTFRfRklMVEVSO1xuICAgICAgICAgICAgdGhpcy5tYWdGaWx0ZXIgPSBNQUdfRklMVEVSU1tzcGVjLm1hZ0ZpbHRlcl0gPyBzcGVjLm1hZ0ZpbHRlciA6IERFRkFVTFRfRklMVEVSO1xuICAgICAgICAgICAgLy8gc2V0IG90aGVyIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHRoaXMubWlwTWFwID0gc3BlYy5taXBNYXAgIT09IHVuZGVmaW5lZCA/IHNwZWMubWlwTWFwIDogREVGQVVMVF9NSVBNQVA7XG4gICAgICAgICAgICB0aGlzLmludmVydFkgPSBzcGVjLmludmVydFkgIT09IHVuZGVmaW5lZCA/IHNwZWMuaW52ZXJ0WSA6IERFRkFVTFRfSU5WRVJUX1k7XG4gICAgICAgICAgICB0aGlzLnByZU11bHRpcGx5QWxwaGEgPSBzcGVjLnByZU11bHRpcGx5QWxwaGEgIT09IHVuZGVmaW5lZCA/IHNwZWMucHJlTXVsdGlwbHlBbHBoYSA6IERFRkFVTFRfUFJFTVVMVElQTFlfQUxQSEE7XG4gICAgICAgICAgICAvLyBzZXQgZm9ybWF0IGFuZCB0eXBlXG4gICAgICAgICAgICB0aGlzLmZvcm1hdCA9IEZPUk1BVFNbc3BlYy5mb3JtYXRdID8gc3BlYy5mb3JtYXQgOiBERUZBVUxUX0ZPUk1BVDtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHNwZWMudHlwZSB8fCBERUZBVUxUX1RZUEU7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnRkxPQVQnICYmICFXZWJHTENvbnRleHQuY2hlY2tFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0JykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQ2Fubm90IGNyZWF0ZSBUZXh0dXJlMkQgb2YgdHlwZSBgRkxPQVRgIGFzIGBPRVNfdGV4dHVyZV9mbG9hdGAgZXh0ZW5zaW9uIGlzIHVuc3VwcG9ydGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBkaW1lbnNpb25zIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gc3BlYy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc3BlYy5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBzZXQgYnVmZmVyZWQgZmFjZXNcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyZWRGYWNlcyA9IFtdO1xuICAgICAgICAgICAgLy8gY3JlYXRlIGN1YmUgbWFwIGJhc2VkIG9uIGlucHV0XG4gICAgICAgICAgICBpZiAoc3BlYy5mYWNlcykge1xuICAgICAgICAgICAgICAgIGxldCB0YXNrcyA9IFtdO1xuICAgICAgICAgICAgICAgIEZBQ0VTLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmFjZSA9IHNwZWMuZmFjZXNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gRkFDRV9UQVJHRVRTW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9hZCBiYXNlZCBvbiB0eXBlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVybFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaChsb2FkRmFjZVVSTCh0aGlzLCB0YXJnZXQsIGZhY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChVdGlsLmlzQ2FudmFzVHlwZShmYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FudmFzXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKGxvYWRGYWNlQ2FudmFzKHRoaXMsIHRhcmdldCwgZmFjZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgLyBhcnJheWJ1ZmZlciBvciBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKGxvYWRGYWNlQXJyYXkodGhpcywgdGFyZ2V0LCBmYWNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBBc3luYy5wYXJhbGxlbCh0YXNrcywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbnVsbFxuICAgICAgICAgICAgICAgIGNoZWNrRGltZW5zaW9ucyh0aGlzKTtcbiAgICAgICAgICAgICAgICBGQUNFUy5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJEYXRhKEZBQ0VfVEFSR0VUU1tpZF0sIG51bGwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHNldCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmRzIHRoZSB0ZXh0dXJlIG9iamVjdCB0byB0aGUgcHJvdmlkZWQgdGV4dHVyZSB1bml0IGxvY2F0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbG9jYXRpb24gLSBUaGUgdGV4dHVyZSB1bml0IGxvY2F0aW9uIGluZGV4LiBEZWZhdWx0cyB0byAwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtUZXh0dXJlQ3ViZU1hcH0gVGhlIHRleHR1cmUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kKGxvY2F0aW9uID0gMCkge1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxvY2F0aW9uKSB8fCBsb2NhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVGV4dHVyZSB1bml0IGxvY2F0aW9uIGlzIGludmFsaWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmluZCBjdWJlIG1hcCB0ZXh0dXJlXG4gICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbFsnVEVYVFVSRScgKyBsb2NhdGlvbl0pO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuYmluZHMgdGhlIHRleHR1cmUgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtUZXh0dXJlQ3ViZU1hcH0gLSBUaGUgdGV4dHVyZSBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHVuYmluZCgpIHtcbiAgICAgICAgICAgIC8vIHVuYmluZCBjdWJlIG1hcCB0ZXh0dXJlXG4gICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWZmZXIgZGF0YSBpbnRvIHRoZSByZXNwZWN0aXZlIGN1YmUgbWFwIGZhY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXQgLSBUaGUgZmFjZSB0YXJnZXQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IGRhdGEgLSBUaGUgZmFjZSBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtUZXh0dXJlQ3ViZU1hcH0gVGhlIHRleHR1cmUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBidWZmZXJEYXRhKHRhcmdldCwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFUQVJHRVRTW3RhcmdldF0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgUHJvdmlkZWQgXFxgdGFyZ2V0XFxgIG9mICR7dGFyZ2V0fSAgaXMgaW52YWxpZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHRleHR1cmUgb2JqZWN0IGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxuICAgICAgICAgICAgaWYgKCF0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgICAvLyBpbnZlcnQgeSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRoaXMuaW52ZXJ0WSk7XG4gICAgICAgICAgICAvLyBwcmVtdWx0aXBseSBhbHBoYSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGhpcy5wcmVNdWx0aXBseUFscGhhKTtcbiAgICAgICAgICAgIC8vIGNhc3QgYXJyYXkgYXJnXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdVTlNJR05FRF9TSE9SVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50MTZBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ1VOU0lHTkVEX0lOVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50MzJBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ0ZMT0FUJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IGVuc3VyZSB0eXBlIGNvcnJlc3BvbmRzIHRvIGRhdGFcbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdVTlNJR05FRF9CWVRFJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ1VOU0lHTkVEX1NIT1JUJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ1VOU0lHTkVEX0lOVCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnRkxPQVQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhICYmICEoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSAmJiAhVXRpbC5pc0NhbnZhc1R5cGUoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGBBcnJheWAsIGBBcnJheUJ1ZmZlcmAsICcgK1xuICAgICAgICAgICAgICAgICAgICAnYEFycmF5QnVmZmVyVmlld2AsIGBJbWFnZURhdGFgLCBgSFRNTEltYWdlRWxlbWVudGAsICcgK1xuICAgICAgICAgICAgICAgICAgICAnYEhUTUxDYW52YXNFbGVtZW50YCwgYEhUTUxWaWRlb0VsZW1lbnRgLCBvciBudWxsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJ1ZmZlciB0aGUgZGF0YVxuICAgICAgICAgICAgaWYgKFV0aWwuaXNDYW52YXNUeXBlKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBkYXRhLndpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy8gYnVmZmVyIHRoZSB0ZXh0dXJlXG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGFyZ2V0XSxcbiAgICAgICAgICAgICAgICAgICAgMCwgLy8gbWlwLW1hcCBsZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy5mb3JtYXRdLCAvLyB3ZWJnbCByZXF1aXJlcyBmb3JtYXQgPT09IGludGVybmFsRm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIGdsW3RoaXMuZm9ybWF0XSxcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy50eXBlXSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciB0aGUgdGV4dHVyZSBkYXRhXG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGFyZ2V0XSxcbiAgICAgICAgICAgICAgICAgICAgMCwgLy8gbWlwLW1hcCBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBnbFt0aGlzLmZvcm1hdF0sIC8vIHdlYmdsIHJlcXVpcmVzIGZvcm1hdCA9PT0gaW50ZXJuYWxGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIDAsIC8vIGJvcmRlciwgbXVzdCBiZSAwXG4gICAgICAgICAgICAgICAgICAgIGdsW3RoaXMuZm9ybWF0XSxcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy50eXBlXSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cmFjayB0aGUgZmFjZSB0aGF0IHdhcyBidWZmZXJlZFxuICAgICAgICAgICAgaWYgKHRoaXMuYnVmZmVyZWRGYWNlcy5pbmRleE9mKHRhcmdldCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJlZEZhY2VzLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGFsbCBmYWNlcyBidWZmZXJlZCwgZ2VuZXJhdGUgbWlwbWFwc1xuICAgICAgICAgICAgaWYgKHRoaXMubWlwTWFwICYmIHRoaXMuYnVmZmVyZWRGYWNlcy5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGdlbmVyYXRlIG1pcG1hcHMgaWYgYWxsIGZhY2VzIGFyZSBidWZmZXJlZFxuICAgICAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfQ1VCRV9NQVApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdW5iaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSB0ZXh0dXJlIHBhcmFtZXRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBieSBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLndyYXAgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIGJvdGggUyBhbmQgVCBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMud3JhcFMgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIHRoZSBTIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy53cmFwVCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgdGhlIFQgZGltZW5zaW9uLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmZpbHRlciAtIFRoZSBtaW4gLyBtYWcgZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMubWluRmlsdGVyIC0gVGhlIG1pbmlmaWNhdGlvbiBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5tYWdGaWx0ZXIgLSBUaGUgbWFnbmlmaWNhdGlvbiBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VGV4dHVyZUN1YmVNYXB9IFRoZSB0ZXh0dXJlIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICAvLyBiaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgICAvLyBzZXQgd3JhcCBTIHBhcmFtZXRlclxuICAgICAgICAgICAgbGV0IHBhcmFtID0gcGFyYW1zLndyYXBTIHx8IHBhcmFtcy53cmFwO1xuICAgICAgICAgICAgaWYgKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKFdSQVBfTU9ERVNbcGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JhcFMgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfUywgZ2xbdGhpcy53cmFwU10pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGBUZXh0dXJlIHBhcmFtZXRlciBcXGAke3BhcmFtfVxcYCBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgXFxgVEVYVFVSRV9XUkFQX1NcXGBgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCB3cmFwIFQgcGFyYW1ldGVyXG4gICAgICAgICAgICBwYXJhbSA9IHBhcmFtcy53cmFwVCB8fCBwYXJhbXMud3JhcDtcbiAgICAgICAgICAgIGlmIChwYXJhbSkge1xuICAgICAgICAgICAgICAgIGlmIChXUkFQX01PREVTW3BhcmFtXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBUID0gcGFyYW07XG4gICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsW3RoaXMud3JhcFRdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIFxcYFRFWFRVUkVfV1JBUF9UXFxgYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgbWFnIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgICAgICAgIHBhcmFtID0gcGFyYW1zLm1hZ0ZpbHRlciB8fCBwYXJhbXMuZmlsdGVyO1xuICAgICAgICAgICAgaWYgKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1BR19GSUxURVJTW3BhcmFtXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hZ0ZpbHRlciA9IHBhcmFtO1xuICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2xbdGhpcy5tYWdGaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yICdURVhUVVJFX01BR19GSUxURVJcXGBgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBtaW4gZmlsdGVyIHBhcmFtZXRlclxuICAgICAgICAgICAgcGFyYW0gPSBwYXJhbXMubWluRmlsdGVyIHx8IHBhcmFtcy5maWx0ZXI7XG4gICAgICAgICAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taXBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE5PTl9NSVBNQVBfTUlOX0ZJTFRFUlNbcGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGdyYWRlIHRvIG1pcC1tYXAgbWluIGZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0gKz0gREVGQVVMVF9NSVBNQVBfTUlOX0ZJTFRFUl9TVUZGSVg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKE1JUE1BUF9NSU5fRklMVEVSU1twYXJhbV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluRmlsdGVyID0gcGFyYW07XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2xbdGhpcy5taW5GaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIFxcYFRFWFRVUkVfTUlOX0ZJTFRFUlxcYGA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTUlOX0ZJTFRFUlNbcGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbkZpbHRlciA9IHBhcmFtO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsW3RoaXMubWluRmlsdGVyXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIFxcYFRFWFRVUkVfTUlOX0ZJTFRFUlxcYGA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1bmJpbmQgdGV4dHVyZVxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gVGV4dHVyZUN1YmVNYXA7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IFdlYkdMQ29udGV4dCA9IHJlcXVpcmUoJy4vV2ViR0xDb250ZXh0Jyk7XG4gICAgbGV0IFZlcnRleFBhY2thZ2UgPSByZXF1aXJlKCcuL1ZlcnRleFBhY2thZ2UnKTtcblxuICAgIGxldCBNT0RFUyA9IHtcbiAgICAgICAgUE9JTlRTOiB0cnVlLFxuICAgICAgICBMSU5FUzogdHJ1ZSxcbiAgICAgICAgTElORV9TVFJJUDogdHJ1ZSxcbiAgICAgICAgTElORV9MT09QOiB0cnVlLFxuICAgICAgICBUUklBTkdMRVM6IHRydWUsXG4gICAgICAgIFRSSUFOR0xFX1NUUklQOiB0cnVlLFxuICAgICAgICBUUklBTkdMRV9GQU46IHRydWVcbiAgICB9O1xuICAgIGxldCBUWVBFUyA9IHtcbiAgICAgICAgQllURTogdHJ1ZSxcbiAgICAgICAgVU5TSUdORURfQllURTogdHJ1ZSxcbiAgICAgICAgU0hPUlQ6IHRydWUsXG4gICAgICAgIFVOU0lHTkVEX1NIT1JUOiB0cnVlLFxuICAgICAgICBGSVhFRDogdHJ1ZSxcbiAgICAgICAgRkxPQVQ6IHRydWVcbiAgICB9O1xuICAgIGxldCBCWVRFU19QRVJfVFlQRSA9IHtcbiAgICAgICAgQllURTogMSxcbiAgICAgICAgVU5TSUdORURfQllURTogMSxcbiAgICAgICAgU0hPUlQ6IDIsXG4gICAgICAgIFVOU0lHTkVEX1NIT1JUOiAyLFxuICAgICAgICBGSVhFRDogNCxcbiAgICAgICAgRkxPQVQ6IDRcbiAgICB9O1xuICAgIGxldCBTSVpFUyA9IHtcbiAgICAgICAgMTogdHJ1ZSxcbiAgICAgICAgMjogdHJ1ZSxcbiAgICAgICAgMzogdHJ1ZSxcbiAgICAgICAgNDogdHJ1ZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBhdHRyaWJ1dGUgcG9pbnQgYnl0ZSBvZmZzZXQuXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfQllURV9PRkZTRVQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgcmVuZGVyIG1vZGUgKHByaW1pdGl2ZSB0eXBlKS5cbiAgICAgKi9cbiAgICBsZXQgREVGQVVMVF9NT0RFID0gJ1RSSUFOR0xFUyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpbmRleCBvZmZzZXQgdG8gcmVuZGVyIGZyb20uXG4gICAgICovXG4gICAgbGV0IERFRkFVTFRfSU5ERVhfT0ZGU0VUID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGNvdW50IG9mIGluZGljZXMgdG8gcmVuZGVyLlxuICAgICAqL1xuICAgIGxldCBERUZBVUxUX0NPVU5UID0gMDtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBhdHRyaWJ1dGUgcG9pbnRlcnMgYW5kIGRldGVybWluZSB0aGUgYnl0ZSBzdHJpZGUgb2YgdGhlIGJ1ZmZlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZVBvaW50ZXJzIC0gVGhlIGF0dHJpYnV0ZSBwb2ludGVyIG1hcC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGJ5dGUgc3RyaWRlIG9mIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U3RyaWRlKGF0dHJpYnV0ZVBvaW50ZXJzKSB7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIGF0dHJpYnV0ZSBwb2ludGVyIGFzc2lnbmVkIHRvIHRoaXMgYnVmZmVyLFxuICAgICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIGZvciBzdHJpZGUsIHNldCB0byBkZWZhdWx0IG9mIDBcbiAgICAgICAgbGV0IGluZGljZXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVQb2ludGVycyk7XG4gICAgICAgIGlmIChpbmRpY2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1heEJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgYnl0ZVNpemVTdW0gPSAwO1xuICAgICAgICBsZXQgYnl0ZVN0cmlkZSA9IDA7XG4gICAgICAgIGluZGljZXMuZm9yRWFjaChpbmRleCA9PiB7XG4gICAgICAgICAgICBsZXQgcG9pbnRlciA9IGF0dHJpYnV0ZVBvaW50ZXJzW2luZGV4XTtcbiAgICAgICAgICAgIGxldCBieXRlT2Zmc2V0ID0gcG9pbnRlci5ieXRlT2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwb2ludGVyLnNpemU7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHBvaW50ZXIudHlwZTtcbiAgICAgICAgICAgIC8vIHRyYWNrIHRoZSBzdW0gb2YgZWFjaCBhdHRyaWJ1dGUgc2l6ZVxuICAgICAgICAgICAgYnl0ZVNpemVTdW0gKz0gc2l6ZSAqIEJZVEVTX1BFUl9UWVBFW3R5cGVdO1xuICAgICAgICAgICAgLy8gdHJhY2sgdGhlIGxhcmdlc3Qgb2Zmc2V0IHRvIGRldGVybWluZSB0aGUgYnl0ZSBzdHJpZGUgb2YgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPiBtYXhCeXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgbWF4Qnl0ZU9mZnNldCA9IGJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnl0ZVN0cmlkZSA9IGJ5dGVPZmZzZXQgKyAoc2l6ZSAqIEJZVEVTX1BFUl9UWVBFW3R5cGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBtYXggYnl0ZSBvZmZzZXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB0aGUgc3VtIG9mXG4gICAgICAgIC8vIHRoZSBzaXplcy4gSWYgc28gdGhpcyBidWZmZXIgaXMgbm90IGludGVybGVhdmVkIGFuZCBkb2VzIG5vdCBuZWVkIGFcbiAgICAgICAgLy8gc3RyaWRlLlxuICAgICAgICBpZiAobWF4Qnl0ZU9mZnNldCA+PSBieXRlU2l6ZVN1bSkge1xuICAgICAgICAgICAgLy8gVE9ETzogdGVzdCB3aGF0IHN0cmlkZSA9PT0gMCBkb2VzIGZvciBhbiBpbnRlcmxlYXZlZCBidWZmZXIgb2ZcbiAgICAgICAgICAgIC8vIGxlbmd0aCA9PT0gMS5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlU3RyaWRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBhdHRyaWJ1dGUgcG9pbnRlcnMgdG8gZW5zdXJlIHRoZXkgYXJlIHZhbGlkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlUG9pbnRlcnMgLSBUaGUgYXR0cmlidXRlIHBvaW50ZXIgbWFwLlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgdmFsaWRhdGVkIGF0dHJpYnV0ZSBwb2ludGVyIG1hcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVQb2ludGVycyhhdHRyaWJ1dGVQb2ludGVycykge1xuICAgICAgICAvLyBwYXJzZSBwb2ludGVycyB0byBlbnN1cmUgdGhleSBhcmUgdmFsaWRcbiAgICAgICAgbGV0IHBvaW50ZXJzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZVBvaW50ZXJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBwYXJzZUludChrZXksIDEwKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQga2V5IGlzIGFuIHZhbGlkIGludGVnZXJcbiAgICAgICAgICAgIGlmIChpc05hTihpbmRleCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgQXR0cmlidXRlIGluZGV4IFxcYCR7a2V5fVxcYCBkb2VzIG5vdCByZXByZXNlbnQgYW4gaW50ZWdlcmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcG9pbnRlciA9IGF0dHJpYnV0ZVBvaW50ZXJzW2tleV07XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHBvaW50ZXIuc2l6ZTtcbiAgICAgICAgICAgIGxldCB0eXBlID0gcG9pbnRlci50eXBlO1xuICAgICAgICAgICAgbGV0IGJ5dGVPZmZzZXQgPSBwb2ludGVyLmJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICAvLyBjaGVjayBzaXplXG4gICAgICAgICAgICBpZiAoIVNJWkVTW3NpemVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0F0dHJpYnV0ZSBwb2ludGVyIGBzaXplYCBwYXJhbWV0ZXIgaXMgaW52YWxpZCwgbXVzdCBiZSBvbmUgb2YgJyArXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKFNJWkVTKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayB0eXBlXG4gICAgICAgICAgICBpZiAoIVRZUEVTW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0F0dHJpYnV0ZSBwb2ludGVyIGB0eXBlYCBwYXJhbWV0ZXIgaXMgaW52YWxpZCwgbXVzdCBiZSBvbmUgb2YgJyArXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKFRZUEVTKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVyc1tpbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IChieXRlT2Zmc2V0ICE9PSB1bmRlZmluZWQpID8gYnl0ZU9mZnNldCA6IERFRkFVTFRfQllURV9PRkZTRVRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcG9pbnRlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFZlcnRleEJ1ZmZlclxuICAgICAqIEBjbGFzc2Rlc2MgQSB2ZXJ0ZXggYnVmZmVyIG9iamVjdC5cbiAgICAgKi9cbiAgICBjbGFzcyBWZXJ0ZXhCdWZmZXIge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYW4gVmVydGV4QnVmZmVyIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtXZWJHTEJ1ZmZlcnxWZXJ0ZXhQYWNrYWdlfEZsb2F0MzJBcnJheXxBcnJheXxOdW1iZXJ9IGFyZyAtIFRoZSBidWZmZXIgb3IgbGVuZ3RoIG9mIHRoZSBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVQb2ludGVycyAtIFRoZSBhcnJheSBwb2ludGVyIG1hcCwgb3IgaW4gdGhlIGNhc2Ugb2YgYSB2ZXJ0ZXggcGFja2FnZSBhcmcsIHRoZSBvcHRpb25zLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSByZW5kZXJpbmcgb3B0aW9ucy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubW9kZSAtIFRoZSBkcmF3IG1vZGUgLyBwcmltaXRpdmUgdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuaW5kZXhPZmZzZXQgLSBUaGUgaW5kZXggb2Zmc2V0IGludG8gdGhlIGRyYXduIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuY291bnQgLSBUaGUgbnVtYmVyIG9mIGluZGljZXMgdG8gZHJhdy5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKGFyZywgYXR0cmlidXRlUG9pbnRlcnMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gV2ViR0xDb250ZXh0LmdldCgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gTU9ERVNbb3B0aW9ucy5tb2RlXSA/IG9wdGlvbnMubW9kZSA6IERFRkFVTFRfTU9ERTtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAob3B0aW9ucy5jb3VudCAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuY291bnQgOiBERUZBVUxUX0NPVU5UO1xuICAgICAgICAgICAgdGhpcy5pbmRleE9mZnNldCA9IChvcHRpb25zLmluZGV4T2Zmc2V0ICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5pbmRleE9mZnNldCA6IERFRkFVTFRfSU5ERVhfT0ZGU0VUO1xuICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIC8vIGZpcnN0LCBzZXQgdGhlIGF0dHJpYnV0ZSBwb2ludGVyc1xuICAgICAgICAgICAgaWYgKGFyZyAmJiBhcmcuYnVmZmVyICYmIGFyZy5wb2ludGVycykge1xuICAgICAgICAgICAgICAgIC8vIFZlcnRleFBhY2thZ2UgYXJndW1lbnQsIHVzZSBpdHMgYXR0cmlidXRlIHBvaW50ZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVycyA9IGFyZy5wb2ludGVycztcbiAgICAgICAgICAgICAgICAvLyBzaGlmdCBvcHRpb25zIGFyZyBzaW5jZSB0aGVyZSB3aWxsIGJlIG5vIGF0dHJpYiBwb2ludGVycyBhcmdcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXR0cmlidXRlUG9pbnRlcnM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlcnMgPSBnZXRBdHRyaWJ1dGVQb2ludGVycyhhdHRyaWJ1dGVQb2ludGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgdGhlIGJ5dGUgc3RyaWRlXG4gICAgICAgICAgICB0aGlzLmJ5dGVTdHJpZGUgPSBnZXRTdHJpZGUodGhpcy5wb2ludGVycyk7XG4gICAgICAgICAgICAvLyB0aGVuIGJ1ZmZlciB0aGUgZGF0YVxuICAgICAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBWZXJ0ZXhQYWNrYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcnRleFBhY2thZ2UgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJEYXRhKGFyZy5idWZmZXIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgV2ViR0xCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2ViR0xCdWZmZXIgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnQXJndW1lbnQgb2YgdHlwZSBgV2ViR0xCdWZmZXJgIG11c3QgYmUgY29tcGxpbWVudGVkIHdpdGggYSBjb3JyZXNwb25kaW5nIGBvcHRpb25zLmJ5dGVMZW5ndGhgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGFyZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gb3B0aW9ucy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFycmF5IG9yIEFycmF5QnVmZmVyIG9yIG51bWJlciBhcmd1bWVudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlckRhdGEoYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBsb2FkIHZlcnRleCBkYXRhIHRvIHRoZSBHUFUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fG51bWJlcn0gYXJnIC0gVGhlIGFycmF5IG9mIGRhdGEgdG8gYnVmZmVyLCBvciBzaXplIG9mIHRoZSBidWZmZXIgaW4gYnl0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlcnRleEJ1ZmZlcn0gVGhlIHZlcnRleCBidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBidWZmZXJEYXRhKGFyZykge1xuICAgICAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBhcmd1bWVudCBpcyB2YWxpZFxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgICAgIC8vIGNhc3QgYXJyYXkgaW50byBGbG9hdDMyQXJyYXlcbiAgICAgICAgICAgICAgICBhcmcgPSBuZXcgRmxvYXQzMkFycmF5KGFyZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICEoYXJnIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpICYmXG4gICAgICAgICAgICAgICAgIShBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKSkgJiZcbiAgICAgICAgICAgICAgICAhKE51bWJlci5pc0ludGVnZXIoYXJnKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgYXJyYXlidWZmZXIgb3IgYSBudW1lcmljIHNpemVcbiAgICAgICAgICAgICAgICB0aHJvdyAnQXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGBBcnJheWAsIGBBcnJheUJ1ZmZlcmAsIGBBcnJheUJ1ZmZlclZpZXdgLCBvciBgTnVtYmVyYCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgYnl0ZSBsZW5ndGhcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGFyZykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSBhcmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGFyZy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY3JlYXRlIGJ1ZmZlciBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHlcbiAgICAgICAgICAgIGlmICghdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYnVmZmVyIHRoZSBkYXRhXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGFyZywgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwbG9hZCBwYXJ0aWFsIHZlcnRleCBkYXRhIHRvIHRoZSBHUFUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBhcnJheSAtIFRoZSBhcnJheSBvZiBkYXRhIHRvIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVPZmZzZXQgLSBUaGUgYnl0ZSBvZmZzZXQgYXQgd2hpY2ggdG8gYnVmZmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZXJ0ZXhCdWZmZXJ9IFRoZSB2ZXJ0ZXggYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgYnVmZmVyU3ViRGF0YShhcnJheSwgYnl0ZU9mZnNldCA9IERFRkFVTFRfQllURV9PRkZTRVQpIHtcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhlIGJ1ZmZlciBleGlzdHNcbiAgICAgICAgICAgIGlmICghdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQnVmZmVyIGhhcyBub3QgeWV0IGJlZW4gYWxsb2NhdGVkLCBhbGxvY2F0ZSB3aXRoICcgK1xuICAgICAgICAgICAgICAgICAgICAnYGJ1ZmZlckRhdGFgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVuc3VyZSBhcmd1bWVudCBpcyB2YWxpZFxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgIShhcnJheSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSAmJlxuICAgICAgICAgICAgICAgICFBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYXkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0FyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBgQXJyYXlgLCBgQXJyYXlCdWZmZXJgLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ29yIGBBcnJheUJ1ZmZlclZpZXdgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgd2UgYXJlbid0IG92ZXJmbG93aW5nIHRoZSBidWZmZXJcbiAgICAgICAgICAgIGlmIChieXRlT2Zmc2V0ICsgYXJyYXkuYnl0ZUxlbmd0aCA+IHRoaXMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IGBBcmd1bWVudCBvZiBsZW5ndGggJHthcnJheS5ieXRlTGVuZ3RofSBieXRlcyB3aXRoIGAgK1xuICAgICAgICAgICAgICAgICAgICBgb2Zmc2V0IG9mICR7Ynl0ZU9mZnNldH0gYnl0ZXMgb3ZlcmZsb3dzIHRoZSBidWZmZXIgYCArXG4gICAgICAgICAgICAgICAgICAgIGBsZW5ndGggb2YgJHt0aGlzLmJ5dGVMZW5ndGh9IGJ5dGVzYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XG4gICAgICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYnl0ZU9mZnNldCwgYXJyYXkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQmluZHMgdGhlIHZlcnRleCBidWZmZXIgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZXJ0ZXhCdWZmZXJ9IC0gUmV0dXJucyB0aGUgdmVydGV4IGJ1ZmZlciBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgYmluZCgpIHtcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICAvLyBiaW5kIGJ1ZmZlclxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgIC8vIGZvciBlYWNoIGF0dHJpYnV0ZSBwb2ludGVyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnBvaW50ZXJzKS5mb3JFYWNoKGluZGV4ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IHRoaXMucG9pbnRlcnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIC8vIHNldCBhdHRyaWJ1dGUgcG9pbnRlclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLnNpemUsXG4gICAgICAgICAgICAgICAgICAgIGdsW3BvaW50ZXIudHlwZV0sXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ5dGVTdHJpZGUsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuYnl0ZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgLy8gZW5hYmxlIGF0dHJpYnV0ZSBpbmRleFxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5iaW5kcyB0aGUgdmVydGV4IGJ1ZmZlciBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlcnRleEJ1ZmZlcn0gVGhlIHZlcnRleCBidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICB1bmJpbmQoKSB7XG4gICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgLy8gdW5iaW5kIGJ1ZmZlclxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMucG9pbnRlcnMpLmZvckVhY2goaW5kZXggPT4ge1xuICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgYXR0cmlidXRlIGluZGV4XG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhlY3V0ZSB0aGUgZHJhdyBjb21tYW5kIGZvciB0aGUgYm91bmQgYnVmZmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gJ2RyYXdBcnJheXMnLiBPcHRpb25hbC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubW9kZSAtIFRoZSBkcmF3IG1vZGUgLyBwcmltaXRpdmUgdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuaW5kZXhPZmZzZXQgLSBUaGUgaW5kZXggb2Zmc2V0IGludG8gdGhlIGRyYXduIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuY291bnQgLSBUaGUgbnVtYmVyIG9mIGluZGljZXMgdG8gZHJhdy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VmVydGV4QnVmZmVyfSBUaGUgdmVydGV4IGJ1ZmZlciBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGRyYXcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgbGV0IG1vZGUgPSBnbFtvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlXTtcbiAgICAgICAgICAgIGxldCBpbmRleE9mZnNldCA9IChvcHRpb25zLmluZGV4T2Zmc2V0ICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5pbmRleE9mZnNldCA6IHRoaXMuaW5kZXhPZmZzZXQ7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAob3B0aW9ucy5jb3VudCAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuY291bnQgOiB0aGlzLmNvdW50O1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0F0dGVtcHRpbmcgdG8gZHJhdyB3aXRoIGEgY291bnQgb2YgMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkcmF3IGVsZW1lbnRzXG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzKG1vZGUsIGluZGV4T2Zmc2V0LCBjb3VudCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gVmVydGV4QnVmZmVyO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBDT01QT05FTlRfVFlQRSA9ICdGTE9BVCc7XG4gICAgbGV0IEJZVEVTX1BFUl9DT01QT05FTlQgPSA0O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBpbnZhbGlkIGF0dHJpYnV0ZSBhcmd1bWVudHMuIEEgdmFsaWQgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBsZW5ndGggPiAwIGtleSBieSBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gaW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyAtIFRoZSBtYXAgb2YgdmVydGV4IGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIHZhbGlkIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZU1hcChhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGxldCBnb29kQXR0cmlidXRlcyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBwYXJzZUZsb2F0KGtleSk7XG4gICAgICAgICAgICAvLyBjaGVjayB0aGF0IGtleSBpcyBhbiB2YWxpZCBpbnRlZ2VyXG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaW5kZXgpIHx8IGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IGBBdHRyaWJ1dGUgaW5kZXggXFxgJHtrZXl9XFxgIGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbGlkIGludGVnZXJgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZlcnRpY2VzID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgLy8gZW5zdXJlIGF0dHJpYnV0ZSBpcyB2YWxpZFxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmVydGljZXMpICYmIHZlcnRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgYXR0cmlidXRlIGRhdGEgYW5kIGluZGV4XG4gICAgICAgICAgICAgICAgZ29vZEF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdmVydGljZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYEVycm9yIHBhcnNpbmcgYXR0cmlidXRlIG9mIGluZGV4IFxcYCR7aW5kZXh9XFxgYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHNvcnQgYXR0cmlidXRlcyBhc2NlbmRpbmcgYnkgaW5kZXhcbiAgICAgICAgZ29vZEF0dHJpYnV0ZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdvb2RBdHRyaWJ1dGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb21wb25lbnQncyBieXRlIHNpemUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wb25lbnQgLSBUaGUgY29tcG9uZW50IHRvIG1lYXN1cmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBieXRlIHNpemUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnRTaXplKGNvbXBvbmVudCkge1xuICAgICAgICAvLyBjaGVjayBpZiBhcnJheVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb21wb25lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB2ZWN0b3JcbiAgICAgICAgaWYgKGNvbXBvbmVudC54ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIDEgY29tcG9uZW50IHZlY3RvclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC55ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyAyIGNvbXBvbmVudCB2ZWN0b3JcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LnogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAzIGNvbXBvbmVudCB2ZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC53ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQgY29tcG9uZW50IHZlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2luZ2xlIGNvbXBvbmVudFxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB0eXBlLCBzaXplLCBhbmQgb2Zmc2V0IGZvciBlYWNoIGF0dHJpYnV0ZSBpbiB0aGUgYXR0cmlidXRlIGFycmF5IGFsb25nIHdpdGggdGhlIGxlbmd0aCBhbmQgc3RyaWRlIG9mIHRoZSBwYWNrYWdlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1ZlcnRleFBhY2thZ2V9IHZlcnRleFBhY2thZ2UgLSBUaGUgVmVydGV4UGFja2FnZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXR0cmlidXRlcyBUaGUgYXJyYXkgb2YgdmVydGV4IGF0dHJpYnV0ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0UG9pbnRlcnNBbmRTdHJpZGUodmVydGV4UGFja2FnZSwgYXR0cmlidXRlcykge1xuICAgICAgICBsZXQgc2hvcnRlc3RBcnJheSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAvLyBjbGVhciBwb2ludGVyc1xuICAgICAgICB2ZXJ0ZXhQYWNrYWdlLnBvaW50ZXJzID0ge307XG4gICAgICAgIC8vIGZvciBlYWNoIGF0dHJpYnV0ZVxuICAgICAgICBhdHRyaWJ1dGVzLmZvckVhY2godmVydGljZXMgPT4ge1xuICAgICAgICAgICAgLy8gc2V0IHNpemUgdG8gbnVtYmVyIG9mIGNvbXBvbmVudHMgaW4gdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgbGV0IHNpemUgPSBnZXRDb21wb25lbnRTaXplKHZlcnRpY2VzLmRhdGFbMF0pO1xuICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIHRoZSBwYWNrYWdlIHdpbGwgYmUgdGhlIHNob3J0ZXN0IGF0dHJpYnV0ZSBhcnJheSBsZW5ndGhcbiAgICAgICAgICAgIHNob3J0ZXN0QXJyYXkgPSBNYXRoLm1pbihzaG9ydGVzdEFycmF5LCB2ZXJ0aWNlcy5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAvLyBzdG9yZSBwb2ludGVyIHVuZGVyIGluZGV4XG4gICAgICAgICAgICB2ZXJ0ZXhQYWNrYWdlLnBvaW50ZXJzW3ZlcnRpY2VzLmluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBDT01QT05FTlRfVFlQRSxcbiAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IG9mZnNldCAqIEJZVEVTX1BFUl9DT01QT05FTlRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBhY2N1bXVsYXRlIGF0dHJpYnV0ZSBvZmZzZXRcbiAgICAgICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gc2V0IHN0cmlkZSB0byB0b3RhbCBvZmZzZXRcbiAgICAgICAgdmVydGV4UGFja2FnZS5zdHJpZGUgPSBvZmZzZXQ7IC8vIG5vdCBpbiBieXRlc1xuICAgICAgICAvLyBzZXQgbGVuZ3RoIG9mIHBhY2thZ2UgdG8gdGhlIHNob3J0ZXN0IGF0dHJpYnV0ZSBhcnJheSBsZW5ndGhcbiAgICAgICAgdmVydGV4UGFja2FnZS5sZW5ndGggPSBzaG9ydGVzdEFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGwgdGhlIGFycmF5YnVmZmVyIHdpdGggYSBzaW5nbGUgY29tcG9uZW50IGF0dHJpYnV0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGJ1ZmZlciAtIFRoZSBhcnJheWJ1ZmZlciB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZlcnRpY2VzIC0gVGhlIHZlcnRleCBhdHRyaWJ1dGUgYXJyYXkgdG8gY29weSBmcm9tLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSBUaGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgdG8gY29weSBmcm9tLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHRvIHRoZSBhdHRyaWJ1dGUsIG5vdCBpbiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIC0gVGhlIHN0cmlkZSBvZiB0aGUgYnVmZmVyLCBub3QgaW4gYnl0ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0MUNvbXBvbmVudEF0dHIoYnVmZmVyLCB2ZXJ0aWNlcywgbGVuZ3RoLCBvZmZzZXQsIHN0cmlkZSkge1xuICAgICAgICBsZXQgdmVydGV4LCBpLCBqO1xuICAgICAgICBmb3IgKGk9MDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IGluIHRoZSBidWZmZXIgdG8gdGhlIHBhcnRpY3VsYXIgdmVydGV4XG4gICAgICAgICAgICBqID0gb2Zmc2V0ICsgKHN0cmlkZSAqIGkpO1xuICAgICAgICAgICAgaWYgKHZlcnRleC54ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJbal0gPSB2ZXJ0ZXgueDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmVydGV4WzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJbal0gPSB2ZXJ0ZXhbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqXSA9IHZlcnRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGwgdGhlIGFycmF5YnVmZmVyIHdpdGggYSBkb3VibGUgY29tcG9uZW50IGF0dHJpYnV0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGJ1ZmZlciAtIFRoZSBhcnJheWJ1ZmZlciB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZlcnRpY2VzIC0gVGhlIHZlcnRleCBhdHRyaWJ1dGUgYXJyYXkgdG8gY29weSBmcm9tLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSBUaGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgdG8gY29weSBmcm9tLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHRvIHRoZSBhdHRyaWJ1dGUsIG5vdCBpbiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIC0gVGhlIHN0cmlkZSBvZiB0aGUgYnVmZmVyLCBub3QgaW4gYnl0ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0MkNvbXBvbmVudEF0dHIoYnVmZmVyLCB2ZXJ0aWNlcywgbGVuZ3RoLCBvZmZzZXQsIHN0cmlkZSkge1xuICAgICAgICBsZXQgdmVydGV4LCBpLCBqO1xuICAgICAgICBmb3IgKGk9MDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IGluIHRoZSBidWZmZXIgdG8gdGhlIHBhcnRpY3VsYXIgdmVydGV4XG4gICAgICAgICAgICBqID0gb2Zmc2V0ICsgKHN0cmlkZSAqIGkpO1xuICAgICAgICAgICAgYnVmZmVyW2pdID0gKHZlcnRleC54ICE9PSB1bmRlZmluZWQpID8gdmVydGV4LnggOiB2ZXJ0ZXhbMF07XG4gICAgICAgICAgICBidWZmZXJbaisxXSA9ICh2ZXJ0ZXgueSAhPT0gdW5kZWZpbmVkKSA/IHZlcnRleC55IDogdmVydGV4WzFdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbCB0aGUgYXJyYXlidWZmZXIgd2l0aCBhIHRyaXBsZSBjb21wb25lbnQgYXR0cmlidXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYnVmZmVyIC0gVGhlIGFycmF5YnVmZmVyIHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmVydGljZXMgLSBUaGUgdmVydGV4IGF0dHJpYnV0ZSBhcnJheSB0byBjb3B5IGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIFRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlciB0byBjb3B5IGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgdG8gdGhlIGF0dHJpYnV0ZSwgbm90IGluIGJ5dGVzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgLSBUaGUgc3RyaWRlIG9mIHRoZSBidWZmZXIsIG5vdCBpbiBieXRlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQzQ29tcG9uZW50QXR0cihidWZmZXIsIHZlcnRpY2VzLCBsZW5ndGgsIG9mZnNldCwgc3RyaWRlKSB7XG4gICAgICAgIGxldCB2ZXJ0ZXgsIGksIGo7XG4gICAgICAgIGZvciAoaT0wOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgaW5kZXggaW4gdGhlIGJ1ZmZlciB0byB0aGUgcGFydGljdWxhciB2ZXJ0ZXhcbiAgICAgICAgICAgIGogPSBvZmZzZXQgKyAoc3RyaWRlICogaSk7XG4gICAgICAgICAgICBidWZmZXJbal0gPSAodmVydGV4LnggIT09IHVuZGVmaW5lZCkgPyB2ZXJ0ZXgueCA6IHZlcnRleFswXTtcbiAgICAgICAgICAgIGJ1ZmZlcltqKzFdID0gKHZlcnRleC55ICE9PSB1bmRlZmluZWQpID8gdmVydGV4LnkgOiB2ZXJ0ZXhbMV07XG4gICAgICAgICAgICBidWZmZXJbaisyXSA9ICh2ZXJ0ZXgueiAhPT0gdW5kZWZpbmVkKSA/IHZlcnRleC56IDogdmVydGV4WzJdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbCB0aGUgYXJyYXlidWZmZXIgd2l0aCBhIHF1YWRydXBsZSBjb21wb25lbnQgYXR0cmlidXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYnVmZmVyIC0gVGhlIGFycmF5YnVmZmVyIHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmVydGljZXMgLSBUaGUgdmVydGV4IGF0dHJpYnV0ZSBhcnJheSB0byBjb3B5IGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIFRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlciB0byBjb3B5IGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgdG8gdGhlIGF0dHJpYnV0ZSwgbm90IGluIGJ5dGVzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgLSBUaGUgc3RyaWRlIG9mIHRoZSBidWZmZXIsIG5vdCBpbiBieXRlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQ0Q29tcG9uZW50QXR0cihidWZmZXIsIHZlcnRpY2VzLCBsZW5ndGgsIG9mZnNldCwgc3RyaWRlKSB7XG4gICAgICAgIGxldCB2ZXJ0ZXgsIGksIGo7XG4gICAgICAgIGZvciAoaT0wOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgaW5kZXggaW4gdGhlIGJ1ZmZlciB0byB0aGUgcGFydGljdWxhciB2ZXJ0ZXhcbiAgICAgICAgICAgIGogPSBvZmZzZXQgKyAoc3RyaWRlICogaSk7XG4gICAgICAgICAgICBidWZmZXJbal0gPSAodmVydGV4LnggIT09IHVuZGVmaW5lZCkgPyB2ZXJ0ZXgueCA6IHZlcnRleFswXTtcbiAgICAgICAgICAgIGJ1ZmZlcltqKzFdID0gKHZlcnRleC55ICE9PSB1bmRlZmluZWQpID8gdmVydGV4LnkgOiB2ZXJ0ZXhbMV07XG4gICAgICAgICAgICBidWZmZXJbaisyXSA9ICh2ZXJ0ZXgueiAhPT0gdW5kZWZpbmVkKSA/IHZlcnRleC56IDogdmVydGV4WzJdO1xuICAgICAgICAgICAgYnVmZmVyW2orM10gPSAodmVydGV4LncgIT09IHVuZGVmaW5lZCkgPyB2ZXJ0ZXgudyA6IHZlcnRleFszXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBWZXJ0ZXhQYWNrYWdlXG4gICAgICogQGNsYXNzZGVzYyBBIHZlcnRleCBwYWNrYWdlIHRvIGFzc2lzdCBpbiBpbnRlcmxlYXZpbmcgdmVydGV4IGRhdGEgYW5kIGJ1aWxkaW5nIHRoZSBhc3NvY2lhdGVkIHZlcnRleCBhdHRyaWJ1dGUgcG9pbnRlcnMuXG4gICAgICovXG4gICAgY2xhc3MgVmVydGV4UGFja2FnZSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3RhbnRpYXRlcyBhIFZlcnRleFBhY2thZ2Ugb2JqZWN0LlxuICAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBUaGUgYXR0cmlidXRlcyB0byBpbnRlcmxlYXZlIGtleWVkIGJ5IGluZGV4LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVycyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgZGF0YSB0byBiZSBpbnRlcmxlYXZlZCBpbnNpZGUgdGhlIHBhY2thZ2UuIFRoaXMgY2xlYXJzIGFueSBwcmV2aW91c2x5IGV4aXN0aW5nIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gVGhlIGF0dHJpYnV0ZXMgdG8gaW50ZXJsZWF2ZWQsIGtleWVkIGJ5IGluZGV4LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZXJ0ZXhQYWNrYWdlfSBUaGUgdmVydGV4IHBhY2thZ2Ugb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGJhZCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBhdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVNYXAoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAvLyBzZXQgYXR0cmlidXRlIHBvaW50ZXJzIGFuZCBzdHJpZGVcbiAgICAgICAgICAgIHNldFBvaW50ZXJzQW5kU3RyaWRlKHRoaXMsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgLy8gc2V0IHNpemUgb2YgZGF0YSB2ZWN0b3JcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBzdHJpZGUgPSB0aGlzLnN0cmlkZTsgLy8gbm90IGluIGJ5dGVzXG4gICAgICAgICAgICBsZXQgcG9pbnRlcnMgPSB0aGlzLnBvaW50ZXJzO1xuICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IHRoaXMuYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGggKiBzdHJpZGUpO1xuICAgICAgICAgICAgLy8gZm9yIGVhY2ggdmVydGV4IGF0dHJpYnV0ZSBhcnJheVxuICAgICAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKHZlcnRpY2VzID0+IHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHBvaW50ZXJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IHBvaW50ZXJzW3ZlcnRpY2VzLmluZGV4XTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHBvaW50ZXJzIG9mZnNldFxuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBwb2ludGVyLmJ5dGVPZmZzZXQgLyBCWVRFU19QRVJfQ09NUE9ORU5UO1xuICAgICAgICAgICAgICAgIC8vIGNvcHkgdmVydGV4IGRhdGEgaW50byBhcnJheWJ1ZmZlclxuICAgICAgICAgICAgICAgIHN3aXRjaCAocG9pbnRlci5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldDJDb21wb25lbnRBdHRyKGJ1ZmZlciwgdmVydGljZXMuZGF0YSwgbGVuZ3RoLCBvZmZzZXQsIHN0cmlkZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0M0NvbXBvbmVudEF0dHIoYnVmZmVyLCB2ZXJ0aWNlcy5kYXRhLCBsZW5ndGgsIG9mZnNldCwgc3RyaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQ0Q29tcG9uZW50QXR0cihidWZmZXIsIHZlcnRpY2VzLmRhdGEsIGxlbmd0aCwgb2Zmc2V0LCBzdHJpZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQxQ29tcG9uZW50QXR0cihidWZmZXIsIHZlcnRpY2VzLmRhdGEsIGxlbmd0aCwgb2Zmc2V0LCBzdHJpZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gVmVydGV4UGFja2FnZTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBXZWJHTENvbnRleHQgPSByZXF1aXJlKCcuL1dlYkdMQ29udGV4dCcpO1xuXG4gICAgLyoqXG4gICAgICogQmluZCB0aGUgdmlld3BvcnQgdG8gdGhlIHJlbmRlcmluZyBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtWaWV3cG9ydH0gdmlld3BvcnQgLSBUaGUgdmlld3BvcnQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvdmVycmlkZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvdmVycmlkZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSBob3Jpem9udGFsIG9mZnNldCBvdmVycmlkZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSAtIFRoZSB2ZXJ0aWNhbCBvZmZzZXQgb3ZlcnJpZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KHZpZXdwb3J0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBnbCA9IHZpZXdwb3J0LmdsO1xuICAgICAgICB4ID0gKHggIT09IHVuZGVmaW5lZCkgPyB4IDogdmlld3BvcnQueDtcbiAgICAgICAgeSA9ICh5ICE9PSB1bmRlZmluZWQpID8geSA6IHZpZXdwb3J0Lnk7XG4gICAgICAgIHdpZHRoID0gKHdpZHRoICE9PSB1bmRlZmluZWQpID8gd2lkdGggOiB2aWV3cG9ydC53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gKGhlaWdodCAhPT0gdW5kZWZpbmVkKSA/IGhlaWdodCA6IHZpZXdwb3J0LmhlaWdodDtcbiAgICAgICAgZ2wudmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFZpZXdwb3J0XG4gICAgICogQGNsYXNzZGVzYyBBIHZpZXdwb3J0IGNsYXNzIGZvciBtYW5hZ2luZyBXZWJHTCB2aWV3cG9ydHMuXG4gICAgICovXG4gICAgY2xhc3MgVmlld3BvcnQge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYSBWaWV3cG9ydCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIC0gVGhlIHZpZXdwb3J0IHNwZWNpZmljYXRpb24gb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3BlYy53aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgdmlld3BvcnQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcGVjLmhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3Ioc3BlYyA9IHt9KSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gV2ViR0xDb250ZXh0LmdldCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAgICAgLy8gc2V0IHNpemVcbiAgICAgICAgICAgIHRoaXMucmVzaXplKFxuICAgICAgICAgICAgICAgIHNwZWMud2lkdGggfHwgdGhpcy5nbC5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgc3BlYy5oZWlnaHQgfHwgdGhpcy5nbC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSB2aWV3cG9ydHMgd2lkdGggYW5kIGhlaWdodC4gVGhpcyByZXNpemVzIHRoZSB1bmRlcmx5aW5nIGNhbnZhcyBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgdmlld3BvcnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZpZXdwb3J0fSBUaGUgdmlld3BvcnQgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemUod2lkdGggPSAwLCBoZWlnaHQgPSAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAnbnVtYmVyJyB8fCB3aWR0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIFxcYHdpZHRoXFxgIG9mIFxcYCR7d2lkdGh9XFxgIGlzIGludmFsaWRgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICdudW1iZXInIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIFxcYGhlaWdodFxcYCBvZiBcXGAke2hlaWdodH1cXGAgaXMgaW52YWxpZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZ2wuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmdsLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB2aWV3cG9ydCBkaW1lbnNpb25zIGFuZCBwb3NpdGlvbi4gVGhlIHVuZGVybHlpbmcgY2FudmFzIGVsZW1lbnQgaXMgbm90IGFmZmVjdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb3ZlcnJpZGUuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG92ZXJyaWRlLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSBob3Jpem9udGFsIG9mZnNldCBvdmVycmlkZS5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdmVydGljYWwgb2Zmc2V0IG92ZXJyaWRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtWaWV3cG9ydH0gLSBUaGUgdmlld3BvcnQgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBwdXNoKHggPSAwLCB5ID0gMCwgd2lkdGggPSB0aGlzLndpZHRoLCBoZWlnaHQgPSB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRocm93IGBQcm92aWRlZCBcXGB4XFxgIG9mIFxcYCR7eH1cXGAgaXMgaW52YWxpZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHkgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIFxcYHlcXGAgb2YgXFxgJHt5fVxcYCBpcyBpbnZhbGlkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICdudW1iZXInIHx8IHdpZHRoIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgUHJvdmlkZWQgXFxgd2lkdGhcXGAgb2YgXFxgJHt3aWR0aH1cXGAgaXMgaW52YWxpZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ251bWJlcicgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgUHJvdmlkZWQgXFxgaGVpZ2h0XFxgIG9mIFxcYCR7aGVpZ2h0fVxcYCBpcyBpbnZhbGlkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHB1c2ggb250byBzdGFja1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHNldCB2aWV3cG9ydFxuICAgICAgICAgICAgc2V0KHRoaXMsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUG9wcyBjdXJyZW50IHRoZSB2aWV3cG9ydCBvYmplY3QgYW5kIHNldHMgdGhlIHZpZXdwb3J0IGJlbmVhdGggaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZpZXdwb3J0fSBUaGUgdmlld3BvcnQgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBwb3AoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVmlld3BvcnQgc3RhY2sgaXMgZW1wdHknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHNldCh0aGlzLCB0b3AueCwgdG9wLnksIHRvcC53aWR0aCwgdG9wLmhlaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBWaWV3cG9ydDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBFWFRFTlNJT05TID0gW1xuICAgICAgICAvLyByYXRpZmllZFxuICAgICAgICAnT0VTX3RleHR1cmVfZmxvYXQnLFxuICAgICAgICAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcsXG4gICAgICAgICdXRUJHTF9sb3NlX2NvbnRleHQnLFxuICAgICAgICAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyxcbiAgICAgICAgJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JyxcbiAgICAgICAgJ1dFQkdMX2RlYnVnX3JlbmRlcmVyX2luZm8nLFxuICAgICAgICAnV0VCR0xfZGVidWdfc2hhZGVycycsXG4gICAgICAgICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycsXG4gICAgICAgICdXRUJHTF9kZXB0aF90ZXh0dXJlJyxcbiAgICAgICAgJ09FU19lbGVtZW50X2luZGV4X3VpbnQnLFxuICAgICAgICAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyxcbiAgICAgICAgJ0VYVF9mcmFnX2RlcHRoJyxcbiAgICAgICAgJ1dFQkdMX2RyYXdfYnVmZmVycycsXG4gICAgICAgICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyxcbiAgICAgICAgJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicsXG4gICAgICAgICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicsXG4gICAgICAgICdFWFRfYmxlbmRfbWlubWF4JyxcbiAgICAgICAgJ0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QnLFxuICAgICAgICAvLyBjb21tdW5pdHlcbiAgICAgICAgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hdGMnLFxuICAgICAgICAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyxcbiAgICAgICAgJ0VYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCcsXG4gICAgICAgICdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnLFxuICAgICAgICAnRVhUX3NSR0InLFxuICAgICAgICAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnLFxuICAgICAgICAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5JyxcbiAgICAgICAgJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnXG4gICAgXTtcblxuICAgIGxldCBfYm91bmRDb250ZXh0ID0gbnVsbDtcbiAgICBsZXQgX2NvbnRleHRzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIHJmYzQxMjIgdmVyc2lvbiA0IGNvbXBsaWFudCBVVUlELlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IC0gVGhlIFVVSUQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFVVSUQoKSB7XG4gICAgICAgIGxldCByZXBsYWNlID0gZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgbGV0IHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwO1xuICAgICAgICAgICAgbGV0IHYgPSAoYyA9PT0gJ3gnKSA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIHJlcGxhY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBIVE1MQ2FudmFzRWxlbWVudCBlbGVtZW50LiBJZiB0aGVyZSBpcyBubyBpZCwgaXQgZ2VuZXJhdGVzIG9uZSBhbmQgYXBwZW5kcyBpdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gVGhlIENhbnZhcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBDYW52YXMgaWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldElkKGNhbnZhcykge1xuICAgICAgICBpZiAoIWNhbnZhcy5pZCkge1xuICAgICAgICAgICAgY2FudmFzLmlkID0gZ2V0VVVJRCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW52YXMuaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENhbnZhcyBlbGVtZW50IG9iamVjdCBmcm9tIGVpdGhlciBhbiBleGlzdGluZyBvYmplY3QsIG9yIGlkZW50aWZpY2F0aW9uIHN0cmluZy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxTdHJpbmd9IGFyZyAtIFRoZSBDYW52YXMgb2JqZWN0IG9yIENhbnZhcyBpZCBvciBzZWxlY3RvciBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIENhbnZhcyBlbGVtZW50IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDYW52YXMoYXJnKSB7XG4gICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGFyZykgfHxcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gcmV0cmlldmUgYSB3cmFwcGVkIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIENhbnZhcyBlbGVtZW50IG9iamVjdCB0byBjcmVhdGUgdGhlIGNvbnRleHQgdW5kZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZXh0IHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dFdyYXBwZXIoYXJnKSB7XG4gICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKF9ib3VuZENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gbGFzdCBib3VuZCBjb250ZXh0XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ib3VuZENvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY2FudmFzID0gZ2V0Q2FudmFzKGFyZyk7XG4gICAgICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0c1tnZXRJZChjYW52YXMpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBubyBib3VuZCBjb250ZXh0IG9yIGFyZ3VtZW50XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGxvYWQgYWxsIGtub3duIGV4dGVuc2lvbnMgZm9yIGEgcHJvdmlkZWQgV2ViR0xSZW5kZXJpbmdDb250ZXh0LiBTdG9yZXMgdGhlIHJlc3VsdHMgaW4gdGhlIGNvbnRleHQgd3JhcHBlciBmb3IgbGF0ZXIgcXVlcmllcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRXcmFwcGVyIC0gVGhlIGNvbnRleHQgd3JhcHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkRXh0ZW5zaW9ucyhjb250ZXh0V3JhcHBlcikge1xuICAgICAgICBsZXQgZ2wgPSBjb250ZXh0V3JhcHBlci5nbDtcbiAgICAgICAgRVhURU5TSU9OUy5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgIGNvbnRleHRXcmFwcGVyLmV4dGVuc2lvbnNbaWRdID0gZ2wuZ2V0RXh0ZW5zaW9uKGlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gY3JlYXRlIGEgV2ViR0xSZW5kZXJpbmdDb250ZXh0IGFuZCBsb2FkIGFsbCBleHRlbnNpb25zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSAtIFRoZSBDYW52YXMgZWxlbWVudCBvYmplY3QgdG8gY3JlYXRlIHRoZSBjb250ZXh0IHVuZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fX0gb3B0aW9ucyAtIFBhcmFtZXRlcnMgdG8gdGhlIHdlYmdsIGNvbnRleHQsIG9ubHkgdXNlZCBkdXJpbmcgaW5zdGFudGlhdGlvbi4gT3B0aW9uYWwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZXh0IHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29udGV4dFdyYXBwZXIoY2FudmFzLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG9wdGlvbnMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBvcHRpb25zKTtcbiAgICAgICAgLy8gd3JhcCBjb250ZXh0XG4gICAgICAgIGxldCBjb250ZXh0V3JhcHBlciA9IHtcbiAgICAgICAgICAgIGlkOiBnZXRJZChjYW52YXMpLFxuICAgICAgICAgICAgZ2w6IGdsLFxuICAgICAgICAgICAgZXh0ZW5zaW9uczoge31cbiAgICAgICAgfTtcbiAgICAgICAgLy8gbG9hZCBXZWJHTCBleHRlbnNpb25zXG4gICAgICAgIGxvYWRFeHRlbnNpb25zKGNvbnRleHRXcmFwcGVyKTtcbiAgICAgICAgLy8gYWRkIGNvbnRleHQgd3JhcHBlciB0byBtYXBcbiAgICAgICAgX2NvbnRleHRzW2dldElkKGNhbnZhcyldID0gY29udGV4dFdyYXBwZXI7XG4gICAgICAgIC8vIGJpbmQgdGhlIGNvbnRleHRcbiAgICAgICAgX2JvdW5kQ29udGV4dCA9IGNvbnRleHRXcmFwcGVyO1xuICAgICAgICByZXR1cm4gY29udGV4dFdyYXBwZXI7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyBhbiBleGlzdGluZyBXZWJHTCBjb250ZXh0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnQgYW5kIGJpbmRzIGl0LiBXaGlsZSBib3VuZCwgdGhlIGFjdGl2ZSBjb250ZXh0IHdpbGwgYmUgdXNlZCBpbXBsaWNpdGx5IGJ5IGFueSBpbnN0YW50aWF0ZWQgYGVzcGVyYCBjb25zdHJ1Y3RzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fFN0cmluZ30gYXJnIC0gVGhlIENhbnZhcyBvYmplY3Qgb3IgQ2FudmFzIGlkZW50aWZpY2F0aW9uIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7V2ViR0xDb250ZXh0fSBUaGUgbmFtZXNwYWNlLCB1c2VkIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgbGV0IHdyYXBwZXIgPSBnZXRDb250ZXh0V3JhcHBlcihhcmcpO1xuICAgICAgICAgICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICBfYm91bmRDb250ZXh0ID0gd3JhcHBlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGBObyBjb250ZXh0IGV4aXN0cyBmb3IgcHJvdmlkZWQgYXJndW1lbnQgJyR7YXJnfSdgO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgYW4gZXhpc3RpbmcgV2ViR0wgY29udGV4dCBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50LiBJZiBubyBjb250ZXh0IGV4aXN0cywgb25lIGlzIGNyZWF0ZWQuXG4gICAgICAgICAqIER1cmluZyBjcmVhdGlvbiBhdHRlbXB0cyB0byBsb2FkIGFsbCBleHRlbnNpb25zIGZvdW5kIGF0OiBodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9leHRlbnNpb25zLy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxTdHJpbmd9IGFyZyAtIFRoZSBDYW52YXMgb2JqZWN0IG9yIENhbnZhcyBpZGVudGlmaWNhdGlvbiBzdHJpbmcuIE9wdGlvbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFBhcmFtZXRlcnMgdG8gdGhlIHdlYmdsIGNvbnRleHQsIG9ubHkgdXNlZCBkdXJpbmcgaW5zdGFudGlhdGlvbi4gT3B0aW9uYWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGFyZywgb3B0aW9ucykge1xuICAgICAgICAgICAgbGV0IHdyYXBwZXIgPSBnZXRDb250ZXh0V3JhcHBlcihhcmcpO1xuICAgICAgICAgICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgbmF0aXZlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIuZ2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZXQgY2FudmFzIGVsZW1lbnRcbiAgICAgICAgICAgIGxldCBjYW52YXMgPSBnZXRDYW52YXMoYXJnKTtcbiAgICAgICAgICAgIC8vIHRyeSB0byBmaW5kIG9yIGNyZWF0ZSBjb250ZXh0XG4gICAgICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgICAgICAgIHRocm93IGBObyBjb250ZXh0IGlzIGN1cnJlbnRseSBib3VuZCBvciBjb3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgYXJndW1lbnQgb2YgdHlwZSAke3R5cGVvZiBhcmd9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBjb250ZXh0XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29udGV4dFdyYXBwZXIoY2FudmFzLCBvcHRpb25zKS5nbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhbiBleGlzdGluZyBXZWJHTCBjb250ZXh0IG9iamVjdCBmb3IgdGhlIHByb3ZpZGVkIG9yIGN1cnJlbnRseSBib3VuZCBjb250ZXh0IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxTdHJpbmd9IGFyZyAtIFRoZSBDYW52YXMgb2JqZWN0IG9yIENhbnZhcyBpZGVudGlmaWNhdGlvbiBzdHJpbmcuIE9wdGlvbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH19IG9wdGlvbnMgLSBQYXJhbWV0ZXJzIHRvIHRoZSB3ZWJnbCBjb250ZXh0LCBvbmx5IHVzZWQgZHVyaW5nIGluc3RhbnRpYXRpb24uIE9wdGlvbmFsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGxldCB3cmFwcGVyID0gZ2V0Q29udGV4dFdyYXBwZXIoYXJnKTtcbiAgICAgICAgICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgZGVsZXRlIF9jb250ZXh0c1t3cmFwcGVyLmlkXTtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgaWYgY3VycmVudGx5IGJvdW5kXG4gICAgICAgICAgICAgICAgaWYgKHdyYXBwZXIgPT09IF9ib3VuZENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2JvdW5kQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgTm8gY29udGV4dCBpcyBjdXJyZW50bHkgYm91bmQgb3IgY291bGQgYmUgYXNzb2NpYXRlZCB3aXRoIHByb3ZpZGVkIGFyZ3VtZW50IG9mIHR5cGUgJHt0eXBlb2YgYXJnfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHN1cHBvcnRlZCBleHRlbnNpb25zIGZvciB0aGUgcHJvdmlkZWQgb3IgY3VycmVudGx5IGJvdW5kIGNvbnRleHQgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fFN0cmluZ30gYXJnIC0gVGhlIENhbnZhcyBvYmplY3Qgb3IgQ2FudmFzIGlkZW50aWZpY2F0aW9uIHN0cmluZy4gT3B0aW9uYWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBbGwgc3VwcG9ydGVkIGV4dGVuc2lvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBzdXBwb3J0ZWRFeHRlbnNpb25zOiBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGxldCB3cmFwcGVyID0gZ2V0Q29udGV4dFdyYXBwZXIoYXJnKTtcbiAgICAgICAgICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4dGVuc2lvbnMgPSB3cmFwcGVyLmV4dGVuc2lvbnM7XG4gICAgICAgICAgICAgICAgbGV0IHN1cHBvcnRlZCA9IFtdO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25zW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgYE5vIGNvbnRleHQgaXMgY3VycmVudGx5IGJvdW5kIG9yIGNvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aCBwcm92aWRlZCBhcmd1bWVudCBvZiB0eXBlICR7dHlwZW9mIGFyZ31gO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB1bnN1cHBvcnRlZCBleHRlbnNpb25zIGZvciB0aGUgcHJvdmlkZWQgb3IgY3VycmVudGx5IGJvdW5kIGNvbnRleHQgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fFN0cmluZ30gYXJnIC0gVGhlIENhbnZhcyBvYmplY3Qgb3IgQ2FudmFzIGlkZW50aWZpY2F0aW9uIHN0cmluZy4gT3B0aW9uYWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBbGwgdW5zdXBwb3J0ZWQgZXh0ZW5zaW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHVuc3VwcG9ydGVkRXh0ZW5zaW9uczogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICBsZXQgd3JhcHBlciA9IGdldENvbnRleHRXcmFwcGVyKGFyZyk7XG4gICAgICAgICAgICBpZiAod3JhcHBlcikge1xuICAgICAgICAgICAgICAgIGxldCBleHRlbnNpb25zID0gd3JhcHBlci5leHRlbnNpb25zO1xuICAgICAgICAgICAgICAgIGxldCB1bnN1cHBvcnRlZCA9IFtdO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXh0ZW5zaW9uc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5zdXBwb3J0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBgTm8gY29udGV4dCBpcyBjdXJyZW50bHkgYm91bmQgb3IgY291bGQgYmUgYXNzb2NpYXRlZCB3aXRoIHByb3ZpZGVkIGFyZ3VtZW50IG9mIHR5cGUgJHt0eXBlb2YgYXJnfWA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiBhbiBleHRlbnNpb24gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGxvYWRlZCBmb3IgdGhlIHByb3ZpZGVkIG9yIGN1cnJlbnRseSBib3VuZCBjb250ZXh0IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxTdHJpbmd9IGFyZyAtIFRoZSBDYW52YXMgb2JqZWN0IG9yIENhbnZhcyBpZGVudGlmaWNhdGlvbiBzdHJpbmcuIE9wdGlvbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXh0ZW5zaW9uIC0gVGhlIGV4dGVuc2lvbiBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgZXh0ZW5zaW9uIGhhcyBiZWVuIGxvYWRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICAgICAqL1xuICAgICAgICBjaGVja0V4dGVuc2lvbjogZnVuY3Rpb24oYXJnLCBleHRlbnNpb24pIHtcbiAgICAgICAgICAgIGlmICghZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hpZnQgcGFyYW1ldGVycyBpZiBubyBjYW52YXMgYXJnIGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gYXJnO1xuICAgICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB3cmFwcGVyID0gZ2V0Q29udGV4dFdyYXBwZXIoYXJnKTtcbiAgICAgICAgICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4dGVuc2lvbnMgPSB3cmFwcGVyLmV4dGVuc2lvbnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnNbZXh0ZW5zaW9uXSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGBObyBjb250ZXh0IGlzIGN1cnJlbnRseSBib3VuZCBvciBjb3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgYXJndW1lbnQgb2YgdHlwZSAke3R5cGVvZiBhcmd9YDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBleHRlbnNpb24gaWYgaXQgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGxvYWRlZCBmb3IgdGhlIHByb3ZpZGVkIG9yIGN1cnJlbnRseSBib3VuZCBjb250ZXh0IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxTdHJpbmd9IGFyZyAtIFRoZSBDYW52YXMgb2JqZWN0IG9yIENhbnZhcyBpZGVudGlmaWNhdGlvbiBzdHJpbmcuIE9wdGlvbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXh0ZW5zaW9uIC0gVGhlIGV4dGVuc2lvbiBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgZXh0ZW5zaW9uIGhhcyBiZWVuIGxvYWRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFeHRlbnNpb246IGZ1bmN0aW9uKGFyZywgZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBpZiAoIWV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIC8vIHNoaWZ0IHBhcmFtZXRlcnMgaWYgbm8gY2FudmFzIGFyZyBpcyBwcm92aWRlZFxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGFyZztcbiAgICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgd3JhcHBlciA9IGdldENvbnRleHRXcmFwcGVyKGFyZyk7XG4gICAgICAgICAgICBpZiAod3JhcHBlcikge1xuICAgICAgICAgICAgICAgIGxldCBleHRlbnNpb25zID0gd3JhcHBlci5leHRlbnNpb25zO1xuICAgICAgICAgICAgICAgIHJldHVybiBleHRlbnNpb25zW2V4dGVuc2lvbl0gfHwgbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGBObyBjb250ZXh0IGlzIGN1cnJlbnRseSBib3VuZCBvciBjb3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgYXJndW1lbnQgb2YgdHlwZSAke3R5cGVvZiBhcmd9YDtcbiAgICAgICAgfVxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICBJbmRleEJ1ZmZlcjogcmVxdWlyZSgnLi9jb3JlL0luZGV4QnVmZmVyJyksXHJcbiAgICAgICAgUmVuZGVyYWJsZTogcmVxdWlyZSgnLi9jb3JlL1JlbmRlcmFibGUnKSxcclxuICAgICAgICBSZW5kZXJUYXJnZXQ6IHJlcXVpcmUoJy4vY29yZS9SZW5kZXJUYXJnZXQnKSxcclxuICAgICAgICBTaGFkZXI6IHJlcXVpcmUoJy4vY29yZS9TaGFkZXInKSxcclxuICAgICAgICBUZXh0dXJlMkQ6IHJlcXVpcmUoJy4vY29yZS9UZXh0dXJlMkQnKSxcclxuICAgICAgICBDb2xvclRleHR1cmUyRDogcmVxdWlyZSgnLi9jb3JlL0NvbG9yVGV4dHVyZTJEJyksXHJcbiAgICAgICAgRGVwdGhUZXh0dXJlMkQ6IHJlcXVpcmUoJy4vY29yZS9EZXB0aFRleHR1cmUyRCcpLFxyXG4gICAgICAgIFRleHR1cmVDdWJlTWFwOiByZXF1aXJlKCcuL2NvcmUvVGV4dHVyZUN1YmVNYXAnKSxcclxuICAgICAgICBWZXJ0ZXhCdWZmZXI6IHJlcXVpcmUoJy4vY29yZS9WZXJ0ZXhCdWZmZXInKSxcclxuICAgICAgICBWZXJ0ZXhQYWNrYWdlOiByZXF1aXJlKCcuL2NvcmUvVmVydGV4UGFja2FnZScpLFxyXG4gICAgICAgIFZpZXdwb3J0OiByZXF1aXJlKCcuL2NvcmUvVmlld3BvcnQnKSxcclxuICAgICAgICBXZWJHTENvbnRleHQ6IHJlcXVpcmUoJy4vY29yZS9XZWJHTENvbnRleHQnKVxyXG4gICAgfTtcclxuXHJcbn0oKSk7XHJcbiIsIihmdW5jdGlvbiAoKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRvcihhcmcpIHtcbiAgICAgICAgbGV0IGkgPSAtMTtcbiAgICAgICAgbGV0IGxlbjtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgbGVuID0gYXJnLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyBpIDogbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xuICAgICAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyBrZXlzW2ldIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChmbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBmbiA9IG51bGw7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWFjaChvYmplY3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBsZXQgY29tcGxldGVkID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBkb25lKGVycikge1xuICAgICAgICAgICAgY29tcGxldGVkLS07XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBudWxsICYmIGNvbXBsZXRlZCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYga2V5IGlzIG51bGwgaW4gY2FzZSBpdGVyYXRvciBpc24ndCBleGhhdXN0ZWQgYW5kIGRvbmVcbiAgICAgICAgICAgICAgICAvLyB3YXMgcmVzb2x2ZWQgc3luY2hyb25vdXNseS5cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdGVyID0gZ2V0SXRlcmF0b3Iob2JqZWN0KTtcbiAgICAgICAgd2hpbGUgKChrZXkgPSBpdGVyKCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG9iamVjdFtrZXldLCBrZXksIGRvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wbGV0ZWQgPT09IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4ZWN1dGUgYSBzZXQgb2YgZnVuY3Rpb25zIGFzeW5jaHJvbm91c2x5LCBvbmNlIGFsbCBoYXZlIGJlZW5cbiAgICAgICAgICogY29tcGxldGVkLCBleGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbi4gSm9icyBtYXkgYmUgcGFzc2VkXG4gICAgICAgICAqIGFzIGFuIGFycmF5IG9yIG9iamVjdC4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIHRoZVxuICAgICAgICAgKiByZXN1bHRzIGluIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgdGFza3MuIEFsbCB0YXNrcyBtdXN0IGhhdmUgYWNjZXB0XG4gICAgICAgICAqIGFuZCBleGVjdXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdXBvbiBjb21wbGV0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gdGFza3MgLSBUaGUgc2V0IG9mIGZ1bmN0aW9ucyB0byBleGVjdXRlLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCB1cG9uIGNvbXBsZXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBwYXJhbGxlbDogZnVuY3Rpb24odGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0cyA9IEFycmF5LmlzQXJyYXkodGFza3MpID8gW10gOiB7fTtcbiAgICAgICAgICAgIGVhY2godGFza3MsIGZ1bmN0aW9uKHRhc2ssIGtleSwgZG9uZSkge1xuICAgICAgICAgICAgICAgIHRhc2soZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trZXldID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZHMgYW4gR0VUIHJlcXVlc3QgY3JlYXRlIGFuIEltYWdlIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgWEhSIG9wdGlvbnMuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnVybCAtIFRoZSBVUkwgZm9yIHRoZSByZXNvdXJjZS5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5zdWNjZXNzIC0gVGhlIHN1Y2Nlc3MgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuZXJyb3IgLSBUaGUgZXJyb3IgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBsb2FkOiBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBsZXQgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3VjY2VzcyhpbWFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltYWdlLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyID0gJ1VuYWJsZSB0byBsb2FkIGltYWdlIGZyb20gVVJMOiBgJyArIGV2ZW50LnBhdGhbMF0uY3VycmVudFNyYyArICdgJztcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWFnZS5zcmMgPSBvcHRpb25zLnVybDtcbiAgICAgICAgfVxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IFV0aWwgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgb25lIG9mIHRoZSBXZWJHTCBgdGV4SW1hZ2UyRGAgb3ZlcnJpZGRlblxuICAgICAqIGNhbnZhcyB0eXBlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gYXJnIC0gVGhlIGFyZ3VtZW50IHRvIHRlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sfSAtIFdoZXRoZXIgb3Igbm90IGl0IGlzIGEgY2FudmFzIHR5cGUuXG4gICAgICovXG4gICAgVXRpbC5pc0NhbnZhc1R5cGUgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIEltYWdlRGF0YSB8fFxuICAgICAgICAgICAgYXJnIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fFxuICAgICAgICAgICAgYXJnIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgfHxcbiAgICAgICAgICAgIGFyZyBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGV4dHVyZSBNVVNUIGJlIGEgcG93ZXItb2YtdHdvLiBPdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNwZWMgLSBUaGUgdGV4dHVyZSBzcGVjaWZpY2F0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2x9IC0gV2hldGhlciBvciBub3QgdGhlIHRleHR1cmUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3by5cbiAgICAgKi9cbiAgICBVdGlsLm11c3RCZVBvd2VyT2ZUd28gPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgIC8vIEFjY29yZGluZyB0bzpcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMX0FQSS9UdXRvcmlhbC9Vc2luZ190ZXh0dXJlc19pbl9XZWJHTCNOb25fcG93ZXItb2YtdHdvX3RleHR1cmVzXG4gICAgICAgIC8vIE4tUE9UIHRleHR1cmVzIGNhbm5vdCBiZSB1c2VkIHdpdGggbWlwbWFwcGluZyBhbmQgdGhleSBtdXN0IG5vdCBcIlJFUEVBVFwiXG4gICAgICAgIHJldHVybiBzcGVjLm1pcE1hcCB8fFxuICAgICAgICAgICAgc3BlYy53cmFwUyA9PT0gJ1JFUEVBVCcgfHxcbiAgICAgICAgICAgIHNwZWMud3JhcFMgPT09ICdNSVJST1JFRF9SRVBFQVQnIHx8XG4gICAgICAgICAgICBzcGVjLndyYXBUID09PSAnUkVQRUFUJyB8fFxuICAgICAgICAgICAgc3BlYy53cmFwVCA9PT0gJ01JUlJPUkVEX1JFUEVBVCc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgaW50ZWdlciBpcyBhIHBvd2VyIG9mIHR3by5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBudW0gLSBUaGUgbnVtYmVyIHRvIHRlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFdoZXRoZXIgb3Igbm90IHRoZSBudW1iZXIgaXMgYSBwb3dlciBvZiB0d28uXG4gICAgICovXG4gICAgVXRpbC5pc1Bvd2VyT2ZUd28gPSBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgcmV0dXJuIChudW0gIT09IDApID8gKG51bSAmIChudW0gLSAxKSkgPT09IDAgOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIHR3byBmb3IgYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBFeC5cbiAgICAgKlxuICAgICAqICAgICAyMDAgLT4gMjU2XG4gICAgICogICAgIDI1NiAtPiAyNTZcbiAgICAgKiAgICAgMjU3IC0+IDUxMlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG51bSAtIFRoZSBudW1iZXIgdG8gbW9kaWZ5LlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIE5leHQgaGlnaGVzdCBwb3dlciBvZiB0d28uXG4gICAgICovXG4gICAgVXRpbC5uZXh0SGlnaGVzdFBvd2VyT2ZUd28gPSBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGlmIChudW0gIT09IDApIHtcbiAgICAgICAgICAgIG51bSA9IG51bS0xO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaT0xOyBpPDMyOyBpPDw9MSkge1xuICAgICAgICAgICAgbnVtID0gbnVtIHwgbnVtID4+IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bSArIDE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSB0ZXh0dXJlIG11c3QgYmUgYSBQT1QsIHJlc2l6ZXMgYW5kIHJldHVybnMgdGhlIGltYWdlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlYyAtIFRoZSB0ZXh0dXJlIHNwZWNpZmljYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1nIC0gVGhlIGltYWdlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IC0gVGhlIG9yaWdpbmFsIGltYWdlLCBvciB0aGUgcmVzaXplZCBjYW52YXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICBVdGlsLnJlc2l6ZUNhbnZhcyA9IGZ1bmN0aW9uKHNwZWMsIGltZykge1xuICAgICAgICBpZiAoIVV0aWwubXVzdEJlUG93ZXJPZlR3byhzcGVjKSB8fFxuICAgICAgICAgICAgKFV0aWwuaXNQb3dlck9mVHdvKGltZy53aWR0aCkgJiYgVXRpbC5pc1Bvd2VyT2ZUd28oaW1nLmhlaWdodCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1nO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBjYW52YXMgZWxlbWVudFxuICAgICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IFV0aWwubmV4dEhpZ2hlc3RQb3dlck9mVHdvKGltZy53aWR0aCk7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBVdGlsLm5leHRIaWdoZXN0UG93ZXJPZlR3byhpbWcuaGVpZ2h0KTtcbiAgICAgICAgLy8gY29weSB0aGUgaW1hZ2UgY29udGVudHMgdG8gdGhlIGNhbnZhc1xuICAgICAgICBsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBpbWcud2lkdGgsIGltZy5oZWlnaHQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVXRpbDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kcyBhbiBYTUxIdHRwUmVxdWVzdCBHRVQgcmVxdWVzdCB0byB0aGUgc3VwcGxpZWQgdXJsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBYSFIgb3B0aW9ucy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudXJsIC0gVGhlIFVSTCBmb3IgdGhlIHJlc291cmNlLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnN1Y2Nlc3MgLSBUaGUgc3VjY2VzcyBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5lcnJvciAtIFRoZSBlcnJvciBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5yZXNwb25zZVR5cGUgLSBUaGUgcmVzcG9uc2VUeXBlIG9mIHRoZSBYSFIuXG4gICAgICAgICAqL1xuICAgICAgICBsb2FkOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgb3B0aW9ucy51cmwsIHRydWUpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IoJ0dFVCAnICsgcmVxdWVzdC5yZXNwb25zZVVSTCArICcgJyArIHJlcXVlc3Quc3RhdHVzICsgJyAoJyArIHJlcXVlc3Quc3RhdHVzVGV4dCArICcpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG59KCkpO1xuIiwidmFyIGpzb24gPSB0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcgPyBKU09OIDogcmVxdWlyZSgnanNvbmlmeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIG9wdHMgPSB7IGNtcDogb3B0cyB9O1xuICAgIHZhciBzcGFjZSA9IG9wdHMuc3BhY2UgfHwgJyc7XG4gICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHNwYWNlID0gQXJyYXkoc3BhY2UrMSkuam9pbignICcpO1xuICAgIHZhciBjeWNsZXMgPSAodHlwZW9mIG9wdHMuY3ljbGVzID09PSAnYm9vbGVhbicpID8gb3B0cy5jeWNsZXMgOiBmYWxzZTtcbiAgICB2YXIgcmVwbGFjZXIgPSBvcHRzLnJlcGxhY2VyIHx8IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gICAgdmFyIGNtcCA9IG9wdHMuY21wICYmIChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhb2JqID0geyBrZXk6IGEsIHZhbHVlOiBub2RlW2FdIH07XG4gICAgICAgICAgICAgICAgdmFyIGJvYmogPSB7IGtleTogYiwgdmFsdWU6IG5vZGVbYl0gfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZihhb2JqLCBib2JqKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSkob3B0cy5jbXApO1xuXG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIHN0cmluZ2lmeSAocGFyZW50LCBrZXksIG5vZGUsIGxldmVsKSB7XG4gICAgICAgIHZhciBpbmRlbnQgPSBzcGFjZSA/ICgnXFxuJyArIG5ldyBBcnJheShsZXZlbCArIDEpLmpvaW4oc3BhY2UpKSA6ICcnO1xuICAgICAgICB2YXIgY29sb25TZXBhcmF0b3IgPSBzcGFjZSA/ICc6ICcgOiAnOic7XG5cbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS50b0pTT04gJiYgdHlwZW9mIG5vZGUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS50b0pTT04oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSByZXBsYWNlci5jYWxsKHBhcmVudCwga2V5LCBub2RlKTtcblxuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCBub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4ganNvbi5zdHJpbmdpZnkobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RyaW5naWZ5KG5vZGUsIGksIG5vZGVbaV0sIGxldmVsKzEpIHx8IGpzb24uc3RyaW5naWZ5KG51bGwpO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGluZGVudCArIHNwYWNlICsgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgb3V0LmpvaW4oJywnKSArIGluZGVudCArICddJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN5Y2xlcykgcmV0dXJuIGpzb24uc3RyaW5naWZ5KCdfX2N5Y2xlX18nKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHNlZW4ucHVzaChub2RlKTtcblxuICAgICAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKG5vZGUpLnNvcnQoY21wICYmIGNtcChub2RlKSk7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHJpbmdpZnkobm9kZSwga2V5LCBub2RlW2tleV0sIGxldmVsKzEpO1xuXG4gICAgICAgICAgICAgICAgaWYoIXZhbHVlKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IGpzb24uc3RyaW5naWZ5KGtleSlcbiAgICAgICAgICAgICAgICAgICAgKyBjb2xvblNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICArIHZhbHVlO1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChpbmRlbnQgKyBzcGFjZSArIGtleVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW4uc3BsaWNlKHNlZW4uaW5kZXhPZihub2RlKSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gJ3snICsgb3V0LmpvaW4oJywnKSArIGluZGVudCArICd9JztcbiAgICAgICAgfVxuICAgIH0pKHsgJyc6IG9iaiB9LCAnJywgb2JqLCAwKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZSB9O1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59O1xuIiwiZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vbGliL3BhcnNlJyk7XG5leHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vbGliL3N0cmluZ2lmeScpO1xuIiwidmFyIGF0LCAvLyBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgY2gsIC8vIFRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgIGVzY2FwZWUgPSB7XG4gICAgICAgICdcIic6ICAnXCInLFxuICAgICAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAgICAgJy8nOiAgJy8nLFxuICAgICAgICBiOiAgICAnXFxiJyxcbiAgICAgICAgZjogICAgJ1xcZicsXG4gICAgICAgIG46ICAgICdcXG4nLFxuICAgICAgICByOiAgICAnXFxyJyxcbiAgICAgICAgdDogICAgJ1xcdCdcbiAgICB9LFxuICAgIHRleHQsXG5cbiAgICBlcnJvciA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIC8vIENhbGwgZXJyb3Igd2hlbiBzb21ldGhpbmcgaXMgd3JvbmcuXG4gICAgICAgIHRocm93IHtcbiAgICAgICAgICAgIG5hbWU6ICAgICdTeW50YXhFcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiBtLFxuICAgICAgICAgICAgYXQ6ICAgICAgYXQsXG4gICAgICAgICAgICB0ZXh0OiAgICB0ZXh0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBcbiAgICBuZXh0ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgLy8gSWYgYSBjIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgdmVyaWZ5IHRoYXQgaXQgbWF0Y2hlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuXG4gICAgICAgIGlmIChjICYmIGMgIT09IGNoKSB7XG4gICAgICAgICAgICBlcnJvcihcIkV4cGVjdGVkICdcIiArIGMgKyBcIicgaW5zdGVhZCBvZiAnXCIgKyBjaCArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGNoYXJhY3Rlci4gV2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzLFxuICAgICAgICAvLyByZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgICAgXG4gICAgICAgIGNoID0gdGV4dC5jaGFyQXQoYXQpO1xuICAgICAgICBhdCArPSAxO1xuICAgICAgICByZXR1cm4gY2g7XG4gICAgfSxcbiAgICBcbiAgICBudW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBhcnNlIGEgbnVtYmVyIHZhbHVlLlxuICAgICAgICB2YXIgbnVtYmVyLFxuICAgICAgICAgICAgc3RyaW5nID0gJyc7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgICAgc3RyaW5nID0gJy0nO1xuICAgICAgICAgICAgbmV4dCgnLScpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSAnLic7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCgpICYmIGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbnVtYmVyID0gK3N0cmluZztcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgICBlcnJvcihcIkJhZCBudW1iZXJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBhcnNlIGEgc3RyaW5nIHZhbHVlLlxuICAgICAgICB2YXIgaGV4LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHN0cmluZyA9ICcnLFxuICAgICAgICAgICAgdWZmZmY7XG4gICAgICAgIFxuICAgICAgICAvLyBXaGVuIHBhcnNpbmcgZm9yIHN0cmluZyB2YWx1ZXMsIHdlIG11c3QgbG9vayBmb3IgXCIgYW5kIFxcIGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgd2hpbGUgKG5leHQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZXggPSBwYXJzZUludChuZXh0KCksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGhleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gdWZmZmYgKiAxNiArIGhleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVmZmZmKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXNjYXBlZVtjaF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gZXNjYXBlZVtjaF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgc3RyaW5nXCIpO1xuICAgIH0sXG5cbiAgICB3aGl0ZSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gU2tpcCB3aGl0ZXNwYWNlLlxuXG4gICAgICAgIHdoaWxlIChjaCAmJiBjaCA8PSAnICcpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB3b3JkID0gZnVuY3Rpb24gKCkge1xuXG4vLyB0cnVlLCBmYWxzZSwgb3IgbnVsbC5cblxuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgbmV4dCgndCcpO1xuICAgICAgICAgICAgbmV4dCgncicpO1xuICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgbmV4dCgnZicpO1xuICAgICAgICAgICAgbmV4dCgnYScpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgbmV4dCgncycpO1xuICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIG5leHQoJ24nKTtcbiAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiVW5leHBlY3RlZCAnXCIgKyBjaCArIFwiJ1wiKTtcbiAgICB9LFxuXG4gICAgdmFsdWUsICAvLyBQbGFjZSBob2xkZXIgZm9yIHRoZSB2YWx1ZSBmdW5jdGlvbi5cblxuICAgIGFycmF5ID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhbiBhcnJheSB2YWx1ZS5cblxuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgICAgICBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICAgICAgbmV4dCgnWycpO1xuICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTsgICAvLyBlbXB0eSBhcnJheVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBhcnJheVwiKTtcbiAgICB9LFxuXG4gICAgb2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhbiBvYmplY3QgdmFsdWUuXG5cbiAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgIG9iamVjdCA9IHt9O1xuXG4gICAgICAgIGlmIChjaCA9PT0gJ3snKSB7XG4gICAgICAgICAgICBuZXh0KCd7Jyk7XG4gICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDsgICAvLyBlbXB0eSBvYmplY3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGtleSA9IHN0cmluZygpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgbmV4dCgnOicpO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0R1cGxpY2F0ZSBrZXkgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsdWUoKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgb2JqZWN0XCIpO1xuICAgIH07XG5cbnZhbHVlID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhIEpTT04gdmFsdWUuIEl0IGNvdWxkIGJlIGFuIG9iamVjdCwgYW4gYXJyYXksIGEgc3RyaW5nLCBhIG51bWJlcixcbi8vIG9yIGEgd29yZC5cblxuICAgIHdoaXRlKCk7XG4gICAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgJ3snOlxuICAgICAgICByZXR1cm4gb2JqZWN0KCk7XG4gICAgY2FzZSAnWyc6XG4gICAgICAgIHJldHVybiBhcnJheSgpO1xuICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgcmV0dXJuIHN0cmluZygpO1xuICAgIGNhc2UgJy0nOlxuICAgICAgICByZXR1cm4gbnVtYmVyKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGNoID49ICcwJyAmJiBjaCA8PSAnOScgPyBudW1iZXIoKSA6IHdvcmQoKTtcbiAgICB9XG59O1xuXG4vLyBSZXR1cm4gdGhlIGpzb25fcGFyc2UgZnVuY3Rpb24uIEl0IHdpbGwgaGF2ZSBhY2Nlc3MgdG8gYWxsIG9mIHRoZSBhYm92ZVxuLy8gZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNvdXJjZSwgcmV2aXZlcikge1xuICAgIHZhciByZXN1bHQ7XG4gICAgXG4gICAgdGV4dCA9IHNvdXJjZTtcbiAgICBhdCA9IDA7XG4gICAgY2ggPSAnICc7XG4gICAgcmVzdWx0ID0gdmFsdWUoKTtcbiAgICB3aGl0ZSgpO1xuICAgIGlmIChjaCkge1xuICAgICAgICBlcnJvcihcIlN5bnRheCBlcnJvclwiKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIG5ldyBzdHJ1Y3R1cmUsXG4gICAgLy8gcGFzc2luZyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byB0aGUgcmV2aXZlciBmdW5jdGlvbiBmb3IgcG9zc2libGVcbiAgICAvLyB0cmFuc2Zvcm1hdGlvbiwgc3RhcnRpbmcgd2l0aCBhIHRlbXBvcmFyeSByb290IG9iamVjdCB0aGF0IGhvbGRzIHRoZSByZXN1bHRcbiAgICAvLyBpbiBhbiBlbXB0eSBrZXkuIElmIHRoZXJlIGlzIG5vdCBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHNpbXBseSByZXR1cm4gdGhlXG4gICAgLy8gcmVzdWx0LlxuXG4gICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nID8gKGZ1bmN0aW9uIHdhbGsoaG9sZGVyLCBrZXkpIHtcbiAgICAgICAgdmFyIGssIHYsIHZhbHVlID0gaG9sZGVyW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICB2ID0gd2Fsayh2YWx1ZSwgayk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV2aXZlci5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgfSh7Jyc6IHJlc3VsdH0sICcnKSkgOiByZXN1bHQ7XG59O1xuIiwidmFyIGN4ID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICBnYXAsXG4gICAgaW5kZW50LFxuICAgIG1ldGEgPSB7ICAgIC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG4gICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgJ1wiJyA6ICdcXFxcXCInLFxuICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICB9LFxuICAgIHJlcDtcblxuZnVuY3Rpb24gcXVvdGUoc3RyaW5nKSB7XG4gICAgLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuICAgIC8vIGJhY2tzbGFzaCBjaGFyYWN0ZXJzLCB0aGVuIHdlIGNhbiBzYWZlbHkgc2xhcCBzb21lIHF1b3RlcyBhcm91bmQgaXQuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXG4gICAgLy8gc2VxdWVuY2VzLlxuICAgIFxuICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBlc2NhcGFibGUudGVzdChzdHJpbmcpID8gJ1wiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGMgPSBtZXRhW2FdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnID8gYyA6XG4gICAgICAgICAgICAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICB9KSArICdcIicgOiAnXCInICsgc3RyaW5nICsgJ1wiJztcbn1cblxuZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyKSB7XG4gICAgLy8gUHJvZHVjZSBhIHN0cmluZyBmcm9tIGhvbGRlcltrZXldLlxuICAgIHZhciBpLCAgICAgICAgICAvLyBUaGUgbG9vcCBjb3VudGVyLlxuICAgICAgICBrLCAgICAgICAgICAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgdiwgICAgICAgICAgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBtaW5kID0gZ2FwLFxuICAgICAgICBwYXJ0aWFsLFxuICAgICAgICB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgIFxuICAgIC8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xuICAgIC8vIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgIGlmICh0eXBlb2YgcmVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gcmVwLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuICAgICAgICBcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnbnVsbCc7XG4gICAgICAgIFxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4gICAgICAgICAgICAvLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlICdudWxsJy4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuICAgICAgICAgICAgLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQXJyYXkuaXNBcnJheVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCAnbnVsbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBlbGVtZW50cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB3cmFwIHRoZW0gaW4gYnJhY2tldHMuXG4gICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ1tdJyA6IGdhcCA/XG4gICAgICAgICAgICAgICAgICAgICdbXFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ10nIDpcbiAgICAgICAgICAgICAgICAgICAgJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgdGhlIHJlcGxhY2VyIGlzIGFuIGFycmF5LCB1c2UgaXQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlXG4gICAgICAgICAgICAvLyBzdHJpbmdpZmllZC5cbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSByZXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4gICAgICAgIC8vIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuXG4gICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICd7fScgOiBnYXAgP1xuICAgICAgICAgICAgJ3tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnfScgOlxuICAgICAgICAgICAgJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnfSc7XG4gICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIHZhciBpO1xuICAgIGdhcCA9ICcnO1xuICAgIGluZGVudCA9ICcnO1xuICAgIFxuICAgIC8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbiAgICAvLyBtYW55IHNwYWNlcy5cbiAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BhY2U7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5kZW50ICs9ICcgJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluZGVudCBzdHJpbmcuXG4gICAgZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbmRlbnQgPSBzcGFjZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4gICAgLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvci5cbiAgICByZXAgPSByZXBsYWNlcjtcbiAgICBpZiAocmVwbGFjZXIgJiYgdHlwZW9mIHJlcGxhY2VyICE9PSAnZnVuY3Rpb24nXG4gICAgJiYgKHR5cGVvZiByZXBsYWNlciAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gJ251bWJlcicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTi5zdHJpbmdpZnknKTtcbiAgICB9XG4gICAgXG4gICAgLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiAnJy5cbiAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuICAgIHJldHVybiBzdHIoJycsIHsnJzogdmFsdWV9KTtcbn07XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICAvLyBTYWZhcmkgOSBtYWtlcyBgYXJndW1lbnRzLmxlbmd0aGAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgdmFyIHJlc3VsdCA9IChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpXG4gICAgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpXG4gICAgOiBbXTtcblxuICB2YXIgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aCxcbiAgICAgIHNraXBJbmRleGVzID0gISFsZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoa2V5ID09ICdsZW5ndGgnIHx8IGlzSW5kZXgoa2V5LCBsZW5ndGgpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSBhcnJheTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcbiAqIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGlsZSBpdCdzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYXQgd2hpY2ggYGZ1bmNgIGlzIG5vIGxvbmdlciBpbnZva2VkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5iZWZvcmUoNSwgYWRkQ29udGFjdFRvTGlzdCkpO1xuICogLy8gPT4gQWxsb3dzIGFkZGluZyB1cCB0byA0IGNvbnRhY3RzIHRvIHRoZSBsaXN0LlxuICovXG5mdW5jdGlvbiBiZWZvcmUobiwgZnVuYykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBuID0gdG9JbnRlZ2VyKG4pO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKC0tbiA+IDApIHtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKG4gPD0gMSkge1xuICAgICAgZnVuYyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiZWZvcmU7XG4iLCJ2YXIgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICghcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIHx8IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwidmFyIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLm5vb3ApO1xuICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICovXG5mdW5jdGlvbiBub29wKCkge1xuICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vb3A7XG4iLCJ2YXIgYmVmb3JlID0gcmVxdWlyZSgnLi9iZWZvcmUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcbiAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnZvY2F0aW9uLiBUaGUgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAqIGluaXRpYWxpemUoKTtcbiAqIGluaXRpYWxpemUoKTtcbiAqIC8vID0+IGBjcmVhdGVBcHBsaWNhdGlvbmAgaXMgaW52b2tlZCBvbmNlXG4gKi9cbmZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9uY2U7XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICogY3JlYXRlZCBmdW5jdGlvbiBhbmQgYXJndW1lbnRzIGZyb20gYHN0YXJ0YCBhbmQgYmV5b25kIHByb3ZpZGVkIGFzXG4gKiBhbiBhcnJheS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gKiBbcmVzdCBwYXJhbWV0ZXJdKGh0dHBzOi8vbWRuLmlvL3Jlc3RfcGFyYW1ldGVycykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBzYXkgPSBfLnJlc3QoZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gKiB9KTtcbiAqXG4gKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAqL1xuZnVuY3Rpb24gcmVzdChmdW5jLCBzdGFydCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBzdGFydCA9IHN0YXJ0ID09PSB1bmRlZmluZWQgPyBzdGFydCA6IHRvSW50ZWdlcihzdGFydCk7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jLCBzdGFydCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzdDtcbiIsInZhciB0b051bWJlciA9IHJlcXVpcmUoJy4vdG9OdW1iZXInKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9GaW5pdGUoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgfVxuICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9GaW5pdGU7XG4iLCJ2YXIgdG9GaW5pdGUgPSByZXF1aXJlKCcuL3RvRmluaXRlJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9JbnRlZ2VyKDMuMik7XG4gKiAvLyA9PiAzXG4gKlxuICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiAwXG4gKlxuICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9JbnRlZ2VyO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9OdW1iZXI7XG4iLCIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuMTQuMVxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gdXRpbHNfaG9va3NfX2hvb2tzICgpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkob2JqKSB7XG4gICAgICAgIHZhciBrO1xuICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAvLyBldmVuIGlmIGl0cyBub3Qgb3duIHByb3BlcnR5IEknZCBzdGlsbCBjYWxsIGl0IG5vbi1lbXB0eVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gW10sIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlX3V0Y19fY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWRUb2tlbnMgICAgOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyICAgOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdCAgIDogZmFsc2UsXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgcGFyc2VkRGF0ZVBhcnRzIDogW10sXG4gICAgICAgICAgICBtZXJpZGllbSAgICAgICAgOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICB2YXIgc29tZTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRfX2lzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgICAgICB2YXIgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IG0uX2lzVmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZF9fY3JlYXRlSW52YWxpZCAoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSB1dGlsc19ob29rc19faG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gbW9tZW50UHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgY29uc29sZSAhPT0gICd1bmRlZmluZWQnKSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgICAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcsICcpICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICBpZiAodXRpbHNfaG9va3NfX2hvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlX3NldF9fc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9vcmRpbmFsUGFyc2VMZW5pZW50LlxuICAgICAgICB0aGlzLl9vcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cCh0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlICsgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZV9jYWxlbmRhcl9fY2FsZW5kYXIgKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV0gfHwgdGhpcy5fY2FsZW5kYXJbJ3NhbWVFbHNlJ107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb25nRGF0ZUZvcm1hdCA9IHtcbiAgICAgICAgTFRTICA6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVCAgIDogJ2g6bW0gQScsXG4gICAgICAgIEwgICAgOiAnTU0vREQvWVlZWScsXG4gICAgICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcbiAgICAgICAgTExMICA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgTExMTCA6ICdkZGRkLCBNTU1NIEQsIFlZWVkgaDptbSBBJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdCAoa2V5KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxuICAgICAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwuc2xpY2UoMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuICAgIGZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludmFsaWREYXRlO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCc7XG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG4gICAgZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgICAgIHMgIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoICA6ICdhbiBob3VyJyxcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICBkICA6ICdhIGRheScsXG4gICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICBNICA6ICdhIG1vbnRoJyxcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeSAgOiAnYSB5ZWFyJyxcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlX19yZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgIHJldHVybiAoaXNGdW5jdGlvbihvdXRwdXQpKSA/XG4gICAgICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRBbGlhcyAodW5pdCwgc2hvcnRoYW5kKSB7XG4gICAgICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIHZhciBwcmlvcml0aWVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICAgICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICAgICAgdmFyIHVuaXRzID0gW107XG4gICAgICAgIGZvciAodmFyIHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgICAgIHVuaXRzLnB1c2goe3VuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdfSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ2V0X3NldF9fc2V0KHRoaXMsIHVuaXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldF9zZXRfX2dldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRfc2V0X19nZXQgKG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRfc2V0X19zZXQgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdHZXQgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gc3RyaW5nU2V0ICh1bml0cywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplT2JqZWN0VW5pdHModW5pdHMpO1xuICAgICAgICAgICAgdmFyIHByaW9yaXRpemVkID0gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW9yaXRpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGFycmF5W2ldIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGkgPSA1O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSAgICAgICAgID0gL1xcZC87ICAgICAgICAgICAgLy8gICAgICAgMCAtIDlcbiAgICB2YXIgbWF0Y2gyICAgICAgICAgPSAvXFxkXFxkLzsgICAgICAgICAgLy8gICAgICAwMCAtIDk5XG4gICAgdmFyIG1hdGNoMyAgICAgICAgID0gL1xcZHszfS87ICAgICAgICAgLy8gICAgIDAwMCAtIDk5OVxuICAgIHZhciBtYXRjaDQgICAgICAgICA9IC9cXGR7NH0vOyAgICAgICAgIC8vICAgIDAwMDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoNiAgICAgICAgID0gL1srLV0/XFxkezZ9LzsgICAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuICAgIHZhciBtYXRjaDF0bzIgICAgICA9IC9cXGRcXGQ/LzsgICAgICAgICAvLyAgICAgICAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzdG80ICAgICAgPSAvXFxkXFxkXFxkXFxkPy87ICAgICAvLyAgICAgOTk5IC0gOTk5OVxuICAgIHZhciBtYXRjaDV0bzYgICAgICA9IC9cXGRcXGRcXGRcXGRcXGRcXGQ/LzsgLy8gICA5OTk5OSAtIDk5OTk5OVxuICAgIHZhciBtYXRjaDF0bzMgICAgICA9IC9cXGR7MSwzfS87ICAgICAgIC8vICAgICAgIDAgLSA5OTlcbiAgICB2YXIgbWF0Y2gxdG80ICAgICAgPSAvXFxkezEsNH0vOyAgICAgICAvLyAgICAgICAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDF0bzYgICAgICA9IC9bKy1dP1xcZHsxLDZ9LzsgIC8vIC05OTk5OTkgLSA5OTk5OTlcblxuICAgIHZhciBtYXRjaFVuc2lnbmVkICA9IC9cXGQrLzsgICAgICAgICAgIC8vICAgICAgIDAgLSBpbmZcbiAgICB2YXIgbWF0Y2hTaWduZWQgICAgPSAvWystXT9cXGQrLzsgICAgICAvLyAgICAtaW5mIC0gaW5mXG5cbiAgICB2YXIgbWF0Y2hPZmZzZXQgICAgPSAvWnxbKy1dXFxkXFxkOj9cXGRcXGQvZ2k7IC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgIHZhciBtYXRjaFNob3J0T2Zmc2V0ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZ2k7IC8vICswMCAtMDAgKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG5cbiAgICB2YXIgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vOyAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuXG4gICAgLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4gICAgLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xuICAgIHZhciBtYXRjaFdvcmQgPSAvWzAtOV0qWydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK3xbXFx1MDYwMC1cXHUwNkZGXFwvXSsoXFxzKj9bXFx1MDYwMC1cXHUwNkZGXSspezEsMn0vaTtcblxuXG4gICAgdmFyIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcmVnZXhFc2NhcGUocy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgWUVBUiA9IDA7XG4gICAgdmFyIE1PTlRIID0gMTtcbiAgICB2YXIgREFURSA9IDI7XG4gICAgdmFyIEhPVVIgPSAzO1xuICAgIHZhciBNSU5VVEUgPSA0O1xuICAgIHZhciBTRUNPTkQgPSA1O1xuICAgIHZhciBNSUxMSVNFQ09ORCA9IDY7XG4gICAgdmFyIFdFRUsgPSA3O1xuICAgIHZhciBXRUVLREFZID0gODtcblxuICAgIHZhciBpbmRleE9mO1xuXG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleE9mID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIC8vIEkga25vd1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggKyAxLCAwKSkuZ2V0VVRDRGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMrKStNTU1NPy87XG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMgKG0sIGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzW20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzWyh0aGlzLl9tb250aHMuaXNGb3JtYXQgfHwgTU9OVEhTX0lOX0ZPUk1BVCkudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml0c19tb250aF9faGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuaXRzX21vbnRoX19oYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgICAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TW9udGggKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgICAgICByZXR1cm4geSA8PSA5OTk5ID8gJycgKyB5IDogJysnICsgeTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCAgIDRdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCAgNV0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3llYXInLCAxKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWScsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWScsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gaW5wdXQubGVuZ3RoID09PSAyID8gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbiAgICB9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gZ2V0SXNMZWFwWWVhciAoKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvL2Nhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxMzQ4L2luc3RhbnRpYXRpbmctYS1qYXZhc2NyaXB0LW9iamVjdC1ieS1jYWxsaW5nLXByb3RvdHlwZS1jb25zdHJ1Y3Rvci1hcHBseVxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgICAgICAvL3RoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG5cbiAgICAgICAgLy90aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG4gICAgZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICAgICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG4gICAgfVxuXG4gICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgICAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICAgICAgeWVhcjogcmVzWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrJywgJ3cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrJywgNSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd3JywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrZGF5JywgMTEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzW20uZGF5KCldIDpcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzW3RoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5X29mX3dlZWtfX2hhbmRsZVN0cmljdFBhcnNlKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGRheV9vZl93ZWVrX19oYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZGQnICYmIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGQnICYmIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGQnICYmIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNNaW5SZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5QaWVjZXMgPSBbXSwgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tLCBtaW5wLCBzaG9ydHAsIGxvbmdwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIG1pbnAgPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgc2hvcnRwID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgbG9uZ3AgPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpO1xuICAgICAgICAgICAgbWluUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgd2Vla2RheSAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIG1pblBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWluUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1lcmlkaWVtKCdhJywgdHJ1ZSk7XG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2hvdXInLCAxMyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBmdW5jdGlvbiBtYXRjaE1lcmlkaWVtIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdBJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRSZWdleFRva2VuKCdobW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbXNzJywgbWF0Y2g1dG82KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgICAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgaGUgd2FudHMuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIG9yZGluYWxQYXJzZTogZGVmYXVsdE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxuICAgIH07XG5cbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG4gICAgdmFyIGxvY2FsZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsO1xuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgICAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgZGVmaW5lTG9jYWxlIGN1cnJlbnRseSBhbHNvIHNldHMgdGhlIGdsb2JhbCBsb2NhbGUsIHdlXG4gICAgICAgICAgICAgICAgLy8gd2FudCB0byB1bmRvIHRoYXQgZm9yIGxhenkgbG9hZGVkIGxvY2FsZXNcbiAgICAgICAgICAgICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxvY2FsZSBrZXkuXG4gICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZSgnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kZWZpbmUtbG9jYWxlLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJlYXQgYXMgaWYgdGhlcmUgaXMgbm8gYmFzZSBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdwYXJlbnRMb2NhbGVVbmRlZmluZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzcGVjaWZpZWQgcGFyZW50TG9jYWxlIGlzIG5vdCBkZWZpbmVkIHlldC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvcGFyZW50LWxvY2FsZS8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpKTtcblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLCBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuICAgIGZ1bmN0aW9uIGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUgKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBpc28gODYwMSByZWdleFxuICAgIC8vIDAwMDAtMDAtMDAgMDAwMC1XMDAgb3IgMDAwMC1XMDAtMCArIFQgKyAwMCBvciAwMDowMCBvciAwMDowMDowMCBvciAwMDowMDowMC4wMDAgKyArMDA6MDAgb3IgKzAwMDAgb3IgKzAwKVxuICAgIHZhciBleHRlbmRlZElzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPy87XG4gICAgdmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPy87XG5cbiAgICB2YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcblxuICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuICAgIF07XG5cbiAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgdmFyIGlzb1RpbWVzID0gW1xuICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEgnLCAvXFxkXFxkL11cbiAgICBdO1xuXG4gICAgdmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBsLFxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgICAgIGFsbG93VGltZSwgZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgdHpGb3JtYXQ7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzJdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgIGlmICh0elJlZ2V4LmV4ZWMobWF0Y2hbNF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZS4gVGhpcyBpcyAnICtcbiAgICAgICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdXBjb21pbmcgbWFqb3IgJyArXG4gICAgICAgICdyZWxlYXNlLiBQbGVhc2UgcmVmZXIgdG8gJyArXG4gICAgICAgICdodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvIGZvciBtb3JlIGluZm8uJyxcbiAgICAgICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZSh1dGlsc19ob29rc19faG9va3Mubm93KCkpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0VVRDTW9udGgoKSwgbm93VmFsdWUuZ2V0VVRDRGF0ZSgpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4gICAgLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbiAgICAvLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbiAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgZGF0ZSwgaW5wdXQgPSBbXSwgY3VycmVudERhdGUsIHllYXJUb1VzZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgICAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhcik7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobG9jYWxfX2NyZWF0ZUxvY2FsKCksIGRvdywgZG95KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIDEpO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICAgICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Rva2VuJywgdG9rZW4sICdwYXJzZWRJbnB1dCcsIHBhcnNlZElucHV0LFxuICAgICAgICAgICAgLy8gICAgICAgICAncmVnZXgnLCBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChjb25maWcuX2xvY2FsZSwgY29uZmlnLl9hW0hPVVJdLCBjb25maWcuX21lcmlkaWVtKTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwIChsb2NhbGUsIGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgIHZhciBpc1BtO1xuXG4gICAgICAgIGlmIChtZXJpZGllbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxlLmlzUE0gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2tcbiAgICAgICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XG4gICAgICAgICAgICBpZiAoaXNQbSAmJiBob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1BtICYmIGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBhcnJheSBvZiBmb3JtYXQgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgICAgICBiZXN0TW9tZW50LFxuXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZF9faXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgICAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZF9fY3JlYXRlSW52YWxpZCh7bnVsbElucHV0OiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSAgZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdmFsaWRfX2lzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh1dGlsc19ob29rc19faG9va3Mubm93KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YobG9jYWxlKSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGlzT2JqZWN0KGlucHV0KSAmJiBpc09iamVjdEVtcHR5KGlucHV0KSkgfHxcbiAgICAgICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsX19jcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRfX2NyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB2YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRfX2NyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuICAgIC8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cbiAgICAvL1xuICAgIC8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2VcbiAgICAvLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxuICAgIGZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgICAgICB2YXIgcmVzLCBpO1xuICAgICAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xuICAgICAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRHVyYXRpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgMCxcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICAgICAgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKCk7XG5cbiAgICAgICAgdGhpcy5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBvZmZzZXQgKHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICAgICAgdmFyIHNpZ24gPSAnKyc7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaWduICsgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArIHNlcGFyYXRvciArIHplcm9GaWxsKH5+KG9mZnNldCkgJSA2MCwgMik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9mZnNldCgnWicsICc6Jyk7XG4gICAgb2Zmc2V0KCdaWicsICcnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1onLCAgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUmVnZXhUb2tlbignWlonLCBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gdGltZXpvbmUgY2h1bmtlclxuICAgIC8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuICAgIC8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxuICAgIHZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuICAgIGZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcobWF0Y2hlciwgc3RyaW5nKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gKChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpIHx8IFtdKTtcbiAgICAgICAgdmFyIGNodW5rICAgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgICAgIHZhciBwYXJ0cyAgID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgIHJldHVybiBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCBtb2RlbCkge1xuICAgICAgICB2YXIgcmVzLCBkaWZmO1xuICAgICAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAgICAgICAgZGlmZiA9IChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/IGlucHV0LnZhbHVlT2YoKSA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgY3JlYXRlX19jcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkICgpIHtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVfdXRjX19jcmVhdGVVVEMoYy5fYSkgOiBsb2NhbF9fY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgIHZhciBhc3BOZXRSZWdleCA9IC9eKFxcLSk/KD86KFxcZCopWy4gXSk/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspXFwuPyhcXGR7M30pP1xcZCopPyQvO1xuXG4gICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgIHZhciBpc29SZWdleCA9IC9eKC0pP1AoPzooLT9bMC05LC5dKilZKT8oPzooLT9bMC05LC5dKilNKT8oPzooLT9bMC05LC5dKilXKT8oPzooLT9bMC05LC5dKilEKT8oPzpUKD86KC0/WzAtOSwuXSopSCk/KD86KC0/WzAtOSwuXSopTSk/KD86KC0/WzAtOSwuXSopUyk/KT8kLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gaW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXMgOiB0b0ludChtYXRjaFtNSUxMSVNFQ09ORF0pICogc2lnblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UobG9jYWxfX2NyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLCBsb2NhbF9fY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pKTtcblxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XG4gICAgICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXMgPSB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0IChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBnZXRfc2V0X19zZXQobW9tLCAnRGF0ZScsIGdldF9zZXRfX2dldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0X3NldF9fZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZU9mZnNldCkge1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGRfc3VidHJhY3RfX2FkZCAgICAgID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpO1xuICAgIHZhciBhZGRfc3VidHJhY3RfX3N1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xuICAgICAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xuICAgICAgICByZXR1cm4gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfY2FsZW5kYXJfX2NhbGVuZGFyICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBsb2NhbF9fY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgZm9ybWF0ID0gdXRpbHNfaG9va3NfX2hvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJztcblxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0cyAmJiAoaXNGdW5jdGlvbihmb3JtYXRzW2Zvcm1hdF0pID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KSA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGxvY2FsX19jcmVhdGVMb2NhbChub3cpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxJbnB1dC52YWx1ZU9mKCkgPCB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgICAgIGluY2x1c2l2aXR5ID0gaW5jbHVzaXZpdHkgfHwgJygpJztcbiAgICAgICAgcmV0dXJuIChpbmNsdXNpdml0eVswXSA9PT0gJygnID8gdGhpcy5pc0FmdGVyKGZyb20sIHVuaXRzKSA6ICF0aGlzLmlzQmVmb3JlKGZyb20sIHVuaXRzKSkgJiZcbiAgICAgICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknID8gdGhpcy5pc0JlZm9yZSh0bywgdW5pdHMpIDogIXRoaXMuaXNBZnRlcih0bywgdW5pdHMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMgfHwgJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCx1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZiAoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgICAgIHZhciB0aGF0LFxuICAgICAgICAgICAgem9uZURlbHRhLFxuICAgICAgICAgICAgZGVsdGEsIG91dHB1dDtcblxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAneWVhcicgfHwgdW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpO1xuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0IC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWx0YSA9IHRoaXMgLSB0aGF0O1xuICAgICAgICAgICAgb3V0cHV0ID0gdW5pdHMgPT09ICdzZWNvbmQnID8gZGVsdGEgLyAxZTMgOiAvLyAxMDAwXG4gICAgICAgICAgICAgICAgdW5pdHMgPT09ICdtaW51dGUnID8gZGVsdGEgLyA2ZTQgOiAvLyAxMDAwICogNjBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2hvdXInID8gZGVsdGEgLyAzNmU1IDogLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2RheScgPyAoZGVsdGEgLSB6b25lRGVsdGEpIC8gODY0ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgdW5pdHMgPT09ICd3ZWVrJyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgICAgIGRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyKSArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgICAgIGFuY2hvcjIsIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgfVxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmcgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMuY2xvbmUoKS51dGMoKTtcbiAgICAgICAgaWYgKDAgPCBtLnllYXIoKSAmJiBtLnllYXIoKSA8PSA5OTk5KSB7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgICAgICBpZiAoIWlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKSA/IHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBsb2NhbF9fY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tKGxvY2FsX19jcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0byAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBsb2NhbF9fY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbiAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4gICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcbiAgICAgICAgLy8gdG8gdXRpbGl6ZSBmYWxsaW5nIHRocm91Z2ggdGhlIGNhc2VzLlxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRoaXMuaG91cnMoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGhpcy5taW51dGVzKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRzKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZHMoMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZWVrcyBhcmUgYSBzcGVjaWFsIGNhc2VcbiAgICAgICAgaWYgKHVuaXRzID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla2RheSgwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdHMgPT09ICdpc29XZWVrJykge1xuICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcXVhcnRlcnMgYXJlIGFsc28gc3BlY2lhbFxuICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgdGhpcy5tb250aChNYXRoLmZsb29yKHRoaXMubW9udGgoKSAvIDMpICogMyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRPZiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICdkYXRlJyBpcyBhbiBhbGlhcyBmb3IgJ2RheScsIHNvIGl0IHNob3VsZCBiZSBjb25zaWRlcmVkIGFzIHN1Y2guXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ2RhdGUnKSB7XG4gICAgICAgICAgICB1bml0cyA9ICdkYXknO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZih1bml0cykuYWRkKDEsICh1bml0cyA9PT0gJ2lzb1dlZWsnID8gJ3dlZWsnIDogdW5pdHMpKS5zdWJ0cmFjdCgxLCAnbXMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b190eXBlX192YWx1ZU9mICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfdmFsaWRfX2lzVmFsaWQgKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRfX2lzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0aW9uRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl9mLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgICAgICBzdHJpY3Q6IHRoaXMuX3N0cmljdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheSgpLFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdyxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgIGlucHV0LCB0aGlzLmlzb1dlZWsoKSwgdGhpcy5pc29XZWVrZGF5KCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtzVGFyZ2V0O1xuICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhckRhdGEgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgICAgICB0aGlzLm1vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSk7XG4gICAgICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdxdWFydGVyJywgNyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0UXVhcnRlciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuICAgIC8vIFBSSU9ST0lUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gbG9jYWxlLl9vcmRpbmFsUGFyc2UgOiBsb2NhbGUuX29yZGluYWxQYXJzZUxlbmllbnQ7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnRCcsICdERCddLCBEQVRFKTtcbiAgICBhZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdLCAxMCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdzZWNvbmQnLCAxNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbjtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIG1vbWVudFByb3RvdHlwZV9fcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xuXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZF9zdWJ0cmFjdF9fYWRkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2FsZW5kYXIgICAgICAgICAgPSBtb21lbnRfY2FsZW5kYXJfX2NhbGVuZGFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmVuZE9mICAgICAgICAgICAgID0gZW5kT2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZyb21Ob3cgICAgICAgICAgID0gZnJvbU5vdztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZ2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdHZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQmVmb3JlICAgICAgICAgID0gaXNCZWZvcmU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lT3JBZnRlciAgICAgPSBpc1NhbWVPckFmdGVyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVmFsaWQgICAgICAgICAgID0gbW9tZW50X3ZhbGlkX19pc1ZhbGlkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubGFuZyAgICAgICAgICAgICAgPSBsYW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgICAgICAgPSBsb2NhbGU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tYXggICAgICAgICAgICAgICA9IHByb3RvdHlwZU1heDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbiAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWluO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zZXQgICAgICAgICAgICAgICA9IHN0cmluZ1NldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN0YXJ0T2YgICAgICAgICAgID0gc3RhcnRPZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN1YnRyYWN0ICAgICAgICAgID0gYWRkX3N1YnRyYWN0X19zdWJ0cmFjdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0RhdGUgICAgICAgICAgICA9IHRvRGF0ZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvSVNPU3RyaW5nICAgICAgID0gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgICAgICA9IHRvSlNPTjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by52YWx1ZU9mICAgICAgICAgICA9IHRvX3R5cGVfX3ZhbHVlT2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcblxuICAgIC8vIFllYXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG5cbiAgICAvLyBXZWVrIFllYXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuXG4gICAgLy8gUXVhcnRlclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucXVhcnRlciA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuXG4gICAgLy8gTW9udGhcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuXG4gICAgLy8gV2Vla1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2VlayAgICAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuXG4gICAgLy8gRGF5XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheSAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG5cbiAgICAvLyBIb3VyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5ob3VyID0gbW9tZW50UHJvdG90eXBlX19wcm90by5ob3VycyA9IGdldFNldEhvdXI7XG5cbiAgICAvLyBNaW51dGVcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbnV0ZSA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcblxuICAgIC8vIFNlY29uZFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2Vjb25kID0gbW9tZW50UHJvdG90eXBlX19wcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xuXG4gICAgLy8gTWlsbGlzZWNvbmRcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kID0gbW9tZW50UHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcblxuICAgIC8vIE9mZnNldFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udXRjT2Zmc2V0ICAgICAgICAgICAgPSBnZXRTZXRPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucGFyc2Vab25lICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNMb2NhbCAgICAgICAgICAgICAgPSBpc0xvY2FsO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1VUQyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuXG4gICAgLy8gVGltZXpvbmVcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuXG4gICAgLy8gRGVwcmVjYXRpb25zXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsIGdldFNldFpvbmUpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKCdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJywgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKTtcblxuICAgIHZhciBtb21lbnRQcm90b3R5cGUgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvO1xuXG4gICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVVbml4IChpbnB1dCkge1xuICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVJblpvbmUgKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlX19wcm90byA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90b3R5cGVfX3Byb3RvLmNhbGVuZGFyICAgICAgICA9IGxvY2FsZV9jYWxlbmRhcl9fY2FsZW5kYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5sb25nRGF0ZUZvcm1hdCAgPSBsb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmludmFsaWREYXRlICAgICA9IGludmFsaWREYXRlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ub3JkaW5hbCAgICAgICAgID0gb3JkaW5hbDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnByZXBhcnNlICAgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnBvc3Rmb3JtYXQgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnJlbGF0aXZlVGltZSAgICA9IHJlbGF0aXZlX19yZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG90eXBlX19wcm90by5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uc2V0ICAgICAgICAgICAgID0gbG9jYWxlX3NldF9fc2V0O1xuXG4gICAgLy8gTW9udGhcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRocyAgICAgICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRocztcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1Nob3J0ICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzUGFyc2UgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzUGFyc2U7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNSZWdleCAgICAgICA9IG1vbnRoc1JlZ2V4O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzU2hvcnRSZWdleCAgPSBtb250aHNTaG9ydFJlZ2V4O1xuXG4gICAgLy8gV2Vla1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2VlayA9IGxvY2FsZVdlZWs7XG4gICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuICAgIC8vIERheSBvZiBXZWVrXG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzUmVnZXggICAgICAgPSAgICAgICAgd2Vla2RheXNSZWdleDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzU2hvcnRSZWdleCAgPSAgICAgICAgd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNNaW5SZWdleCAgICA9ICAgICAgICB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgLy8gSG91cnNcbiAgICBwcm90b3R5cGVfX3Byb3RvLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgIGZ1bmN0aW9uIGxpc3RzX19nZXQgKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoKTtcbiAgICAgICAgdmFyIHV0YyA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdHNfX2dldChmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gbGlzdHNfX2dldChmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8vICgpXG4gICAgLy8gKDUpXG4gICAgLy8gKGZtdCwgNSlcbiAgICAvLyAoZm10KVxuICAgIC8vICh0cnVlKVxuICAgIC8vICh0cnVlLCA1KVxuICAgIC8vICh0cnVlLCBmbXQsIDUpXG4gICAgLy8gKHRydWUsIGZtdClcbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpLFxuICAgICAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMDtcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RzX19nZXQoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gbGlzdHNfX2dldChmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RNb250aHNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5cyAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5c1Nob3J0IChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXNNaW4gKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicpO1xuICAgIH1cblxuICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUpO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUpO1xuXG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2Fic19fYWJzICgpIHtcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKGlucHV0LCB2YWx1ZSk7XG5cbiAgICAgICAgZHVyYXRpb24uX21pbGxpc2Vjb25kcyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbWlsbGlzZWNvbmRzO1xuICAgICAgICBkdXJhdGlvbi5fZGF5cyAgICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgICAgICBkdXJhdGlvbi5fbW9udGhzICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGQgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIHN1YnRyYWN0KDEsICdzJykgb3Igc3VidHJhY3QoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19zdWJ0cmFjdCAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0NlaWwgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSB0aGlzLl9kYXlzO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gdGhpcy5fbW9udGhzO1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgID0gdGhpcy5fZGF0YTtcbiAgICAgICAgdmFyIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycywgbW9udGhzRnJvbURheXM7XG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxuICAgICAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcbiAgICAgICAgaWYgKCEoKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKSkpIHtcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgbW9udGhzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICAgICAgc2Vjb25kcyAgICAgICAgICAgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgPSBzZWNvbmRzICUgNjA7XG5cbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgID0gaG91cnMgJSAyNDtcblxuICAgICAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICAgICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgICAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgZGF0YS5kYXlzICAgPSBkYXlzO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICAgICAgZGF0YS55ZWFycyAgPSB5ZWFycztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzVG9Nb250aHMgKGRheXMpIHtcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcbiAgICAgICAgcmV0dXJuIGRheXMgKiA0ODAwIC8gMTQ2MDk3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1RvRGF5cyAobW9udGhzKSB7XG4gICAgICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgICAgICByZXR1cm4gbW9udGhzICogMTQ2MDk3IC8gNDgwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcyAodW5pdHMpIHtcbiAgICAgICAgdmFyIGRheXM7XG4gICAgICAgIHZhciBtb250aHM7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIGRheXMgICA9IHRoaXMuX2RheXMgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICAgICAgcmV0dXJuIHVuaXRzID09PSAnbW9udGgnID8gbW9udGhzIDogbW9udGhzIC8gMTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnICAgOiByZXR1cm4gZGF5cyAvIDcgICAgICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RheScgICAgOiByZXR1cm4gZGF5cyAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZScgOiByZXR1cm4gZGF5cyAqIDE0NDAgICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCcgOiByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FzX192YWx1ZU9mICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzIChhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKTtcbiAgICB2YXIgYXNTZWNvbmRzICAgICAgPSBtYWtlQXMoJ3MnKTtcbiAgICB2YXIgYXNNaW51dGVzICAgICAgPSBtYWtlQXMoJ20nKTtcbiAgICB2YXIgYXNIb3VycyAgICAgICAgPSBtYWtlQXMoJ2gnKTtcbiAgICB2YXIgYXNEYXlzICAgICAgICAgPSBtYWtlQXMoJ2QnKTtcbiAgICB2YXIgYXNXZWVrcyAgICAgICAgPSBtYWtlQXMoJ3cnKTtcbiAgICB2YXIgYXNNb250aHMgICAgICAgPSBtYWtlQXMoJ00nKTtcbiAgICB2YXIgYXNZZWFycyAgICAgICAgPSBtYWtlQXMoJ3knKTtcblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2dldF9fZ2V0ICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHMgKyAncyddKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtuYW1lXTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XG4gICAgdmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbiAgICB2YXIgbWludXRlcyAgICAgID0gbWFrZUdldHRlcignbWludXRlcycpO1xuICAgIHZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xuICAgIHZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IG1ha2VHZXR0ZXIoJ21vbnRocycpO1xuICAgIHZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHZhciB0aHJlc2hvbGRzID0ge1xuICAgICAgICBzOiA0NSwgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgIG06IDQ1LCAgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgIGg6IDIyLCAgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgIGQ6IDI2LCAgLy8gZGF5cyB0byBtb250aFxuICAgICAgICBNOiAxMSAgIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG4gICAgZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX3JlbGF0aXZlVGltZSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKTtcbiAgICAgICAgdmFyIHNlY29uZHMgID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSk7XG4gICAgICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgICAgICB2YXIgaG91cnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKTtcbiAgICAgICAgdmFyIGRheXMgICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSk7XG4gICAgICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgICAgICB2YXIgeWVhcnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygneScpKTtcblxuICAgICAgICB2YXIgYSA9IHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8PSAxICAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPD0gMSAgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAmJiBbJ2hoJywgaG91cnNdICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPCB0aHJlc2hvbGRzLmQgJiYgWydkZCcsIGRheXNdICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8PSAxICAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICYmIFsnTU0nLCBtb250aHNdICB8fFxuICAgICAgICAgICAgICAgIHllYXJzICAgPD0gMSAgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyAocm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZihyb3VuZGluZ0Z1bmN0aW9uKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IGR1cmF0aW9uX2h1bWFuaXplX19yZWxhdGl2ZVRpbWUodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGlzb19zdHJpbmdfX2FicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gaXNvX3N0cmluZ19fdG9JU09TdHJpbmcoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICB2YXIgc2Vjb25kcyA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9tb250aHMpO1xuICAgICAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgbWludXRlcyAlPSA2MDtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgdmFyIFkgPSB5ZWFycztcbiAgICAgICAgdmFyIE0gPSBtb250aHM7XG4gICAgICAgIHZhciBEID0gZGF5cztcbiAgICAgICAgdmFyIGggPSBob3VycztcbiAgICAgICAgdmFyIG0gPSBtaW51dGVzO1xuICAgICAgICB2YXIgcyA9IHNlY29uZHM7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICh0b3RhbCA8IDAgPyAnLScgOiAnJykgK1xuICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgIChZID8gWSArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAoTSA/IE0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKEQgPyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChoID8gaCArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobSA/IG0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHMgPyBzICsgJ1MnIDogJycpO1xuICAgIH1cblxuICAgIHZhciBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hYnMgICAgICAgICAgICA9IGR1cmF0aW9uX2Fic19fYWJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYWRkICAgICAgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnN1YnRyYWN0ICAgICAgID0gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19zdWJ0cmFjdDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzICAgICAgICAgICAgID0gYXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICAgID0gZHVyYXRpb25fYXNfX3ZhbHVlT2Y7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmdldCAgICAgICAgICAgID0gZHVyYXRpb25fZ2V0X19nZXQ7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmhvdXJzICAgICAgICAgID0gaG91cnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5kYXlzICAgICAgICAgICA9IGRheXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubW9udGhzICAgICAgICAgPSBtb250aHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by55ZWFycyAgICAgICAgICA9IHllYXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSVNPU3RyaW5nICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b1N0cmluZyAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9KU09OICAgICAgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG4gICAgLy8gRGVwcmVjYXRpb25zXG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCBpc29fc3RyaW5nX190b0lTT1N0cmluZyk7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sYW5nID0gbGFuZztcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG4gICAgYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy52ZXJzaW9uID0gJzIuMTQuMSc7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2sobG9jYWxfX2NyZWF0ZUxvY2FsKTtcblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5mbiAgICAgICAgICAgICAgICAgICAgPSBtb21lbnRQcm90b3R5cGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcbiAgICB1dGlsc19ob29rc19faG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQztcbiAgICB1dGlsc19ob29rc19faG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gbW9tZW50X19jcmVhdGVVbml4O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tb250aHMgICAgICAgICAgICAgICAgPSBsaXN0c19fbGlzdE1vbnRocztcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pbnZhbGlkICAgICAgICAgICAgICAgPSB2YWxpZF9fY3JlYXRlSW52YWxpZDtcbiAgICB1dGlsc19ob29rc19faG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbjtcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzICAgICAgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IG1vbWVudF9fY3JlYXRlSW5ab25lO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc0R1cmF0aW9uICAgICAgICAgICAgPSBpc0R1cmF0aW9uO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0c19fbGlzdE1vbnRoc1Nob3J0O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzTWluO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZWZpbmVMb2NhbGUgICAgICAgICAgPSBkZWZpbmVMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZUxvY2FsZSAgICAgICAgICA9IHVwZGF0ZUxvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubG9jYWxlcyAgICAgICAgICAgICAgID0gbG9jYWxlX2xvY2FsZXNfX2xpc3RMb2NhbGVzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyA9IGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbiAgICB1dGlsc19ob29rc19faG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbiAgICB1dGlsc19ob29rc19faG9va3MuY2FsZW5kYXJGb3JtYXQgICAgICAgID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnByb3RvdHlwZSAgICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZTtcblxuICAgIHZhciBfbW9tZW50ID0gdXRpbHNfaG9va3NfX2hvb2tzO1xuXG4gICAgcmV0dXJuIF9tb21lbnQ7XG5cbn0pKTsiLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgR3JhcGggPSByZXF1aXJlKCcuLi9wcm9qZWN0aW9uL0dyYXBoJyk7XG5cbiAgICBMLkNSUy5HcmFwaCA9IEwuZXh0ZW5kKHt9LCBMLkNSUywge1xuXG4gICAgICAgIHByb2plY3Rpb246IEdyYXBoLFxuXG4gICAgICAgIHRyYW5zZm9ybWF0aW9uOiBuZXcgTC5UcmFuc2Zvcm1hdGlvbigxLCAwLCAxLCAwKSxcblxuICAgICAgICBpbmZpbml0ZTogZmFsc2UsXG5cbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uKHpvb20pIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdygyLCB6b29tKTtcbiAgICAgICAgfSxcblxuICAgICAgICB6b29tOiBmdW5jdGlvbihzY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3RhbmNlOiBmdW5jdGlvbihsYXRsbmcxLCBsYXRsbmcyKSB7XG4gICAgICAgICAgICBsZXQgZHggPSBsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nO1xuICAgICAgICAgICAgbGV0IGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEwuQ1JTLkdyYXBoO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIEdyYXBoOiByZXF1aXJlKCcuL0dyYXBoJylcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIE1hcDogcmVxdWlyZSgnLi9tYXAvTWFwJyksXG4gICAgICAgIFByb2plY3Rpb246IHJlcXVpcmUoJy4vcHJvamVjdGlvbi9leHBvcnRzJyksXG4gICAgICAgIENSUzogcmVxdWlyZSgnLi9DUlMvZXhwb3J0cycpLFxuICAgICAgICBUaWxlTGF5ZXI6IHJlcXVpcmUoJy4vbGF5ZXIvZXhwb3J0cycpLFxuICAgICAgICBSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlci9leHBvcnRzJyksXG4gICAgICAgIFRpbGVSZXF1ZXN0b3I6IHJlcXVpcmUoJy4vcmVxdWVzdC9UaWxlUmVxdWVzdG9yJyksXG4gICAgICAgIE1ldGFSZXF1ZXN0b3I6IHJlcXVpcmUoJy4vcmVxdWVzdC9NZXRhUmVxdWVzdG9yJyksXG4gICAgICAgIENvbG9yUmFtcDoge1xuICAgICAgICAgICAgLy8gZXhwb3NlIGFzIHN0YXRpYyBtZXRob2RcbiAgICAgICAgICAgIGdldENvbG9yUmFtcDogcmVxdWlyZSgnLi9yZW5kZXJlci9taXhpbi9Db2xvclJhbXAnKS5nZXRDb2xvclJhbXBcbiAgICAgICAgfVxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgc2V0RGF0ZUhpc3RvZ3JhbSA9IGZ1bmN0aW9uKGZpZWxkLCBmcm9tLCB0bywgaW50ZXJ2YWwpIHtcbiAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgJ0RhdGVIaXN0b2dyYW0gYGZpZWxkYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93ICdEYXRlSGlzdG9ncmFtIGBmcm9tYCBhcmUgbWlzc2luZyBmcm9tIGFyZ3VtZW50JztcbiAgICAgICAgfVxuICAgICAgICBpZiAodG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgJ0RhdGVIaXN0b2dyYW0gYHRvYCBhcmUgbWlzc2luZyBmcm9tIGFyZ3VtZW50JztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXJhbXMuZGF0ZV9oaXN0b2dyYW0gPSB7XG4gICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgdG86IHRvLFxuICAgICAgICAgICAgaW50ZXJ2YWw6IGludGVydmFsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xlYXJFeHRyZW1hKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBsZXQgZ2V0RGF0ZUhpc3RvZ3JhbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zLmRhdGVfaGlzdG9ncmFtO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgc2V0RGF0ZUhpc3RvZ3JhbTogc2V0RGF0ZUhpc3RvZ3JhbSxcbiAgICAgICAgZ2V0RGF0ZUhpc3RvZ3JhbTogZ2V0RGF0ZUhpc3RvZ3JhbVxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAoIW1ldGEuZXh0cmVtYSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdIaXN0b2dyYW0gYGZpZWxkYCAnICsgZmllbGQgKyAnIGlzIG5vdCBvcmRpbmFsIGluIG1ldGEgZGF0YSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnSGlzdG9ncmFtIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGxldCBzZXRIaXN0b2dyYW0gPSBmdW5jdGlvbihmaWVsZCwgaW50ZXJ2YWwpIHtcbiAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgJ0hpc3RvZ3JhbSBgZmllbGRgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhyb3cgJ0hpc3RvZ3JhbSBgaW50ZXJ2YWxgIGFyZSBtaXNzaW5nIGZyb20gYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRmllbGQodGhpcy5fbWV0YVtmaWVsZF0sIGZpZWxkKTtcbiAgICAgICAgdGhpcy5fcGFyYW1zLmhpc3RvZ3JhbSA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgIGludGVydmFsOiBpbnRlcnZhbFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsZWFyRXh0cmVtYSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgbGV0IGdldEhpc3RvZ3JhbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zLmhpc3RvZ3JhbTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHNldEhpc3RvZ3JhbTogc2V0SGlzdG9ncmFtLFxuICAgICAgICBnZXRIaXN0b2dyYW06IGdldEhpc3RvZ3JhbVxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgTUVUUklDUyA9IHtcbiAgICAgICAgJ21pbic6IHRydWUsXG4gICAgICAgICdtYXgnOiB0cnVlLFxuICAgICAgICAnc3VtJzogdHJ1ZSxcbiAgICAgICAgJ2F2Zyc6IHRydWVcbiAgICB9O1xuXG4gICAgbGV0IGNoZWNrRmllbGQgPSBmdW5jdGlvbihtZXRhLCBmaWVsZCkge1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgaWYgKCFtZXRhLmV4dHJlbWEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnTWV0cml4IGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3Qgb3JkaW5hbCBpbiBtZXRhIGRhdGEnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ01ldHJpYyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IHJlY29nbml6ZWQgaW4gbWV0YSBkYXRhJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgc2V0TWV0cmljID0gZnVuY3Rpb24oZmllbGQsIHR5cGUpIHtcbiAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgJ01ldHJpYyBgZmllbGRgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyAnTWV0cmljIGB0eXBlYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRmllbGQodGhpcy5fbWV0YVtmaWVsZF0sIGZpZWxkKTtcbiAgICAgICAgaWYgKCFNRVRSSUNTW3R5cGVdKSB7XG4gICAgICAgICAgICB0aHJvdyAnTWV0cmljIHR5cGUgYCcgKyB0eXBlICsgJ2AgaXMgbm90IHN1cHBvcnRlZCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFyYW1zLm1ldHJpYyA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGxldCBnZXRNZXRyaWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcy5tZXRyaWM7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvLyB0aWxpbmdcbiAgICAgICAgc2V0TWV0cmljOiBzZXRNZXRyaWMsXG4gICAgICAgIGdldE1ldHJpYzogZ2V0TWV0cmljLFxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAobWV0YS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93ICdUZXJtcyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IG9mIHR5cGUgYHN0cmluZ2AgaW4gbWV0YSBkYXRhJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93ICdUZXJtcyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IHJlY29nbml6ZWQgaW4gbWV0YSBkYXRhJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgc2V0VGVybXMgPSBmdW5jdGlvbihmaWVsZCwgc2l6ZSkge1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyAnVGVybXMgYGZpZWxkYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRmllbGQodGhpcy5fbWV0YVtmaWVsZF0sIGZpZWxkKTtcbiAgICAgICAgdGhpcy5fcGFyYW1zLnRlcm1zID0ge1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsZWFyRXh0cmVtYSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgbGV0IGdldFRlcm1zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbXMudGVybXM7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBzZXRUZXJtczogc2V0VGVybXMsXG4gICAgICAgIGdldFRlcm1zOiBnZXRUZXJtc1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAobWV0YS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93ICdUZXJtcyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IG9mIHR5cGUgYHN0cmluZ2AgaW4gbWV0YSBkYXRhJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93ICdUZXJtcyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IHJlY29nbml6ZWQgaW4gbWV0YSBkYXRhJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgc2V0VGVybXNGaWx0ZXIgPSBmdW5jdGlvbihmaWVsZCwgdGVybXMpIHtcbiAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgJ1Rlcm1zIGBmaWVsZGAgaXMgbWlzc2luZyBmcm9tIGFyZ3VtZW50JztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVybXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgJ1Rlcm1zIGB0ZXJtc2AgYXJlIG1pc3NpbmcgZnJvbSBhcmd1bWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tGaWVsZCh0aGlzLl9tZXRhW2ZpZWxkXSwgZmllbGQpO1xuICAgICAgICB0aGlzLl9wYXJhbXMudGVybXNfZmlsdGVyID0ge1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgdGVybXM6IHRlcm1zXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xlYXJFeHRyZW1hKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBsZXQgZ2V0VGVybXNGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcy50ZXJtc19maWx0ZXI7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBzZXRUZXJtc0ZpbHRlcjogc2V0VGVybXNGaWx0ZXIsXG4gICAgICAgIGdldFRlcm1zRmlsdGVyOiBnZXRUZXJtc0ZpbHRlclxuICAgIH07XG5cbn0oKSk7XG4iLCIvLyBQcm92aWRlcyB0b3AgaGl0cyBxdWVyeSBmdW5jdGlvbmFsaXR5LiAnc2l6ZScgaW5kaWNhdGVzIHRoZSBudW1iZXIgb2YgdG9wXG4vLyBoaXRzIHRvIHJldHVybiwgJ2luY2x1ZGUnIGlzIHRoZSBsaXN0IG9mIGZpZWxkcyB0byBpbmNsdWRlIGluIHRoZSByZXR1cm5lZFxuLy8gZGF0YSwgJ3NvcnQnIGlzIHRoZSBmaWVsZCB0byB1c2UgZm9yIHNvcnQgY3JpdGVyYSwgYW5kICdvcmRlcicgaXMgdmFsdWUgb2Zcbi8vICdhc2MnIG9yICdkZXNjJyB0byBpbmRpY2F0ZSBzb3J0IG9yZGVyaW5nLlxuKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IGNoZWNrRmllbGQgPSBmdW5jdGlvbihtZXRhLCBmaWVsZCkge1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgaWYgKCFtZXRhLmV4dHJlbWEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnUmFuZ2UgYGZpZWxkYCAnICsgZmllbGQgKyAnIGlzIG5vdCBvcmRpbmFsIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ1RvcFRlcm1zIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGxldCBzZXRUb3BIaXRzID0gZnVuY3Rpb24oc2l6ZSwgaW5jbHVkZSwgc29ydCwgb3JkZXIpIHtcbiAgICAgICAgaWYgKHNvcnQpIHtcbiAgICAgICAgICAgIGNoZWNrRmllbGQodGhpcy5fbWV0YVtzb3J0XSwgc29ydCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFyYW1zLnRvcF9oaXRzID0ge1xuICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgIGluY2x1ZGU6IGluY2x1ZGUsXG4gICAgICAgICAgICBzb3J0OiBzb3J0LFxuICAgICAgICAgICAgb3JkZXI6IG9yZGVyXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xlYXJFeHRyZW1hKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBsZXQgZ2V0VG9wSGl0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zLnRvcF9oaXRzO1xuICAgIH07XG5cbiAgICAvLyBiaW5kIHBvaW50IGZvciBleHRlcm5hbCBjb250cm9sc1xuICAgIGxldCBzZXRTb3J0RmllbGQgPSBmdW5jdGlvbihzb3J0KSB7XG4gICAgICAgIGlmICghc29ydCkge1xuICAgICAgICAgICAgdGhyb3cgJ1RvcEhpdHMgYHNvcnRgIGFyZ3VtZW50IGlzIG1pc3NpbmcnO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRmllbGQodGhpcy5fbWV0YVtzb3J0XSwgc29ydCk7XG4gICAgICAgIGlmIChzb3J0ICE9PSB0aGlzLl9wYXJhbXMudG9wX2hpdHMuc29ydCkge1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1zLnRvcF9oaXRzLnNvcnQgPSBzb3J0O1xuICAgICAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLy8gYmluZCBwb2ludCBmb3IgZXh0ZXJuYWwgY29udHJvbHNcbiAgICBsZXQgZ2V0U29ydEZpZWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbXMudG9wX2hpdHMuc29ydDtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHNldFRvcEhpdHM6IHNldFRvcEhpdHMsXG4gICAgICAgIGdldFRvcEhpdHM6IGdldFRvcEhpdHMsXG4gICAgICAgIHNldFNvcnRGaWVsZDogc2V0U29ydEZpZWxkLFxuICAgICAgICBnZXRTb3J0RmllbGQ6IGdldFNvcnRGaWVsZFxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAobWV0YS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93ICdUb3BUZXJtcyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IG9mIHR5cGUgYHN0cmluZ2AgaW4gbWV0YSBkYXRhJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93ICdUb3BUZXJtcyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IHJlY29nbml6ZWQgaW4gbWV0YSBkYXRhJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgc2V0VG9wVGVybXMgPSBmdW5jdGlvbihmaWVsZCwgc2l6ZSkge1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyAnVG9wVGVybXMgYGZpZWxkYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRmllbGQodGhpcy5fbWV0YVtmaWVsZF0sIGZpZWxkKTtcbiAgICAgICAgdGhpcy5fcGFyYW1zLnRvcF90ZXJtcyA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGxldCBnZXRUb3BUZXJtcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zLnRvcF90ZXJtcztcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHNldFRvcFRlcm1zOiBzZXRUb3BUZXJtcyxcbiAgICAgICAgZ2V0VG9wVGVybXM6IGdldFRvcFRlcm1zXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIG1vZChuLCBtKSB7XG4gICAgICAgIHJldHVybiAoKG4gJSBtKSArIG0pICUgbTtcbiAgICB9XG5cbiAgICBsZXQgQmFzZSA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgdG1zOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldE9wYWNpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5vcGFjaXR5O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5faGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9wcmV2TWFwLmFkZExheWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5faGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZNYXAgPSB0aGlzLl9tYXA7XG4gICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNIaWRkZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hpZGRlbjtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRCcmlnaHRuZXNzOiBmdW5jdGlvbihicmlnaHRuZXNzKSB7XG4gICAgICAgICAgICB0aGlzLl9icmlnaHRuZXNzID0gYnJpZ2h0bmVzcztcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5jc3MoJy13ZWJraXQtZmlsdGVyJywgJ2JyaWdodG5lc3MoJyArICh0aGlzLl9icmlnaHRuZXNzICogMTAwKSArICclKScpO1xuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLmNzcygnZmlsdGVyJywgJ2JyaWdodG5lc3MoJyArICh0aGlzLl9icmlnaHRuZXNzICogMTAwKSArICclKScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJyaWdodG5lc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9icmlnaHRuZXNzICE9PSB1bmRlZmluZWQpID8gdGhpcy5fYnJpZ2h0bmVzcyA6IDE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNUYXJnZXRMYXllcjogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jb250YWluZXIgPT09IGVsZW0gfHwgJC5jb250YWlucyh0aGlzLl9jb250YWluZXIsIGVsZW0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRMYXllclBvaW50RnJvbUxvbkxhdDogZnVuY3Rpb24obG9ubGF0UG9pbnQsIHpvb20pIHtcbiAgICAgICAgICAgIHpvb20gPSAoem9vbSAhPT0gdW5kZWZpbmVkKSA/IHpvb20gOiB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgbGV0IHBpeGVsID0gdGhpcy5fbWFwLnByb2plY3QobG9ubGF0UG9pbnQsIHpvb20pO1xuICAgICAgICAgICAgbGV0IHBvdyA9IE1hdGgucG93KDIsIHpvb20pO1xuICAgICAgICAgICAgbGV0IHRpbGVTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBtb2QocGl4ZWwueCwgcG93ICogdGlsZVNpemUpLFxuICAgICAgICAgICAgICAgIHk6IG1vZChwaXhlbC55LCBwb3cgKiB0aWxlU2l6ZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGF5ZXJQb2ludEZyb21FdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbGV0IGxvbmxhdCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXRMbmcoZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TGF5ZXJQb2ludEZyb21Mb25MYXQobG9ubGF0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRUaWxlQ29vcmRGcm9tTGF5ZXJQb2ludDogZnVuY3Rpb24obGF5ZXJQb2ludCkge1xuICAgICAgICAgICAgbGV0IHRpbGVTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBNYXRoLmZsb29yKGxheWVyUG9pbnQueCAvIHRpbGVTaXplKSxcbiAgICAgICAgICAgICAgICB5OiBNYXRoLmZsb29yKGxheWVyUG9pbnQueSAvIHRpbGVTaXplKSxcbiAgICAgICAgICAgICAgICB6OiB0aGlzLl9tYXAuZ2V0Wm9vbSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJpbkNvb3JkRnJvbUxheWVyUG9pbnQ6IGZ1bmN0aW9uKGxheWVyUG9pbnQsIHJlcykge1xuICAgICAgICAgICAgbGV0IHRpbGVTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuICAgICAgICAgICAgbGV0IHJlc29sdXRpb24gPSByZXMgfHwgdGhpcy5nZXRSZXNvbHV0aW9uKCkgfHwgdGlsZVNpemU7XG4gICAgICAgICAgICBsZXQgdHggPSBtb2QobGF5ZXJQb2ludC54LCB0aWxlU2l6ZSk7XG4gICAgICAgICAgICBsZXQgeSA9IHRoaXMub3B0aW9ucy50bXMgPyByZXNvbHV0aW9uIC0gbGF5ZXJQb2ludC55IDogbGF5ZXJQb2ludC55O1xuICAgICAgICAgICAgbGV0IHR5ID0gbW9kKHksIHRpbGVTaXplKTtcbiAgICAgICAgICAgIGxldCBwaXhlbFNpemUgPSB0aWxlU2l6ZSAvIHJlc29sdXRpb247XG4gICAgICAgICAgICBsZXQgYnggPSBNYXRoLmZsb29yKHR4IC8gcGl4ZWxTaXplKTtcbiAgICAgICAgICAgIGxldCBieSA9IE1hdGguZmxvb3IodHkgLyBwaXhlbFNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBieCxcbiAgICAgICAgICAgICAgICB5OiBieSxcbiAgICAgICAgICAgICAgICBpbmRleDogYnggKyAoYnkgKiByZXNvbHV0aW9uKSxcbiAgICAgICAgICAgICAgICBzaXplOiBwaXhlbFNpemVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FkZFRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgY29udGFpbmVyKSB7XG4gICAgICAgICAgICBsZXQgdGlsZVBvcyA9IHRoaXMuX2dldFRpbGVQb3MoY29vcmRzKTtcbiAgICAgICAgICAgIGxldCBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIHNvIHRoYXQgd2UgZG9uJ3QgcGFzcyBpbiB3cmFwcGVkIGNvb3JkcyBoZXJlXG4gICAgICAgICAgICBsZXQgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZShjb29yZHMsIEwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcykpO1xuICAgICAgICAgICAgdGhpcy5faW5pdFRpbGUodGlsZSk7XG4gICAgICAgICAgICAvLyBpZiBjcmVhdGVUaWxlIGlzIGRlZmluZWQgd2l0aCBhIHNlY29uZCBhcmd1bWVudCAoXCJkb25lXCIgY2FsbGJhY2spLFxuICAgICAgICAgICAgLy8gd2Uga25vdyB0aGF0IHRpbGUgaXMgYXN5bmMgYW5kIHdpbGwgYmUgcmVhZHkgbGF0ZXI7IG90aGVyd2lzZVxuICAgICAgICAgICAgaWYgKHRoaXMuY3JlYXRlVGlsZS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFyayB0aWxlIGFzIHJlYWR5LCBidXQgZGVsYXkgb25lIGZyYW1lIGZvciBvcGFjaXR5IGFuaW1hdGlvbiB0byBoYXBwZW5cbiAgICAgICAgICAgICAgICBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShMLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMsIG51bGwsIHRpbGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zKTtcbiAgICAgICAgICAgIC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuICAgICAgICAgICAgdGhpcy5fdGlsZXNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBlbDogdGlsZSxcbiAgICAgICAgICAgICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50OiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRpbGUpO1xuICAgICAgICAgICAgLy8gQGV2ZW50IHRpbGVsb2Fkc3RhcnQ6IFRpbGVFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVxdWVzdGVkIGFuZCBzdGFydHMgbG9hZGluZy5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZWxvYWRzdGFydCcsIHtcbiAgICAgICAgICAgICAgICB0aWxlOiB0aWxlLFxuICAgICAgICAgICAgICAgIGNvb3JkczogY29vcmRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gdmFsaWRUb0NvcHkoZnVuY05hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmNOYW1lICE9PSAnY29uc3RydWN0b3InICYmXG4gICAgICAgICAgICBmdW5jTmFtZSAhPT0gJ29uJyAmJlxuICAgICAgICAgICAgZnVuY05hbWUgIT09ICdvZmYnICYmXG4gICAgICAgICAgICBmdW5jTmFtZVswXSAhPT0gJ18nO1xuICAgIH1cblxuICAgIGxldCBDb21wb3NpdGUgPSBMLkNsYXNzLmV4dGVuZCh7XG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obGF5ZXJzID0gW10pIHtcbiAgICAgICAgICAgIGxldCBmdW5jdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIC8vIGdldCBhIGxpc3Qgb2YgYWxsIGZ1bmN0aW9ucyBmb3IgZWFjaCBsYXllclxuICAgICAgICAgICAgbGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgICAgICAgICAgIF8uZm9ySW4obGF5ZXIsICh2YWwsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbCkgJiYgdmFsaWRUb0NvcHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zW2tleV0gPSBmdW5jdGlvbnNba2V5XSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uc1trZXldLnB1c2gobGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHNldCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICB0aGlzLl9sYXllcnMgPSBsYXllcnM7XG4gICAgICAgICAgICB0aGlzLl9mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuICAgICAgICAgICAgLy8gZXh0ZW5kIHRoaXMgY29tcG9zaXRlIGNsYXNzIGZvciBlYWNoIGZ1bmN0aW9uXG4gICAgICAgICAgICBfLmZvckluKGZ1bmN0aW9ucywgKGxheWVycywgZnVuYykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4dGVuZChmdW5jKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uOiBmdW5jdGlvbihldnQsIGZ1bmMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgICAgICAgICAgICBsYXllci5vbihldnQsIGZ1bmMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldnRdID0gdGhpcy5faGFuZGxlcnNbZXZ0XSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2dF0ucHVzaChmdW5jKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvZmY6IGZ1bmN0aW9uKGV2dCwgZnVuYykge1xuICAgICAgICAgICAgbGV0IGhhbmRsZXJzID0gdGhpcy5faGFuZGxlcnNbZXZ0XTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGhhbmRsZXJzLmluZGV4T2YoZnVuYyk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnMuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIub2ZmKGV2dCwgZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5faGFuZGxlcnNbZXZ0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZXh0ZW5kOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICBsZXQgZnVuY3Rpb25zID0gdGhpcy5fZnVuY3Rpb25zO1xuICAgICAgICAgICAgdGhpc1tmdW5jXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGxldCBsYXllcnMgPSBmdW5jdGlvbnNbZnVuY107XG4gICAgICAgICAgICAgICAgbGV0IGxheWVyLCBpO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8bGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBsYXllcltmdW5jXS5hcHBseShsYXllciwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdCAhPT0gbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFN1YkxheWVyOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmdW5jdGlvbnMgPSB0aGlzLl9mdW5jdGlvbnM7XG4gICAgICAgICAgICBfLmZvckluKGxheWVyLCAodmFsLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhIGZ1bmN0aW9uIGFuZCB2YWxpZCB0byBjb3B5XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih2YWwpICYmIHZhbGlkVG9Db3B5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGxheWVyIHRvIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbnNba2V5XSA9IGZ1bmN0aW9uc1trZXldIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbnNba2V5XS5wdXNoKGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uc1trZXldLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYSBuZXcgZnVuY3Rpb24sIGV4dGVuZCB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHRlbmQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gYWRkIHRvIGxheWVyc1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgICAgICAgLy8gYWRkIGhhbmRsZXJzIHRvIGxheWVyXG4gICAgICAgICAgICBfLmZvckluKHRoaXMuX2hhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVycywgZXZ0KSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLm9uKGV2dCwgZnVuYyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVTdWJMYXllcjogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMuX2xheWVycy5pbmRleE9mKGxheWVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZnVuY3Rpb25zID0gdGhpcy5fZnVuY3Rpb25zO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBmdW5jdGlvbnMgdXNlZCBleGNsdXNpdmVseSBieSB0aGlzIGxheWVyXG4gICAgICAgICAgICBfLmZvckluKGxheWVyLCAodmFsLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbCkgJiYgdmFsaWRUb0NvcHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBmdW5jdGlvbnNba2V5XS5pbmRleE9mKGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gZnVuY3Rpb24gbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zW2tleV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBleGNsdXNpdmUgb3duZXIgb2YgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uc1trZXldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gbW9yZSB1c2UgZm9yIHRoaXMgZnVuY3Rpb24sIHJlbW92ZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZ1bmN0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGxheWVyXG4gICAgICAgICAgICB0aGlzLl9sYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBoYW5kbGVycyBmcm9tIGxheWVyXG4gICAgICAgICAgICBfLmZvckluKHRoaXMuX2hhbmRsZXJzLCAoaGFuZGxlcnMsIGV2dCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuYyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLm9mZihldnQsIGZ1bmMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ29tcG9zaXRlO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcblxuICAgIGxldCBEZWJ1ZyA9IEJhc2UuZXh0ZW5kKHtcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICB1bmxvYWRJbnZpc2libGVUaWxlczogdHJ1ZSxcbiAgICAgICAgICAgIHpJbmRleDogNTAwMFxuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIHNldCByZW5kZXJlclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnJlbmRlcmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnTm8gYHJlbmRlcmVyQ2xhc3NgIG9wdGlvbiBmb3VuZC4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSBleHRlbmRcbiAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCB0aGlzLCBvcHRpb25zLnJlbmRlcmVyQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IG9wdGlvbnNcbiAgICAgICAgICAgIEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGEgPGRpdj4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICAgICAgICAgICAgbGV0IHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC10aWxlJyk7XG4gICAgICAgICAgICAvLyBkcmF3IHRvIGl0XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRpbGUodGlsZSwgY29vcmQpO1xuICAgICAgICAgICAgLy8gcGFzcyB0aWxlIHRvIGNhbGxiYWNrXG4gICAgICAgICAgICByZXR1cm4gdGlsZTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEZWJ1ZztcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBJbWFnZSA9IEwuVGlsZUxheWVyLmV4dGVuZCh7XG5cbiAgICAgICAgZ2V0T3BhY2l0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm9wYWNpdHk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZNYXAuYWRkTGF5ZXIodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcHJldk1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0hpZGRlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGlkZGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEJyaWdodG5lc3M6IGZ1bmN0aW9uKGJyaWdodG5lc3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2JyaWdodG5lc3MgPSBicmlnaHRuZXNzO1xuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLmNzcygnLXdlYmtpdC1maWx0ZXInLCAnYnJpZ2h0bmVzcygnICsgKHRoaXMuX2JyaWdodG5lc3MgKiAxMDApICsgJyUpJyk7XG4gICAgICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikuY3NzKCdmaWx0ZXInLCAnYnJpZ2h0bmVzcygnICsgKHRoaXMuX2JyaWdodG5lc3MgKiAxMDApICsgJyUpJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QnJpZ2h0bmVzczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX2JyaWdodG5lc3MgIT09IHVuZGVmaW5lZCkgPyB0aGlzLl9icmlnaHRuZXNzIDogMTtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSW1hZ2U7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgYm9vbFF1ZXJ5Q2hlY2sgPSByZXF1aXJlKCcuLi9xdWVyeS9Cb29sJyk7XG5cbiAgICBmdW5jdGlvbiBtb2QobiwgbSkge1xuICAgICAgICByZXR1cm4gKChuICUgbSkgKyBtKSAlIG07XG4gICAgfVxuXG4gICAgbGV0IExpdmUgPSBMLkNsYXNzLmV4dGVuZCh7XG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB2YWwgPT4geyByZXR1cm4gdmFsOyB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obWV0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAvLyBzZXQgcmVuZGVyZXJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlbmRlcmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgZXh0ZW5kIGFuZCBpbml0aWFsaXplXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVuZGVyZXJDbGFzcy5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIgPSBuZXcgb3B0aW9ucy5yZW5kZXJlckNsYXNzKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIgPSBvcHRpb25zLnJlbmRlcmVyQ2xhc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGV4dGVuZCB0aGlzIG9iamVjdFxuICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIHRoaXMsIHJlbmRlcmVyKTtcbiAgICAgICAgICAgICAgICAvLyBjb3B5IHByb3RvdHlwZSBvcHRpb25zIHByb3BlcnR5IGJ5IHZhbHVlLCB0aGlzIGlzIGltcG9ydGFudFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnJlbmRlcmVyQ2xhc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgb3B0aW9uc1xuICAgICAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gc2V0IG1ldGFcbiAgICAgICAgICAgIHRoaXMuX21ldGEgPSBtZXRhO1xuICAgICAgICAgICAgLy8gc2V0IHBhcmFtc1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGJpbm5pbmc6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gc2V0IGV4dHJlbWEgLyBjYWNoZVxuICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJFeHRyZW1hKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJFeHRyZW1hOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2V4dHJlbWEgPSB7XG4gICAgICAgICAgICAgICAgbWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgICAgIG1heDogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRFeHRyZW1hOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHRyZW1hO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUV4dHJlbWE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGxldCBleHRyZW1hID0gdGhpcy5leHRyYWN0RXh0cmVtYShkYXRhKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXh0cmVtYS5taW4gPCB0aGlzLl9leHRyZW1hLm1pbikge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4dHJlbWEubWluID0gZXh0cmVtYS5taW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0cmVtYS5tYXggPiB0aGlzLl9leHRyZW1hLm1heCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4dHJlbWEubWF4ID0gZXh0cmVtYS5tYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICAgICAgfSxcblxuICAgICAgICBleHRyYWN0RXh0cmVtYTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IF8ubWluKGRhdGEpLFxuICAgICAgICAgICAgICAgIG1heDogXy5tYXgoZGF0YSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0UXVlcnk6IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAoIXF1ZXJ5Lm11c3QgJiYgIXF1ZXJ5Lm11c3Rfbm90ICYmICFxdWVyeS5zaG91bGQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnUm9vdCBxdWVyeSBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGBtdXN0YCwgYG11c3Rfbm90YCwgb3IgYHNob3VsZGAgYXJndW1lbnQuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgdGhlIHF1ZXJ5IGlzIHZhbGlkXG4gICAgICAgICAgICBib29sUXVlcnlDaGVjayh0aGlzLl9tZXRhLCBxdWVyeSk7XG4gICAgICAgICAgICAvLyBzZXQgcXVlcnlcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5tdXN0ID0gcXVlcnkubXVzdDtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5tdXN0X25vdCA9IHF1ZXJ5Lm11c3Rfbm90O1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1zLnNob3VsZCA9IHF1ZXJ5LnNob3VsZDtcbiAgICAgICAgICAgIC8vIGNsZWF0IGV4dHJlbWFcbiAgICAgICAgICAgIHRoaXMuY2xlYXJFeHRyZW1hKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0UXVlcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtdXN0OiB0aGlzLl9wYXJhbXMubXVzdCxcbiAgICAgICAgICAgICAgICBtdXN0X25vdDogdGhpcy5fcGFyYW1zLm11c3Rfbm90LFxuICAgICAgICAgICAgICAgIHNob3VsZDogdGhpcy5fcGFyYW1zLnNob3VsZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJRdWVyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBjbGVhciBxdWVyeVxuICAgICAgICAgICAgdGhpcy5fcGFyYW1zLm11c3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbXMubXVzdF9ub3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbXMuc2hvdWxkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gY2xlYXQgZXh0cmVtYVxuICAgICAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRNZXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXRhO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldE5vcm1hbGl6ZWRDb29yZHM6IGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgICAgICAgICAgbGV0IHBvdyA9IE1hdGgucG93KDIsIGNvb3Jkcy56KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogbW9kKGNvb3Jkcy54LCBwb3cpLFxuICAgICAgICAgICAgICAgIHk6IG1vZChjb29yZHMueSwgcG93KSxcbiAgICAgICAgICAgICAgICB6OiBjb29yZHMuelxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYWNoZUtleUZyb21Db29yZDogZnVuY3Rpb24oY29vcmRzLCBub3JtYWxpemUpIHtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBsZWFmbGV0IGxheWVyIHggYW5kIHkgbWF5IGJlID4gbl4yLCBhbmQgPCAwIGluIHRoZSBjYXNlXG4gICAgICAgICAgICAgICAgLy8gb2YgYSB3cmFwYXJvdW5kLiBJZiBub3JtYWxpemUgaXMgdHJ1ZSwgbW9kIHRoZSBjb29yZHNcbiAgICAgICAgICAgICAgICBjb29yZHMgPSB0aGlzLmdldE5vcm1hbGl6ZWRDb29yZHMoY29vcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb29yZHMueiArICc6JyArIGNvb3Jkcy54ICsgJzonICsgY29vcmRzLnk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29vcmRGcm9tQ2FjaGVLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgbGV0IGFyciA9IGtleS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBwYXJzZUludChhcnJbMV0sIDEwKSxcbiAgICAgICAgICAgICAgICB5OiBwYXJzZUludChhcnJbMl0sIDEwKSxcbiAgICAgICAgICAgICAgICB6OiBwYXJzZUludChhcnJbMF0sIDEwKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblRpbGVVbmxvYWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBsZXQgY29vcmRzID0gZXZlbnQuY29vcmRzO1xuICAgICAgICAgICAgLy8gcmVzcGVjdCB0aGUgVE1TIHNldHRpbmcgaW4gdGhlIG9wdGlvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XG4gICAgICAgICAgICAgICAgY29vcmRzID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBldmVudC5jb29yZHMueCxcbiAgICAgICAgICAgICAgICAgICAgeTogTWF0aC5wb3coMiwgZXZlbnQuY29vcmRzLnopIC0gMSAtIGV2ZW50LmNvb3Jkcy55LFxuICAgICAgICAgICAgICAgICAgICB6OiBldmVudC5jb29yZHMuelxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjYWNoZSBrZXkgZnJvbSBjb29yZHNcbiAgICAgICAgICAgIGxldCBrZXkgPSB0aGlzLmNhY2hlS2V5RnJvbUNvb3JkKGNvb3Jkcyk7XG4gICAgICAgICAgICAvLyBjYWNoZSBrZXkgZnJvbSBub3JtYWxpemVkIGNvb3Jkc1xuICAgICAgICAgICAgbGV0IG5rZXkgPSB0aGlzLmNhY2hlS2V5RnJvbUNvb3JkKGNvb3JkcywgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBnZXQgY2FjaGUgZW50cnlcbiAgICAgICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9jYWNoZVtua2V5XTtcbiAgICAgICAgICAgIC8vIGNvdWxkIHRoZSBiZSBjYXNlIHdoZXJlIHRoZSBjYWNoZSBpcyBjbGVhcmVkIGJlZm9yZSB0aWxlcyBhcmVcbiAgICAgICAgICAgIC8vIHVubG9hZGVkXG4gICAgICAgICAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgdGlsZSBmcm9tIHRoZSBjYWNoZVxuICAgICAgICAgICAgZGVsZXRlIGNhY2hlZC50aWxlc1trZXldO1xuICAgICAgICAgICAgLy8gZG9uJ3QgcmVtb3ZlIGNhY2hlIGVudHJ5IHVubGVzcyB0byB0aWxlcyB1c2UgaXQgYW55bW9yZVxuICAgICAgICAgICAgaWYgKF8ua2V5cyhjYWNoZWQudGlsZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgdGlsZSBiZWluZyBkZWxldGVkXG4gICAgICAgICAgICAgICAgbGV0IHRpbGUgPSBjYWNoZWQudGlsZXNba2V5XTtcbiAgICAgICAgICAgICAgICAvLyBubyBtb3JlIHRpbGVzIHVzZSB0aGlzIGNhY2hlZCBkYXRhLCBzbyBkZWxldGUgaXRcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2NhY2hldW5sb2FkJywge1xuICAgICAgICAgICAgICAgICAgICB0aWxlOiB0aWxlLFxuICAgICAgICAgICAgICAgICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgICAgICAgICAgICAgICAgZW50cnk6IGNhY2hlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWNoZVtua2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfcmVxdWVzdFRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgdGlsZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIHJlc3BlY3QgdGhlIFRNUyBzZXR0aW5nIGluIHRoZSBvcHRpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRtcykge1xuICAgICAgICAgICAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogY29vcmRzLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IE1hdGgucG93KDIsIGNvb3Jkcy56KSAtIDEgLSBjb29yZHMueSxcbiAgICAgICAgICAgICAgICAgICAgejogY29vcmRzLnpcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5jb29yZHMgPSB0aGlzLmdldE5vcm1hbGl6ZWRDb29yZHMoY29vcmRzKTtcbiAgICAgICAgICAgIC8vIGNhY2hlIGtleSBmcm9tIGNvb3Jkc1xuICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29vcmRzKTtcbiAgICAgICAgICAgIC8vIGNhY2hlIGtleSBmcm9tIG5vcm1hbGl6ZWQgY29vcmRzXG4gICAgICAgICAgICBsZXQgbmtleSA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29vcmRzLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5fY2FjaGVbbmtleV07XG4gICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHRpbGUgdW5kZXIgbm9ybWFsaXplIGNvb3Jkc1xuICAgICAgICAgICAgICAgIGNhY2hlZC50aWxlc1trZXldID0gdGlsZTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlZC5pc1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FjaGUgZW50cnkgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdjYWNoZWhpdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGU6IHRpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5OiBjYWNoZWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGlsZSBpcyBhbHJlYWR5IHBlbmRpbmcsIGFkZCBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWQuY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgY2FjaGUgZW50cnlcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZVtua2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaXNQZW5kaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aWxlczoge30sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogWyBjYWxsYmFjayBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGlsZSB0byB0aGUgY2FjaGUgZW50cnlcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZVtua2V5XS50aWxlc1trZXldID0gdGlsZTtcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IHRoZSB0aWxlXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0VGlsZShuY29vcmRzLCBkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX2NhY2hlW25rZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGlsZSBpcyBubyBsb25nZXIgYmVpbmcgdHJhY2tlZCwgaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZmxhZyBhcyBubyBsb25nZXIgcGVuZGluZ1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWQuaXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBhbmQgc3RvcmUgdGlsZSBkYXRhIGluIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZC5kYXRhID0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhlY3V0ZSBwZW5kaW5nIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWQuY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZC5jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBpcyBsb2FkZWQgaW50byBjYWNoZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2NhY2hlbG9hZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGU6IHRpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5OiBjYWNoZWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBleHRyZW1hXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51cGRhdGVFeHRyZW1hKGNhY2hlZC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGV4dHJlbWEgY2hhbmdlZCwgZmlyZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnZXh0cmVtYWNoYW5nZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZTogdGlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzOiBjb29yZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5OiBjYWNoZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlcXVlc3RUaWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaXZlO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcblxuICAgIGZ1bmN0aW9uIG1vZChuLCBtKSB7XG4gICAgICAgIHJldHVybiAoKG4gJSBtKSArIG0pICUgbTtcbiAgICB9XG5cbiAgICBsZXQgUGVuZGluZyA9IEJhc2UuZXh0ZW5kKHtcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICB1bmxvYWRJbnZpc2libGVUaWxlczogdHJ1ZSxcbiAgICAgICAgICAgIHpJbmRleDogNTAwMFxuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdUaWxlcyA9IHt9O1xuICAgICAgICAgICAgLy8gc2V0IHJlbmRlcmVyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucmVuZGVyZXJDbGFzcykge1xuICAgICAgICAgICAgICAgIHRocm93ICdObyBgcmVuZGVyZXJDbGFzc2Agb3B0aW9uIGZvdW5kLic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGV4dGVuZFxuICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIHRoaXMsIG9wdGlvbnMucmVuZGVyZXJDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgb3B0aW9uc1xuICAgICAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZDogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLl9pbmNyZW1lbnRIYW5kbGVyID0gdGlsZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5jcmVtZW50KHRpbGUuY29vcmRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsYXllci5fZGVjcmVtZW50SGFuZGxlciA9IHRpbGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlY3JlbWVudCh0aWxlLmNvb3Jkcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGF5ZXIub24oJ3RpbGVzdGFydGxvYWQnLCBsYXllci5faW5jcmVtZW50SGFuZGxlcik7XG4gICAgICAgICAgICBsYXllci5vbigndGlsZWxvYWQnLCBsYXllci5fZGVjcmVtZW50SGFuZGxlcik7XG4gICAgICAgICAgICBsYXllci5vbigndGlsZWVycm9yJywgbGF5ZXIuX2RlY3JlbWVudEhhbmRsZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLm9mZigndGlsZXN0YXJ0bG9hZCcsIGxheWVyLl9pbmNyZW1lbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIGxheWVyLm9mZigndGlsZWxvYWQnLCBsYXllci5fZGVjcmVtZW50SGFuZGxlcik7XG4gICAgICAgICAgICBsYXllci5vZmYoJ3RpbGVlcnJvcicsIGxheWVyLl9kZWNyZW1lbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIGxheWVyLl9pbmNyZW1lbnRIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICAgIGxheWVyLl9kZWNyZW1lbnRIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5jcmVtZW50OiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICAgICAgbGV0IGhhc2ggPSB0aGlzLl9nZXRUaWxlSGFzaChjb29yZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ1RpbGVzW2hhc2hdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nVGlsZXNbaGFzaF0gPSAxO1xuICAgICAgICAgICAgICAgIGxldCB0aWxlcyA9IHRoaXMuX2dldFRpbGVzV2l0aEhhc2goaGFzaCk7XG4gICAgICAgICAgICAgICAgdGlsZXMuZm9yRWFjaCh0aWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGlsZShjb29yZCwgdGlsZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdUaWxlc1toYXNoXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kZWNyZW1lbnQ6IGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgICAgICBsZXQgaGFzaCA9IHRoaXMuX2dldFRpbGVIYXNoKGNvb3JkKTtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdUaWxlc1toYXNoXS0tO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdUaWxlc1toYXNoXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nVGlsZXNbaGFzaF07XG4gICAgICAgICAgICAgICAgbGV0IHRpbGVzID0gdGhpcy5fZ2V0VGlsZXNXaXRoSGFzaChoYXNoKTtcbiAgICAgICAgICAgICAgICB0aWxlcy5mb3JFYWNoKHRpbGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVUaWxlKGNvb3JkLCB0aWxlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0VGlsZUNsYXNzOiBmdW5jdGlvbihoYXNoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2xlYWZsZXQtcGVuZGluZy0nICsgaGFzaDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0Tm9ybWFsaXplZENvb3JkczogZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgICAgICBsZXQgcG93ID0gTWF0aC5wb3coMiwgY29vcmRzLnopO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBtb2QoY29vcmRzLngsIHBvdyksXG4gICAgICAgICAgICAgICAgeTogbW9kKGNvb3Jkcy55LCBwb3cpLFxuICAgICAgICAgICAgICAgIHo6IGNvb3Jkcy56XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRUaWxlSGFzaDogZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgICAgICBsZXQgbmNvb3JkcyA9IHRoaXMuX2dldE5vcm1hbGl6ZWRDb29yZHMoY29vcmRzKTtcbiAgICAgICAgICAgIHJldHVybiBuY29vcmRzLnogKyAnLScgKyBuY29vcmRzLnggKyAnLScgKyBuY29vcmRzLnk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFRpbGVzV2l0aEhhc2g6IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLl9nZXRUaWxlQ2xhc3MoaGFzaCk7XG4gICAgICAgICAgICBsZXQgdGlsZXMgPSBbXTtcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5maW5kKCcuJyArIGNsYXNzTmFtZSkuZWFjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGlsZXMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRpbGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVUaWxlOiBmdW5jdGlvbihjb29yZCwgdGlsZSkge1xuICAgICAgICAgICAgLy8gZ2V0IGhhc2hcbiAgICAgICAgICAgIGxldCBoYXNoID0gdGhpcy5fZ2V0VGlsZUhhc2goY29vcmQpO1xuICAgICAgICAgICAgJCh0aWxlKS5hZGRDbGFzcyh0aGlzLl9nZXRUaWxlQ2xhc3MoaGFzaCkgKyAnIHBlbmRpbmcnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nVGlsZXNbaGFzaF0gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaWxlKHRpbGUsIGNvb3JkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJCh0aWxlKS5yZW1vdmVDbGFzcygncGVuZGluZycpO1xuICAgICAgICAgICAgICAgIHRpbGUuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIDxkaXY+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAgICAgICAgICAgIGxldCB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdGlsZSBsZWFmbGV0LXRpbGUtcGVuZGluZycpO1xuICAgICAgICAgICAgLy8gZ2V0IGhhc2hcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRpbGUoY29vcmQsIHRpbGUpO1xuICAgICAgICAgICAgLy8gcGFzcyB0aWxlIHRvIGNhbGxiYWNrXG4gICAgICAgICAgICByZXR1cm4gdGlsZTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQZW5kaW5nO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gZGVidWcgdGlsZSBsYXllclxuICAgIGxldCBEZWJ1ZyA9IHJlcXVpcmUoJy4vY29yZS9EZWJ1ZycpO1xuXG4gICAgLy8gcGVuZGluZyB0aWxlIGxheWVyXG4gICAgbGV0IFBlbmRpbmcgPSByZXF1aXJlKCcuL2NvcmUvUGVuZGluZycpO1xuXG4gICAgLy8gaW1hZ2UgbGF5ZXJcbiAgICBsZXQgSW1hZ2UgPSByZXF1aXJlKCcuL2NvcmUvSW1hZ2UnKTtcblxuICAgIC8vIGNvbXBvc2l0ZSBsYXllclxuICAgIGxldCBDb21wb3NpdGUgPSByZXF1aXJlKCcuL2NvcmUvQ29tcG9zaXRlJyk7XG5cbiAgICAvLyBsaXZlIGxheWVyIC0gYmFzZSB0eXBlIGZvciBleHRlbnNpb25cbiAgICBsZXQgTGl2ZSA9IHJlcXVpcmUoJy4vY29yZS9MaXZlJyk7XG5cbiAgICAvLyBsaXZlIHRpbGUgbGF5ZXJzXG4gICAgbGV0IEhlYXRtYXAgPSByZXF1aXJlKCcuL3R5cGUvSGVhdG1hcCcpO1xuICAgIGxldCBUb3BUcmFpbHMgPSByZXF1aXJlKCcuL3R5cGUvVG9wVHJhaWxzJyk7XG4gICAgbGV0IFRvcENvdW50ID0gcmVxdWlyZSgnLi90eXBlL1RvcENvdW50Jyk7XG4gICAgbGV0IFRvcEZyZXF1ZW5jeSA9IHJlcXVpcmUoJy4vdHlwZS9Ub3BGcmVxdWVuY3knKTtcbiAgICBsZXQgVG9waWNDb3VudCA9IHJlcXVpcmUoJy4vdHlwZS9Ub3BpY0NvdW50Jyk7XG4gICAgbGV0IFRvcGljRnJlcXVlbmN5ID0gcmVxdWlyZSgnLi90eXBlL1RvcGljRnJlcXVlbmN5Jyk7XG4gICAgbGV0IFByZXZpZXcgPSByZXF1aXJlKCcuL3R5cGUvUHJldmlldycpO1xuICAgIGxldCBNYWNybyA9IHJlcXVpcmUoJy4vdHlwZS9NYWNybycpO1xuICAgIGxldCBNaWNybyA9IHJlcXVpcmUoJy4vdHlwZS9NaWNybycpO1xuICAgIGxldCBDb3VudCA9IHJlcXVpcmUoJy4vdHlwZS9Db3VudCcpO1xuICAgIGxldCBDb21tdW5pdHkgPSByZXF1aXJlKCcuL3R5cGUvQ29tbXVuaXR5Jyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgRGVidWc6IERlYnVnLFxuICAgICAgICBQZW5kaW5nOiBQZW5kaW5nLFxuICAgICAgICBJbWFnZTogSW1hZ2UsXG4gICAgICAgIENvbXBvc2l0ZTogQ29tcG9zaXRlLFxuICAgICAgICBMaXZlOiBMaXZlLFxuICAgICAgICBIZWF0bWFwOiBIZWF0bWFwLFxuICAgICAgICBUb3BDb3VudDogVG9wQ291bnQsXG4gICAgICAgIFRvcFRyYWlsczogVG9wVHJhaWxzLFxuICAgICAgICBUb3BGcmVxdWVuY3k6IFRvcEZyZXF1ZW5jeSxcbiAgICAgICAgVG9waWNDb3VudDogVG9waWNDb3VudCxcbiAgICAgICAgVG9waWNGcmVxdWVuY3k6IFRvcGljRnJlcXVlbmN5LFxuICAgICAgICBQcmV2aWV3OiBQcmV2aWV3LFxuICAgICAgICBNYWNybzogTWFjcm8sXG4gICAgICAgIE1pY3JvOiBNaWNybyxcbiAgICAgICAgQ291bnQ6IENvdW50LFxuICAgICAgICBDb21tdW5pdHk6IENvbW11bml0eVxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgREVGQVVMVF9SRVNPTFVUSU9OID0gMjU2O1xuXG4gICAgbGV0IFRpbGluZyA9IHJlcXVpcmUoJy4vVGlsaW5nJyk7XG5cbiAgICBsZXQgc2V0UmVzb2x1dGlvbiA9IGZ1bmN0aW9uKHJlc29sdXRpb24pIHtcbiAgICAgICAgaWYgKHJlc29sdXRpb24gIT09IHRoaXMuX3BhcmFtcy5iaW5uaW5nLnJlc29sdXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5iaW5uaW5nLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgbGV0IGdldFJlc29sdXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcy5iaW5uaW5nLnJlc29sdXRpb24gfHwgREVGQVVMVF9SRVNPTFVUSU9OO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLy8gdGlsaW5nXG4gICAgICAgIHNldFhGaWVsZDogVGlsaW5nLnNldFhGaWVsZCxcbiAgICAgICAgZ2V0WEZpZWxkOiBUaWxpbmcuZ2V0WEZpZWxkLFxuICAgICAgICBzZXRZRmllbGQ6IFRpbGluZy5zZXRZRmllbGQsXG4gICAgICAgIGdldFlGaWVsZDogVGlsaW5nLmdldFlGaWVsZCxcbiAgICAgICAgZ2V0TGF5ZXJQb2ludEZyb21EYXRhUG9pbnQ6IFRpbGluZy5nZXRMYXllclBvaW50RnJvbURhdGFQb2ludCxcbiAgICAgICAgZ2V0RGF0YVBvaW50RnJvbUxheWVyUG9pbnQ6IFRpbGluZy5nZXREYXRhUG9pbnRGcm9tTGF5ZXJQb2ludCxcbiAgICAgICAgREVGQVVMVF9YX0ZJRUxEOiBUaWxpbmcuREVGQVVMVF9YX0ZJRUxELFxuICAgICAgICBERUZBVUxUX1lfRklFTEQ6IFRpbGluZy5ERUZBVUxUX1lfRklFTEQsXG4gICAgICAgIERFRkFVTFRfUElYRUxfTUFYOiBUaWxpbmcuREVGQVVMVF9QSVhFTF9NQVgsXG4gICAgICAgIC8vIGJpbm5pbmdcbiAgICAgICAgc2V0UmVzb2x1dGlvbjogc2V0UmVzb2x1dGlvbixcbiAgICAgICAgZ2V0UmVzb2x1dGlvbjogZ2V0UmVzb2x1dGlvbixcbiAgICAgICAgREVGQVVMVF9SRVNPTFVUSU9OOiBERUZBVUxUX1JFU09MVVRJT05cbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IGdldFR5cGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbXMuZWxhc3RpYyA/IHRoaXMuX3BhcmFtcy5lbGFzdGljLnR5cGUgOiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIGxldCBzZXRUeXBlcyA9IGZ1bmN0aW9uKHR5cGVzKSB7XG4gICAgICAgIGlmICghdHlwZXMpIHtcbiAgICAgICAgICAgIHRocm93ICdRdWVyeVN0cmluZyBgdHlwZXNgIGFyZSBub3QgcHJvdmlkZWQuJztcbiAgICAgICAgfVxuICAgICAgICB0eXBlcyA9IEFycmF5LmlzQXJyYXkodHlwZXMpID8gdHlwZXMgOiBbIHR5cGVzIF07XG4gICAgICAgIHRoaXMuX3BhcmFtcy5lbGFzdGljID0ge1xuICAgICAgICAgICAgdHlwZXM6IHR5cGVzXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBzZXRUeXBlczogc2V0VHlwZXMsXG4gICAgICAgIGdldFR5cGVzOiBnZXRUeXBlc1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5cbiAgICBsZXQgREVGQVVMVF9USUxFX1NJWkUgPSAyNTY7XG4gICAgbGV0IERFRkFVTFRfWF9GSUVMRCA9ICdwaXhlbC54JztcbiAgICBsZXQgREVGQVVMVF9ZX0ZJRUxEID0gJ3BpeGVsLnknO1xuICAgIGxldCBERUZBVUxUX1BJWEVMX01JTiA9IDA7XG4gICAgbGV0IERFRkFVTFRfUElYRUxfTUFYID0gTWF0aC5wb3coMiwgMzIpO1xuXG4gICAgbGV0IGNoZWNrRmllbGQgPSBmdW5jdGlvbihtZXRhLCBmaWVsZCkge1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgaWYgKG1ldGEuZXh0cmVtYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnRmllbGQgYCcgKyBmaWVsZCArICdgIGlzIG5vdCBvcmRpbmFsIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ0ZpZWxkIGAnICsgZmllbGQgKyAnYCBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGxldCBzZXRYRmllbGQgPSBmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICBpZiAoZmllbGQgIT09IHRoaXMuX3BhcmFtcy5iaW5uaW5nLngpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZCA9PT0gREVGQVVMVF9YX0ZJRUxEKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgaWYgZGVmYXVsdFxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5iaW5uaW5nLnggPSBERUZBVUxUX1hfRklFTEQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zLmJpbm5pbmcubGVmdCA9IERFRkFVTFRfUElYRUxfTUlOO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5iaW5uaW5nLnJpZ2h0ID0gREVGQVVMVF9QSVhFTF9NQVg7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ldGEgPSB0aGlzLl9tZXRhW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tGaWVsZChtZXRhLCBmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zLmJpbm5pbmcueCA9IGZpZWxkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMuYmlubmluZy5sZWZ0ID0gbWV0YS5leHRyZW1hLm1pbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zLmJpbm5pbmcucmlnaHQgPSBtZXRhLmV4dHJlbWEubWF4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyRXh0cmVtYSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgbGV0IGdldFhGaWVsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zLmJpbm5pbmcueDtcbiAgICB9O1xuXG4gICAgbGV0IHNldFlGaWVsZCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgIGlmIChmaWVsZCAhPT0gdGhpcy5fcGFyYW1zLmJpbm5pbmcueSkge1xuICAgICAgICAgICAgaWYgKGZpZWxkID09PSBERUZBVUxUX1lfRklFTEQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXNldCBpZiBkZWZhdWx0XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zLmJpbm5pbmcueSA9IERFRkFVTFRfWV9GSUVMRDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMuYmlubmluZy5ib3R0b20gPSBERUZBVUxUX1BJWEVMX01BWDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMuYmlubmluZy50b3AgPSBERUZBVUxUX1BJWEVMX01JTjtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyRXh0cmVtYSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWV0YSA9IHRoaXMuX21ldGFbZmllbGRdO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0ZpZWxkKG1ldGEsIGZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMuYmlubmluZy55ID0gZmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5iaW5uaW5nLmJvdHRvbSA9IG1ldGEuZXh0cmVtYS5taW47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5iaW5uaW5nLnRvcCA9IG1ldGEuZXh0cmVtYS5tYXg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJFeHRyZW1hKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBsZXQgZ2V0WUZpZWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbXMuYmlubmluZy55O1xuICAgIH07XG5cbiAgICBsZXQgZ2V0TGF5ZXJQb2ludEZyb21EYXRhUG9pbnQgPSBmdW5jdGlvbih4LCB5LCB6b29tKSB7XG4gICAgICAgIGxldCBiaW5uaW5nID0gdGhpcy5fcGFyYW1zLmJpbm5pbmc7XG4gICAgICAgIGxldCB0aWxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZSB8fCBERUZBVUxUX1RJTEVfU0laRTtcbiAgICAgICAgbGV0IHBvdyA9IE1hdGgucG93KDIsIHpvb20pO1xuICAgICAgICBsZXQgZXh0ZW50ID0gdGlsZVNpemUgKiBwb3c7XG4gICAgICAgIGxldCBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cbiAgICAgICAgbGV0IGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcDtcbiAgICAgICAgaWYgKG1ldGFbYmlubmluZy54XS50eXBlID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgIGxlZnQgPSBtb21lbnQoYmlubmluZy5sZWZ0KS52YWx1ZU9mKCk7XG4gICAgICAgICAgICByaWdodCA9IG1vbWVudChiaW5uaW5nLnJpZ2h0KS52YWx1ZU9mKCk7XG4gICAgICAgICAgICB4ID0gbW9tZW50KHgpLnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBiaW5uaW5nLmxlZnQ7XG4gICAgICAgICAgICByaWdodCA9IGJpbm5pbmcucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFbYmlubmluZy55XS50eXBlID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgIGJvdHRvbSA9IG1vbWVudChiaW5uaW5nLmJvdHRvbSkudmFsdWVPZigpO1xuICAgICAgICAgICAgdG9wID0gbW9tZW50KGJpbm5pbmcudG9wKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICB5ID0gbW9tZW50KHkpLnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvdHRvbSA9IGJpbm5pbmcuYm90dG9tO1xuICAgICAgICAgICAgdG9wID0gYmlubmluZy50b3A7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgeFJhbmdlID0gTWF0aC5hYnMocmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgbGV0IHlSYW5nZSA9IE1hdGguYWJzKGJvdHRvbSAtIHRvcCk7XG4gICAgICAgIGxldCBueCwgbnk7XG4gICAgICAgIGlmIChsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgICAgIG54ID0gMSAtICgoeCAtIHJpZ2h0KSAvIHhSYW5nZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBueCA9ICh4IC0gbGVmdCkgLyB4UmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvcCA+IGJvdHRvbSkge1xuICAgICAgICAgICAgbnkgPSAxIC0gKCh5IC0gYm90dG9tKSAvIHlSYW5nZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBueSA9ICh5IC0gdG9wKSAvIHlSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogZXh0ZW50ICogbngsXG4gICAgICAgICAgICB5OiBleHRlbnQgKiBueVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBsZXQgZ2V0RGF0YVBvaW50RnJvbUxheWVyUG9pbnQgPSBmdW5jdGlvbih4LCB5LCB6b29tKSB7XG4gICAgICAgIGxldCBiaW5uaW5nID0gdGhpcy5fcGFyYW1zLmJpbm5pbmc7XG4gICAgICAgIGxldCB0aWxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZSB8fCBERUZBVUxUX1RJTEVfU0laRTtcbiAgICAgICAgbGV0IHBvdyA9IE1hdGgucG93KDIsIHpvb20pO1xuICAgICAgICBsZXQgZXh0ZW50ID0gdGlsZVNpemUgKiBwb3c7XG4gICAgICAgIGxldCBueCA9IHggLyBleHRlbnQ7XG4gICAgICAgIGxldCBueSA9IHkgLyBleHRlbnQ7XG4gICAgICAgIGxldCB4UmFuZ2UgPSBNYXRoLmFicyhiaW5uaW5nLnJpZ2h0IC0gYmlubmluZy5sZWZ0KTtcbiAgICAgICAgbGV0IHlSYW5nZSA9IE1hdGguYWJzKGJpbm5pbmcuYm90dG9tIC0gYmlubmluZy50b3ApO1xuICAgICAgICBsZXQgcHgsIHB5O1xuICAgICAgICBpZiAoYmlubmluZy5sZWZ0ID4gYmlubmluZy5yaWdodCkge1xuICAgICAgICAgICAgcHggPSBiaW5uaW5nLnJpZ2h0ICsgKDEgLSBueCkgKiB4UmFuZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBweCA9IGJpbm5pbmcubGVmdCArIG54ICogeFJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaW5uaW5nLnRvcCA+IGJpbm5pbmcuYm90dG9tKSB7XG4gICAgICAgICAgICBweSA9IGJpbm5pbmcuYm90dG9tICsgKDEgLSBueSkgKiB5UmFuZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBweSA9IGJpbm5pbmcudG9wICsgbnkgKiB5UmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHB4LFxuICAgICAgICAgICAgeTogcHlcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHNldFhGaWVsZDogc2V0WEZpZWxkLFxuICAgICAgICBnZXRYRmllbGQ6IGdldFhGaWVsZCxcbiAgICAgICAgc2V0WUZpZWxkOiBzZXRZRmllbGQsXG4gICAgICAgIGdldFlGaWVsZDogZ2V0WUZpZWxkLFxuICAgICAgICBnZXRMYXllclBvaW50RnJvbURhdGFQb2ludDogZ2V0TGF5ZXJQb2ludEZyb21EYXRhUG9pbnQsXG4gICAgICAgIGdldERhdGFQb2ludEZyb21MYXllclBvaW50OiBnZXREYXRhUG9pbnRGcm9tTGF5ZXJQb2ludCxcbiAgICAgICAgREVGQVVMVF9YX0ZJRUxEOiBERUZBVUxUX1hfRklFTEQsXG4gICAgICAgIERFRkFVTFRfWV9GSUVMRDogREVGQVVMVF9ZX0ZJRUxELFxuICAgICAgICBERUZBVUxUX1BJWEVMX01BWDogREVGQVVMVF9QSVhFTF9NQVhcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IGNoZWNrO1xuXG4gICAgZnVuY3Rpb24gY2hlY2tRdWVyeShtZXRhLCBxdWVyeSkge1xuICAgICAgICBsZXQga2V5cyA9IF8ua2V5cyhxdWVyeSk7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgJ0Jvb2wgc3ViLXF1ZXJ5IG11c3Qgb25seSBoYXZlIGEgc2luZ2xlIGtleSwgcXVlcnkgaGFzIG11bHRpcGxlIGtleXM6IGAnICsgSlNPTi5zdHJpbmdpZnkoa2V5cykgKyAnYC4nO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0ga2V5c1swXTtcbiAgICAgICAgbGV0IGNoZWNrRnVuYyA9IGNoZWNrW3R5cGVdO1xuICAgICAgICBpZiAoIWNoZWNrRnVuYykge1xuICAgICAgICAgICAgdGhyb3cgJ1F1ZXJ5IHR5cGUgYCcgKyB0eXBlICsgJ2AgaXMgbm90IHJlY29nbml6ZWQuJztcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBxdWVyeSBieSB0eXBlXG4gICAgICAgIGNoZWNrW3R5cGVdKG1ldGEsIHF1ZXJ5W3R5cGVdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1F1ZXJpZXMobWV0YSwgcXVlcmllcykge1xuICAgICAgICBpZiAoXy5pc0FycmF5KHF1ZXJpZXMpKSB7XG4gICAgICAgICAgICBxdWVyaWVzLmZvckVhY2gocXVlcnkgPT4ge1xuICAgICAgICAgICAgICAgIGNoZWNrUXVlcnkobWV0YSxxdWVyeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBxdWVyaWVzO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrUXVlcnkobWV0YSwgcXVlcmllcyk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBxdWVyaWVzXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tCb29sKG1ldGEsIHF1ZXJ5KSB7XG4gICAgICAgIGlmICghcXVlcnkubXVzdCAmJiAhcXVlcnkubXVzdF9ub3QgJiYgIXF1ZXJ5LnNob3VsZCkge1xuICAgICAgICAgICAgdGhyb3cgJ0Jvb2wgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBgbXVzdGAsIGBtdXN0X25vdGAsIG9yIGBzaG91bGRgIHF1ZXJ5IGFyZ3VtZW50Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5Lm11c3QpIHtcbiAgICAgICAgICAgIGNoZWNrUXVlcmllcyhtZXRhLCBxdWVyeS5tdXN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkubXVzdF9ub3QpIHtcbiAgICAgICAgICAgIGNoZWNrUXVlcmllcyhtZXRhLCBxdWVyeS5tdXN0X25vdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5LnNob3VsZCkge1xuICAgICAgICAgICAgY2hlY2tRdWVyaWVzKG1ldGEsIHF1ZXJ5LnNob3VsZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVjayA9IHtcbiAgICAgICAgYm9vbDogY2hlY2tCb29sLFxuICAgICAgICBleGlzdHM6IHJlcXVpcmUoJy4vRXhpc3RzJyksXG4gICAgICAgIHByZWZpeDogcmVxdWlyZSgnLi9QcmVmaXgnKSxcbiAgICAgICAgcXVlcnlfc3RyaW5nOiByZXF1aXJlKCcuL1F1ZXJ5U3RyaW5nJyksXG4gICAgICAgIHJhbmdlOiByZXF1aXJlKCcuL1JhbmdlJyksXG4gICAgICAgIHRlcm1zOiByZXF1aXJlKCcuL1Rlcm1zJyksXG4gICAgICAgIG1hdGNoOiByZXF1aXJlKCcuL01hdGNoJyksXG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gY2hlY2tCb29sO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IGNoZWNrRmllbGQgPSBmdW5jdGlvbihtZXRhLCBmaWVsZCkge1xuICAgICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgICAgIHRocm93ICdUZXJtcyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IHJlY29nbml6ZWQgaW4gbWV0YSBkYXRhLic7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRhLCBxdWVyeSkge1xuICAgICAgICBpZiAoIXF1ZXJ5LmZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyAnRXhpc3RzIGBmaWVsZGAgaXMgbWlzc2luZyBmcm9tIGFyZ3VtZW50Lic7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tGaWVsZChtZXRhW3F1ZXJ5LmZpZWxkXSwgcXVlcnkuZmllbGQpO1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAobWV0YS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93ICdNYXRjaCBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IGBzdHJpbmdgIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ01hdGNoIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEuJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1ldGEsIHF1ZXJ5KSB7XG4gICAgICAgIGlmICghcXVlcnkuZmllbGQpIHtcbiAgICAgICAgICAgIHRocm93ICdNYXRjaCBgZmllbGRgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcXVlcnkuc3RyaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyAnTWF0Y2ggYHN0cmluZ2AgaXMgbWlzc2luZyBmcm9tIGFyZ3VtZW50Lic7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tGaWVsZChtZXRhW3F1ZXJ5LmZpZWxkXSwgcXVlcnkuZmllbGQpO1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAobWV0YS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93ICdQcmVmaXggYGZpZWxkYCAnICsgZmllbGQgKyAnIGlzIG5vdCBvZiB0eXBlIGBzdHJpbmdgIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ1ByZWZpeCBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IHJlY29nbml6ZWQgaW4gbWV0YSBkYXRhLic7XG4gICAgICAgIH0gICAgICAgIFxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1ldGEsIHF1ZXJ5KSB7XG4gICAgICAgIGlmICghcXVlcnkuZmllbGQpIHtcbiAgICAgICAgICAgIHRocm93ICdQcmVmaXggYGZpZWxkYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWVyeS5wcmVmaXhlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyAnUHJlZml4IGBwcmVmaXhlc2AgYXJlIG1pc3NpbmcgZnJvbSBhcmd1bWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tGaWVsZChtZXRhW3F1ZXJ5LmZpZWxkXSwgcXVlcnkuZmllbGQpO1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAobWV0YS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93ICdRdWVyeVN0cmluZyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IGBzdHJpbmdgIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ1F1ZXJ5U3RyaW5nIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEuJztcbiAgICAgICAgfSAgICAgICAgXG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0YSwgcXVlcnkpIHtcbiAgICAgICAgaWYgKCFxdWVyeS5maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgJ1F1ZXJ5U3RyaW5nIGBmaWVsZGAgaXMgbWlzc2luZyBmcm9tIGFyZ3VtZW50Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFxdWVyeS5zdHJpbmcpIHtcbiAgICAgICAgICAgIHRocm93ICdRdWVyeVN0cmluZyBgc3RyaW5nYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQuJztcbiAgICAgICAgfVxuICAgICAgICBjaGVja0ZpZWxkKG1ldGFbcXVlcnkuZmllbGRdLCBxdWVyeS5maWVsZCk7XG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBjaGVja0ZpZWxkID0gZnVuY3Rpb24obWV0YSwgZmllbGQpIHtcbiAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgIGlmICghbWV0YS5leHRyZW1hKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1JhbmdlIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3Qgb3JkaW5hbCBpbiBtZXRhIGRhdGEuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93ICdSYW5nZSBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IHJlY29nbml6ZWQgaW4gbWV0YSBkYXRhLic7XG4gICAgICAgIH0gICAgICAgIFxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1ldGEsIHF1ZXJ5KSB7XG4gICAgICAgIGlmICghcXVlcnkuZmllbGQpIHtcbiAgICAgICAgICAgIHRocm93ICdSYW5nZSBgZmllbGRgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWVyeS5mcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93ICdSYW5nZSBgZnJvbWAgaXMgbWlzc2luZyBmcm9tIGFyZ3VtZW50Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5LnRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93ICdSYW5nZSBgdG9gIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudC4nO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRmllbGQobWV0YVtxdWVyeS5maWVsZF0sIHF1ZXJ5LmZpZWxkKTtcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IGNoZWNrRmllbGQgPSBmdW5jdGlvbihtZXRhLCBmaWVsZCkge1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgaWYgKG1ldGEudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVGVybXMgYGZpZWxkYCAnICsgZmllbGQgKyAnIGlzIG5vdCBvZiB0eXBlIGBzdHJpbmdgIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ1Rlcm1zIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEuJztcbiAgICAgICAgfSAgICBcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRhLCBxdWVyeSkge1xuICAgICAgICBpZiAoIXF1ZXJ5LmZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyAnVGVybXMgYGZpZWxkYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkudGVybXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgJ1Rlcm1zIGB0ZXJtc2AgYXJlIG1pc3NpbmcgZnJvbSBhcmd1bWVudC4nO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRmllbGQobWV0YVtxdWVyeS5maWVsZF0sIHF1ZXJ5LmZpZWxkKTtcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IExpdmUgPSByZXF1aXJlKCcuLi9jb3JlL0xpdmUnKTtcblxuICAgIGxldCBDb21tdW5pdHkgPSBMaXZlLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2NvbW11bml0eScsXG5cbiAgICAgICAgZXh0cmFjdEV4dHJlbWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIG1heDogLUluZmluaXR5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbW11bml0eTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBMaXZlID0gcmVxdWlyZSgnLi4vY29yZS9MaXZlJyk7XG4gICAgbGV0IEVsYXN0aWMgPSByZXF1aXJlKCcuLi9wYXJhbS9FbGFzdGljJyk7XG4gICAgbGV0IFRpbGluZyA9IHJlcXVpcmUoJy4uL3BhcmFtL1RpbGluZycpO1xuXG4gICAgbGV0IENvdW50ID0gTGl2ZS5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBwYXJhbXNcbiAgICAgICAgICAgIEVsYXN0aWMsXG4gICAgICAgICAgICBUaWxpbmdcbiAgICAgICAgXSxcblxuICAgICAgICB0eXBlOiAnY291bnQnLFxuXG4gICAgICAgIC8vIGV4dHJlbWUgbm90IHJlbGV2YW50IGZvciBjb3VudCB0aWxlXG4gICAgICAgIGV4dHJhY3RFeHRyZW1hOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWluOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBtYXg6IC1JbmZpbml0eVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb3VudDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBMaXZlID0gcmVxdWlyZSgnLi4vY29yZS9MaXZlJyk7XG4gICAgbGV0IEVsYXN0aWMgPSByZXF1aXJlKCcuLi9wYXJhbS9FbGFzdGljJyk7XG4gICAgbGV0IEJpbm5pbmcgPSByZXF1aXJlKCcuLi9wYXJhbS9CaW5uaW5nJyk7XG4gICAgbGV0IE1ldHJpYyA9IHJlcXVpcmUoJy4uL2FnZy9NZXRyaWMnKTtcblxuICAgIGxldCBIZWF0bWFwID0gTGl2ZS5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBwYXJhbXNcbiAgICAgICAgICAgIEVsYXN0aWMsXG4gICAgICAgICAgICBCaW5uaW5nLFxuICAgICAgICAgICAgLy8gYWdnc1xuICAgICAgICAgICAgTWV0cmljXG4gICAgICAgIF0sXG5cbiAgICAgICAgdHlwZTogJ2hlYXRtYXAnLFxuXG4gICAgICAgIGV4dHJhY3RFeHRyZW1hOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBsZXQgYmlucyA9IG5ldyBGbG9hdDY0QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1pbjogXy5taW4oYmlucyksXG4gICAgICAgICAgICAgICAgbWF4OiBfLm1heChiaW5zKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhlYXRtYXA7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgTGl2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvTGl2ZScpO1xuICAgIGxldCBFbGFzdGljID0gcmVxdWlyZSgnLi4vcGFyYW0vRWxhc3RpYycpO1xuICAgIGxldCBCaW5uaW5nID0gcmVxdWlyZSgnLi4vcGFyYW0vQmlubmluZycpO1xuXG4gICAgbGV0IE1hY3JvID0gTGl2ZS5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBwYXJhbXNcbiAgICAgICAgICAgIEVsYXN0aWMsXG4gICAgICAgICAgICBCaW5uaW5nXG4gICAgICAgIF0sXG5cbiAgICAgICAgdHlwZTogJ21hY3JvJyxcblxuICAgICAgICBleHRyYWN0RXh0cmVtYTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgbGV0IGJpbnMgPSBuZXcgRmxvYXQ2NEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IF8ubWluKGJpbnMpLFxuICAgICAgICAgICAgICAgIG1heDogXy5tYXgoYmlucylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNYWNybztcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBMaXZlID0gcmVxdWlyZSgnLi4vY29yZS9MaXZlJyk7XG4gICAgbGV0IEVsYXN0aWMgPSByZXF1aXJlKCcuLi9wYXJhbS9FbGFzdGljJyk7XG4gICAgbGV0IFRpbGluZyA9IHJlcXVpcmUoJy4uL3BhcmFtL1RpbGluZycpO1xuICAgIGxldCBUb3BIaXRzID0gcmVxdWlyZSgnLi4vYWdnL1RvcEhpdHMnKTtcblxuICAgIGxldCBNaWNybyA9IExpdmUuZXh0ZW5kKHtcblxuICAgICAgICBpbmNsdWRlczogW1xuICAgICAgICAgICAgLy8gcGFyYW1zXG4gICAgICAgICAgICBFbGFzdGljLFxuICAgICAgICAgICAgVGlsaW5nLFxuICAgICAgICAgICAgLy8gYWdnc1xuICAgICAgICAgICAgVG9wSGl0c1xuICAgICAgICBdLFxuXG4gICAgICAgIHR5cGU6ICdtaWNybycsXG5cbiAgICAgICAgLy8gZXh0cmVtZSBub3QgcmVsZXZhbnQgZm9yIG1pY3JvXG4gICAgICAgIGV4dHJhY3RFeHRyZW1hOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWluOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBtYXg6IC1JbmZpbml0eVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNaWNybztcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBMaXZlID0gcmVxdWlyZSgnLi4vY29yZS9MaXZlJyk7XG4gICAgbGV0IEVsYXN0aWMgPSByZXF1aXJlKCcuLi9wYXJhbS9FbGFzdGljJyk7XG4gICAgbGV0IEJpbm5pbmcgPSByZXF1aXJlKCcuLi9wYXJhbS9CaW5uaW5nJyk7XG4gICAgbGV0IFRvcEhpdHMgPSByZXF1aXJlKCcuLi9hZ2cvVG9wSGl0cycpO1xuXG4gICAgbGV0IFByZXZpZXcgPSBMaXZlLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIHBhcmFtc1xuICAgICAgICAgICAgRWxhc3RpYyxcbiAgICAgICAgICAgIEJpbm5pbmcsXG4gICAgICAgICAgICAvLyBhZ2dzXG4gICAgICAgICAgICBUb3BIaXRzXG4gICAgICAgIF0sXG5cbiAgICAgICAgdHlwZTogJ3ByZXZpZXcnLFxuXG4gICAgICAgIC8vIGV4dHJlbWUgbm90IHJlbGV2YW50IGZvciBwcmV2aWV3XG4gICAgICAgIGV4dHJhY3RFeHRyZW1hOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWluOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBtYXg6IC1JbmZpbml0eVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQcmV2aWV3O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IExpdmUgPSByZXF1aXJlKCcuLi9jb3JlL0xpdmUnKTtcbiAgICBsZXQgRWxhc3RpYyA9IHJlcXVpcmUoJy4uL3BhcmFtL0VsYXN0aWMnKTtcbiAgICBsZXQgVGlsaW5nID0gcmVxdWlyZSgnLi4vcGFyYW0vVGlsaW5nJyk7XG4gICAgbGV0IFRvcFRlcm1zID0gcmVxdWlyZSgnLi4vYWdnL1RvcFRlcm1zJyk7XG4gICAgbGV0IEhpc3RvZ3JhbSA9IHJlcXVpcmUoJy4uL2FnZy9IaXN0b2dyYW0nKTtcblxuICAgIGxldCBUb3BDb3VudCA9IExpdmUuZXh0ZW5kKHtcblxuICAgICAgICBpbmNsdWRlczogW1xuICAgICAgICAgICAgLy8gcGFyYW1zXG4gICAgICAgICAgICBFbGFzdGljLFxuICAgICAgICAgICAgVGlsaW5nLFxuICAgICAgICAgICAgVG9wVGVybXMsXG4gICAgICAgICAgICAvLyBhZ2dzXG4gICAgICAgICAgICBIaXN0b2dyYW1cbiAgICAgICAgXSxcblxuICAgICAgICB0eXBlOiAndG9wX2NvdW50J1xuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvcENvdW50O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IExpdmUgPSByZXF1aXJlKCcuLi9jb3JlL0xpdmUnKTtcbiAgICBsZXQgRWxhc3RpYyA9IHJlcXVpcmUoJy4uL3BhcmFtL0VsYXN0aWMnKTtcbiAgICBsZXQgVGlsaW5nID0gcmVxdWlyZSgnLi4vcGFyYW0vVGlsaW5nJyk7XG4gICAgbGV0IFRvcFRlcm1zID0gcmVxdWlyZSgnLi4vYWdnL1RvcFRlcm1zJyk7XG4gICAgbGV0IERhdGVIaXN0b2dyYW0gPSByZXF1aXJlKCcuLi9hZ2cvRGF0ZUhpc3RvZ3JhbScpO1xuICAgIGxldCBIaXN0b2dyYW0gPSByZXF1aXJlKCcuLi9hZ2cvSGlzdG9ncmFtJyk7XG5cbiAgICBsZXQgVG9wRnJlcXVlbmN5ID0gTGl2ZS5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBwYXJhbXNcbiAgICAgICAgICAgIEVsYXN0aWMsXG4gICAgICAgICAgICBUaWxpbmcsXG4gICAgICAgICAgICAvLyBhZ2dzXG4gICAgICAgICAgICBUb3BUZXJtcyxcbiAgICAgICAgICAgIERhdGVIaXN0b2dyYW0sXG4gICAgICAgICAgICBIaXN0b2dyYW1cbiAgICAgICAgXSxcblxuICAgICAgICB0eXBlOiAndG9wX2ZyZXF1ZW5jeScsXG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVG9wRnJlcXVlbmN5O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IExpdmUgPSByZXF1aXJlKCcuLi9jb3JlL0xpdmUnKTtcbiAgICBsZXQgRWxhc3RpYyA9IHJlcXVpcmUoJy4uL3BhcmFtL0VsYXN0aWMnKTtcbiAgICBsZXQgQmlubmluZyA9IHJlcXVpcmUoJy4uL3BhcmFtL0Jpbm5pbmcnKTtcbiAgICBsZXQgVGVybXMgPSByZXF1aXJlKCcuLi9hZ2cvVGVybXMnKTtcblxuICAgIGxldCBUb3BUcmFpbHMgPSBMaXZlLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIHBhcmFtc1xuICAgICAgICAgICAgRWxhc3RpYyxcbiAgICAgICAgICAgIEJpbm5pbmcsXG4gICAgICAgICAgICAvLyBhZ2dzXG4gICAgICAgICAgICBUZXJtc1xuICAgICAgICBdLFxuXG4gICAgICAgIHR5cGU6ICd0b3BfdHJhaWxzJyxcblxuICAgICAgICBleHRyYWN0RXh0cmVtYTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1pbjogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgbWF4OiAtSW5maW5pdHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUb3BUcmFpbHM7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgTGl2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvTGl2ZScpO1xuICAgIGxldCBFbGFzdGljID0gcmVxdWlyZSgnLi4vcGFyYW0vRWxhc3RpYycpO1xuICAgIGxldCBUaWxpbmcgPSByZXF1aXJlKCcuLi9wYXJhbS9UaWxpbmcnKTtcbiAgICBsZXQgVGVybXNGaWx0ZXIgPSByZXF1aXJlKCcuLi9hZ2cvVGVybXNGaWx0ZXInKTtcbiAgICBsZXQgSGlzdG9ncmFtID0gcmVxdWlyZSgnLi4vYWdnL0hpc3RvZ3JhbScpO1xuXG4gICAgbGV0IFRvcGljQ291bnQgPSBMaXZlLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIHBhcmFtc1xuICAgICAgICAgICAgRWxhc3RpYyxcbiAgICAgICAgICAgIFRpbGluZyxcbiAgICAgICAgICAgIC8vIGFnZ3NcbiAgICAgICAgICAgIFRlcm1zRmlsdGVyLFxuICAgICAgICAgICAgSGlzdG9ncmFtLFxuICAgICAgICBdLFxuXG4gICAgICAgIHR5cGU6ICd0b3BpY19jb3VudCcsXG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVG9waWNDb3VudDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBMaXZlID0gcmVxdWlyZSgnLi4vY29yZS9MaXZlJyk7XG4gICAgbGV0IEVsYXN0aWMgPSByZXF1aXJlKCcuLi9wYXJhbS9FbGFzdGljJyk7XG4gICAgbGV0IFRpbGluZyA9IHJlcXVpcmUoJy4uL3BhcmFtL1RpbGluZycpO1xuICAgIGxldCBUZXJtc0ZpbHRlciA9IHJlcXVpcmUoJy4uL2FnZy9UZXJtc0ZpbHRlcicpO1xuICAgIGxldCBEYXRlSGlzdG9ncmFtID0gcmVxdWlyZSgnLi4vYWdnL0RhdGVIaXN0b2dyYW0nKTtcbiAgICBsZXQgSGlzdG9ncmFtID0gcmVxdWlyZSgnLi4vYWdnL0hpc3RvZ3JhbScpO1xuXG4gICAgbGV0IFRvcGljRnJlcXVlbmN5ID0gTGl2ZS5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBwYXJhbXMgICAgICAgICAgICBcbiAgICAgICAgICAgIEVsYXN0aWMsXG4gICAgICAgICAgICBUaWxpbmcsXG4gICAgICAgICAgICAvLyBhZ2dzXG4gICAgICAgICAgICBUZXJtc0ZpbHRlcixcbiAgICAgICAgICAgIERhdGVIaXN0b2dyYW0sXG4gICAgICAgICAgICBIaXN0b2dyYW1cbiAgICAgICAgXSxcblxuICAgICAgICB0eXBlOiAndG9waWNfZnJlcXVlbmN5J1xuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvcGljRnJlcXVlbmN5O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IHJlc2V0TW91c2VDdXJzb3JTdHlsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyB3ZSBvbmx5IHdhbnQgdGhpcyBib3VuZCBPTkNFIHBlciBtYXBcbiAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLmNzcygnY3Vyc29yJywgJycpO1xuICAgIH07XG5cbiAgICBsZXQgTWFwID0gTC5NYXAuZXh0ZW5kKHtcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEwuTWFwLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLm9uKCdtb3VzZW1vdmUnLCByZXNldE1vdXNlQ3Vyc29yU3R5bGUsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gTWFwO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gY2FydGVzaWFuIHByb2plY3Rpb24gaW4gKDAsMCksICgyNTYsIDI1NikgY29vcmRpbmF0ZSBzcGFjZVxuICAgIEwuUHJvamVjdGlvbi5HcmFwaCA9IHtcblxuICAgICAgICBwcm9qZWN0OiBmdW5jdGlvbihsYXRsbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTC5Qb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bnByb2plY3Q6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEwuTGF0TG5nKHBvaW50LnksIHBvaW50LngpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJvdW5kczogTC5ib3VuZHMoWzAsIDBdLCBbMjU2LCAyNTZdKVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEwuUHJvamVjdGlvbi5HcmFwaDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBET00gPSByZXF1aXJlKCcuL0RPTScpO1xuXG4gICAgbGV0IENhbnZhcyA9IERPTS5leHRlbmQoe1xuXG4gICAgICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgIERPTS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgLy8gaGFuZGxlcnNcbiAgICAgICAgICAgIG1hcC5vbignY2xpY2snLCB0aGlzLm9uQ2xpY2ssIHRoaXMpO1xuICAgICAgICAgICAgbWFwLm9uKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGVyc1xuICAgICAgICAgICAgbWFwLm9mZignY2xpY2snLCB0aGlzLm9uQ2xpY2ssIHRoaXMpO1xuICAgICAgICAgICAgbWFwLm9mZignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSwgdGhpcyk7XG4gICAgICAgICAgICBET00ucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMsIGRvbmUpIHtcbiAgICAgICAgICAgIGxldCB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICAgICAgICAgICAgdGlsZS5zdHlsZVsncG9pbnRlci1ldmVudHMnXSA9ICdhbGwnO1xuICAgICAgICAgICAgdGlsZS53aWR0aCA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcbiAgICAgICAgICAgIHRpbGUuaGVpZ2h0ID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdFRpbGUoY29vcmRzLCB0aWxlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZG9uZShudWxsLCB0aWxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJUaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsZXQgdGlsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG4gICAgICAgICAgICBfLmZvckluKHRoaXMuX3RpbGVzLCB0aWxlID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY3R4ID0gdGlsZS5lbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGlsZVNpemUsIHRpbGVTaXplKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2FudmFzO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IEJhc2UgPSByZXF1aXJlKCcuLi8uLi9sYXllci9jb3JlL0Jhc2UnKTtcblxuICAgIGxldCBET00gPSBCYXNlLmV4dGVuZCh7XG5cbiAgICAgICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgTC5HcmlkTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgICAgIG1hcC5vbignem9vbXN0YXJ0JywgdGhpcy5jbGVhckV4dHJlbWEsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMub25UaWxlVW5sb2FkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2NhY2hlbG9hZCcsIHRoaXMub25DYWNoZUxvYWQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbignY2FjaGVoaXQnLCB0aGlzLm9uQ2FjaGVIaXQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbignY2FjaGV1bmxvYWQnLCB0aGlzLm9uQ2FjaGVVbmxvYWQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbignZXh0cmVtYWNoYW5nZScsIHRoaXMub25FeHRyZW1hQ2hhbmdlLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICBMLkdyaWRMYXllci5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgbWFwLm9mZignem9vbXN0YXJ0JywgdGhpcy5jbGVhckV4dHJlbWEsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ3RpbGV1bmxvYWQnLCB0aGlzLm9uVGlsZVVubG9hZCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9mZignY2FjaGVsb2FkJywgdGhpcy5vbkNhY2hlTG9hZCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9mZignY2FjaGVoaXQnLCB0aGlzLm9uQ2FjaGVIaXQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2NhY2hldW5sb2FkJywgdGhpcy5vbkNhY2hlVW5sb2FkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdleHRyZW1hY2hhbmdlJywgdGhpcy5vbkV4dHJlbWFDaGFuZ2UsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2FjaGVIaXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBsZXQgY2FjaGVkID0gZXZlbnQuZW50cnk7XG4gICAgICAgICAgICBsZXQgdGlsZSA9IGV2ZW50LnRpbGU7XG4gICAgICAgICAgICBsZXQgY29vcmRzID0gZXZlbnQuY29vcmRzO1xuICAgICAgICAgICAgLy8gZGF0YSBleGlzdHMsIHJlbmRlciBvbmx5IHRoaXMgdGlsZVxuICAgICAgICAgICAgaWYgKGNhY2hlZC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaWxlKHRpbGUsIGNhY2hlZC5kYXRhLCBjb29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2FjaGVMb2FkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgLy8gc2FtZSBleHRyZW1hLCB3ZSBhcmUgZ29vZCB0byByZW5kZXIgdGhlIHRpbGVzLiBJblxuICAgICAgICAgICAgLy8gdGhlIGNhc2Ugb2YgYSBtYXAgd2l0aCB3cmFwYXJvdW5kLCB3ZSBtYXkgaGF2ZVxuICAgICAgICAgICAgLy8gbXVsdGlwbGUgdGlsZXMgZGVwZW5kZW50IG9uIHRoZSByZXNwb25zZSwgc28gaXRlcmF0ZVxuICAgICAgICAgICAgLy8gb3ZlciBlYWNoIHRpbGUgYW5kIGRyYXcgaXQuXG4gICAgICAgICAgICBsZXQgY2FjaGVkID0gZXZlbnQuZW50cnk7XG4gICAgICAgICAgICBsZXQgY29vcmRzID0gZXZlbnQuY29vcmRzO1xuICAgICAgICAgICAgaWYgKGNhY2hlZC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgXy5mb3JJbihjYWNoZWQudGlsZXMsIHRpbGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbGUodGlsZSwgY2FjaGVkLmRhdGEsIGNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25FeHRyZW1hQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHJlZHJhdyBhbGwgdGlsZXNcbiAgICAgICAgICAgIF8uZm9ySW4odGhpcy5fY2FjaGUsIGNhY2hlZCA9PiB7XG4gICAgICAgICAgICAgICAgXy5mb3JJbihjYWNoZWQudGlsZXMsICh0aWxlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbGUodGlsZSwgY2FjaGVkLmRhdGEsIHRoaXMuY29vcmRGcm9tQ2FjaGVLZXkoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2FjaGVVbmxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyVGlsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IERPTTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBET00gPSByZXF1aXJlKCcuL0RPTScpO1xuXG4gICAgbGV0IEhUTUwgPSBET00uZXh0ZW5kKHtcblxuICAgICAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICBET00ucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgICAgIC8vIGhhbmRsZXJzXG4gICAgICAgICAgICBtYXAub24oJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0aGlzKTtcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5vbignbW91c2Vtb3ZlJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25Nb3VzZU1vdmUoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikub24oJ21vdXNlb3ZlcicsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VPdmVyKGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLm9uKCdtb3VzZW91dCcsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VPdXQoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25SZW1vdmU6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgLy8gaGFuZGxlcnNcbiAgICAgICAgICAgIG1hcC5vZmYoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0aGlzKTtcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5vZmYoJ21vdXNlbW92ZScpO1xuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLm9mZignbW91c2VvdmVyJyk7XG4gICAgICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikub2ZmKCdtb3VzZW91dCcpO1xuICAgICAgICAgICAgRE9NLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzLCBkb25lKSB7XG4gICAgICAgICAgICBsZXQgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXRpbGUgbGVhZmxldC1odG1sLXRpbGUnKTtcbiAgICAgICAgICAgIHRpbGUud2lkdGggPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG4gICAgICAgICAgICB0aWxlLmhlaWdodCA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RUaWxlKGNvb3JkcywgdGlsZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRvbmUobnVsbCwgdGlsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU92ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSFRNTDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBCYXNlID0gcmVxdWlyZSgnLi4vLi4vbGF5ZXIvY29yZS9CYXNlJyk7XG5cbiAgICBsZXQgTk9fT1AgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgbGV0IE92ZXJsYXkgPSBCYXNlLmV4dGVuZCh7XG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgekluZGV4OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgdGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMub25UaWxlVW5sb2FkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2NhY2hlbG9hZCcsIHRoaXMub25DYWNoZUxvYWQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbignY2FjaGVoaXQnLCB0aGlzLm9uQ2FjaGVIaXQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbignY2FjaGV1bmxvYWQnLCB0aGlzLm9uQ2FjaGVVbmxvYWQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbignZXh0cmVtYWNoYW5nZScsIHRoaXMub25FeHRyZW1hQ2hhbmdlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVzID0ge307XG4gICAgICAgICAgICB0aGlzLl9pbml0Q29udGFpbmVyKCk7XG4gICAgICAgICAgICAvLyBhZGQgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICAgIG1hcC5vbignY2xpY2snLCB0aGlzLm9uQ2xpY2ssIHRoaXMpO1xuICAgICAgICAgICAgbWFwLm9uKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0VmlldygpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25SZW1vdmU6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGxheWVyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuICAgICAgICAgICAgTC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgbWFwLl9yZW1vdmVab29tTGltaXQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl90aWxlWm9vbSA9IG51bGw7XG4gICAgICAgICAgICAvLyByZW1vdmUgaGFuZGxlcnNcbiAgICAgICAgICAgIHRoaXMub2ZmKCd0aWxldW5sb2FkJywgdGhpcy5vblRpbGVVbmxvYWQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2NhY2hlbG9hZCcsIHRoaXMub25DYWNoZUxvYWQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2NhY2hlaGl0JywgdGhpcy5vbkNhY2hlSGl0LCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdjYWNoZXVubG9hZCcsIHRoaXMub25DYWNoZVVubG9hZCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9mZignZXh0cmVtYWNoYW5nZScsIHRoaXMub25FeHRyZW1hQ2hhbmdlLCB0aGlzKTtcbiAgICAgICAgICAgIG1hcC5vZmYoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0aGlzKTtcbiAgICAgICAgICAgIG1hcC5vZmYoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE5vLW9wIHRoZXNlIGZ1bmN0aW9uc1xuICAgICAgICBfdXBkYXRlT3BhY2l0eTogTk9fT1AsXG4gICAgICAgIF9pbml0VGlsZTogTk9fT1AsXG4gICAgICAgIF91cGRhdGVMZXZlbHM6IE5PX09QLFxuICAgICAgICBfcmVtb3ZlVGlsZXNBdFpvb206IE5PX09QLFxuICAgICAgICBfc2V0Wm9vbVRyYW5zZm9ybXM6IE5PX09QLFxuXG4gICAgICAgIF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTmFtZSArPSAnbGVhZmxldC1sYXllciBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlWkluZGV4KCk7XG4gICAgICAgICAgICB0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9wcnVuZVRpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgaWYgKHpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fFxuICAgICAgICAgICAgICAgIHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5mb3JJbih0aGlzLl90aWxlcywgdGlsZSA9PiB7XG4gICAgICAgICAgICAgICAgdGlsZS5yZXRhaW4gPSB0aWxlLmN1cnJlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF8uZm9ySW4odGhpcy5fdGlsZXMsIHRpbGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aWxlLmN1cnJlbnQgJiYgIXRpbGUuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb29yZHMgPSB0aWxlLmNvb3JkcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9yZXRhaW5QYXJlbnQoY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogLSA1KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmV0YWluQ2hpbGRyZW4oY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXy5mb3JJbih0aGlzLl90aWxlcywgKHRpbGUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGlsZS5yZXRhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9yZW1vdmVBbGxUaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfLmZvckluKHRoaXMuX3RpbGVzLCAodGlsZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2ludmFsaWRhdGVBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVab29tID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2V0VmlldzogZnVuY3Rpb24oY2VudGVyLCB6b29tLCBub1BydW5lLCBub1VwZGF0ZSkge1xuICAgICAgICAgICAgbGV0IHRpbGVab29tID0gTWF0aC5yb3VuZCh6b29tKTtcbiAgICAgICAgICAgIGlmICgodGhpcy5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB8fFxuICAgICAgICAgICAgICAgICh0aGlzLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pKSB7XG4gICAgICAgICAgICAgICAgdGlsZVpvb20gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGlsZVpvb21DaGFuZ2VkID0gdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5ab29taW5nICYmICh0aWxlWm9vbSAhPT0gdGhpcy5fdGlsZVpvb20pO1xuICAgICAgICAgICAgaWYgKCFub1VwZGF0ZSB8fCB0aWxlWm9vbUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hYm9ydExvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWJvcnRMb2FkaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0R3JpZCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aWxlWm9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZShjZW50ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5vUHJ1bmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJ1bmVUaWxlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldFpvb21UcmFuc2Zvcm0oY2VudGVyLCB6b29tKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2V0Wm9vbVRyYW5zZm9ybTogZnVuY3Rpb24oY2VudGVyLCB6b29tKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudENlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Wm9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICAgICAgICBsZXQgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGN1cnJlbnRab29tKTtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgbGV0IHZpZXdIYWxmID0gdGhpcy5fbWFwLmdldFNpemUoKS5tdWx0aXBseUJ5KDAuNSk7XG4gICAgICAgICAgICBsZXQgY3VycmVudENlbnRlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QoY3VycmVudENlbnRlciwgem9vbSk7XG4gICAgICAgICAgICBsZXQgZGVzdENlbnRlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QoY2VudGVyLCB6b29tKTtcbiAgICAgICAgICAgIGxldCBjZW50ZXJPZmZzZXQgPSBkZXN0Q2VudGVyUG9pbnQuc3VidHJhY3QoY3VycmVudENlbnRlclBvaW50KTtcbiAgICAgICAgICAgIGxldCB0b3BMZWZ0T2Zmc2V0ID0gdmlld0hhbGYubXVsdGlwbHlCeSgtc2NhbGUpLmFkZChwb3NpdGlvbikuYWRkKHZpZXdIYWxmKS5zdWJ0cmFjdChjZW50ZXJPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKEwuQnJvd3Nlci5hbnkzZCkge1xuICAgICAgICAgICAgICAgIEwuRG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0LCBzY2FsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFByaXZhdGUgbWV0aG9kIHRvIGxvYWQgdGlsZXMgaW4gdGhlIGdyaWQncyBhY3RpdmUgem9vbSBsZXZlbCBhY2NvcmRpbmcgdG8gbWFwIGJvdW5kc1xuICAgICAgICBfdXBkYXRlOiBmdW5jdGlvbihjZW50ZXIpIHtcbiAgICAgICAgICAgIGxldCBtYXAgPSB0aGlzLl9tYXA7XG4gICAgICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB6b29tID0gbWFwLmdldFpvb20oKTtcbiAgICAgICAgICAgIGlmIChjZW50ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90aWxlWm9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgb3V0IG9mIG1pbnpvb20vbWF4em9vbVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwaXhlbEJvdW5kcyA9IHRoaXMuX2dldFRpbGVkUGl4ZWxCb3VuZHMoY2VudGVyKSxcbiAgICAgICAgICAgICAgICB0aWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKHBpeGVsQm91bmRzKSxcbiAgICAgICAgICAgICAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuICAgICAgICAgICAgICAgIHF1ZXVlID0gW107XG5cbiAgICAgICAgICAgIF8uZm9ySW4odGhpcy5fdGlsZXMsIHRpbGUgPT4ge1xuICAgICAgICAgICAgICAgIHRpbGUuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBfdXBkYXRlIGp1c3QgbG9hZHMgbW9yZSB0aWxlcy4gSWYgdGhlIHRpbGUgem9vbSBsZXZlbCBkaWZmZXJzIHRvbyBtdWNoXG4gICAgICAgICAgICAvLyBmcm9tIHRoZSBtYXAncywgbGV0IF9zZXRWaWV3IHJlc2V0IGxldmVscyBhbmQgcHJ1bmUgb2xkIHRpbGVzLlxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VmlldyhjZW50ZXIsIHpvb20pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHF1ZXVlIG9mIGNvb3JkaW5hdGVzIHRvIGxvYWQgdGlsZXMgZnJvbVxuICAgICAgICAgICAgbGV0IGksIGo7XG4gICAgICAgICAgICBmb3IgKGogPSB0aWxlUmFuZ2UubWluLnk7IGogPD0gdGlsZVJhbmdlLm1heC55OyBqKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSB0aWxlUmFuZ2UubWluLng7IGkgPD0gdGlsZVJhbmdlLm1heC54OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvb3JkcyA9IG5ldyBMLlBvaW50KGksIGopO1xuICAgICAgICAgICAgICAgICAgICBjb29yZHMueiA9IHRoaXMuX3RpbGVab29tO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNWYWxpZFRpbGUoY29vcmRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgdGlsZSA9IHRoaXMuX3RpbGVzW3RoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzb3J0IHRpbGUgcXVldWUgdG8gbG9hZCB0aWxlcyBpbiBvcmRlciBvZiB0aGVpciBkaXN0YW5jZSB0byBjZW50ZXJcbiAgICAgICAgICAgIHF1ZXVlLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBiYXRjaCBvZiB0aWxlcyB0byBsb2FkXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBAZXZlbnQgbG9hZGluZzogRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBzdGFydHMgbG9hZGluZyB0aWxlc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2xvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRpbGUocXVldWVbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfcmVtb3ZlVGlsZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBsZXQgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gICAgICAgICAgICBpZiAoIXRpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdGlsZXNba2V5XTtcbiAgICAgICAgICAgIC8vIEBldmVudCB0aWxldW5sb2FkOiBUaWxlRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlbW92ZWQgKGUuZy4gd2hlbiBhIHRpbGUgZ29lcyBvZmYgdGhlIHNjcmVlbikuXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGV1bmxvYWQnLCB7XG4gICAgICAgICAgICAgICAgY29vcmRzOiB0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzLCBkb25lKSB7XG4gICAgICAgICAgICBsZXQgdGlsZSA9IHtcbiAgICAgICAgICAgICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50OiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdFRpbGUoY29vcmRzLCB0aWxlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZG9uZShudWxsLCB0aWxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FkZFRpbGU6IGZ1bmN0aW9uKGNvb3Jkcykge1xuXG4gICAgICAgICAgICBsZXQgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZShjb29yZHMsIEwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcykpO1xuICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuICAgICAgICAgICAgdGhpcy5fdGlsZXNba2V5XSA9IHRpbGU7XG5cbiAgICAgICAgICAgIC8vIEBldmVudCB0aWxlbG9hZHN0YXJ0OiBUaWxlRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlcXVlc3RlZCBhbmQgc3RhcnRzIGxvYWRpbmcuXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGVsb2Fkc3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgY29vcmRzOiBjb29yZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF90aWxlUmVhZHk6IGZ1bmN0aW9uKGNvb3JkcywgZXJyLCB0aWxlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX21hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBAZXZlbnQgdGlsZWVycm9yOiBUaWxlRXJyb3JFdmVudFxuICAgICAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgbG9hZGluZyBhIHRpbGUuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxlZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgIHRpbGU6IHRpbGUsXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkczogY29vcmRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aWxlIGxvYWRlZFxuICAgICAgICAgICAgdGlsZS5sb2FkZWQgPSArbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHRpbGUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3BydW5lVGlsZXMoKTtcblxuICAgICAgICAgICAgLy8gQGV2ZW50IHRpbGVsb2FkOiBUaWxlRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSB0aWxlIGxvYWRzLlxuICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcbiAgICAgICAgICAgICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgICAgICAgICAgICB0aWxlOiB0aWxlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX25vVGlsZXNUb0xvYWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBAZXZlbnQgbG9hZDogRXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIGxvYWRlZCBhbGwgdmlzaWJsZSB0aWxlcy5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2xvYWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoTC5Ccm93c2VyLmllbHQ5IHx8ICF0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IGEgYml0IG1vcmUgdGhhbiAwLjIgc2VjcyAodGhlIGR1cmF0aW9uIG9mIHRoZSB0aWxlIGZhZGUtaW4pXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRyaWdnZXIgYSBwcnVuaW5nLlxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKSwgMjUwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DYWNoZUhpdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2FjaGVMb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25FeHRyZW1hQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DYWNoZVVubG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gT3ZlcmxheTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBlc3BlciA9IHJlcXVpcmUoJ2VzcGVyJyk7XG4gICAgbGV0IE92ZXJsYXkgPSByZXF1aXJlKCcuL092ZXJsYXknKTtcblxuICAgIGxldCBXZWJHTCA9IE92ZXJsYXkuZXh0ZW5kKHtcblxuICAgICAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICBPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgICAgICBtYXAub24oJ3pvb21zdGFydCcsIHRoaXMub25ab29tU3RhcnQsIHRoaXMpO1xuICAgICAgICAgICAgbWFwLm9uKCd6b29tZW5kJywgdGhpcy5vblpvb21FbmQsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgIE92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgICAgIG1hcC5vZmYoJ3pvb21zdGFydCcsIHRoaXMub25ab29tU3RhcnQsIHRoaXMpO1xuICAgICAgICAgICAgbWFwLm9mZignem9vbWVuZCcsIHRoaXMub25ab29tRW5kLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblpvb21TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1pvb21pbmcgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uWm9vbUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1pvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuX2dsO1xuICAgICAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRnJhbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBPdmVybGF5LnByb3RvdHlwZS5faW5pdENvbnRhaW5lci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9nbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRHTCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pc1pvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbldlYkdMSW5pdDogZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgZG9uZShudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdEdMOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuX2dsID0gZXNwZXIuV2ViR0xDb250ZXh0LmdldCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1pc3NpbmcgY29udGV4dFxuICAgICAgICAgICAgaWYgKCFnbCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdVbmFibGUgdG8gYWNxdWlyZSBhIFdlYkdMIGNvbnRleHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW5pdCB0aGUgd2ViZ2wgc3RhdGVcbiAgICAgICAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FKTtcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgICAgICAvLyBnZXQgbWFwIHNpemVcbiAgICAgICAgICAgIGxldCBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKTtcbiAgICAgICAgICAgIGxldCBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICAvLyBzZXQgdmlld3BvcnQgc2l6ZVxuICAgICAgICAgICAgdGhpcy5fdmlld3BvcnQgPSBuZXcgZXNwZXIuVmlld3BvcnQoe1xuICAgICAgICAgICAgICAgIHdpZHRoOiBzaXplLnggKiBkZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgIGhlaWdodDogc2l6ZS55ICogZGV2aWNlUGl4ZWxSYXRpb1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBzZXQgY2FudmFzIHNpemVcbiAgICAgICAgICAgIHRoaXMuX2dsLmNhbnZhcy5zdHlsZS53aWR0aCA9IHNpemUueCArICdweCc7XG4gICAgICAgICAgICB0aGlzLl9nbC5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcbiAgICAgICAgICAgIC8vIHdlYmdsIGluaXQgY2FsbGJhY2tcbiAgICAgICAgICAgIHRoaXMub25XZWJHTEluaXQoZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmbGFnIGFzIHJlYWR5XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGRyYXcgbG9vcFxuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFRyYW5zbGF0aW9uTWF0cml4OiBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgICAgICAgICBsZXQgbWF0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgICAgICAgICBtYXRbMF0gPSAxO1xuICAgICAgICAgICAgbWF0WzFdID0gMDtcbiAgICAgICAgICAgIG1hdFsyXSA9IDA7XG4gICAgICAgICAgICBtYXRbM10gPSAwO1xuICAgICAgICAgICAgbWF0WzRdID0gMDtcbiAgICAgICAgICAgIG1hdFs1XSA9IDE7XG4gICAgICAgICAgICBtYXRbNl0gPSAwO1xuICAgICAgICAgICAgbWF0WzddID0gMDtcbiAgICAgICAgICAgIG1hdFs4XSA9IDA7XG4gICAgICAgICAgICBtYXRbOV0gPSAwO1xuICAgICAgICAgICAgbWF0WzEwXSA9IDE7XG4gICAgICAgICAgICBtYXRbMTFdID0gMDtcbiAgICAgICAgICAgIG1hdFsxMl0gPSB4O1xuICAgICAgICAgICAgbWF0WzEzXSA9IHk7XG4gICAgICAgICAgICBtYXRbMTRdID0gejtcbiAgICAgICAgICAgIG1hdFsxNV0gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIG1hdDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRPcnRob01hdHJpeDogZnVuY3Rpb24obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICAgICAgICAgIGxldCBtYXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICAgICAgICAgIG1hdFswXSA9IDIgLyAocmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgICAgIG1hdFsxXSA9IDA7XG4gICAgICAgICAgICBtYXRbMl0gPSAwO1xuICAgICAgICAgICAgbWF0WzNdID0gMDtcbiAgICAgICAgICAgIG1hdFs0XSA9IDA7XG4gICAgICAgICAgICBtYXRbNV0gPSAyIC8gKHRvcCAtIGJvdHRvbSk7XG4gICAgICAgICAgICBtYXRbNl0gPSAwO1xuICAgICAgICAgICAgbWF0WzddID0gMDtcbiAgICAgICAgICAgIG1hdFs4XSA9IDA7XG4gICAgICAgICAgICBtYXRbOV0gPSAwO1xuICAgICAgICAgICAgbWF0WzEwXSA9IC0yIC8gKGZhciAtIG5lYXIpO1xuICAgICAgICAgICAgbWF0WzExXSA9IDA7XG4gICAgICAgICAgICBtYXRbMTJdID0gLSgocmlnaHQgKyBsZWZ0KSAvIChyaWdodCAtIGxlZnQpKTtcbiAgICAgICAgICAgIG1hdFsxM10gPSAtKCh0b3AgKyBib3R0b20pIC8gKHRvcCAtIGJvdHRvbSkpO1xuICAgICAgICAgICAgbWF0WzE0XSA9IC0oKGZhciArIG5lYXIpIC8gKGZhciAtIG5lYXIpKTtcbiAgICAgICAgICAgIG1hdFsxNV0gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIG1hdDtcbiAgICAgICAgfSxcblxuICAgICAgICBfcG9zaXRpb25Db250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgbGV0IGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgICAgIC8vIHNldCB2aWV3cG9ydCBzaXplXG4gICAgICAgICAgICB0aGlzLl92aWV3cG9ydC5yZXNpemUoXG4gICAgICAgICAgICAgICAgc2l6ZS54ICogZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgICBzaXplLnkgKiBkZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIC8vIHNldCBjYW52YXMgc2l6ZVxuICAgICAgICAgICAgdGhpcy5fZ2wuY2FudmFzLnN0eWxlLndpZHRoID0gc2l6ZS54ICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuX2dsLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuICAgICAgICAgICAgLy8gcmUtcG9zaXRpb24gY29udGFpbmVyXG4gICAgICAgICAgICBsZXQgdG9wTGVmdCA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChbMCwgMF0pO1xuICAgICAgICAgICAgTC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hcCAmJiB0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlLXBvc2l0aW9uIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzWm9vbWluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9zaXRpb24gdGhlIGNvbnRhaW5lciBhbmQgcmVzaXplIHZpZXdwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbkNvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHJhdyB0aGUgZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRnJhbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fZHJhdy5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXJGcmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBpbXBsZW1lbnQgdGhpc1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gV2ViR0w7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgQ29yZSA9IHtcbiAgICAgICAgSFRNTDogcmVxdWlyZSgnLi9jb3JlL0hUTUwnKSxcbiAgICAgICAgV2ViR0w6IHJlcXVpcmUoJy4vY29yZS9XZWJHTCcpLFxuICAgICAgICBDYW52YXM6IHJlcXVpcmUoJy4vY29yZS9DYW52YXMnKVxuICAgIH07XG5cbiAgICAvLyBjYW52YXMgcmVuZGVyZXJzXG4gICAgbGV0IENhbnZhcyA9IHtcbiAgICAgICAgSGVhdG1hcDogcmVxdWlyZSgnLi90eXBlL2NhbnZhcy9IZWF0bWFwJyksXG4gICAgICAgIFRvcFRyYWlsczogcmVxdWlyZSgnLi90eXBlL2NhbnZhcy9Ub3BUcmFpbHMnKSxcbiAgICAgICAgUHJldmlldzogcmVxdWlyZSgnLi90eXBlL2NhbnZhcy9QcmV2aWV3JylcbiAgICB9O1xuXG4gICAgLy8gaHRtbCByZW5kZXJlcnNcbiAgICBsZXQgSFRNTCA9IHtcbiAgICAgICAgRW1wdHk6IHJlcXVpcmUoJy4vdHlwZS9odG1sL0VtcHR5JyksXG4gICAgICAgIEhlYXRtYXA6IHJlcXVpcmUoJy4vdHlwZS9odG1sL0hlYXRtYXAnKSxcbiAgICAgICAgUmluZzogcmVxdWlyZSgnLi90eXBlL2h0bWwvUmluZycpLFxuICAgICAgICBXb3JkQ2xvdWQ6IHJlcXVpcmUoJy4vdHlwZS9odG1sL1dvcmRDbG91ZCcpLFxuICAgICAgICBXb3JkSGlzdG9ncmFtOiByZXF1aXJlKCcuL3R5cGUvaHRtbC9Xb3JkSGlzdG9ncmFtJyksXG4gICAgICAgIENvbW11bml0eTogcmVxdWlyZSgnLi90eXBlL2h0bWwvQ29tbXVuaXR5JyksXG4gICAgICAgIENvbW11bml0eUxhYmVsOiByZXF1aXJlKCcuL3R5cGUvaHRtbC9Db21tdW5pdHlMYWJlbCcpXG4gICAgfTtcblxuICAgIC8vIHdlYmdsIHJlbmRlcmVyc1xuICAgIGxldCBXZWJHTCA9IHtcbiAgICAgICAgSGVhdG1hcDogcmVxdWlyZSgnLi90eXBlL3dlYmdsL0hlYXRtYXAnKSxcbiAgICAgICAgUG9pbnQ6IHJlcXVpcmUoJy4vdHlwZS93ZWJnbC9Qb2ludCcpXG4gICAgfTtcblxuICAgIC8vIHBlbmRpbmcgbGF5ZXIgcmVuZGVyZXJzXG4gICAgbGV0IFBlbmRpbmcgPSB7XG4gICAgICAgIERlbGF5ZWRCbGluazogcmVxdWlyZSgnLi90eXBlL3BlbmRpbmcvRGVsYXllZEJsaW5rJyksXG4gICAgICAgIERlbGF5ZWRTcGluOiByZXF1aXJlKCcuL3R5cGUvcGVuZGluZy9EZWxheWVkU3BpbicpLFxuICAgICAgICBCbGluazogcmVxdWlyZSgnLi90eXBlL3BlbmRpbmcvQmxpbmsnKSxcbiAgICAgICAgU3BpbjogcmVxdWlyZSgnLi90eXBlL3BlbmRpbmcvU3BpbicpLFxuICAgICAgICBCbGlua1NwaW46IHJlcXVpcmUoJy4vdHlwZS9wZW5kaW5nL0JsaW5rU3BpbicpXG4gICAgfTtcblxuICAgIC8vIHBlbmRpbmcgbGF5ZXIgcmVuZGVyZXJzXG4gICAgbGV0IERlYnVnID0ge1xuICAgICAgICBDb29yZDogcmVxdWlyZSgnLi90eXBlL2RlYnVnL0Nvb3JkJylcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIENvcmU6IENvcmUsXG4gICAgICAgIEhUTUw6IEhUTUwsXG4gICAgICAgIENhbnZhczogQ2FudmFzLFxuICAgICAgICBXZWJHTDogV2ViR0wsXG4gICAgICAgIERlYnVnOiBEZWJ1ZyxcbiAgICAgICAgUGVuZGluZzogUGVuZGluZ1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgTlVNX0dSQURJRU5UX1NURVBTID0gMTAwO1xuXG4gICAgZnVuY3Rpb24gcmdiMmxhYihyZ2IpIHtcbiAgICAgICAgbGV0IHIgPSByZ2JbMF0gPiAwLjA0MDQ1ID8gTWF0aC5wb3coKHJnYlswXSArIDAuMDU1KSAvIDEuMDU1LCAyLjQpIDogcmdiWzBdIC8gMTIuOTI7XG4gICAgICAgIGxldCBnID0gcmdiWzFdID4gMC4wNDA0NSA/IE1hdGgucG93KChyZ2JbMV0gKyAwLjA1NSkgLyAxLjA1NSwgMi40KSA6IHJnYlsxXSAvIDEyLjkyO1xuICAgICAgICBsZXQgYiA9IHJnYlsyXSA+IDAuMDQwNDUgPyBNYXRoLnBvdygocmdiWzJdICsgMC4wNTUpIC8gMS4wNTUsIDIuNCkgOiByZ2JbMl0gLyAxMi45MjtcbiAgICAgICAgLy9PYnNlcnZlci4gPSAywrAsIElsbHVtaW5hbnQgPSBENjVcbiAgICAgICAgbGV0IHggPSByICogMC40MTI0NTY0ICsgZyAqIDAuMzU3NTc2MSArIGIgKiAwLjE4MDQzNzU7XG4gICAgICAgIGxldCB5ID0gciAqIDAuMjEyNjcyOSArIGcgKiAwLjcxNTE1MjIgKyBiICogMC4wNzIxNzUwO1xuICAgICAgICBsZXQgeiA9IHIgKiAwLjAxOTMzMzkgKyBnICogMC4xMTkxOTIwICsgYiAqIDAuOTUwMzA0MTtcbiAgICAgICAgeCA9IHggLyAwLjk1MDQ3OyAvLyBPYnNlcnZlcj0gMsKwLCBJbGx1bWluYW50PSBENjVcbiAgICAgICAgeSA9IHkgLyAxLjAwMDAwO1xuICAgICAgICB6ID0geiAvIDEuMDg4ODM7XG4gICAgICAgIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxIC8gMykgOiAoNy43ODcwMzcgKiB4KSArICgxNiAvIDExNik7XG4gICAgICAgIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxIC8gMykgOiAoNy43ODcwMzcgKiB5KSArICgxNiAvIDExNik7XG4gICAgICAgIHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxIC8gMykgOiAoNy43ODcwMzcgKiB6KSArICgxNiAvIDExNik7XG4gICAgICAgIHJldHVybiBbKDExNiAqIHkpIC0gMTYsXG4gICAgICAgICAgICA1MDAgKiAoeCAtIHkpLFxuICAgICAgICAgICAgMjAwICogKHkgLSB6KSxcbiAgICAgICAgICAgIHJnYlszXV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFiMnJnYihsYWIpIHtcbiAgICAgICAgbGV0IHkgPSAobGFiWzBdICsgMTYpIC8gMTE2O1xuICAgICAgICBsZXQgeCA9IHkgKyBsYWJbMV0gLyA1MDA7XG4gICAgICAgIGxldCB6ID0geSAtIGxhYlsyXSAvIDIwMDtcbiAgICAgICAgeCA9IHggPiAwLjIwNjg5MzAzNCA/IHggKiB4ICogeCA6ICh4IC0gNCAvIDI5KSAvIDcuNzg3MDM3O1xuICAgICAgICB5ID0geSA+IDAuMjA2ODkzMDM0ID8geSAqIHkgKiB5IDogKHkgLSA0IC8gMjkpIC8gNy43ODcwMzc7XG4gICAgICAgIHogPSB6ID4gMC4yMDY4OTMwMzQgPyB6ICogeiAqIHogOiAoeiAtIDQgLyAyOSkgLyA3Ljc4NzAzNztcbiAgICAgICAgeCA9IHggKiAwLjk1MDQ3OyAvLyBPYnNlcnZlcj0gMsKwLCBJbGx1bWluYW50PSBENjVcbiAgICAgICAgeSA9IHkgKiAxLjAwMDAwO1xuICAgICAgICB6ID0geiAqIDEuMDg4ODM7XG4gICAgICAgIGxldCByID0geCAqIDMuMjQwNDU0MiArIHkgKiAtMS41MzcxMzg1ICsgeiAqIC0wLjQ5ODUzMTQ7XG4gICAgICAgIGxldCBnID0geCAqIC0wLjk2OTI2NjAgKyB5ICogMS44NzYwMTA4ICsgeiAqIDAuMDQxNTU2MDtcbiAgICAgICAgbGV0IGIgPSB4ICogMC4wNTU2NDM0ICsgeSAqIC0wLjIwNDAyNTkgKyB6ICogMS4wNTcyMjUyO1xuICAgICAgICByID0gciA+IDAuMDAzMDQgPyAxLjA1NSAqIE1hdGgucG93KHIsIDEgLyAyLjQpIC0gMC4wNTUgOiAxMi45MiAqIHI7XG4gICAgICAgIGcgPSBnID4gMC4wMDMwNCA/IDEuMDU1ICogTWF0aC5wb3coZywgMSAvIDIuNCkgLSAwLjA1NSA6IDEyLjkyICogZztcbiAgICAgICAgYiA9IGIgPiAwLjAwMzA0ID8gMS4wNTUgKiBNYXRoLnBvdyhiLCAxIC8gMi40KSAtIDAuMDU1IDogMTIuOTIgKiBiO1xuICAgICAgICByZXR1cm4gW01hdGgubWF4KE1hdGgubWluKHIsIDEpLCAwKSwgTWF0aC5tYXgoTWF0aC5taW4oZywgMSksIDApLCBNYXRoLm1heChNYXRoLm1pbihiLCAxKSwgMCksIGxhYlszXV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzdGFuY2UoYzEsIGMyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICAoYzFbMF0gLSBjMlswXSkgKiAoYzFbMF0gLSBjMlswXSkgK1xuICAgICAgICAgICAgKGMxWzFdIC0gYzJbMV0pICogKGMxWzFdIC0gYzJbMV0pICtcbiAgICAgICAgICAgIChjMVsyXSAtIGMyWzJdKSAqIChjMVsyXSAtIGMyWzJdKSArXG4gICAgICAgICAgICAoYzFbM10gLSBjMlszXSkgKiAoYzFbM10gLSBjMlszXSkpO1xuICAgIH1cblxuICAgIGxldCBidWlsZEZsYXRMb29rdXBUYWJsZSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOVU1fR1JBRElFTlRfU1RFUFM7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goY29sb3JbMF0pO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goY29sb3JbMV0pO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goY29sb3JbMl0pO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goY29sb3JbM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuICAgIC8vIEludGVycG9sYXRlIGJldHdlZW4gYSBzZXQgb2YgY29sb3JzIHVzaW5nIGV2ZW4gcGVyY2VwdHVhbCBkaXN0YW5jZSBhbmQgaW50ZXJwb2xhdGlvbiBpbiBDSUUgTCphKmIqIHNwYWNlXG4gICAgbGV0IGJ1aWxkUGVyY2VwdHVhbExvb2t1cFRhYmxlID0gZnVuY3Rpb24oYmFzZUNvbG9ycykge1xuICAgICAgICBsZXQgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKE5VTV9HUkFESUVOVF9TVEVQUyAqIDQgKiA0KTtcbiAgICAgICAgbGV0IG91dHB1dEdyYWRpZW50ID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICAgICAgICAvLyBDYWxjdWxhdGUgcGVyY2VwdHVhbCBzcHJlYWQgaW4gTCphKmIqIHNwYWNlXG4gICAgICAgIGxldCBsYWJzID0gXy5tYXAoYmFzZUNvbG9ycywgY29sb3IgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJnYjJsYWIoW2NvbG9yWzBdIC8gMjU1LCBjb2xvclsxXSAvIDI1NSwgY29sb3JbMl0gLyAyNTUsIGNvbG9yWzNdIC8gMjU1XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZGlzdGFuY2VzID0gXy5tYXAobGFicywgKGNvbG9yLCBpbmRleCwgY29sb3JzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXggPiAwID8gZGlzdGFuY2UoY29sb3IsIGNvbG9yc1tpbmRleCAtIDFdKSA6IDA7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDYWxjdWxhdGUgY3VtdWxhdGl2ZSBkaXN0YW5jZXMgaW4gWzAsMV1cbiAgICAgICAgbGV0IHRvdGFsRGlzdGFuY2UgPSBfLnJlZHVjZShkaXN0YW5jZXMsIChhLCBiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBkaXN0YW5jZXMgPSBfLm1hcChkaXN0YW5jZXMsIGQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGQgLyB0b3RhbERpc3RhbmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGRpc3RhbmNlVHJhdmVyc2VkID0gMDtcbiAgICAgICAgbGV0IGtleSA9IDA7XG4gICAgICAgIGxldCBwcm9ncmVzcztcbiAgICAgICAgbGV0IHN0ZXBQcm9ncmVzcztcbiAgICAgICAgbGV0IHJnYjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOVU1fR1JBRElFTlRfU1RFUFM7IGkrKykge1xuICAgICAgICAgICAgcHJvZ3Jlc3MgPSBpIC8gKE5VTV9HUkFESUVOVF9TVEVQUyAtIDEpO1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzID4gZGlzdGFuY2VUcmF2ZXJzZWQgKyBkaXN0YW5jZXNba2V5ICsgMV0gJiYga2V5ICsgMSA8IGxhYnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGtleSArPSAxO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlVHJhdmVyc2VkICs9IGRpc3RhbmNlc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RlcFByb2dyZXNzID0gKHByb2dyZXNzIC0gZGlzdGFuY2VUcmF2ZXJzZWQpIC8gZGlzdGFuY2VzW2tleSArIDFdO1xuICAgICAgICAgICAgcmdiID0gbGFiMnJnYihbXG4gICAgICAgICAgICAgICAgbGFic1trZXldWzBdICsgKGxhYnNba2V5ICsgMV1bMF0gLSBsYWJzW2tleV1bMF0pICogc3RlcFByb2dyZXNzLFxuICAgICAgICAgICAgICAgIGxhYnNba2V5XVsxXSArIChsYWJzW2tleSArIDFdWzFdIC0gbGFic1trZXldWzFdKSAqIHN0ZXBQcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBsYWJzW2tleV1bMl0gKyAobGFic1trZXkgKyAxXVsyXSAtIGxhYnNba2V5XVsyXSkgKiBzdGVwUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbGFic1trZXldWzNdICsgKGxhYnNba2V5ICsgMV1bM10gLSBsYWJzW2tleV1bM10pICogc3RlcFByb2dyZXNzXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIG91dHB1dEdyYWRpZW50W2kgKiA0XSA9IHJnYlswXTtcbiAgICAgICAgICAgIG91dHB1dEdyYWRpZW50W2kgKiA0ICsgMV0gPSByZ2JbMV07XG4gICAgICAgICAgICBvdXRwdXRHcmFkaWVudFtpICogNCArIDJdID0gcmdiWzJdO1xuICAgICAgICAgICAgb3V0cHV0R3JhZGllbnRbaSAqIDQgKyAzXSA9IHJnYlszXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0R3JhZGllbnQ7XG4gICAgfTtcblxuICAgIGxldCBDT09MID0gYnVpbGRQZXJjZXB0dWFsTG9va3VwVGFibGUoW1xuICAgICAgICBbMHgwNCwgMHgyMCwgMHg0MCwgMHg1MF0sXG4gICAgICAgIFsweDA4LCAweDQwLCAweDgxLCAweDdmXSxcbiAgICAgICAgWzB4MDgsIDB4NjgsIDB4YWMsIDB4ZmZdLFxuICAgICAgICBbMHgyYiwgMHg4YywgMHhiZSwgMHhmZl0sXG4gICAgICAgIFsweDRlLCAweGIzLCAweGQzLCAweGZmXSxcbiAgICAgICAgWzB4N2IsIDB4Y2MsIDB4YzQsIDB4ZmZdLFxuICAgICAgICBbMHhhOCwgMHhkZCwgMHhiNSwgMHhmZl0sXG4gICAgICAgIFsweGNjLCAweGViLCAweGM1LCAweGZmXSxcbiAgICAgICAgWzB4ZTAsIDB4ZjMsIDB4ZGIsIDB4ZmZdLFxuICAgICAgICBbMHhmNywgMHhmYywgMHhmMCwgMHhmZl1cbiAgICBdKTtcblxuICAgIGxldCBIT1QgPSBidWlsZFBlcmNlcHR1YWxMb29rdXBUYWJsZShbXG4gICAgICAgIFsweDQwLCAweDAwLCAweDEzLCAweDUwXSxcbiAgICAgICAgWzB4ODAsIDB4MDAsIDB4MjYsIDB4N2ZdLFxuICAgICAgICBbMHhiZCwgMHgwMCwgMHgyNiwgMHhmZl0sXG4gICAgICAgIFsweGUzLCAweDFhLCAweDFjLCAweGZmXSxcbiAgICAgICAgWzB4ZmMsIDB4NGUsIDB4MmEsIDB4ZmZdLFxuICAgICAgICBbMHhmZCwgMHg4ZCwgMHgzYywgMHhmZl0sXG4gICAgICAgIFsweGZlLCAweGIyLCAweDRjLCAweGZmXSxcbiAgICAgICAgWzB4ZmUsIDB4ZDksIDB4NzYsIDB4ZmZdLFxuICAgICAgICBbMHhmZiwgMHhlZCwgMHhhMCwgMHhmZl1cbiAgICBdKTtcblxuICAgIGxldCBWRVJEQU5UID0gYnVpbGRQZXJjZXB0dWFsTG9va3VwVGFibGUoW1xuICAgICAgICBbMHgwMCwgMHg0MCwgMHgyNiwgMHg1MF0sXG4gICAgICAgIFsweDAwLCAweDVhLCAweDMyLCAweDdmXSxcbiAgICAgICAgWzB4MjMsIDB4ODQsIDB4NDMsIDB4ZmZdLFxuICAgICAgICBbMHg0MSwgMHhhYiwgMHg1ZCwgMHhmZl0sXG4gICAgICAgIFsweDc4LCAweGM2LCAweDc5LCAweGZmXSxcbiAgICAgICAgWzB4YWQsIDB4ZGQsIDB4OGUsIDB4ZmZdLFxuICAgICAgICBbMHhkOSwgMHhmMCwgMHhhMywgMHhmZl0sXG4gICAgICAgIFsweGY3LCAweGZjLCAweGI5LCAweGZmXSxcbiAgICAgICAgWzB4ZmYsIDB4ZmYsIDB4ZTUsIDB4ZmZdXG4gICAgXSk7XG5cbiAgICBsZXQgU1BFQ1RSQUwgPSBidWlsZFBlcmNlcHR1YWxMb29rdXBUYWJsZShbXG4gICAgICAgIFsweDI2LCAweDFhLCAweDQwLCAweDUwXSxcbiAgICAgICAgWzB4NDQsIDB4MmYsIDB4NzIsIDB4N2ZdLFxuICAgICAgICBbMHhlMSwgMHgyYiwgMHgwMiwgMHhmZl0sXG4gICAgICAgIFsweDAyLCAweGRjLCAweDAxLCAweGZmXSxcbiAgICAgICAgWzB4ZmYsIDB4ZDIsIDB4MDIsIDB4ZmZdLFxuICAgICAgICBbMHhmZiwgMHhmZiwgMHhmZiwgMHhmZl1cbiAgICBdKTtcblxuICAgIGxldCBURU1QRVJBVFVSRSA9IGJ1aWxkUGVyY2VwdHVhbExvb2t1cFRhYmxlKFtcbiAgICAgICAgWzB4MDAsIDB4MTYsIDB4NDAsIDB4NTBdLFxuICAgICAgICBbMHgwMCwgMHgzOSwgMHg2NiwgMHg3Zl0sXG4gICAgICAgIFsweDMxLCAweDNkLCAweDY2LCAweGZmXSxcbiAgICAgICAgWzB4ZTEsIDB4MmIsIDB4MDIsIDB4ZmZdLFxuICAgICAgICBbMHhmZiwgMHhkMiwgMHgwMiwgMHhmZl0sXG4gICAgICAgIFsweGZmLCAweGZmLCAweGZmLCAweGZmXVxuICAgIF0pO1xuXG4gICAgbGV0IEdSRVlTQ0FMRSA9IGJ1aWxkUGVyY2VwdHVhbExvb2t1cFRhYmxlKFtcbiAgICAgICAgWzB4MDAsIDB4MDAsIDB4MDAsIDB4N2ZdLFxuICAgICAgICBbMHg0MCwgMHg0MCwgMHg0MCwgMHhmZl0sXG4gICAgICAgIFsweGZmLCAweGZmLCAweGZmLCAweGZmXVxuICAgIF0pO1xuXG4gICAgbGV0IFBPTEFSX0hPVCA9IGJ1aWxkUGVyY2VwdHVhbExvb2t1cFRhYmxlKFtcbiAgICAgICAgWyAweGZmLCAweDQ0LCAweDAwLCAweGZmIF0sXG4gICAgICAgIFsgMHhiZCwgMHhiZCwgMHhiZCwgMHhiMCBdXG4gICAgXSk7XG5cbiAgICBsZXQgUE9MQVJfQ09MRCA9IGJ1aWxkUGVyY2VwdHVhbExvb2t1cFRhYmxlKFtcbiAgICAgICAgWyAweGJkLCAweGJkLCAweGJkLCAweGIwIF0sXG4gICAgICAgIFsgMHgzMiwgMHhhNSwgMHhmOSwgMHhmZiBdXG4gICAgXSk7XG5cbiAgICBsZXQgRklSRSA9IGJ1aWxkUGVyY2VwdHVhbExvb2t1cFRhYmxlKFtcbiAgICAgICAgWzB4OTYsIDB4MDAsIDB4MDAsIDB4OTZdLFxuICAgICAgICBbMHhmZiwgMHhmZiwgMHgzMiwgMHhmZl1cbiAgICBdKTtcblxuICAgIGxldCBGTEFUID0gYnVpbGRGbGF0TG9va3VwVGFibGUoWzB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmZdKTtcblxuICAgIGxldCBidWlsZExvb2t1cEZ1bmN0aW9uID0gZnVuY3Rpb24oUkFNUCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2NhbGVkVmFsdWUsIGluQ29sb3IpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IE1hdGguZmxvb3Ioc2NhbGVkVmFsdWUgKiAoTlVNX0dSQURJRU5UX1NURVBTIC0gMSkpO1xuICAgICAgICAgICAgaW5Db2xvclswXSA9IFJBTVBbaW5kZXggKiA0XTtcbiAgICAgICAgICAgIGluQ29sb3JbMV0gPSBSQU1QW2luZGV4ICogNCArIDFdO1xuICAgICAgICAgICAgaW5Db2xvclsyXSA9IFJBTVBbaW5kZXggKiA0ICsgMl07XG4gICAgICAgICAgICBpbkNvbG9yWzNdID0gUkFNUFtpbmRleCAqIDQgKyAzXTtcbiAgICAgICAgICAgIHJldHVybiBpbkNvbG9yO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBsZXQgY29uY2F0ID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBsZXQgY29tYmluZWQgPSBuZXcgRmxvYXQzMkFycmF5KGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuICAgICAgICBjb21iaW5lZC5zZXQoYSwgMCk7XG4gICAgICAgIGNvbWJpbmVkLnNldChiLCBhLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICB9O1xuXG4gICAgbGV0IENvbG9yVGFibGVzID0ge1xuICAgICAgICBjb29sOiBDT09MLFxuICAgICAgICBob3Q6IEhPVCxcbiAgICAgICAgdmVyZGFudDogVkVSREFOVCxcbiAgICAgICAgc3BlY3RyYWw6IFNQRUNUUkFMLFxuICAgICAgICB0ZW1wZXJhdHVyZTogVEVNUEVSQVRVUkUsXG4gICAgICAgIGdyZXk6IEdSRVlTQ0FMRSxcbiAgICAgICAgcG9sYXI6IGNvbmNhdChQT0xBUl9IT1QsIFBPTEFSX0NPTEQpLFxuICAgICAgICBmbGF0OiBGTEFUXG4gICAgfTtcblxuICAgIGxldCBDb2xvclJhbXAgPSB7XG4gICAgICAgIGNvb2w6IGJ1aWxkTG9va3VwRnVuY3Rpb24oQ09PTCksXG4gICAgICAgIGhvdDogYnVpbGRMb29rdXBGdW5jdGlvbihIT1QpLFxuICAgICAgICB2ZXJkYW50OiBidWlsZExvb2t1cEZ1bmN0aW9uKFZFUkRBTlQpLFxuICAgICAgICBzcGVjdHJhbDogYnVpbGRMb29rdXBGdW5jdGlvbihTUEVDVFJBTCksXG4gICAgICAgIHRlbXBlcmF0dXJlOiBidWlsZExvb2t1cEZ1bmN0aW9uKFRFTVBFUkFUVVJFKSxcbiAgICAgICAgZ3JleTogYnVpbGRMb29rdXBGdW5jdGlvbihHUkVZU0NBTEUpLFxuICAgICAgICBmaXJlOiBidWlsZExvb2t1cEZ1bmN0aW9uKEZJUkUpLFxuICAgICAgICBwb2xhcjogYnVpbGRMb29rdXBGdW5jdGlvbihjb25jYXQoUE9MQVJfSE9ULCBQT0xBUl9DT0xEKSksXG4gICAgICAgIGZsYXQ6IGJ1aWxkTG9va3VwRnVuY3Rpb24oRkxBVClcbiAgICB9O1xuXG4gICAgbGV0IHNldENvbG9yUmFtcCA9IGZ1bmN0aW9uKHR5cGUsIGJhc2VDb2xvcnMpIHtcbiAgICAgICAgbGV0IGZ1bmMgPSBDb2xvclJhbXBbdHlwZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yUmFtcCA9IGZ1bmM7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFzZUNvbG9ycykge1xuICAgICAgICAgICAgQ29sb3JSYW1wW3R5cGUudG9Mb3dlckNhc2UoKV0gPSBidWlsZExvb2t1cEZ1bmN0aW9uKGJ1aWxkUGVyY2VwdHVhbExvb2t1cFRhYmxlKGJhc2VDb2xvcnMpKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yUmFtcCA9IENvbG9yUmFtcFt0eXBlLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jb2xvclJhbXBUeXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgbGV0IGdldENvbG9yUmFtcCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yUmFtcCB8fCBDb2xvclJhbXBbdHlwZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9O1xuXG4gICAgbGV0IGdldENvbG9yUmFtcFRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBDb2xvclRhYmxlc1t0aGlzLl9jb2xvclJhbXBUeXBlXTtcbiAgICB9O1xuXG4gICAgbGV0IGluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fY29sb3JSYW1wID0gQ29sb3JSYW1wLnZlcmRhbnQ7XG4gICAgICAgIHRoaXMuX2NvbG9yUmFtcFR5cGUgPSAndmVyZGFudCc7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBpbml0aWFsaXplOiBpbml0aWFsaXplLFxuICAgICAgICBzZXRDb2xvclJhbXA6IHNldENvbG9yUmFtcCxcbiAgICAgICAgZ2V0Q29sb3JSYW1wOiBnZXRDb2xvclJhbXAsXG4gICAgICAgIGdldENvbG9yUmFtcFRhYmxlOiBnZXRDb2xvclJhbXBUYWJsZSxcbiAgICAgICAgTlVNX0dSQURJRU5UX1NURVBTOiBOVU1fR1JBRElFTlRfU1RFUFNcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IFRJTEVfU0laRSA9IDI1NjtcblxuICAgIGZ1bmN0aW9uIGZyYWN0KGYpIHtcbiAgICAgICAgcmV0dXJuIGYgJSAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vZChuLCBtKSB7XG4gICAgICAgIHJldHVybiAoKG4gJSBtKSArIG0pICUgbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRIYXNoKGx4LCBseSwgcmFkaXVzKSB7XG4gICAgICAgIGxldCBkaWFtZXRlciA9IHJhZGl1cyAqIDI7XG4gICAgICAgIGxldCB4SGFzaCA9IE1hdGguZmxvb3IobHggLyBkaWFtZXRlcik7XG4gICAgICAgIGxldCB5SGFzaCA9IE1hdGguZmxvb3IobHkgLyBkaWFtZXRlcik7XG4gICAgICAgIHJldHVybiB4SGFzaCArICc6JyArIHlIYXNoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEhhc2hlcyhseCwgbHksIHJhZGl1cywgem9vbSkge1xuICAgICAgICBsZXQgZGlhbWV0ZXIgPSByYWRpdXMgKiAyO1xuICAgICAgICBsZXQgbnVtQ2VsbHMgPSBNYXRoLmNlaWwoKE1hdGgucG93KDIsIHpvb20pICogVElMRV9TSVpFKSAvIGRpYW1ldGVyKTtcbiAgICAgICAgbGV0IHggPSBseCAvIGRpYW1ldGVyO1xuICAgICAgICBsZXQgeSA9IGx5IC8gZGlhbWV0ZXI7XG4gICAgICAgIGxldCBmeCA9IGZyYWN0KHgpO1xuICAgICAgICBsZXQgZnkgPSBmcmFjdCh5KTtcbiAgICAgICAgbGV0IHB4ID0gZnggPiAwLjU7XG4gICAgICAgIGxldCBueCA9IGZ4IDwgMC41O1xuICAgICAgICBsZXQgcHkgPSBmeSA+IDAuNTtcbiAgICAgICAgbGV0IG55ID0gZnkgPCAwLjU7XG4gICAgICAgIGxldCBjeCA9IE1hdGguZmxvb3IoeCk7XG4gICAgICAgIGxldCBjeSA9IE1hdGguZmxvb3IoeSk7XG4gICAgICAgIGxldCBjZWxscyA9IFtcbiAgICAgICAgICAgIFtjeCwgY3ldXG4gICAgICAgIF07XG4gICAgICAgIGlmIChweCkge1xuICAgICAgICAgICAgY2VsbHMucHVzaChbY3grMSwgY3ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHkpIHtcbiAgICAgICAgICAgIGNlbGxzLnB1c2goW2N4LCBjeSsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG54KSB7XG4gICAgICAgICAgICBjZWxscy5wdXNoKFtjeC0xLCBjeV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChueSkge1xuICAgICAgICAgICAgY2VsbHMucHVzaChbY3gsIGN5LTFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnggJiYgbnkpIHtcbiAgICAgICAgICAgIGNlbGxzLnB1c2goW2N4LTEsIGN5LTFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHggJiYgcHkpIHtcbiAgICAgICAgICAgIGNlbGxzLnB1c2goW2N4KzEsIGN5KzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnggJiYgcHkpIHtcbiAgICAgICAgICAgIGNlbGxzLnB1c2goW2N4LTEsIGN5KzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHggJiYgbnkpIHtcbiAgICAgICAgICAgIGNlbGxzLnB1c2goW2N4KzEsIGN5LTFdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gaGFzaGVzXG4gICAgICAgIHJldHVybiBjZWxscy5tYXAoY2VsbCA9PiB7XG4gICAgICAgICAgICAvLyBtb2QgdGhlIGNlbGwgY29vcmRzIGlmIHRoZXkgb3ZlcmZsb3dcbiAgICAgICAgICAgIGNlbGxbMF0gPSBtb2QoY2VsbFswXSwgbnVtQ2VsbHMpO1xuICAgICAgICAgICAgY2VsbFsxXSA9IG1vZChjZWxsWzFdLCBudW1DZWxscyk7XG4gICAgICAgICAgICAvLyBoYXNoXG4gICAgICAgICAgICByZXR1cm4gY2VsbFswXSArICc6JyArIGNlbGxbMV07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNpcmNsZUNvbGxpc2lvbihwb2ludCwgb3JpZ2luLCByYWRpdXMsIHpvb20pIHtcbiAgICAgICAgbGV0IGRpbSA9IE1hdGgucG93KDIsIHpvb20pICogVElMRV9TSVpFO1xuICAgICAgICBsZXQgcCwgbztcbiAgICAgICAgLy8gY2hlY2sgY2FzZXMgd2hlcmUgdGhlIHBvaW50IGlzIG5lYXIgdGhlIG9wcG9zaW5nIGhvcml6b250YWwgZXh0cmVtYVxuICAgICAgICAvLyBvZiB0aGUgbWFwIGFuZCBlbnN1cmUgdGhhdCB0aGUgZGlzdGFuY2UgY2FsY3VsYXRlZCBpcyB0aGUgc2hvcnRlc3RcbiAgICAgICAgaWYgKHBvaW50LnggPCByYWRpdXMgJiYgZGltIC0gb3JpZ2luLnggPCByYWRpdXMpIHtcbiAgICAgICAgICAgIHAgPSBwb2ludDtcbiAgICAgICAgICAgIG8gPSB7XG4gICAgICAgICAgICAgICAgeDogb3JpZ2luLnggLSBkaW0sXG4gICAgICAgICAgICAgICAgeTogb3JpZ2luLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZGltIC0gcG9pbnQueCA8IHJhZGl1cyAmJiBvcmlnaW4ueCA8IHJhZGl1cykge1xuICAgICAgICAgICAgcCA9IHtcbiAgICAgICAgICAgICAgICB4OiBwb2ludC54IC0gZGltLFxuICAgICAgICAgICAgICAgIHk6IHBvaW50LnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvID0gb3JpZ2luO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IHBvaW50O1xuICAgICAgICAgICAgbyA9IG9yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZHggPSBwLnggLSBvLng7XG4gICAgICAgIGxldCBkeSA9IHAueSAtIG8ueTtcbiAgICAgICAgbGV0IGRpc3RTcXIgPSAoZHggKiBkeCkgKyAoZHkgKiBkeSk7XG4gICAgICAgIGlmIChkaXN0U3FyIDwgKHJhZGl1cyAqIHJhZGl1cykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLmNsZWFySGFzaCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySGFzaCgpIHtcbiAgICAgICAgdGhpcy5fc3BhdGlhbEhhc2ggPSB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRQb2ludChwb2ludCwgcmFkaXVzLCB6b29tKSB7XG4gICAgICAgIC8vIHNwYXRpYWwgaGFzaCBrZXlcbiAgICAgICAgbGV0IHggPSBwb2ludC54O1xuICAgICAgICBsZXQgeSA9IHBvaW50Lnk7XG4gICAgICAgIGxldCBoYXNoZXMgPSBnZXRIYXNoZXMoeCwgeSwgcmFkaXVzLCB6b29tKTtcbiAgICAgICAgLy8gYWRkIHBpeGVsIHRvIGhhc2hcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaT0wOyBpPGhhc2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGhhc2ggPSBoYXNoZXNbaV07XG4gICAgICAgICAgICB0aGlzLl9zcGF0aWFsSGFzaFtoYXNoXSA9IHRoaXMuX3NwYXRpYWxIYXNoW2hhc2hdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5fc3BhdGlhbEhhc2hbaGFzaF0ucHVzaChwb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVQb2ludChwb2ludCwgcmFkaXVzLCB6b29tKSB7XG4gICAgICAgIC8vIHNwYXRpYWwgaGFzaCBrZXlcbiAgICAgICAgbGV0IGhhc2hlcyA9IGdldEhhc2hlcyhwb2ludC54LCBwb2ludC55LCByYWRpdXMsIHpvb20pO1xuICAgICAgICAvLyBhZGQgcGl4ZWwgdG8gaGFzaFxuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpPTA7IGk8aGFzaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaGFzaCA9IGhhc2hlc1tpXTtcbiAgICAgICAgICAgIGxldCBwb2ludHMgPSB0aGlzLl9zcGF0aWFsSGFzaFtoYXNoXTtcbiAgICAgICAgICAgIGlmIChwb2ludHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBwb2ludHMuaW5kZXhPZihwb2ludCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGljayhwb2ludCwgcmFkaXVzLCB6b29tKSB7XG4gICAgICAgIGxldCBoYXNoID0gZ2V0SGFzaChwb2ludC54LCBwb2ludC55LCByYWRpdXMpO1xuICAgICAgICAvLyBnZXQgcG9pbnRzIGluIGJpblxuICAgICAgICBsZXQgcG9pbnRzID0gdGhpcy5fc3BhdGlhbEhhc2hbaGFzaF07XG4gICAgICAgIGlmIChwb2ludHMpIHtcbiAgICAgICAgICAgIC8vIGZpbmQgZmlyc3QgaW50ZXJzZWN0aW5nIHBvaW50IGluIHRoZSBiaW5cbiAgICAgICAgICAgIGxldCBwLCBpO1xuICAgICAgICAgICAgZm9yIChpPTA7IGk8cG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgaWYgKGNpcmNsZUNvbGxpc2lvbihwb2ludCwgcCwgcmFkaXVzLCB6b29tKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gZmlyc3QgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGluaXRpYWxpemU6IGluaXRpYWxpemUsXG4gICAgICAgIGNsZWFySGFzaDogY2xlYXJIYXNoLFxuICAgICAgICBhZGRQb2ludDogYWRkUG9pbnQsXG4gICAgICAgIHJlbW92ZVBvaW50OiByZW1vdmVQb2ludCxcbiAgICAgICAgcGljazogcGlja1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgU0lHTU9JRF9TQ0FMRSA9IDAuMTU7XG5cbiAgICAvLyBsb2cxMFxuXG4gICAgZnVuY3Rpb24gbG9nMTBUcmFuc2Zvcm0odmFsLCBtaW4sIG1heCkge1xuICAgICAgICBsZXQgbG9nTWluID0gTWF0aC5sb2cxMChtaW4gfHwgMSk7XG4gICAgICAgIGxldCBsb2dNYXggPSBNYXRoLmxvZzEwKG1heCB8fCAxKTtcbiAgICAgICAgbGV0IGxvZ1ZhbCA9IE1hdGgubG9nMTAodmFsIHx8IDEpO1xuICAgICAgICByZXR1cm4gKGxvZ1ZhbCAtIGxvZ01pbikgLyAoKGxvZ01heCAtIGxvZ01pbikgfHwgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52ZXJzZUxvZzEwVHJhbnNmb3JtKG52YWwsIG1pbiwgbWF4KSB7XG4gICAgICAgIGxldCBsb2dNaW4gPSBNYXRoLmxvZzEwKG1pbiB8fCAxKTtcbiAgICAgICAgbGV0IGxvZ01heCA9IE1hdGgubG9nMTAobWF4IHx8IDEpO1xuICAgICAgICByZXR1cm4gTWF0aC5wb3coMTAsIChudmFsICogbG9nTWF4IC0gbnZhbCAqIGxvZ01pbikgKyBsb2dNaW4pO1xuICAgIH1cblxuICAgIC8vIHNpZ21vaWRcblxuICAgIGZ1bmN0aW9uIHNpZ21vaWRUcmFuc2Zvcm0odmFsLCBtaW4sIG1heCkge1xuICAgICAgICBsZXQgYWJzTWluID0gTWF0aC5hYnMobWluKTtcbiAgICAgICAgbGV0IGFic01heCA9IE1hdGguYWJzKG1heCk7XG4gICAgICAgIGxldCBkaXN0YW5jZSA9IE1hdGgubWF4KGFic01pbiwgYWJzTWF4KTtcbiAgICAgICAgbGV0IHNjYWxlZFZhbCA9IHZhbCAvIChTSUdNT0lEX1NDQUxFICogZGlzdGFuY2UpO1xuICAgICAgICByZXR1cm4gMSAvICgxICsgTWF0aC5leHAoLXNjYWxlZFZhbCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmVyc2VTaWdtb2lkVHJhbnNmb3JtKG52YWwsIG1pbiwgbWF4KSB7XG4gICAgICAgIGxldCBhYnNNaW4gPSBNYXRoLmFicyhtaW4pO1xuICAgICAgICBsZXQgYWJzTWF4ID0gTWF0aC5hYnMobWF4KTtcbiAgICAgICAgbGV0IGRpc3RhbmNlID0gTWF0aC5tYXgoYWJzTWluLCBhYnNNYXgpO1xuICAgICAgICBpZiAobnZhbCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIC1kaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnZhbCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLmxvZygoMS9udmFsKSAtIDEpICogLShTSUdNT0lEX1NDQUxFICogZGlzdGFuY2UpO1xuICAgIH1cblxuICAgIC8vIGxpbmVhclxuXG4gICAgZnVuY3Rpb24gbGluZWFyVHJhbnNmb3JtKHZhbCwgbWluLCBtYXgpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gbWF4IC0gbWluO1xuICAgICAgICBpZiAocmFuZ2UgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodmFsIC0gbWluKSAvIHJhbmdlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmVyc2VMaW5lYXJUcmFuc2Zvcm0obnZhbCwgbWluLCBtYXgpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gbWF4IC0gbWluO1xuICAgICAgICBpZiAocmFuZ2UgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW4gKyBudmFsICogcmFuZ2U7XG4gICAgfVxuXG4gICAgbGV0IFRyYW5zZm9ybSA9IHtcbiAgICAgICAgbGluZWFyOiBsaW5lYXJUcmFuc2Zvcm0sXG4gICAgICAgIGxvZzEwOiBsb2cxMFRyYW5zZm9ybSxcbiAgICAgICAgc2lnbW9pZDogc2lnbW9pZFRyYW5zZm9ybVxuICAgIH07XG5cbiAgICBsZXQgSW52ZXJzZSA9IHtcbiAgICAgICAgbGluZWFyOiBpbnZlcnNlTGluZWFyVHJhbnNmb3JtLFxuICAgICAgICBsb2cxMDogaW52ZXJzZUxvZzEwVHJhbnNmb3JtLFxuICAgICAgICBzaWdtb2lkOiBpbnZlcnNlU2lnbW9pZFRyYW5zZm9ybVxuICAgIH07XG5cbiAgICBsZXQgaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9yYW5nZSA9IHtcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogMVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1GdW5jID0gbG9nMTBUcmFuc2Zvcm07XG4gICAgICAgIHRoaXMuX2ludmVyc2VGdW5jID0gaW52ZXJzZUxvZzEwVHJhbnNmb3JtO1xuICAgIH07XG5cbiAgICBsZXQgc2V0VHJhbnNmb3JtRnVuYyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgbGV0IGZ1bmMgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUZ1bmMgPSBUcmFuc2Zvcm1bZnVuY107XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybVR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9pbnZlcnNlRnVuYyA9IEludmVyc2VbZnVuY107XG4gICAgfTtcblxuICAgIGxldCBzZXRWYWx1ZVJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgdGhpcy5fcmFuZ2UubWluID0gcmFuZ2UubWluO1xuICAgICAgICB0aGlzLl9yYW5nZS5tYXggPSByYW5nZS5tYXg7XG4gICAgfTtcblxuICAgIGxldCBnZXRWYWx1ZVJhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYW5nZTtcbiAgICB9O1xuXG4gICAgbGV0IGdldFRyYW5zZm9ybUVudW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zZm9ybVR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl90cmFuc2Zvcm1UeXBlID09PSAnc2lnbW9pZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG5cbiAgICBsZXQgaW50ZXJwb2xhdGVUb1JhbmdlID0gZnVuY3Rpb24obnZhbCkge1xuICAgICAgICAvLyBpbnRlcnBvbGF0ZSBiZXR3ZWVuIHRoZSBmaWx0ZXIgcmFuZ2VcbiAgICAgICAgbGV0IHJNaW4gPSB0aGlzLl9yYW5nZS5taW47XG4gICAgICAgIGxldCByTWF4ID0gdGhpcy5fcmFuZ2UubWF4O1xuICAgICAgICBsZXQgcnZhbCA9IChudmFsIC0gck1pbikgLyAock1heCAtIHJNaW4pO1xuICAgICAgICAvLyBlbnN1cmUgb3V0cHV0IGlzIFswOjFdXG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBydmFsKSk7XG4gICAgfTtcblxuICAgIGxldCB0cmFuc2Zvcm1WYWx1ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAvLyBjbGFtcCB0aGUgdmFsdWUgYmV0d2VlbiB0aGUgZXh0cmVtZSAoc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSlcbiAgICAgICAgbGV0IG1pbiA9IHRoaXMuX2V4dHJlbWEubWluO1xuICAgICAgICBsZXQgbWF4ID0gdGhpcy5fZXh0cmVtYS5tYXg7XG4gICAgICAgIGxldCBjbGFtcGVkID0gTWF0aC5tYXgoTWF0aC5taW4odmFsLCBtYXgpLCBtaW4pO1xuICAgICAgICAvLyBub3JtYWxpemUgdGhlIHZhbHVlXG4gICAgICAgIGlmIChtaW4gIT09IG1heCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybUZ1bmMoY2xhbXBlZCwgbWluLCBtYXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG1pbiA9PT0gbWF4LCBhbHdheXMgcmV0dXJuIDFcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfTtcblxuICAgIGxldCB1bnRyYW5zZm9ybVZhbHVlID0gZnVuY3Rpb24obnZhbCkge1xuICAgICAgICBsZXQgbWluID0gdGhpcy5fZXh0cmVtYS5taW47XG4gICAgICAgIGxldCBtYXggPSB0aGlzLl9leHRyZW1hLm1heDtcbiAgICAgICAgLy8gY2xhbXAgdGhlIHZhbHVlIGJldHdlZW4gdGhlIGV4dHJlbWUgKHNob3VsZG4ndCBiZSBuZWNlc3NhcnkpXG4gICAgICAgIGxldCBjbGFtcGVkID0gTWF0aC5tYXgoTWF0aC5taW4obnZhbCwgMSksIDApO1xuICAgICAgICAvLyB1bm5vcm1hbGl6ZSB0aGUgdmFsdWVcbiAgICAgICAgaWYgKG1pbiAhPT0gbWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW52ZXJzZUZ1bmMoY2xhbXBlZCwgbWluLCBtYXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG1pbiA9PT0gbWF4LCBhbHdheXMgcmV0dXJuIDFcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBpbml0aWFsaXplOiBpbml0aWFsaXplLFxuICAgICAgICBzZXRUcmFuc2Zvcm1GdW5jOiBzZXRUcmFuc2Zvcm1GdW5jLFxuICAgICAgICBzZXRWYWx1ZVJhbmdlOiBzZXRWYWx1ZVJhbmdlLFxuICAgICAgICBnZXRWYWx1ZVJhbmdlOiBnZXRWYWx1ZVJhbmdlLFxuICAgICAgICBnZXRUcmFuc2Zvcm1FbnVtOiBnZXRUcmFuc2Zvcm1FbnVtLFxuICAgICAgICB0cmFuc2Zvcm1WYWx1ZTogdHJhbnNmb3JtVmFsdWUsXG4gICAgICAgIHVudHJhbnNmb3JtVmFsdWU6IHVudHJhbnNmb3JtVmFsdWUsXG4gICAgICAgIGludGVycG9sYXRlVG9SYW5nZTogaW50ZXJwb2xhdGVUb1JhbmdlXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBQT1NJVElWRSA9ICcxJztcbiAgICBsZXQgTkVVVFJBTCA9ICcwJztcbiAgICBsZXQgTkVHQVRJVkUgPSAnLTEnO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q2xhc3NGdW5jKG1pbiwgbWF4KSB7XG4gICAgICAgIG1pbiA9IG1pbiAhPT0gdW5kZWZpbmVkID8gbWluIDogLTE7XG4gICAgICAgIG1heCA9IG1heCAhPT0gdW5kZWZpbmVkID8gbWF4IDogMTtcbiAgICAgICAgbGV0IHBvc2l0aXZlID0gWzAuMjUgKiBtYXgsIDAuNSAqIG1heCwgMC43NSAqIG1heF07XG4gICAgICAgIGxldCBuZWdhdGl2ZSA9IFstMC4yNSAqIG1pbiwgLTAuNSAqIG1pbiwgLTAuNzUgKiBtaW5dO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2VudGltZW50KSB7XG4gICAgICAgICAgICBsZXQgcHJlZml4O1xuICAgICAgICAgICAgbGV0IHJhbmdlO1xuICAgICAgICAgICAgaWYgKHNlbnRpbWVudCA8IDApIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnbmVnLSc7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBuZWdhdGl2ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJ3Bvcy0nO1xuICAgICAgICAgICAgICAgIHJhbmdlID0gcG9zaXRpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYWJzID0gTWF0aC5hYnMoc2VudGltZW50KTtcbiAgICAgICAgICAgIGlmIChhYnMgPiByYW5nZVsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyAnNCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA+IHJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArICczJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzID4gcmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgJzInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArICcxJztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUb3RhbChjb3VudCkge1xuICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcG9zID0gY291bnRbUE9TSVRJVkVdID8gY291bnRbUE9TSVRJVkVdIDogMDtcbiAgICAgICAgbGV0IG5ldSA9IGNvdW50W05FVVRSQUxdID8gY291bnRbTkVVVFJBTF0gOiAwO1xuICAgICAgICBsZXQgbmVnID0gY291bnRbTkVHQVRJVkVdID8gY291bnRbTkVHQVRJVkVdIDogMDtcbiAgICAgICAgcmV0dXJuIHBvcyArIG5ldSArIG5lZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBdmcoY291bnQpIHtcbiAgICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBvcyA9IGNvdW50W1BPU0lUSVZFXSA/IGNvdW50W1BPU0lUSVZFXSA6IDA7XG4gICAgICAgIGxldCBuZXUgPSBjb3VudFtORVVUUkFMXSA/IGNvdW50W05FVVRSQUxdIDogMDtcbiAgICAgICAgbGV0IG5lZyA9IGNvdW50W05FR0FUSVZFXSA/IGNvdW50W05FR0FUSVZFXSA6IDA7XG4gICAgICAgIGxldCB0b3RhbCA9IHBvcyArIG5ldSArIG5lZztcbiAgICAgICAgcmV0dXJuICh0b3RhbCAhPT0gMCkgPyAocG9zIC0gbmVnKSAvIHRvdGFsIDogMDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZ2V0Q2xhc3NGdW5jOiBnZXRDbGFzc0Z1bmMsXG4gICAgICAgIGdldFRvdGFsOiBnZXRUb3RhbCxcbiAgICAgICAgZ2V0QXZnOiBnZXRBdmdcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IENhbnZhcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQ2FudmFzJyk7XG4gICAgbGV0IENvbG9yUmFtcCA9IHJlcXVpcmUoJy4uLy4uL21peGluL0NvbG9yUmFtcCcpO1xuICAgIGxldCBWYWx1ZVRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uLy4uL21peGluL1ZhbHVlVHJhbnNmb3JtJyk7XG5cbiAgICBsZXQgSGVhdG1hcCA9IENhbnZhcy5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBtaXhpbnNcbiAgICAgICAgICAgIENvbG9yUmFtcCxcbiAgICAgICAgICAgIFZhbHVlVHJhbnNmb3JtXG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBDb2xvclJhbXAuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgVmFsdWVUcmFuc2Zvcm0uaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlckNhbnZhczogZnVuY3Rpb24oYmlucywgcmVzb2x1dGlvbiwgcmFtcCkge1xuICAgICAgICAgICAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHJlc29sdXRpb247XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSByZXNvbHV0aW9uO1xuICAgICAgICAgICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgbGV0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgcmVzb2x1dGlvbiwgcmVzb2x1dGlvbik7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgbGV0IGNvbG9yID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgbGV0IG52YWwsIHJ2YWwsIGJpbiwgaTtcbiAgICAgICAgICAgIGZvciAoaT0wOyBpPGJpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBiaW4gPSBiaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChiaW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JbMF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb2xvclsxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yWzJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JbM10gPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG52YWwgPSB0aGlzLnRyYW5zZm9ybVZhbHVlKGJpbik7XG4gICAgICAgICAgICAgICAgICAgIHJ2YWwgPSB0aGlzLmludGVycG9sYXRlVG9SYW5nZShudmFsKTtcbiAgICAgICAgICAgICAgICAgICAgcmFtcChydmFsLCBjb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGFbaSAqIDRdID0gTWF0aC5yb3VuZChjb2xvclswXSAqIDI1NSk7XG4gICAgICAgICAgICAgICAgZGF0YVtpICogNCArIDFdID0gTWF0aC5yb3VuZChjb2xvclsxXSAqIDI1NSk7XG4gICAgICAgICAgICAgICAgZGF0YVtpICogNCArIDJdID0gTWF0aC5yb3VuZChjb2xvclsyXSAqIDI1NSk7XG4gICAgICAgICAgICAgICAgZGF0YVtpICogNCArIDNdID0gTWF0aC5yb3VuZChjb2xvclszXSAqIDI1NSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKGNhbnZhcywgZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJpbnMgPSBuZXcgRmxvYXQ2NEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgbGV0IHJlc29sdXRpb24gPSBNYXRoLnNxcnQoYmlucy5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IHJhbXAgPSB0aGlzLmdldENvbG9yUmFtcCgpO1xuICAgICAgICAgICAgbGV0IHRpbGVDYW52YXMgPSB0aGlzLnJlbmRlckNhbnZhcyhiaW5zLCByZXNvbHV0aW9uLCByYW1wKTtcbiAgICAgICAgICAgIGxldCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgdGlsZUNhbnZhcyxcbiAgICAgICAgICAgICAgICAwLCAwLFxuICAgICAgICAgICAgICAgIHJlc29sdXRpb24sIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgMCwgMCxcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGVhdG1hcDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBDYW52YXMgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0NhbnZhcycpO1xuXG4gICAgbGV0IFByZXZpZXcgPSBDYW52YXMuZXh0ZW5kKHtcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgICAgICBsaW5lQ29sb3I6ICcjZmZmJ1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZSxcblxuICAgICAgICBfZHJhd0hpZ2hsaWdodDogZnVuY3Rpb24oY2FudmFzLCB4LCB5LCBzaXplKSB7XG4gICAgICAgICAgICBsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5vcHRpb25zLmZpbGxDb2xvcjtcbiAgICAgICAgICAgIGN0eC5yZWN0KFxuICAgICAgICAgICAgICAgIHggKiBzaXplLFxuICAgICAgICAgICAgICAgIHkgKiBzaXplLFxuICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgc2l6ZSk7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5vcHRpb25zLmxpbmVXaWR0aDtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMub3B0aW9ucy5saW5lQ29sb3I7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBjbGVhciBleGlzdGluZyBoaWdobGlnaHRcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGlsZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGdldCBsYXllciBjb29yZFxuICAgICAgICAgICAgbGV0IGxheWVyUG9pbnQgPSB0aGlzLmdldExheWVyUG9pbnRGcm9tRXZlbnQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIC8vIGdldCB0aWxlIGNvb3JkXG4gICAgICAgICAgICBsZXQgY29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZyb21MYXllclBvaW50KGxheWVyUG9pbnQpO1xuICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGtleVxuICAgICAgICAgICAgbGV0IG5rZXkgPSB0aGlzLmNhY2hlS2V5RnJvbUNvb3JkKGNvb3JkLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGdldCBjYWNoZSBlbnRyeVxuICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX2NhY2hlW25rZXldO1xuICAgICAgICAgICAgaWYgKGNhY2hlZCAmJiBjYWNoZWQuZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIGdldCBiaW4gY29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgIGxldCBiaW4gPSB0aGlzLmdldEJpbkNvb3JkRnJvbUxheWVyUG9pbnQobGF5ZXJQb2ludCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGJpbiBkYXRhIGVudHJ5XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBjYWNoZWQuZGF0YVtiaW4uaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIHRpbGUgcmVseWluZyBvbiB0aGF0IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgXy5mb3JJbihjYWNoZWQudGlsZXMsIHRpbGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhd0hpZ2hsaWdodCh0aWxlLCBiaW4ueCwgYmluLnksIGJpbi5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2xsaXNpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNvb3JkLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBjb29yZC56LFxuICAgICAgICAgICAgICAgICAgICAgICAgejogY29vcmQueixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ4OiBiaW4ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5OiBiaW4ueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwcmV2aWV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhlY3V0ZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW92ZXInLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbTogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYWcgYXMgaGlnaGxpZ2h0ZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZCA9IGNvbGxpc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGN1cnNvclxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuX21hcC5fY29udGFpbmVyKS5jc3MoJ2N1cnNvcicsICdwb2ludGVyJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtb3VzZSBvdXRcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW91dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbTogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5oaWdobGlnaHRlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xlYXIgaGlnaGxpZ2h0ZWQgZmxhZ1xuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQcmV2aWV3O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IENhbnZhcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQ2FudmFzJyk7XG4gICAgbGV0IENvbG9yUmFtcCA9IHJlcXVpcmUoJy4uLy4uL21peGluL0NvbG9yUmFtcCcpO1xuICAgIGxldCBWYWx1ZVRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uLy4uL21peGluL1ZhbHVlVHJhbnNmb3JtJyk7XG5cbiAgICBsZXQgVG9wVHJhaWxzID0gQ2FudmFzLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIG1peGluc1xuICAgICAgICAgICAgQ29sb3JSYW1wLFxuICAgICAgICAgICAgVmFsdWVUcmFuc2Zvcm1cbiAgICAgICAgXSxcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBzZWxlY3RlZENvbG9yOiBbMjU1LCAxMDAsIDI1NSwgMjU1XSxcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkQ29sb3I6IFsyMDAsIDAsIDI1NSwgMjU1XSxcbiAgICAgICAgICAgIGRvd25TYW1wbGVGYWN0b3I6IDhcbiAgICAgICAgfSxcblxuICAgICAgICBoaWdobGlnaHRlZDogbnVsbCxcblxuICAgICAgICBzZWxlY3RlZDogbnVsbCxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIENvbG9yUmFtcC5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBWYWx1ZVRyYW5zZm9ybS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJIaWdobGlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGlsZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhclNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaWxlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldFNlbGVjdGlvbjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB2YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRIaWdobGlnaHQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFySGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkID0gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGUub3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICBsZXQgYmluID0gdGhpcy5fZ2V0QmluRGF0YShlKTtcbiAgICAgICAgICAgIGlmIChiaW4pIHtcbiAgICAgICAgICAgICAgICAvLyBleGVjdXRlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdjbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbTogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYmluXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gZmxhZyBhcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKGJpbik7XG4gICAgICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0VHJhaWxzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xlYXIgc2VsZWN0ZWQgZmxhZ1xuICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0VHJhaWxzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgbGV0IGJpbiA9IHRoaXMuX2dldEJpbkRhdGEoZSk7XG4gICAgICAgICAgICBpZiAoYmluKSB7XG4gICAgICAgICAgICAgICAgLy8gZXhlY3V0ZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdmVyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbTogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGJpblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZmxhZyBhcyBoaWdobGlnaHRlZFxuICAgICAgICAgICAgICAgIHRoaXMuc2V0SGlnaGxpZ2h0KGJpbik7XG4gICAgICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0VHJhaWxzKCk7XG4gICAgICAgICAgICAgICAgLy8gc2V0IGN1cnNvclxuICAgICAgICAgICAgICAgICQodGhpcy5fbWFwLl9jb250YWluZXIpLmNzcygnY3Vyc29yJywgJ3BvaW50ZXInKTtcbiAgICAgICAgICAgICAgICAvLyBleGl0IGVhcmx5XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbW91c2Ugb3V0XG4gICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW06IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuaGlnaGxpZ2h0ZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xlYXJIaWdobGlnaHQoKTtcbiAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodFRyYWlscygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRCaW5EYXRhOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAvLyBnZXQgbGF5ZXIgY29vcmRcbiAgICAgICAgICAgIGxldCBsYXllclBvaW50ID0gdGhpcy5nZXRMYXllclBvaW50RnJvbUV2ZW50KGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAvLyBnZXQgdGlsZSBjb29yZFxuICAgICAgICAgICAgbGV0IGNvb3JkID0gdGhpcy5nZXRUaWxlQ29vcmRGcm9tTGF5ZXJQb2ludChsYXllclBvaW50KTtcbiAgICAgICAgICAgIC8vIGdldCBjYWNoZSBrZXlcbiAgICAgICAgICAgIGxldCBua2V5ID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZCwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBnZXQgY2FjaGUgZW50cnlcbiAgICAgICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9jYWNoZVtua2V5XTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLnBpeGVscykge1xuICAgICAgICAgICAgICAgIC8vIGdldCBiaW4gY29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgIGxldCBiaW4gPSB0aGlzLmdldEJpbkNvb3JkRnJvbUxheWVyUG9pbnQobGF5ZXJQb2ludCk7XG4gICAgICAgICAgICAgICAgLy8gZG93bnNhbXBsZSB0aGUgYmluIHJlc1xuICAgICAgICAgICAgICAgIGxldCB4ID0gTWF0aC5mbG9vcihiaW4ueCAvIHRoaXMub3B0aW9ucy5kb3duU2FtcGxlRmFjdG9yKTtcbiAgICAgICAgICAgICAgICBsZXQgeSA9IE1hdGguZmxvb3IoYmluLnkgLyB0aGlzLm9wdGlvbnMuZG93blNhbXBsZUZhY3Rvcik7XG4gICAgICAgICAgICAgICAgLy8gaWYgaGl0cyBhIHBpeGVsXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZC5waXhlbHNbeF0gJiYgY2FjaGVkLnBpeGVsc1t4XVt5XSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMoY2FjaGVkLnBpeGVsc1t4XVt5XSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRha2UgZmlyc3QgZW50cnlcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlkID0gaWRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgY29sbGlzaW9uIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBsZXQgY29sbGlzaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogY29vcmQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNvb3JkLnosXG4gICAgICAgICAgICAgICAgICAgICAgICB6OiBjb29yZC56LFxuICAgICAgICAgICAgICAgICAgICAgICAgYng6IGJpbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgYnk6IGJpbi55LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RvcC10cmFpbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxpc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBfaGlnaGxpZ2h0VHJhaWxzRm9yRGF0YTogZnVuY3Rpb24oY2FjaGVkKSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkO1xuICAgICAgICAgICAgbGV0IGhpZ2hsaWdodGVkID0gdGhpcy5oaWdobGlnaHRlZDtcbiAgICAgICAgICAgIGlmIChjYWNoZWQuZGF0YSkge1xuICAgICAgICAgICAgICAgIGxldCB0cmFpbDtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhaWwgPSBjYWNoZWQudHJhaWxzW3NlbGVjdGVkLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCB0aWxlIHJlbHlpbmcgb24gdGhhdCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmZvckluKGNhY2hlZC50aWxlcywgdGlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyVHJhaWwodGlsZSwgdHJhaWwsIHRoaXMub3B0aW9ucy5zZWxlY3RlZENvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFpbCA9IGNhY2hlZC50cmFpbHNbaGlnaGxpZ2h0ZWQudmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9ySW4oY2FjaGVkLnRpbGVzLCB0aWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJUcmFpbCh0aWxlLCB0cmFpbCwgdGhpcy5vcHRpb25zLmhpZ2hsaWdodGVkQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2hpZ2hsaWdodFRyYWlsczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfLmZvckluKHRoaXMuX2NhY2hlLCBjYWNoZWQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodFRyYWlsc0ZvckRhdGEoY2FjaGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9yZW5kZXJUcmFpbDogZnVuY3Rpb24oY2FudmFzLCBwaXhlbHMsIGNvbG9yKSB7XG4gICAgICAgICAgICBsZXQgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgbGV0IGhpZ2hsaWdodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgaGlnaGxpZ2h0LmhlaWdodCA9IHJlc29sdXRpb247XG4gICAgICAgICAgICBoaWdobGlnaHQud2lkdGggPSByZXNvbHV0aW9uO1xuICAgICAgICAgICAgbGV0IGhpZ2hsaWdodEN0eCA9IGhpZ2hsaWdodC5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgbGV0IGltYWdlRGF0YSA9IGhpZ2hsaWdodEN0eC5nZXRJbWFnZURhdGEoMCwgMCwgcmVzb2x1dGlvbiwgcmVzb2x1dGlvbik7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgbGV0IHBpeGVsLCB4LCB5LCBpLCBqO1xuICAgICAgICAgICAgZm9yIChpPTA7IGk8cGl4ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGl4ZWwgPSBwaXhlbHNbaV07XG4gICAgICAgICAgICAgICAgeCA9IHBpeGVsWzBdO1xuICAgICAgICAgICAgICAgIHkgPSBwaXhlbFsxXTtcbiAgICAgICAgICAgICAgICBqID0geCArIChyZXNvbHV0aW9uICogeSk7XG4gICAgICAgICAgICAgICAgZGF0YVtqICogNF0gPSBjb2xvclswXTtcbiAgICAgICAgICAgICAgICBkYXRhW2ogKiA0ICsgMV0gPSBjb2xvclsxXTtcbiAgICAgICAgICAgICAgICBkYXRhW2ogKiA0ICsgMl0gPSBjb2xvclsyXTtcbiAgICAgICAgICAgICAgICBkYXRhW2ogKiA0ICsgM10gPSBjb2xvclszXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhpZ2hsaWdodEN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgICAgICAgIC8vIGRyYXcgdG8gdGlsZVxuICAgICAgICAgICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICBoaWdobGlnaHQsXG4gICAgICAgICAgICAgICAgMCwgMCxcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uLCByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEsIGNvb3JkKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtb2RpZnkgY2FjaGUgZW50cnlcbiAgICAgICAgICAgIGxldCBua2V5ID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZCwgdHJ1ZSk7XG4gICAgICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5fY2FjaGVbbmtleV07XG4gICAgICAgICAgICBpZiAoY2FjaGVkLnRyYWlscykge1xuICAgICAgICAgICAgICAgIC8vIHRyYWlscyBhbHJlYWR5IGFkZGVkLCBleGl0IGVhcmx5XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRyYWlscyA9IGNhY2hlZC50cmFpbHMgPSB7fTtcbiAgICAgICAgICAgIGxldCBwaXhlbHMgPSBjYWNoZWQucGl4ZWxzID0ge307XG4gICAgICAgICAgICBsZXQgaWRzICA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgICAgICAgbGV0IGJpbnMsIGJpbjtcbiAgICAgICAgICAgIGxldCBpZCwgaSwgajtcbiAgICAgICAgICAgIGxldCByeCwgcnksIHgsIHk7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgICAgICBiaW5zID0gZGF0YVtpZF07XG4gICAgICAgICAgICAgICAgZm9yIChqPTA7IGo8Ymlucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBiaW4gPSBiaW5zW2pdO1xuICAgICAgICAgICAgICAgICAgICAvLyBkb3duIHNhbXBsZSB0aGUgcGl4ZWwgdG8gbWFrZSBpbnRlcmFjdGlvbiBlYXNpZXJcbiAgICAgICAgICAgICAgICAgICAgcnggPSBNYXRoLmZsb29yKGJpblswXSAvIHRoaXMub3B0aW9ucy5kb3duU2FtcGxlRmFjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgcnkgPSBNYXRoLmZsb29yKGJpblsxXSAvIHRoaXMub3B0aW9ucy5kb3duU2FtcGxlRmFjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3J4XSA9IHBpeGVsc1tyeF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsc1tyeF1bcnldID0gcGl4ZWxzW3J4XVtyeV0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsc1tyeF1bcnldW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBwaXhlbCB1bmRlciB0aGUgdHJhaWwgYXQgY29ycmVjdCByZXNvbHV0aW9uXG4gICAgICAgICAgICAgICAgICAgIHggPSBiaW5bMF07XG4gICAgICAgICAgICAgICAgICAgIHkgPSBiaW5bMV07XG4gICAgICAgICAgICAgICAgICAgIHRyYWlsc1tpZF0gPSB0cmFpbHNbaWRdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICB0cmFpbHNbaWRdLnB1c2goWyB4LCB5IF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byBoaWdobGlnaHQgc2VsZWN0ZWQgdHJhaWxzIGluIHRoZSB0aWxlXG4gICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRUcmFpbHNGb3JEYXRhKGNhY2hlZCk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUb3BUcmFpbHM7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbihlbGVtLCBjb29yZCkge1xuICAgICAgICAgICAgJChlbGVtKS5lbXB0eSgpO1xuICAgICAgICAgICAgJChlbGVtKS5hcHBlbmQoJzxkaXYgc3R5bGU9XCJ0b3A6MDsgbGVmdDowO1wiPicgKyBjb29yZC56ICsgJywgJyArIGNvb3JkLnggKyAnLCAnICsgY29vcmQueSArICc8L2Rpdj4nKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBIVE1MID0gcmVxdWlyZSgnLi4vLi4vY29yZS9IVE1MJyk7XG5cbiAgICBsZXQgQ29tbXVuaXR5ID0gSFRNTC5leHRlbmQoe1xuXG4gICAgICAgIF9nZXRCaW5Db29yZEZyb21DYXJ0ZXNpYW46IGZ1bmN0aW9uKHB4LCBweSwgem9vbSkge1xuICAgICAgICAgICAgLy8gQ29vcmRzIGFyZSBuYW1lZCBsb24vbGF0LCBidXQgYXJlIGFjdHVhbGx5IGluIHRoZSByYW5nZSBbMCwgMjU1XS5cbiAgICAgICAgICAgIC8vIFRoZSBMZWFmbGV0IG1hcCBpcyBzZXR1cCB0byB1c2UgYSBjdXN0b20gcHJvamVjdGlvbiB0byByZWZsZWN0IHRoaXMgb25cbiAgICAgICAgICAgIC8vIGNyZWF0aW9uLlxuICAgICAgICAgICAgbGV0IGxheWVyUHQgPSB0aGlzLl9nZXRMYXllclBvaW50RnJvbUxvbkxhdCh7XG4gICAgICAgICAgICAgICAgJ2xvbic6IHB4LFxuICAgICAgICAgICAgICAgICdsYXQnOiBweVxuICAgICAgICAgICAgfSwgem9vbSk7XG4gICAgICAgICAgICBsZXQgcmVzID0gIHRoaXMuZ2V0QmluQ29vcmRGcm9tTGF5ZXJQb2ludChsYXllclB0LCAyNTYpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyByZW5kZXIgY29tbXVuaXR5IHJpbmdzXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGF0YSwgY29vcmQpIHtcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhkYXRhKTtcbiAgICAgICAgICAgIGxldCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgICAgICAgICAgbGV0IGRlY29kZWRTdHJpbmcgPSBkZWNvZGVyLmRlY29kZShkYXRhVmlldyk7XG4gICAgICAgICAgICBsZXQganNvbk9iaiA9IEpTT04ucGFyc2UoZGVjb2RlZFN0cmluZyk7XG5cbiAgICAgICAgICAgIGxldCBkaXZzID0gJCgpO1xuICAgICAgICAgICAgXy5mb3JFYWNoKGpzb25PYmouY29tbXVuaXRpZXMsIGNvbW11bml0eSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW11bml0eS5udW1Ob2RlcyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpdiA9IHRoaXMuX2NyZWF0ZVJpbmdEaXYoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tdW5pdHkucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbXVuaXR5LmNvb3JkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkLnosXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29tbXVuaXR5LXJpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2LmRhdGEoJ25hbWUnLCBjb21tdW5pdHkubWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBkaXYuZGF0YSgnY291bnQnLCBjb21tdW5pdHkubnVtTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICBkaXZzID0gZGl2cy5hZGQoZGl2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICQoY29udGFpbmVyKS5hcHBlbmQoZGl2cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gZm9yd2FyZCBjb21tdW5pdHkgbWV0YWRhdGEgc3RyaW5nIHRvIGFwcCBsZXZlbCBtb3VzZW1vdmUgaGFuZGxlciB3aGVuIHBvaW50ZXIgaXNcbiAgICAgICAgLy8gb3ZlciBhIGNvbW11bml0eSByaW5nXG4gICAgICAgIG9uTW91c2VPdmVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gJChlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHtuYW1lOiB0YXJnZXQuZGF0YSgnbmFtZScpLCBjb3VudDogdGFyZ2V0LmRhdGEoJ2NvdW50Jyl9O1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3ZlcicsIHtcbiAgICAgICAgICAgICAgICBlbGVtOiBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbXVuaXR5JyxcbiAgICAgICAgICAgICAgICBsYXllcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gZm9yd2FyZCBjbGVhcmVkIHN0cmluZyB0byBhcHAgbGV2ZWwgbW91c2Vtb3ZlIGhhbmRsZXIgd2hlbiBwb2ludGVyIG1vdmVzIG9mZlxuICAgICAgICAvLyBhIGNvbW11bml0eSByaW5nXG4gICAgICAgIG9uTW91c2VPdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdXQnLCB7XG4gICAgICAgICAgICAgICAgZWxlbTogZS5vcmlnaW5hbEV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbXVuaXR5JyxcbiAgICAgICAgICAgICAgICBsYXllcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NyZWF0ZVJpbmdEaXY6IGZ1bmN0aW9uKGNvbW11bml0eVJhZGl1cywgY29tbXVuaXR5Q29vcmRzLCB6b29tTGV2ZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgbGV0IHJhZGl1cyA9IE1hdGgubWF4KDQsIGNvbW11bml0eVJhZGl1cyAqIE1hdGgucG93KDIsIHpvb21MZXZlbCkpO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJhZGl1cyAvIDI7XG4gICAgICAgICAgICBsZXQgYmluQ29vcmQgPSB0aGlzLl9nZXRCaW5Db29yZEZyb21DYXJ0ZXNpYW4oXG4gICAgICAgICAgICAgICAgY29tbXVuaXR5Q29vcmRzWzBdLFxuICAgICAgICAgICAgICAgIGNvbW11bml0eUNvb3Jkc1sxXSxcbiAgICAgICAgICAgICAgICB6b29tTGV2ZWwpO1xuICAgICAgICAgICAgbGV0IGxlZnQgPSBiaW5Db29yZC54O1xuICAgICAgICAgICAgbGV0IHRvcCA9IGJpbkNvb3JkLnk7XG5cbiAgICAgICAgICAgIHJldHVybiAkKFxuICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtjbGFzc05hbWV9XCIgc3R5bGU9XCJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogJHtsZWZ0IC0gb2Zmc2V0fXB4O1xuICAgICAgICAgICAgICAgICAgICB0b3A6ICR7dG9wIC0gb2Zmc2V0fXB4O1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJHtyYWRpdXN9cHg7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJHtyYWRpdXN9cHg7XCI+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ29tbXVuaXR5O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IEhUTUwgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0hUTUwnKTtcblxuICAgIGxldCBDb21tdW5pdHlMYWJlbCA9IEhUTUwuZXh0ZW5kKHtcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBsYWJlbFNjYWxlOiAxLjAsXG4gICAgICAgICAgICBsYWJlbE1heExlbmd0aDogMjAwLFxuICAgICAgICAgICAgbGFiZWxUaHJlc2hvbGQ6IFtcbiAgICAgICAgICAgICAgICBbMCwgNTAwMF0sXG4gICAgICAgICAgICAgICAgWzEwLCAxMDBdLFxuICAgICAgICAgICAgICAgIFsxNCwgMTBdLFxuICAgICAgICAgICAgICAgIFsxNiwgMF1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGV4cGFuZCB0aHJlc2hvbGRzIGZvciBsb29rdXBzIGR1cmluZyByZW5kZXJpbmdcbiAgICAgICAgICAgIHRoaXMubGFiZWxUaHJlc2hvbGQgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWxUaHJlc2hvbGQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbFRocmVzaG9sZCA9IHRoaXMub3B0aW9ucy5sYWJlbFRocmVzaG9sZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKF8uZHJvcFJpZ2h0KHRoaXMub3B0aW9ucy5sYWJlbFRocmVzaG9sZCwgMSksICh2LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5vcHRpb25zLmxhYmVsVGhyZXNob2xkW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSBuZXh0WzBdIC0gdlswXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYWJlbFRocmVzaG9sZCA9IHRoaXMubGFiZWxUaHJlc2hvbGQuY29uY2F0KFxuICAgICAgICAgICAgICAgICAgICAgICAgXy56aXAoXy5yYW5nZSh2WzBdLCBuZXh0WzBdKSwgXy5maWxsKEFycmF5KHN0ZXApLCB2WzFdKSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxUaHJlc2hvbGQucHVzaChfLmxhc3QodGhpcy5vcHRpb25zLmxhYmVsVGhyZXNob2xkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gcmVuZGVyIGNvbW11bml0eSByaW5nc1xuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEsIGNvb3JkKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoZGF0YSk7XG4gICAgICAgICAgICBsZXQgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKTtcbiAgICAgICAgICAgIGxldCBkZWNvZGVkU3RyaW5nID0gZGVjb2Rlci5kZWNvZGUoZGF0YVZpZXcpO1xuICAgICAgICAgICAgbGV0IGpzb25PYmogPSBKU09OLnBhcnNlKGRlY29kZWRTdHJpbmcpO1xuXG4gICAgICAgICAgICBsZXQgZGl2cyA9ICQoKTtcbiAgICAgICAgICAgIF8uZm9yRWFjaChqc29uT2JqLmNvbW11bml0aWVzLCBjb21tdW5pdHkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpZHggPSBfLmNsYW1wKGNvb3JkLnosIDAsIHRoaXMubGFiZWxUaHJlc2hvbGQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW11bml0eS5udW1Ob2RlcyA+IHRoaXMubGFiZWxUaHJlc2hvbGRbaWR4XVsxXSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGl2ID0gdGhpcy5fY3JlYXRlTGFiZWxEaXYoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tdW5pdHkuY29vcmRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbXVuaXR5LnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkLnosXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tdW5pdHkubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29tbXVuaXR5LWxhYmVsJyk7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5kYXRhKCduYW1lJywgY29tbXVuaXR5Lm1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2LmRhdGEoJ2NvdW50JywgY29tbXVuaXR5Lm51bU5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2cyA9IGRpdnMuYWRkKGRpdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkKGNvbnRhaW5lcikuYXBwZW5kKGRpdnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGZvcndhcmQgY29tbXVuaXR5IG1ldGFkYXRhIHN0cmluZyB0byBhcHAgbGV2ZWwgbW91c2Vtb3ZlIGhhbmRsZXIgd2hlbiBwb2ludGVyIGlzXG4gICAgICAgIC8vIG92ZXIgYSBjb21tdW5pdHkgcmluZ1xuICAgICAgICBvbk1vdXNlT3ZlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9ICQoZS5vcmlnaW5hbEV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB7bmFtZTogdGFyZ2V0LmRhdGEoJ25hbWUnKSwgY291bnQ6IHRhcmdldC5kYXRhKCdjb3VudCcpfTtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW92ZXInLCB7XG4gICAgICAgICAgICAgICAgZWxlbTogZS5vcmlnaW5hbEV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW11bml0eS1sYWJlbHMnLFxuICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBmb3J3YXJkIGNsZWFyZWQgc3RyaW5nIHRvIGFwcCBsZXZlbCBtb3VzZW1vdmUgaGFuZGxlciB3aGVuIHBvaW50ZXIgbW92ZXMgb2ZmXG4gICAgICAgIC8vIGEgY29tbXVuaXR5IHJpbmdcbiAgICAgICAgb25Nb3VzZU91dDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW91dCcsIHtcbiAgICAgICAgICAgICAgICBlbGVtOiBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tdW5pdHktbGFiZWxzJyxcbiAgICAgICAgICAgICAgICBsYXllcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEJpbkNvb3JkRnJvbUNhcnRlc2lhbjogZnVuY3Rpb24ocHgsIHB5LCB6b29tKSB7XG4gICAgICAgICAgICAvLyBDb29yZHMgYXJlIG5hbWVkIGxvbi9sYXQsIGJ1dCBhcmUgYWN0dWFsbHkgaW4gdGhlIHJhbmdlIFswLCAyNTVdLlxuICAgICAgICAgICAgLy8gVGhlIExlYWZsZXQgbWFwIGlzIHNldHVwIHRvIHVzZSBhIGN1c3RvbSBwcm9qZWN0aW9uIHRvIHJlZmxlY3QgdGhpcyBvblxuICAgICAgICAgICAgLy8gY3JlYXRpb24uXG4gICAgICAgICAgICBsZXQgbGF5ZXJQdCA9IHRoaXMuX2dldExheWVyUG9pbnRGcm9tTG9uTGF0KHtcbiAgICAgICAgICAgICAgICAnbG9uJzogcHgsXG4gICAgICAgICAgICAgICAgJ2xhdCc6IHB5XG4gICAgICAgICAgICB9LCB6b29tKTtcbiAgICAgICAgICAgIGxldCByZXMgPSAgdGhpcy5nZXRCaW5Db29yZEZyb21MYXllclBvaW50KGxheWVyUHQsIDI1Nik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGVMYWJlbERpdjogZnVuY3Rpb24oY29tbXVuaXR5Q29vcmRzLCBjb21tdW5pdHlSYWRpdXMsIHpvb21MZXZlbCwgbGFiZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgbGV0IHJhZGl1cyA9IE1hdGgubWF4KDE2LCBjb21tdW5pdHlSYWRpdXMgKiBNYXRoLnBvdygyLCB6b29tTGV2ZWwpKTtcbiAgICAgICAgICAgIGxldCBiaW5Db29yZCA9IHRoaXMuX2dldEJpbkNvb3JkRnJvbUNhcnRlc2lhbihcbiAgICAgICAgICAgICAgICBjb21tdW5pdHlDb29yZHNbMF0sXG4gICAgICAgICAgICAgICAgY29tbXVuaXR5Q29vcmRzWzFdLFxuICAgICAgICAgICAgICAgIHpvb21MZXZlbCk7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IGJpbkNvb3JkLnggLSB0aGlzLm9wdGlvbnMubGFiZWxNYXhMZW5ndGggLyAyO1xuICAgICAgICAgICAgbGV0IHRvcCA9IGJpbkNvb3JkLnkgLSAocmFkaXVzIC8gMik7XG4gICAgICAgICAgICByZXR1cm4gJChcbiAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7Y2xhc3NOYW1lfSAke3JhZGl1c31cIiBzdHlsZT1cIlxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAke2xlZnR9cHg7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogJHt0b3B9cHg7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAke3JhZGl1c31weDtcIj4ke2xhYmVsfTwvZGl2PlxuICAgICAgICAgICAgICAgIGApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbW11bml0eUxhYmVsO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IEhUTUwgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0hUTUwnKTtcblxuICAgIGxldCBFbXB0eSA9IEhUTUwuZXh0ZW5kKHt9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gRW1wdHk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgSFRNTCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvSFRNTCcpO1xuICAgIGxldCBDb2xvclJhbXAgPSByZXF1aXJlKCcuLi8uLi9taXhpbi9Db2xvclJhbXAnKTtcbiAgICBsZXQgVmFsdWVUcmFuc2Zvcm0gPSByZXF1aXJlKCcuLi8uLi9taXhpbi9WYWx1ZVRyYW5zZm9ybScpO1xuXG4gICAgbGV0IEhlYXRtYXAgPSBIVE1MLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIG1peGluc1xuICAgICAgICAgICAgQ29sb3JSYW1wLFxuICAgICAgICAgICAgVmFsdWVUcmFuc2Zvcm1cbiAgICAgICAgXSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIENvbG9yUmFtcC5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBWYWx1ZVRyYW5zZm9ybS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU92ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSAkKGUub3JpZ2luYWxFdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGFyZ2V0LmF0dHIoJ2RhdGEtdmFsdWUnKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGxldCAkcGFyZW50ID0gdGFyZ2V0LnBhcmVudHMoJy5sZWFmbGV0LWh0bWwtdGlsZScpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdmVyJywge1xuICAgICAgICAgICAgICAgICAgICBlbGVtOiBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQodmFsdWUsIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgeDogcGFyc2VJbnQoJHBhcmVudC5hdHRyKCdkYXRhLXgnKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB5OiBwYXJzZUludCgkcGFyZW50LmF0dHIoJ2RhdGEteScpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHo6IHRoaXMuX21hcC5nZXRab29tKCksXG4gICAgICAgICAgICAgICAgICAgIGJ4OiBwYXJzZUludCh0YXJnZXQuYXR0cignZGF0YS1ieCcpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIGJ5OiBwYXJzZUludCh0YXJnZXQuYXR0cignZGF0YS1ieScpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdoZWF0bWFwJyxcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gJChlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRhcmdldC5hdHRyKCdkYXRhLXZhbHVlJyk7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgJHBhcmVudCA9IHRhcmdldC5wYXJlbnRzKCcubGVhZmxldC1odG1sLXRpbGUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3V0Jywge1xuICAgICAgICAgICAgICAgICAgICBlbGVtOiBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQodmFsdWUsIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgeDogcGFyc2VJbnQoJHBhcmVudC5hdHRyKCdkYXRhLXgnKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB5OiBwYXJzZUludCgkcGFyZW50LmF0dHIoJ2RhdGEteScpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHo6IHRoaXMuX21hcC5nZXRab29tKCksXG4gICAgICAgICAgICAgICAgICAgIGJ4OiBwYXJzZUludCh0YXJnZXQuYXR0cignZGF0YS1ieCcpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIGJ5OiBwYXJzZUludCh0YXJnZXQuYXR0cignZGF0YS1ieScpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdoZWF0bWFwJyxcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAvLyB1bi1zZWxlY3QgYW55IHByZXYgc2VsZWN0ZWQgcGl4ZWxcbiAgICAgICAgICAgICQoJy5oZWF0bWFwLXBpeGVsJykucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgLy8gZ2V0IHRhcmdldFxuICAgICAgICAgICAgbGV0IHRhcmdldCA9ICQoZS5vcmlnaW5hbEV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUYXJnZXRMYXllcihlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgbGF5ZXIgaXMgbm90IHRoZSB0YXJnZXRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lmhhc0NsYXNzKCdoZWF0bWFwLXBpeGVsJykpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGFyZ2V0LmF0dHIoJ2RhdGEtdmFsdWUnKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGxldCAkcGFyZW50ID0gdGFyZ2V0LnBhcmVudHMoJy5sZWFmbGV0LWh0bWwtdGlsZScpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnY2xpY2snLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW06IGUub3JpZ2luYWxFdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludCh2YWx1ZSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB4OiBwYXJzZUludCgkcGFyZW50LmF0dHIoJ2RhdGEteCcpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHk6IHBhcnNlSW50KCRwYXJlbnQuYXR0cignZGF0YS15JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgejogdGhpcy5fbWFwLmdldFpvb20oKSxcbiAgICAgICAgICAgICAgICAgICAgYng6IHBhcnNlSW50KHRhcmdldC5hdHRyKCdkYXRhLWJ4JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgYnk6IHBhcnNlSW50KHRhcmdldC5hdHRyKCdkYXRhLWJ5JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2hlYXRtYXAnLFxuICAgICAgICAgICAgICAgICAgICBsYXllcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJpbnMgPSBuZXcgRmxvYXQ2NEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgbGV0IHJlc29sdXRpb24gPSBNYXRoLnNxcnQoYmlucy5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IHJhbXAgPSB0aGlzLmdldENvbG9yUmFtcCgpO1xuICAgICAgICAgICAgbGV0IHBpeGVsU2l6ZSA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZSAvIHJlc29sdXRpb247XG4gICAgICAgICAgICBsZXQgY29sb3IgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgICAgICBsZXQgaHRtbCA9ICcnO1xuICAgICAgICAgICAgbGV0IG52YWwsIHJ2YWwsIGJpbjtcbiAgICAgICAgICAgIGxldCBsZWZ0LCB0b3A7XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGZvciAoaT0wOyBpPGJpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBiaW4gPSBiaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChiaW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IChpICUgcmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IE1hdGguZmxvb3IoaSAvIHJlc29sdXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBudmFsID0gdGhpcy50cmFuc2Zvcm1WYWx1ZShiaW4pO1xuICAgICAgICAgICAgICAgICAgICBydmFsID0gdGhpcy5pbnRlcnBvbGF0ZVRvUmFuZ2UobnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbXAocnZhbCwgY29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgciA9IE1hdGgucm91bmQoY29sb3JbMF0gKiAyNTUpO1xuICAgICAgICAgICAgICAgIGxldCBnID0gTWF0aC5yb3VuZChjb2xvclsxXSAqIDI1NSk7XG4gICAgICAgICAgICAgICAgbGV0IGIgPSBNYXRoLnJvdW5kKGNvbG9yWzJdICogMjU1KTtcbiAgICAgICAgICAgICAgICBsZXQgYSA9IGNvbG9yWzNdO1xuICAgICAgICAgICAgICAgIGxldCByZ2JhID0gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSwgJHthfSlgO1xuICAgICAgICAgICAgICAgIGh0bWwgKz0gYFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaGVhdG1hcC1waXhlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXZhbHVlPVwiJHtiaW59XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYng9XCIke2xlZnR9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYnk9XCIke3RvcH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICR7cGl4ZWxTaXplfXB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAke3BpeGVsU2l6ZX1weDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAke2xlZnQgKiBwaXhlbFNpemV9cHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAke3RvcCAqIHBpeGVsU2l6ZX1weDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3JnYmF9O1wiPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGVhdG1hcDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBIVE1MID0gcmVxdWlyZSgnLi4vLi4vY29yZS9IVE1MJyk7XG4gICAgbGV0IFZhbHVlVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vLi4vbWl4aW4vVmFsdWVUcmFuc2Zvcm0nKTtcblxuICAgIGxldCBIZWF0bWFwID0gSFRNTC5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBtaXhpbnNcbiAgICAgICAgICAgIFZhbHVlVHJhbnNmb3JtXG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBWYWx1ZVRyYW5zZm9ybS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9ICQoZS5vcmlnaW5hbEV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAkKCcuaGVhdG1hcC1yaW5nJykucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVGFyZ2V0TGF5ZXIoZS5vcmlnaW5hbEV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGxheWVyIGlzIG5vdCB0aGUgdGFyZ2V0XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldC5oYXNDbGFzcygnaGVhdG1hcC1yaW5nJykpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJpbnMgPSBuZXcgRmxvYXQ2NEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgbGV0IHJlc29sdXRpb24gPSBNYXRoLnNxcnQoYmlucy5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGJpblNpemUgPSAodGhpcy5vcHRpb25zLnRpbGVTaXplIC8gcmVzb2x1dGlvbik7XG4gICAgICAgICAgICBsZXQgaHRtbCA9ICcnO1xuICAgICAgICAgICAgYmlucy5mb3JFYWNoKChiaW4sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFiaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcGVyY2VudCA9IHRoaXMudHJhbnNmb3JtVmFsdWUoYmluKTtcbiAgICAgICAgICAgICAgICBsZXQgcmFkaXVzID0gcGVyY2VudCAqIGJpblNpemU7XG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IChiaW5TaXplIC0gcmFkaXVzKSAvIDI7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQgPSAoaW5kZXggJSByZXNvbHV0aW9uKSAqIGJpblNpemU7XG4gICAgICAgICAgICAgICAgbGV0IHRvcCA9IE1hdGguZmxvb3IoaW5kZXggLyByZXNvbHV0aW9uKSAqIGJpblNpemU7XG4gICAgICAgICAgICAgICAgaHRtbCArPVxuICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJoZWF0bWFwLXJpbmdcIiBzdHlsZT1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogJHtsZWZ0ICsgb2Zmc2V0fXB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAke3RvcCArIG9mZnNldH1weDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAke3JhZGl1c31weDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJHtyYWRpdXN9cHg7XCI+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhlYXRtYXA7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgSFRNTCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvSFRNTCcpO1xuICAgIGxldCBWYWx1ZVRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uLy4uL21peGluL1ZhbHVlVHJhbnNmb3JtJyk7XG4gICAgbGV0IHNlbnRpbWVudCA9IHJlcXVpcmUoJy4uLy4uL3NlbnRpbWVudC9TZW50aW1lbnQnKTtcbiAgICBsZXQgc2VudGltZW50RnVuYyA9IHNlbnRpbWVudC5nZXRDbGFzc0Z1bmMoLTEsIDEpO1xuXG4gICAgbGV0IFZFUlRJQ0FMX09GRlNFVCA9IDI0O1xuICAgIGxldCBIT1JJWk9OVEFMX09GRlNFVCA9IDEwO1xuICAgIGxldCBOVU1fQVRURU1QVFMgPSAxO1xuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gaW5pdGlhbCBwb3NpdGlvbiwgcmV0dXJuIGEgbmV3IHBvc2l0aW9uLCBpbmNyZW1lbnRhbGx5IHNwaXJhbGxlZFxuICAgICAqIG91dHdhcmRzLlxuICAgICAqL1xuICAgIGxldCBzcGlyYWxQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICBsZXQgcGkyID0gMiAqIE1hdGguUEk7XG4gICAgICAgIGxldCBjaXJjID0gcGkyICogcG9zLnJhZGl1cztcbiAgICAgICAgbGV0IGluYyA9IChwb3MuYXJjTGVuZ3RoID4gY2lyYyAvIDEwKSA/IGNpcmMgLyAxMCA6IHBvcy5hcmNMZW5ndGg7XG4gICAgICAgIGxldCBkYSA9IGluYyAvIHBvcy5yYWRpdXM7XG4gICAgICAgIGxldCBudCA9IChwb3MudCArIGRhKTtcbiAgICAgICAgaWYgKG50ID4gcGkyKSB7XG4gICAgICAgICAgICBudCA9IG50ICUgcGkyO1xuICAgICAgICAgICAgcG9zLnJhZGl1cyA9IHBvcy5yYWRpdXMgKyBwb3MucmFkaXVzSW5jO1xuICAgICAgICB9XG4gICAgICAgIHBvcy50ID0gbnQ7XG4gICAgICAgIHBvcy54ID0gcG9zLnJhZGl1cyAqIE1hdGguY29zKG50KTtcbiAgICAgICAgcG9zLnkgPSBwb3MucmFkaXVzICogTWF0aC5zaW4obnQpO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIGJvdW5kaW5nIGJveCBhIGludGVyc2VjdHMgYm91bmRpbmcgYm94IGJcbiAgICAgKi9cbiAgICBsZXQgaW50ZXJzZWN0VGVzdCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLmFicyhhLnggLSBiLngpICogMiA8IChhLndpZHRoICsgYi53aWR0aCkpICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoYS55IC0gYi55KSAqIDIgPCAoYS5oZWlnaHQgKyBiLmhlaWdodCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIGJvdW5kaW5nIGJveCBhIGlzIG5vdCBmdWxseSBjb250YWluZWQgaW5zaWRlIGJvdW5kaW5nIGJveCBiXG4gICAgICovXG4gICAgbGV0IG92ZXJsYXBUZXN0ID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gKGEueCArIGEud2lkdGggLyAyID4gYi54ICsgYi53aWR0aCAvIDIgfHxcbiAgICAgICAgICAgIGEueCAtIGEud2lkdGggLyAyIDwgYi54IC0gYi53aWR0aCAvIDIgfHxcbiAgICAgICAgICAgIGEueSArIGEuaGVpZ2h0IC8gMiA+IGIueSArIGIuaGVpZ2h0IC8gMiB8fFxuICAgICAgICAgICAgYS55IC0gYS5oZWlnaHQgLyAyIDwgYi55IC0gYi5oZWlnaHQgLyAyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB3b3JkIGludGVyc2VjdHMgYW5vdGhlciB3b3JkLCBvciBpcyBub3QgZnVsbHkgY29udGFpbmVkIGluIHRoZVxuICAgICAqIHRpbGUgYm91bmRpbmcgYm94XG4gICAgICovXG4gICAgbGV0IGludGVyc2VjdFdvcmQgPSBmdW5jdGlvbihwb3NpdGlvbiwgd29yZCwgY2xvdWQsIGJiKSB7XG4gICAgICAgIGxldCBib3ggPSB7XG4gICAgICAgICAgICB4OiBwb3NpdGlvbi54LFxuICAgICAgICAgICAgeTogcG9zaXRpb24ueSxcbiAgICAgICAgICAgIGhlaWdodDogd29yZC5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogd29yZC53aWR0aFxuICAgICAgICB9O1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNsb3VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0VGVzdChib3gsIGNsb3VkW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBpdCBkb2Vzbid0IGludGVyc2VjdCB0aGUgYm9yZGVyO1xuICAgICAgICBpZiAob3ZlcmxhcFRlc3QoYm94LCBiYikpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGhpdHMgYSBib3JkZXIsIGluY3JlbWVudCBjb2xsaXNpb24gY291bnRcbiAgICAgICAgICAgIC8vIGFuZCBleHRlbmQgYXJjIGxlbmd0aFxuICAgICAgICAgICAgcG9zaXRpb24uY29sbGlzaW9ucysrO1xuICAgICAgICAgICAgcG9zaXRpb24uYXJjTGVuZ3RoID0gcG9zaXRpb24ucmFkaXVzO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBsZXQgV29yZENsb3VkID0gSFRNTC5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBtaXhpbnNcbiAgICAgICAgICAgIFZhbHVlVHJhbnNmb3JtXG4gICAgICAgIF0sXG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgbWF4TnVtV29yZHM6IDE1LFxuICAgICAgICAgICAgbWluRm9udFNpemU6IDEwLFxuICAgICAgICAgICAgbWF4Rm9udFNpemU6IDIwXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBWYWx1ZVRyYW5zZm9ybS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRIaWdobGlnaHQ6IGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIC8vIEhpZ2hsaWdodCBzZWxlY3RlZCB3b3JkXG4gICAgICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikuYWRkQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgJChgLndvcmQtY2xvdWQtbGFiZWxbZGF0YS13b3JkPVwiJHt3b3JkfVwiXWApLmFkZENsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ID0gd29yZDtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlT3ZlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9ICQoZS5vcmlnaW5hbEV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAkKCcud29yZC1jbG91ZC1sYWJlbCcpLnJlbW92ZUNsYXNzKCdob3ZlcicpO1xuICAgICAgICAgICAgbGV0IHdvcmQgPSB0YXJnZXQuYXR0cignZGF0YS13b3JkJyk7XG4gICAgICAgICAgICBpZiAod29yZCkge1xuICAgICAgICAgICAgICAgIC8vIGhpZ2hsaWdodCBhbGwgaW5zdGFuY2VzIG9mIHRoZSB3b3JkXG4gICAgICAgICAgICAgICAgJChgLndvcmQtY2xvdWQtbGFiZWxbZGF0YS13b3JkPVwiJHt3b3JkfVwiXWApLmFkZENsYXNzKCdob3ZlcicpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBsYXllciBjb29yZFxuICAgICAgICAgICAgICAgIGxldCBsYXllclBvaW50ID0gdGhpcy5nZXRMYXllclBvaW50RnJvbUV2ZW50KGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRpbGUgY29vcmRcbiAgICAgICAgICAgICAgICBsZXQgY29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZyb21MYXllclBvaW50KGxheWVyUG9pbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjYWNoZSBrZXlcbiAgICAgICAgICAgICAgICBsZXQgbmtleSA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29vcmQsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjYWNoZSBlbnRyeVxuICAgICAgICAgICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9jYWNoZVtua2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkICYmIGNhY2hlZC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtOiBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHdvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjb29yZC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogY29vcmQueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHo6IGNvb3JkLnosXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjYWNoZWQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3b3JkLWNsb3VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gJChlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICQoJy53b3JkLWNsb3VkLWxhYmVsJykucmVtb3ZlQ2xhc3MoJ2hvdmVyJyk7XG4gICAgICAgICAgICBsZXQgd29yZCA9IHRhcmdldC5hdHRyKCdkYXRhLXdvcmQnKTtcbiAgICAgICAgICAgIGlmICh3b3JkKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGxheWVyIGNvb3JkXG4gICAgICAgICAgICAgICAgbGV0IGxheWVyUG9pbnQgPSB0aGlzLmdldExheWVyUG9pbnRGcm9tRXZlbnQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGlsZSBjb29yZFxuICAgICAgICAgICAgICAgIGxldCBjb29yZCA9IHRoaXMuZ2V0VGlsZUNvb3JkRnJvbUxheWVyUG9pbnQobGF5ZXJQb2ludCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGtleVxuICAgICAgICAgICAgICAgIGxldCBua2V5ID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGVudHJ5XG4gICAgICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX2NhY2hlW25rZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW92ZXInLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtOiBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHdvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjb29yZC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogY29vcmQueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHo6IGNvb3JkLnosXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjYWNoZWQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3b3JkLWNsb3VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAvLyB1bi1zZWxlY3QgYW55IHByZXYgc2VsZWN0ZWQgd29yZHNcbiAgICAgICAgICAgICQoJy53b3JkLWNsb3VkLWxhYmVsJykucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgIC8vIGdldCB0YXJnZXRcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSAkKGUub3JpZ2luYWxFdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVGFyZ2V0TGF5ZXIoZS5vcmlnaW5hbEV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGxheWVyIGlzIG5vdCB0aGUgdGFyZ2V0XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHdvcmQgPSB0YXJnZXQuYXR0cignZGF0YS13b3JkJyk7XG4gICAgICAgICAgICBpZiAod29yZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SGlnaGxpZ2h0KHdvcmQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBsYXllciBjb29yZFxuICAgICAgICAgICAgICAgIGxldCBsYXllclBvaW50ID0gdGhpcy5nZXRMYXllclBvaW50RnJvbUV2ZW50KGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRpbGUgY29vcmRcbiAgICAgICAgICAgICAgICBsZXQgY29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZyb21MYXllclBvaW50KGxheWVyUG9pbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjYWNoZSBrZXlcbiAgICAgICAgICAgICAgICBsZXQgbmtleSA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29vcmQsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjYWNoZSBlbnRyeVxuICAgICAgICAgICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9jYWNoZVtua2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkICYmIGNhY2hlZC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnY2xpY2snLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtOiBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHdvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjb29yZC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogY29vcmQueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHo6IGNvb3JkLnosXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjYWNoZWQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3b3JkLWNsb3VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9tZWFzdXJlV29yZHM6IGZ1bmN0aW9uKHdvcmRDb3VudHMpIHtcbiAgICAgICAgICAgIC8vIHNvcnQgd29yZHMgYnkgZnJlcXVlbmN5XG4gICAgICAgICAgICB3b3JkQ291bnRzID0gd29yZENvdW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIuY291bnQgLSBhLmNvdW50O1xuICAgICAgICAgICAgfSkuc2xpY2UoMCwgdGhpcy5vcHRpb25zLm1heE51bVdvcmRzKTtcbiAgICAgICAgICAgIC8vIGJ1aWxkIG1lYXN1cmVtZW50IGh0bWxcbiAgICAgICAgICAgIGxldCAkaHRtbCA9ICQoJzxkaXYgc3R5bGU9XCJoZWlnaHQ6MjU2cHg7IHdpZHRoOjI1NnB4O1wiPjwvZGl2PicpO1xuICAgICAgICAgICAgbGV0IG1pbkZvbnRTaXplID0gdGhpcy5vcHRpb25zLm1pbkZvbnRTaXplO1xuICAgICAgICAgICAgbGV0IG1heEZvbnRTaXplID0gdGhpcy5vcHRpb25zLm1heEZvbnRTaXplO1xuICAgICAgICAgICAgd29yZENvdW50cy5mb3JFYWNoKHdvcmQgPT4ge1xuICAgICAgICAgICAgICAgIHdvcmQucGVyY2VudCA9IHRoaXMudHJhbnNmb3JtVmFsdWUod29yZC5jb3VudCk7XG4gICAgICAgICAgICAgICAgd29yZC5mb250U2l6ZSA9IG1pbkZvbnRTaXplICsgd29yZC5wZXJjZW50ICogKG1heEZvbnRTaXplIC0gbWluRm9udFNpemUpO1xuICAgICAgICAgICAgICAgICRodG1sLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwid29yZC1jbG91ZC1sYWJlbFwiIHN0eWxlPVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OmhpZGRlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogJHt3b3JkLmZvbnRTaXplfXB4O1wiPiR7d29yZC50ZXh0fTwvZGl2PjtcbiAgICAgICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGFwcGVuZCBtZWFzdXJlbWVudHNcbiAgICAgICAgICAgICQoJ2JvZHknKS5hcHBlbmQoJGh0bWwpO1xuICAgICAgICAgICAgJGh0bWwuY2hpbGRyZW4oKS5lYWNoKChpbmRleCwgZWxlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHdvcmRDb3VudHNbaW5kZXhdLndpZHRoID0gZWxlbS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICB3b3JkQ291bnRzW2luZGV4XS5oZWlnaHQgPSBlbGVtLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJGh0bWwucmVtb3ZlKCk7XG4gICAgICAgICAgICByZXR1cm4gd29yZENvdW50cztcbiAgICAgICAgfSxcblxuICAgICAgICBfY3JlYXRlV29yZENsb3VkOiBmdW5jdGlvbih3b3JkQ291bnRzKSB7XG4gICAgICAgICAgICBsZXQgdGlsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG4gICAgICAgICAgICBsZXQgYm91bmRpbmdCb3ggPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHRpbGVTaXplIC0gSE9SSVpPTlRBTF9PRkZTRVQgKiAyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGlsZVNpemUgLSBWRVJUSUNBTF9PRkZTRVQgKiAyLFxuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBjbG91ZCA9IFtdO1xuICAgICAgICAgICAgLy8gc29ydCB3b3JkcyBieSBmcmVxdWVuY3lcbiAgICAgICAgICAgIHdvcmRDb3VudHMgPSB0aGlzLl9tZWFzdXJlV29yZHMod29yZENvdW50cyk7XG4gICAgICAgICAgICAvLyBhc3NlbWJsZSB3b3JkIGNsb3VkXG4gICAgICAgICAgICB3b3JkQ291bnRzLmZvckVhY2god29yZENvdW50ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydGluZyBzcGlyYWwgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBsZXQgcG9zID0ge1xuICAgICAgICAgICAgICAgICAgICByYWRpdXM6IDEsXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1c0luYzogNSxcbiAgICAgICAgICAgICAgICAgICAgYXJjTGVuZ3RoOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgdDogMCxcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uczogMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gc3BpcmFsIG91dHdhcmRzIHRvIGZpbmQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICB3aGlsZSAocG9zLmNvbGxpc2lvbnMgPCBOVU1fQVRURU1QVFMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IHBvc2l0aW9uIGluIGEgc3BpcmFsXG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHNwaXJhbFBvc2l0aW9uKHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRlc3QgZm9yIGludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWludGVyc2VjdFdvcmQocG9zLCB3b3JkQ291bnQsIGNsb3VkLCBib3VuZGluZ0JveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3VkLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHdvcmRDb3VudC50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiB3b3JkQ291bnQuZm9udFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudDogTWF0aC5yb3VuZCgod29yZENvdW50LnBlcmNlbnQgKiAxMDApIC8gMTApICogMTAsIC8vIHJvdW5kIHRvIG5lYXJlc3QgMTBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBwb3MueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwb3MueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd29yZENvdW50LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogd29yZENvdW50LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW50aW1lbnQ6IHdvcmRDb3VudC5zZW50aW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZnOiB3b3JkQ291bnQuYXZnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2xvdWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXh0cmFjdEV4dHJlbWE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGxldCBzdW1zID0gXy5tYXAoZGF0YSwgZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc051bWJlcihjb3VudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VudGltZW50LmdldFRvdGFsKGNvdW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IF8ubWluKHN1bXMpLFxuICAgICAgICAgICAgICAgIG1heDogXy5tYXgoc3VtcyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhIHx8IF8uaXNFbXB0eShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBoaWdobGlnaHQgPSB0aGlzLmhpZ2hsaWdodDtcbiAgICAgICAgICAgIGxldCB3b3JkQ291bnRzID0gXy5tYXAoZGF0YSwgZnVuY3Rpb24oY291bnQsIGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChfLmlzTnVtYmVyKGNvdW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDoga2V5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB0b3RhbCA9IHNlbnRpbWVudC5nZXRUb3RhbChjb3VudCk7XG4gICAgICAgICAgICAgICAgbGV0IGF2ZyA9IHNlbnRpbWVudC5nZXRBdmcoY291bnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiB0b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDoga2V5LFxuICAgICAgICAgICAgICAgICAgICBhdmc6IGF2ZyxcbiAgICAgICAgICAgICAgICAgICAgc2VudGltZW50OiBzZW50aW1lbnRGdW5jKGF2ZylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBleGl0IGVhcmx5IGlmIG5vIHdvcmRzXG4gICAgICAgICAgICBpZiAod29yZENvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZW5lcmVhdGUgdGhlIGNsb3VkXG4gICAgICAgICAgICBsZXQgY2xvdWQgPSB0aGlzLl9jcmVhdGVXb3JkQ2xvdWQod29yZENvdW50cyk7XG4gICAgICAgICAgICAvLyBidWlsZCBodG1sIGVsZW1lbnRzXG4gICAgICAgICAgICBsZXQgaGFsZlNpemUgPSB0aGlzLm9wdGlvbnMudGlsZVNpemUgLyAyO1xuICAgICAgICAgICAgbGV0IGh0bWwgPSAnJztcbiAgICAgICAgICAgIGNsb3VkLmZvckVhY2goZnVuY3Rpb24od29yZCkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBjbGFzc2VzXG4gICAgICAgICAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnd29yZC1jbG91ZC1sYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBgd29yZC1jbG91ZC1sYWJlbC0ke3dvcmQucGVyY2VudH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgd29yZC50ZXh0ID09PSBoaWdobGlnaHQgPyAnaGlnaGxpZ2h0JyA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgd29yZC5zZW50aW1lbnQgPyB3b3JkLnNlbnRpbWVudCA6ICcnXG4gICAgICAgICAgICAgICAgICAgIF0uam9pbignICcpO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBzdHlsZXNcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYGZvbnQtc2l6ZTogJHt3b3JkLmZvbnRTaXplfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGBsZWZ0OiAkeyhoYWxmU2l6ZSArIHdvcmQueCkgLSAod29yZC53aWR0aCAvIDIpfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGB0b3A6ICR7KGhhbGZTaXplICsgd29yZC55KSAtICh3b3JkLmhlaWdodCAvIDIpfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGB3aWR0aDogJHt3b3JkLndpZHRofXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGBoZWlnaHQ6ICR7d29yZC5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJzsnKTtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgaHRtbCBmb3IgZW50cnlcbiAgICAgICAgICAgICAgICBodG1sICs9XG4gICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7Y2xhc3NOYW1lc31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCIke3N0eWxlc31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1zZW50aW1lbnQ9XCIke3dvcmQuYXZnfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXdvcmQ9XCIke3dvcmQudGV4dH1cIj4ke3dvcmQudGV4dH08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBXb3JkQ2xvdWQ7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgSFRNTCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvSFRNTCcpO1xuICAgIGxldCBWYWx1ZVRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uLy4uL21peGluL1ZhbHVlVHJhbnNmb3JtJyk7XG4gICAgbGV0IHNlbnRpbWVudCA9IHJlcXVpcmUoJy4uLy4uL3NlbnRpbWVudC9TZW50aW1lbnQnKTtcbiAgICBsZXQgc2VudGltZW50RnVuYyA9IHNlbnRpbWVudC5nZXRDbGFzc0Z1bmMoLTEsIDEpO1xuXG4gICAgbGV0IGlzU2luZ2xlVmFsdWUgPSBmdW5jdGlvbihjb3VudCkge1xuICAgICAgICAvLyBzaW5nbGUgdmFsdWVzIGFyZSBuZXZlciBudWxsLCBhbmQgYWx3YXlzIG51bWJlcnNcbiAgICAgICAgcmV0dXJuIGNvdW50ICE9PSBudWxsICYmIF8uaXNOdW1iZXIoY291bnQpO1xuICAgIH07XG5cbiAgICBsZXQgZXh0cmFjdENvdW50ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgaWYgKGlzU2luZ2xlVmFsdWUoY291bnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbnRpbWVudC5nZXRUb3RhbChjb3VudCk7XG4gICAgfTtcblxuICAgIGxldCBleHRyYWN0U2VudGltZW50Q2xhc3MgPSBmdW5jdGlvbihhdmcpIHtcbiAgICAgICAgaWYgKGF2ZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VudGltZW50RnVuYyhhdmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuXG4gICAgbGV0IGV4dHJhY3RGcmVxdWVuY3kgPSBmdW5jdGlvbihjb3VudCkge1xuICAgICAgICBpZiAoaXNTaW5nbGVWYWx1ZShjb3VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY291bnQ6IGNvdW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb3VudDogc2VudGltZW50LmdldFRvdGFsKGNvdW50KSxcbiAgICAgICAgICAgIGF2Zzogc2VudGltZW50LmdldEF2Zyhjb3VudClcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgbGV0IGV4dHJhY3RBdmcgPSBmdW5jdGlvbihmcmVxdWVuY2llcykge1xuICAgICAgICBpZiAoZnJlcXVlbmNpZXNbMF0uYXZnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3VtID0gXy5zdW1CeShmcmVxdWVuY2llcywgZnVuY3Rpb24oZnJlcXVlbmN5KSB7XG4gICAgICAgICAgICByZXR1cm4gZnJlcXVlbmN5LmF2ZztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdW0gLyBmcmVxdWVuY2llcy5sZW5ndGg7XG4gICAgfTtcblxuICAgIGxldCBleHRyYWN0VmFsdWVzID0gZnVuY3Rpb24oZGF0YSwga2V5KSB7XG4gICAgICAgIGxldCBmcmVxdWVuY2llcyA9IF8ubWFwKGRhdGEsIGV4dHJhY3RGcmVxdWVuY3kpO1xuICAgICAgICBsZXQgYXZnID0gZXh0cmFjdEF2ZyhmcmVxdWVuY2llcyk7XG4gICAgICAgIGxldCBtYXggPSBfLm1heEJ5KGZyZXF1ZW5jaWVzLCB2YWwgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5jb3VudDtcbiAgICAgICAgfSkuY291bnQ7XG4gICAgICAgIGxldCB0b3RhbCA9IF8uc3VtQnkoZnJlcXVlbmNpZXMsIHZhbCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLmNvdW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcGljOiBrZXksXG4gICAgICAgICAgICBmcmVxdWVuY2llczogZnJlcXVlbmNpZXMsXG4gICAgICAgICAgICBtYXg6IG1heCxcbiAgICAgICAgICAgIHRvdGFsOiB0b3RhbCxcbiAgICAgICAgICAgIGF2ZzogYXZnXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGxldCBXb3JkSGlzdG9ncmFtID0gSFRNTC5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBtaXhpbnNcbiAgICAgICAgICAgIFZhbHVlVHJhbnNmb3JtXG4gICAgICAgIF0sXG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgbWF4TnVtV29yZHM6IDgsXG4gICAgICAgICAgICBtaW5Gb250U2l6ZTogMTYsXG4gICAgICAgICAgICBtYXhGb250U2l6ZTogMjJcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFZhbHVlVHJhbnNmb3JtLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhclNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHQgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEhpZ2hsaWdodDogZnVuY3Rpb24od29yZCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IHNlbGVjdGVkIHdvcmRcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5hZGRDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICAkKGAud29yZC1oaXN0b2dyYW0tZW50cnlbZGF0YS13b3JkPVwiJHt3b3JkfVwiXWApLmFkZENsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ID0gd29yZDtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlT3ZlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9ICQoZS5vcmlnaW5hbEV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAkKCcud29yZC1oaXN0b2dyYW0tZW50cnknKS5yZW1vdmVDbGFzcygnaG92ZXInKTtcbiAgICAgICAgICAgIGxldCB3b3JkID0gdGFyZ2V0LmF0dHIoJ2RhdGEtd29yZCcpO1xuICAgICAgICAgICAgaWYgKHdvcmQpIHtcbiAgICAgICAgICAgICAgICAkKGAud29yZC1oaXN0b2dyYW0tZW50cnlbZGF0YS13b3JkPVwiJHt3b3JkfVwiXWApLmFkZENsYXNzKCdob3ZlcicpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBsYXllciBjb29yZFxuICAgICAgICAgICAgICAgIGxldCBsYXllclBvaW50ID0gdGhpcy5nZXRMYXllclBvaW50RnJvbUV2ZW50KGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRpbGUgY29vcmRcbiAgICAgICAgICAgICAgICBsZXQgY29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZyb21MYXllclBvaW50KGxheWVyUG9pbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjYWNoZSBrZXlcbiAgICAgICAgICAgICAgICBsZXQgbmtleSA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29vcmQsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjYWNoZSBlbnRyeVxuICAgICAgICAgICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9jYWNoZVtua2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkICYmIGNhY2hlZC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdmVyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbTogZS5vcmlnaW5hbEV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogY29vcmQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNvb3JkLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB6OiBjb29yZC56LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY2FjaGVkLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd29yZC1oaXN0b2dyYW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2VPdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSAkKGUub3JpZ2luYWxFdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgJCgnLndvcmQtaGlzdG9ncmFtLWVudHJ5JykucmVtb3ZlQ2xhc3MoJ2hvdmVyJyk7XG4gICAgICAgICAgICBsZXQgd29yZCA9IHRhcmdldC5hdHRyKCdkYXRhLXdvcmQnKTtcbiAgICAgICAgICAgIGlmICh3b3JkKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGxheWVyIGNvb3JkXG4gICAgICAgICAgICAgICAgbGV0IGxheWVyUG9pbnQgPSB0aGlzLmdldExheWVyUG9pbnRGcm9tRXZlbnQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGlsZSBjb29yZFxuICAgICAgICAgICAgICAgIGxldCBjb29yZCA9IHRoaXMuZ2V0VGlsZUNvb3JkRnJvbUxheWVyUG9pbnQobGF5ZXJQb2ludCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGtleVxuICAgICAgICAgICAgICAgIGxldCBua2V5ID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGVudHJ5XG4gICAgICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX2NhY2hlW25rZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW91dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW06IGUub3JpZ2luYWxFdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNvb3JkLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBjb29yZC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgejogY29vcmQueixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGNhY2hlZC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3dvcmQtaGlzdG9ncmFtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAvLyB1bi1zZWxlY3QgYW5kIHByZXYgc2VsZWN0ZWQgaGlzdG9ncmFtXG4gICAgICAgICAgICAkKCcud29yZC1oaXN0b2dyYW0tZW50cnknKS5yZW1vdmVDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgLy8gZ2V0IHRhcmdldFxuICAgICAgICAgICAgbGV0IHRhcmdldCA9ICQoZS5vcmlnaW5hbEV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUYXJnZXRMYXllcihlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgbGF5ZXIgaXMgbm90IHRoZSB0YXJnZXRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgd29yZCA9IHRhcmdldC5hdHRyKCdkYXRhLXdvcmQnKTtcbiAgICAgICAgICAgIGlmICh3b3JkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIaWdobGlnaHQod29yZCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGxheWVyIGNvb3JkXG4gICAgICAgICAgICAgICAgbGV0IGxheWVyUG9pbnQgPSB0aGlzLmdldExheWVyUG9pbnRGcm9tRXZlbnQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGlsZSBjb29yZFxuICAgICAgICAgICAgICAgIGxldCBjb29yZCA9IHRoaXMuZ2V0VGlsZUNvb3JkRnJvbUxheWVyUG9pbnQobGF5ZXJQb2ludCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGtleVxuICAgICAgICAgICAgICAgIGxldCBua2V5ID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGVudHJ5XG4gICAgICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX2NhY2hlW25rZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW92ZXInLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtOiBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHdvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjb29yZC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogY29vcmQueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHo6IGNvb3JkLnosXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjYWNoZWQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3b3JkLWhpc3RvZ3JhbScsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBleHRyYWN0RXh0cmVtYTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgbGV0IHN1bXMgPSBfLm1hcChkYXRhLCBjb3VudHMgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLnN1bUJ5KGNvdW50cywgZXh0cmFjdENvdW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IF8ubWluKHN1bXMpLFxuICAgICAgICAgICAgICAgIG1heDogXy5tYXgoc3VtcyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhIHx8IF8uaXNFbXB0eShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBoaWdobGlnaHQgPSB0aGlzLmhpZ2hsaWdodDtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgb2JqZWN0IHRvIGFycmF5XG4gICAgICAgICAgICBsZXQgdmFsdWVzID0gXy5tYXAoZGF0YSwgZXh0cmFjdFZhbHVlcykuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiLnRvdGFsIC0gYS50b3RhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZ2V0IG51bWJlciBvZiBlbnRyaWVzXG4gICAgICAgICAgICBsZXQgbnVtRW50cmllcyA9IE1hdGgubWluKHZhbHVlcy5sZW5ndGgsIHRoaXMub3B0aW9ucy5tYXhOdW1Xb3Jkcyk7XG4gICAgICAgICAgICBsZXQgJGh0bWwgPSAkKCc8ZGl2IGNsYXNzPVwid29yZC1oaXN0b2dyYW1zXCIgc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9jaztcIj48L2Rpdj4nKTtcbiAgICAgICAgICAgIGxldCB0b3RhbEhlaWdodCA9IDA7XG4gICAgICAgICAgICBsZXQgbWluRm9udFNpemUgPSB0aGlzLm9wdGlvbnMubWluRm9udFNpemU7XG4gICAgICAgICAgICBsZXQgbWF4Rm9udFNpemUgPSB0aGlzLm9wdGlvbnMubWF4Rm9udFNpemU7XG4gICAgICAgICAgICB2YWx1ZXMuc2xpY2UoMCwgbnVtRW50cmllcykuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRvcGljID0gdmFsdWUudG9waWM7XG4gICAgICAgICAgICAgICAgbGV0IGZyZXF1ZW5jaWVzID0gdmFsdWUuZnJlcXVlbmNpZXM7XG4gICAgICAgICAgICAgICAgbGV0IG1heCA9IHZhbHVlLm1heDtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWwgPSB2YWx1ZS50b3RhbDtcbiAgICAgICAgICAgICAgICBsZXQgYXZnID0gdmFsdWUuYXZnO1xuICAgICAgICAgICAgICAgIGxldCBzZW50aW1lbnRDbGFzcyA9IGV4dHJhY3RTZW50aW1lbnRDbGFzcyhhdmcpO1xuICAgICAgICAgICAgICAgIGxldCBoaWdobGlnaHRDbGFzcyA9ICh0b3BpYyA9PT0gaGlnaGxpZ2h0KSA/ICdoaWdobGlnaHQnIDogJyc7XG4gICAgICAgICAgICAgICAgLy8gc2NhbGUgdGhlIGhlaWdodCBiYXNlZCBvbiBsZXZlbCBtaW4gLyBtYXhcbiAgICAgICAgICAgICAgICBsZXQgcGVyY2VudCA9IHRoaXMudHJhbnNmb3JtVmFsdWUodG90YWwpO1xuICAgICAgICAgICAgICAgIGxldCBwZXJjZW50TGFiZWwgPSBNYXRoLnJvdW5kKChwZXJjZW50ICogMTAwKSAvIDEwKSAqIDEwO1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBtaW5Gb250U2l6ZSArIHBlcmNlbnQgKiAobWF4Rm9udFNpemUgLSBtaW5Gb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgdG90YWxIZWlnaHQgKz0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBjb250YWluZXIgJ2VudHJ5JyBmb3IgY2hhcnQgYW5kIGhhc2h0YWdcbiAgICAgICAgICAgICAgICBsZXQgJGVudHJ5ID0gJChcbiAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwid29yZC1oaXN0b2dyYW0tZW50cnkgJHtoaWdobGlnaHRDbGFzc31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1zZW50aW1lbnQ9XCIke2F2Z31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS13b3JkPVwiJHt0b3BpY31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJoZWlnaHQ6JHtoZWlnaHR9cHg7XCI+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgY2hhcnRcbiAgICAgICAgICAgICAgICBsZXQgJGNoYXJ0ID0gJChcbiAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwid29yZC1oaXN0b2dyYW0tbGVmdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXNlbnRpbWVudD1cIiR7YXZnfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXdvcmQ9XCIke3RvcGljfVwiPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgbGV0IGJhcldpZHRoID0gJ2NhbGMoJyArICgxMDAgLyBmcmVxdWVuY2llcy5sZW5ndGgpICsgJyUpJztcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYmFyc1xuICAgICAgICAgICAgICAgIGZyZXF1ZW5jaWVzLmZvckVhY2goZnJlcXVlbmN5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gZnJlcXVlbmN5LmNvdW50O1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXZnID0gZnJlcXVlbmN5LmF2ZztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlbnRpbWVudENsYXNzID0gZXh0cmFjdFNlbnRpbWVudENsYXNzKGF2Zyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgcGVyY2VudCByZWxhdGl2ZSB0byB0aGUgaGlnaGVzdCBjb3VudCBpbiB0aGUgdGlsZVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVsYXRpdmVQZXJjZW50ID0gKG1heCAhPT0gMCkgPyAoY291bnQgLyBtYXgpICogMTAwIDogMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBpbnZpc2libGUgaWYgemVybyBjb3VudFxuICAgICAgICAgICAgICAgICAgICBsZXQgdmlzaWJpbGl0eSA9IHJlbGF0aXZlUGVyY2VudCA9PT0gMCA/ICdoaWRkZW4nIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgc3R5bGUgY2xhc3Mgb2YgdGhlIGJhclxuICAgICAgICAgICAgICAgICAgICBsZXQgcGVyY2VudExhYmVsID0gTWF0aC5yb3VuZChyZWxhdGl2ZVBlcmNlbnQgLyAxMCkgKiAxMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJhckNsYXNzZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dvcmQtaGlzdG9ncmFtLWJhcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYHdvcmQtaGlzdG9ncmFtLWJhci0ke3BlcmNlbnRMYWJlbH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke3NlbnRpbWVudENsYXNzfS1maWxsYFxuICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiYXJIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiYXJUb3A7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSB0aGVyZSBpcyBhdCBsZWFzdCBhIHNpbmdsZSBwaXhlbCBvZiBjb2xvclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHJlbGF0aXZlUGVyY2VudCAvIDEwMCkgKiBoZWlnaHQgPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJIZWlnaHQgPSAnM3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhclRvcCA9ICdjYWxjKDEwMCUgLSAzcHgpJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhckhlaWdodCA9IGAke3JlbGF0aXZlUGVyY2VudH0lYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhclRvcCA9IGAoMTAwIC0gcmVsYXRpdmVQZXJjZW50KSVgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBiYXJcbiAgICAgICAgICAgICAgICAgICAgJGNoYXJ0LmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke2JhckNsYXNzZXN9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXdvcmQ9XCIke3RvcGljfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiAke3Zpc2liaWxpdHl9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAke2JhcldpZHRofTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICR7YmFySGVpZ2h0fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6ICR7YmFyVG9wfTtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgJGVudHJ5LmFwcGVuZCgkY2hhcnQpO1xuICAgICAgICAgICAgICAgIGxldCB0b3BpY0NsYXNzZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICd3b3JkLWhpc3RvZ3JhbS1sYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgIGB3b3JkLWhpc3RvZ3JhbS1sYWJlbC0ke3BlcmNlbnRMYWJlbH1gLFxuICAgICAgICAgICAgICAgICAgICBzZW50aW1lbnRDbGFzc1xuICAgICAgICAgICAgICAgIF0uam9pbignICcpO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0YWcgbGFiZWxcbiAgICAgICAgICAgICAgICBsZXQgJHRvcGljID0gJChcbiAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwid29yZC1oaXN0b2dyYW0tcmlnaHRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke3RvcGljQ2xhc3Nlc31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtc2VudGltZW50PVwiJHthdmd9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXdvcmQ9XCIke3RvcGljfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogJHtoZWlnaHR9cHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZS1oZWlnaHQ6ICR7aGVpZ2h0fXB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJHtoZWlnaHR9cHg7XCI+JHt0b3BpY308L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgICAgICRlbnRyeS5hcHBlbmQoJHRvcGljKTtcbiAgICAgICAgICAgICAgICAkaHRtbC5hcHBlbmQoJGVudHJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJGh0bWwuY3NzKCd0b3AnLCAodGhpcy5vcHRpb25zLnRpbGVTaXplIC8gMikgLSAodG90YWxIZWlnaHQgLyAyKSk7XG4gICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJGh0bWxbMF0ub3V0ZXJIVE1MO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFdvcmRIaXN0b2dyYW07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgREVMQVkgPSAxMjAwO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgcmVuZGVyVGlsZTogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgbGV0IGRlbGF5ID0gLShNYXRoLnJhbmRvbSgpICogREVMQVkpO1xuICAgICAgICAgICAgZWxlbS5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz1cImJsaW5raW5nIGJsaW5raW5nLXRpbGVcIiBzdHlsZT1cImFuaW1hdGlvbi1kZWxheToke2RlbGF5fW1zXCI+PC9kaXY+YDtcbiAgICAgICAgfVxuXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBERUxBWSA9IDEyMDA7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICBsZXQgZGVsYXkgPSAtKE1hdGgucmFuZG9tKCkgKiBERUxBWSk7XG4gICAgICAgICAgICBlbGVtLmlubmVySFRNTCA9XG4gICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ2ZXJ0aWNhbC1jZW50ZXJlZC1ib3ggYmxpbmtpbmdcIiBzdHlsZT1cImFuaW1hdGlvbi1kZWxheTogJHtkZWxheX1tc1wiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxvYWRlci1jaXJjbGVcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsb2FkZXItbGluZS1tYXNrXCIgc3R5bGU9XCJhbmltYXRpb24tZGVsYXk6ICR7ZGVsYXl9bXNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibG9hZGVyLWxpbmVcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICBgO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IERFTEFZID0gMTIwMDtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBkZWxheSA9IC0oTWF0aC5yYW5kb20oKSAqIERFTEFZKTtcbiAgICAgICAgICAgICAgICBpZiAoJChlbGVtKS5oYXNDbGFzcygncGVuZGluZycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XCJibGlua2luZyBibGlua2luZy10aWxlXCIgc3R5bGU9XCJhbmltYXRpb24tZGVsYXk6ICR7ZGVsYXl9bXNcIj48L2Rpdj5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIERFTEFZKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBERUxBWSA9IDEyMDA7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZGVsYXkgPSAtKE1hdGgucmFuZG9tKCkgKiBERUxBWSk7XG4gICAgICAgICAgICAgICAgaWYgKCQoZWxlbSkuaGFzQ2xhc3MoJ3BlbmRpbmcnKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLmlubmVySFRNTCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidmVydGljYWwtY2VudGVyZWQtYm94XCIgc3R5bGU9XCJhbmltYXRpb24tZGVsYXk6ICR7ZGVsYXl9bXNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibG9hZGVyLWNpcmNsZVwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibG9hZGVyLWxpbmUtbWFza1wiIHN0eWxlPVwiYW5pbWF0aW9uLWRlbGF5OiAke2RlbGF5fW1zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibG9hZGVyLWxpbmVcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgREVMQVkpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IERFTEFZID0gMTIwMDtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgIGxldCBkZWxheSA9IC0oTWF0aC5yYW5kb20oKSAqIERFTEFZKTtcbiAgICAgICAgICAgIGVsZW0uaW5uZXJIVE1MID1cbiAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInZlcnRpY2FsLWNlbnRlcmVkLWJveFwiIHN0eWxlPVwiYW5pbWF0aW9uLWRlbGF5OiAke2RlbGF5fW1zXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibG9hZGVyLWNpcmNsZVwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxvYWRlci1saW5lLW1hc2tcIiBzdHlsZT1cImFuaW1hdGlvbi1kZWxheTogJHtkZWxheX1tc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsb2FkZXItbGluZVwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIGA7XG4gICAgICAgIH1cblxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgZXNwZXIgPSByZXF1aXJlKCdlc3BlcicpO1xuICAgIGxldCBXZWJHTCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvV2ViR0wnKTtcbiAgICBsZXQgQ29sb3JSYW1wID0gcmVxdWlyZSgnLi4vLi4vbWl4aW4vQ29sb3JSYW1wJyk7XG4gICAgbGV0IFZhbHVlVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vLi4vbWl4aW4vVmFsdWVUcmFuc2Zvcm0nKTtcbiAgICBsZXQgU2hhZGVycyA9IHJlcXVpcmUoJy4vU2hhZGVycycpO1xuXG4gICAgbGV0IFRJTEVfU0laRSA9IDI1NjtcblxuICAgIGZ1bmN0aW9uIGVuY29kZShlbmMsIHZhbCkge1xuICAgICAgICBlbmNbMF0gPSAodmFsIC8gMTY3NzcyMTYuMCkgJiAweEZGO1xuICAgICAgICBlbmNbMV0gPSAodmFsIC8gNjU1MzYuMCkgJiAweEZGO1xuICAgICAgICBlbmNbMl0gPSAodmFsIC8gMjU2LjApICYgMHhGRjtcbiAgICAgICAgZW5jWzNdID0gdmFsICYgMHhGRjtcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICB9XG5cbiAgICBsZXQgSGVhdG1hcCA9IFdlYkdMLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIG1peGluc1xuICAgICAgICAgICAgQ29sb3JSYW1wLFxuICAgICAgICAgICAgVmFsdWVUcmFuc2Zvcm1cbiAgICAgICAgXSxcblxuICAgICAgICBvbldlYkdMSW5pdDogZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHdlIHVzZSB0aGUgY29ycmVjdCBjb250ZXh0XG4gICAgICAgICAgICBlc3Blci5XZWJHTENvbnRleHQuYmluZCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgLy8gcXVhZCB2ZXJ0aWNlc1xuICAgICAgICAgICAgbGV0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgMCwgLVRJTEVfU0laRSxcbiAgICAgICAgICAgICAgICBUSUxFX1NJWkUsIC1USUxFX1NJWkUsXG4gICAgICAgICAgICAgICAgVElMRV9TSVpFLCAwLFxuICAgICAgICAgICAgICAgIDAsIC1USUxFX1NJWkUsXG4gICAgICAgICAgICAgICAgVElMRV9TSVpFLCAwLFxuICAgICAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICAgICAgLy8gdXZzXG4gICAgICAgICAgICAgICAgMCwgMCxcbiAgICAgICAgICAgICAgICAxLCAwLFxuICAgICAgICAgICAgICAgIDEsIDEsXG4gICAgICAgICAgICAgICAgMCwgMCxcbiAgICAgICAgICAgICAgICAxLCAxLFxuICAgICAgICAgICAgICAgIDAsIDFcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gcXVhZCBidWZmZXJcbiAgICAgICAgICAgIHRoaXMuX3F1YWRCdWZmZXIgPSBuZXcgZXNwZXIuVmVydGV4QnVmZmVyKFxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgMDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdGTE9BVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0OiAwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRkxPQVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldDogMiAqIDYgKiA0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IDYsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBsb2FkIHNoYWRlclxuICAgICAgICAgICAgdGhpcy5fc2hhZGVyID0gbmV3IGVzcGVyLlNoYWRlcih7XG4gICAgICAgICAgICAgICAgdmVydDogU2hhZGVycy5oZWF0bWFwLnZlcnQsXG4gICAgICAgICAgICAgICAgZnJhZzogU2hhZGVycy5oZWF0bWFwLmZyYWdcbiAgICAgICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvbmUobnVsbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIENvbG9yUmFtcC5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBWYWx1ZVRyYW5zZm9ybS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DYWNoZUxvYWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBsZXQgY2FjaGVkID0gZXZlbnQuZW50cnk7XG4gICAgICAgICAgICBsZXQgY29vcmRzID0gZXZlbnQuY29vcmRzO1xuICAgICAgICAgICAgaWYgKGNhY2hlZC5kYXRhICYmIGNhY2hlZC5kYXRhLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJUaWxlVGV4dHVyZShjYWNoZWQsIGNvb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25FeHRyZW1hQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF8uZm9ySW4odGhpcy5fY2FjaGUsIGNhY2hlZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZC5kYXRhICYmIGNhY2hlZC5kYXRhLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyVGlsZVRleHR1cmUoY2FjaGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBidWZmZXJUaWxlVGV4dHVyZTogZnVuY3Rpb24oY2FjaGVkKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBGbG9hdDY0QXJyYXkoY2FjaGVkLmRhdGEpO1xuICAgICAgICAgICAgbGV0IHJlc29sdXRpb24gPSBNYXRoLnNxcnQoZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGJpbnMgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCAqIDQpO1xuICAgICAgICAgICAgbGV0IGVuYyA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgICAgIGxldCBiaW4sIGk7XG4gICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAoaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBiaW4gPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIHN1bSArPSBiaW47XG4gICAgICAgICAgICAgICAgZW5jb2RlKGVuYywgYmluKTtcbiAgICAgICAgICAgICAgICBiaW5zW2kgKiA0XSA9IGVuY1swXTtcbiAgICAgICAgICAgICAgICBiaW5zW2kgKiA0ICsgMV0gPSBlbmNbMV07XG4gICAgICAgICAgICAgICAgYmluc1tpICogNCArIDJdID0gZW5jWzJdO1xuICAgICAgICAgICAgICAgIGJpbnNbaSAqIDQgKyAzXSA9IGVuY1szXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHdlIHVzZSB0aGUgY29ycmVjdCBjb250ZXh0XG4gICAgICAgICAgICAgICAgZXNwZXIuV2ViR0xDb250ZXh0LmJpbmQodGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHRleHR1cmVcbiAgICAgICAgICAgICAgICBjYWNoZWQudGV4dHVyZSA9IG5ldyBlc3Blci5UZXh0dXJlMkQoe1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzcmM6IGJpbnMsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ1JHQkEnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnVU5TSUdORURfQllURScsXG4gICAgICAgICAgICAgICAgICAgIHdyYXA6ICdDTEFNUF9UT19FREdFJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiAnTkVBUkVTVCcsXG4gICAgICAgICAgICAgICAgICAgIGludmVydFk6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxldCBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxCb3VuZHMoKTtcbiAgICAgICAgICAgIGxldCBkaW0gPSBNYXRoLnBvdygyLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpKSAqIFRJTEVfU0laRTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9ydGhvTWF0cml4KFxuICAgICAgICAgICAgICAgIGJvdW5kcy5taW4ueCxcbiAgICAgICAgICAgICAgICBib3VuZHMubWF4LngsXG4gICAgICAgICAgICAgICAgKGRpbSAtIGJvdW5kcy5tYXgueSksXG4gICAgICAgICAgICAgICAgKGRpbSAtIGJvdW5kcy5taW4ueSksXG4gICAgICAgICAgICAgICAgLTEsIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlclRpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSB0aGlzLl9xdWFkQnVmZmVyO1xuICAgICAgICAgICAgbGV0IHNoYWRlciA9IHRoaXMuX3NoYWRlcjtcbiAgICAgICAgICAgIGxldCB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgICAgICAgICAgIGxldCBkaW0gPSBNYXRoLnBvdygyLCB6b29tKSAqIFRJTEVfU0laRTtcbiAgICAgICAgICAgIC8vIGJpbmQgYnVmZmVyXG4gICAgICAgICAgICBidWZmZXIuYmluZCgpO1xuICAgICAgICAgICAgLy8gZm9yIGVhY2ggdGlsZVxuICAgICAgICAgICAgXy5mb3JJbih0aGlzLl9jYWNoZSwgY2FjaGVkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlZC50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYmluZCB0aWxlIHRleHR1cmUgdG8gdGV4dHVyZSB1bml0IDBcbiAgICAgICAgICAgICAgICBjYWNoZWQudGV4dHVyZS5iaW5kKDApO1xuICAgICAgICAgICAgICAgIF8uZm9ySW4oY2FjaGVkLnRpbGVzLCAodGlsZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIHRpbGVzIHBvc2l0aW9uIGZyb20gaXRzIGtleVxuICAgICAgICAgICAgICAgICAgICBsZXQgY29vcmRzID0gdGhpcy5jb29yZEZyb21DYWNoZUtleShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBoYXZlIHRvIGNoZWNrIGhlcmUgaWYgdGhlIHRpbGVzIGFyZSBzdGFsZSBvciBub3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3Jkcy56ICE9PSB6b29tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBUSUxFX1NJWkUgKiBjb29yZHMueDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHkgPSAodGhpcy5vcHRpb25zLnRtcykgPyAoVElMRV9TSVpFICogKGNvb3Jkcy55ICsgMSkpIDogZGltIC0gKFRJTEVfU0laRSAqIGNvb3Jkcy55KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIG1vZGVsIG1hdHJpeFxuICAgICAgICAgICAgICAgICAgICBsZXQgbW9kZWwgPSB0aGlzLmdldFRyYW5zbGF0aW9uTWF0cml4KHgsIHksIDApO1xuICAgICAgICAgICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndU1vZGVsTWF0cml4JywgbW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHRoZSB0aWxlXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5kcmF3KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gdW5iaW5kIHRleHR1cmVcbiAgICAgICAgICAgICAgICBjYWNoZWQudGV4dHVyZS51bmJpbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gdW5iaW5kIGJ1ZmZlclxuICAgICAgICAgICAgYnVmZmVyLnVuYmluZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlckZyYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHNldHVwXG4gICAgICAgICAgICB0aGlzLl92aWV3cG9ydC5wdXNoKCk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIudXNlKCk7XG4gICAgICAgICAgICAvLyBzZXQgdW5pZm9ybXNcbiAgICAgICAgICAgIHRoaXMuX3NoYWRlci5zZXRVbmlmb3JtKCd1UHJvamVjdGlvbk1hdHJpeCcsIHRoaXMuZ2V0UHJvamVjdGlvbk1hdHJpeCgpKTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRlci5zZXRVbmlmb3JtKCd1T3BhY2l0eScsIHRoaXMuZ2V0T3BhY2l0eSgpKTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRlci5zZXRVbmlmb3JtKCd1UmFuZ2VNaW4nLCB0aGlzLmdldFZhbHVlUmFuZ2UoKS5taW4pO1xuICAgICAgICAgICAgdGhpcy5fc2hhZGVyLnNldFVuaWZvcm0oJ3VSYW5nZU1heCcsIHRoaXMuZ2V0VmFsdWVSYW5nZSgpLm1heCk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybSgndU1pbicsIHRoaXMuZ2V0RXh0cmVtYSgpLm1pbik7XG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybSgndU1heCcsIHRoaXMuZ2V0RXh0cmVtYSgpLm1heCk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybSgndVRyYW5zZm9ybVR5cGUnLCB0aGlzLmdldFRyYW5zZm9ybUVudW0oKSk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybSgndVRleHR1cmVTYW1wbGVyJywgMCk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybSgndVJhbXAnLCB0aGlzLmdldENvbG9yUmFtcFRhYmxlKCkpO1xuICAgICAgICAgICAgLy8gZHJhd1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJUaWxlcygpO1xuICAgICAgICAgICAgLy8gdGVhcmRvd25cbiAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0LnBvcCgpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGVhdG1hcDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBlc3BlciA9IHJlcXVpcmUoJ2VzcGVyJyk7XG4gICAgbGV0IHBhcmFsbGVsID0gcmVxdWlyZSgnYXN5bmMvcGFyYWxsZWwnKTtcbiAgICBsZXQgV2ViR0wgPSByZXF1aXJlKCcuLi8uLi9jb3JlL1dlYkdMJyk7XG4gICAgbGV0IFNwYXRpYWxIYXNoID0gcmVxdWlyZSgnLi4vLi4vbWl4aW4vU3BhdGlhbEhhc2gnKTtcbiAgICBsZXQgU2hhZGVycyA9IHJlcXVpcmUoJy4vU2hhZGVycycpO1xuXG4gICAgbGV0IFRJTEVfU0laRSA9IDI1NjtcbiAgICBsZXQgQ09NUE9ORU5UX0JZVEVfU0laRSA9IDI7XG4gICAgbGV0IENPTVBPTkVOVFNfUEVSX1BPSU5UID0gNDsgLy8gZW5jb2RpbmcgdHdvIHVpbnQzMidzIGFjcm9zcyB4eS96d1xuICAgIGxldCBNQVhfVElMRVMgPSAxMjg7XG4gICAgbGV0IE1BWF9QT0lOVFNfUEVSX1RJTEUgPSAyNTYgKiAyNTY7XG4gICAgbGV0IE1BWF9USUxFX0JZVEVfU0laRSA9IE1BWF9QT0lOVFNfUEVSX1RJTEUgKiBDT01QT05FTlRTX1BFUl9QT0lOVCAqIENPTVBPTkVOVF9CWVRFX1NJWkU7XG4gICAgbGV0IE1BWF9CVUZGRVJfQllURV9TSVpFID0gTUFYX1RJTEVTICogTUFYX1RJTEVfQllURV9TSVpFO1xuXG4gICAgbGV0IE5VTV9TTElDRVMgPSA2NDtcbiAgICBsZXQgUE9JTlRfUkFESVVTID0gODtcbiAgICBsZXQgUE9JTlRfUkFESVVTX0lOQyA9IDI7XG5cbiAgICBsZXQgUE9TSVRJT05TX0lOREVYID0gMDtcbiAgICBsZXQgT0ZGU0VUU19JTkRFWCA9IDE7XG5cbiAgICBmdW5jdGlvbiBlbmNvZGVQb2ludChhcnJheWJ1ZmZlciwgaW5kZXgsIHgsIHkpIHtcbiAgICAgICAgYXJyYXlidWZmZXJbaW5kZXhdID0geCA+PiAxNjtcbiAgICAgICAgYXJyYXlidWZmZXJbaW5kZXgrMV0gPSB4ICYgMHgwMDAwRkZGRjtcbiAgICAgICAgYXJyYXlidWZmZXJbaW5kZXgrMl0gPSB5ID4+IDE2O1xuICAgICAgICBhcnJheWJ1ZmZlcltpbmRleCszXSA9IHkgJiAweDAwMDBGRkZGO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5Sml0dGVyKHBvaW50LCBtYXhEaXN0KSB7XG4gICAgICAgIGxldCBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAoTWF0aC5QSSAqIDIpO1xuICAgICAgICBsZXQgZGlzdCA9IE1hdGgucmFuZG9tKCkgKiBtYXhEaXN0O1xuICAgICAgICBwb2ludC54ICs9IE1hdGguRmxvb3IoTWF0aC5jb3MoYW5nbGUpICogZGlzdCk7XG4gICAgICAgIHBvaW50LnkgKz0gTWF0aC5GbG9vcihNYXRoLnNpbihhbmdsZSkgKiBkaXN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDaXJjbGVPdXRsaW5lQnVmZmVyKG51bVNlZ21lbnRzKSB7XG4gICAgICAgIGxldCB0aGV0YSA9ICgyICogTWF0aC5QSSkgLyBudW1TZWdtZW50cztcbiAgICAgICAgbGV0IHJhZGl1cyA9IDEuMDtcbiAgICAgICAgLy8gcHJlY2FsY3VsYXRlIHNpbmUgYW5kIGNvc2luZVxuICAgICAgICBsZXQgYyA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgbGV0IHMgPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgIGxldCB0O1xuICAgICAgICAvLyBzdGFydCBhdCBhbmdsZSA9IDBcbiAgICAgICAgbGV0IHggPSByYWRpdXM7XG4gICAgICAgIGxldCB5ID0gMDtcbiAgICAgICAgbGV0IHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtU2VnbWVudHMgKiAyKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHBvc2l0aW9uc1tpKjJdID0geDtcbiAgICAgICAgICAgIHBvc2l0aW9uc1tpKjIrMV0gPSB5O1xuICAgICAgICAgICAgLy8gYXBwbHkgdGhlIHJvdGF0aW9uXG4gICAgICAgICAgICB0ID0geDtcbiAgICAgICAgICAgIHggPSBjICogeCAtIHMgKiB5O1xuICAgICAgICAgICAgeSA9IHMgKiB0ICsgYyAqIHk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBvaW50ZXJzID0ge307XG4gICAgICAgIHBvaW50ZXJzW1BPU0lUSU9OU19JTkRFWF0gPSB7XG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgdHlwZTogJ0ZMT0FUJ1xuICAgICAgICB9O1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1vZGU6ICdMSU5FX0xPT1AnLFxuICAgICAgICAgICAgY291bnQ6IHBvc2l0aW9ucy5sZW5ndGggLyAyXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgZXNwZXIuVmVydGV4QnVmZmVyKHBvc2l0aW9ucywgcG9pbnRlcnMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNpcmNsZUZpbGxCdWZmZXIobnVtU2VnbWVudHMpIHtcbiAgICAgICAgbGV0IHRoZXRhID0gKDIgKiBNYXRoLlBJKSAvIG51bVNlZ21lbnRzO1xuICAgICAgICBsZXQgcmFkaXVzID0gMS4wO1xuICAgICAgICAvLyBwcmVjYWxjdWxhdGUgc2luZSBhbmQgY29zaW5lXG4gICAgICAgIGxldCBjID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgICBsZXQgcyA9IE1hdGguc2luKHRoZXRhKTtcbiAgICAgICAgbGV0IHQ7XG4gICAgICAgIC8vIHN0YXJ0IGF0IGFuZ2xlID0gMFxuICAgICAgICBsZXQgeCA9IHJhZGl1cztcbiAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICBsZXQgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSgobnVtU2VnbWVudHMgKyAyKSAqIDIpO1xuICAgICAgICBwb3NpdGlvbnNbMF0gPSAwO1xuICAgICAgICBwb3NpdGlvbnNbMV0gPSAwO1xuICAgICAgICBwb3NpdGlvbnNbcG9zaXRpb25zLmxlbmd0aC0yXSA9IHJhZGl1cztcbiAgICAgICAgcG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGgtMV0gPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuICAgICAgICAgICAgcG9zaXRpb25zWyhpKzEpKjJdID0geDtcbiAgICAgICAgICAgIHBvc2l0aW9uc1soaSsxKSoyKzFdID0geTtcbiAgICAgICAgICAgIC8vIGFwcGx5IHRoZSByb3RhdGlvblxuICAgICAgICAgICAgdCA9IHg7XG4gICAgICAgICAgICB4ID0gYyAqIHggLSBzICogeTtcbiAgICAgICAgICAgIHkgPSBzICogdCArIGMgKiB5O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBvaW50ZXJzID0ge307XG4gICAgICAgIHBvaW50ZXJzW1BPU0lUSU9OU19JTkRFWF0gPSB7XG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgdHlwZTogJ0ZMT0FUJ1xuICAgICAgICB9O1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1vZGU6ICdUUklBTkdMRV9GQU4nLFxuICAgICAgICAgICAgY291bnQ6IHBvc2l0aW9ucy5sZW5ndGggLyAyXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgZXNwZXIuVmVydGV4QnVmZmVyKHBvc2l0aW9ucywgcG9pbnRlcnMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGxldCBQb2ludCA9IFdlYkdMLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIG1peGluc1xuICAgICAgICAgICAgU3BhdGlhbEhhc2hcbiAgICAgICAgXSxcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBwb2ludE91dGxpbmU6IDEsXG4gICAgICAgICAgICBwb2ludE91dGxpbmVDb2xvcjogWzAuMCwgMC4wLCAwLjAsIDEuMF0sXG4gICAgICAgICAgICBwb2ludEZpbGxDb2xvcjogWzAuMiwgMC4xNSwgMC40LCAwLjVdLFxuICAgICAgICAgICAgcG9pbnRSYWRpdXM6IFBPSU5UX1JBRElVUyxcbiAgICAgICAgICAgIHNlbGVjdGVkT3V0bGluZUNvbG9yOiBbMC4wLCAwLjAsIDAuMCwgMS4wXSxcbiAgICAgICAgICAgIHNlbGVjdGVkRmlsbENvbG9yOiBbMC44LCAwLjQsIDAuMiwgMC41XSxcbiAgICAgICAgICAgIHNlbGVjdGVkUmFkaXVzOiBQT0lOVF9SQURJVVMgKyBQT0lOVF9SQURJVVNfSU5DLFxuICAgICAgICAgICAgaGlnaGxpZ2h0ZWRPdXRsaW5lQ29sb3I6IFswLjAsIDAuMCwgMC4wLCAxLjBdLFxuICAgICAgICAgICAgaGlnaGxpZ2h0ZWRGaWxsQ29sb3I6IFswLjMsIDAuMjUsIDAuNSwgMC41XSxcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkUmFkaXVzOiBQT0lOVF9SQURJVVMgKyBQT0lOVF9SQURJVVNfSU5DLFxuICAgICAgICAgICAgYmxlbmRpbmc6IHRydWUsXG4gICAgICAgICAgICBqaXR0ZXI6IHRydWUsXG4gICAgICAgICAgICBqaXR0ZXJEaXN0YW5jZTogMTBcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFNwYXRpYWxIYXNoLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbldlYkdMSW5pdDogZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHdlIHVzZSB0aGUgY29ycmVjdCBjb250ZXh0XG4gICAgICAgICAgICBlc3Blci5XZWJHTENvbnRleHQuYmluZCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBjaXJjbGUgdmVydGV4YnVmZmVyXG4gICAgICAgICAgICB0aGlzLl9jaXJjbGVGaWxsQnVmZmVyID0gY3JlYXRlQ2lyY2xlRmlsbEJ1ZmZlcihOVU1fU0xJQ0VTKTtcbiAgICAgICAgICAgIHRoaXMuX2NpcmNsZU91dGxpbmVCdWZmZXIgPSBjcmVhdGVDaXJjbGVPdXRsaW5lQnVmZmVyKE5VTV9TTElDRVMpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSByb290IG9mZnNldCBidWZmZXJcbiAgICAgICAgICAgIHRoaXMuX29mZnNldEJ1ZmZlciA9IG5ldyBlc3Blci5WZXJ0ZXhCdWZmZXIoTUFYX0JVRkZFUl9CWVRFX1NJWkUpO1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSBleHRlbnNpb24gZm9yIGhhcmR3YXJlIGluc3RhbmNpbmdcbiAgICAgICAgICAgIHRoaXMuX2V4dCA9IGVzcGVyLldlYkdMQ29udGV4dC5nZXRFeHRlbnNpb24oJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMgV2ViR0wgZXh0ZW5zaW9uIGlzIG5vdCBzdXBwb3J0ZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xlYXIgdGhlIGNodW5rc1xuICAgICAgICAgICAgdGhpcy5pbml0Q2h1bmtzKCk7XG4gICAgICAgICAgICAvLyBsb2FkIHNoYWRlcnNcbiAgICAgICAgICAgIHBhcmFsbGVsKHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZWQ6IChkb25lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaGFkZXIgPSBuZXcgZXNwZXIuU2hhZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnQ6IFNoYWRlcnMuaW5zdGFuY2VkUG9pbnQudmVydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWc6IFNoYWRlcnMuaW5zdGFuY2VkUG9pbnQuZnJhZ1xuICAgICAgICAgICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUobnVsbCwgc2hhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmRpdmlkdWFsOiAoZG9uZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2hhZGVyID0gbmV3IGVzcGVyLlNoYWRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0OiBTaGFkZXJzLnBvaW50LnZlcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnOiBTaGFkZXJzLnBvaW50LmZyYWdcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKG51bGwsIHNoYWRlcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIChlcnIsIHNoYWRlcnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VkU2hhZGVyID0gc2hhZGVycy5pbnN0YW5jZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5kaXZpZHVhbFNoYWRlciA9IHNoYWRlcnMuaW5kaXZpZHVhbDtcbiAgICAgICAgICAgICAgICBkb25lKG51bGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q29sbGlzaW9uUmFkaXVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucG9pbnRSYWRpdXMgKyB0aGlzLm9wdGlvbnMucG9pbnRPdXRsaW5lO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgIFdlYkdMLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgICAgICBtYXAub24oJ3pvb21lbmQnLCB0aGlzLm9uWm9vbUVuZCwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25SZW1vdmU6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgV2ViR0wucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgICAgIG1hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLm9uWm9vbUVuZCwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25ab29tU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhckhhc2goKTtcbiAgICAgICAgICAgIFdlYkdMLnByb3RvdHlwZS5vblpvb21TdGFydC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRDaHVua3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHdlIHVzZSB0aGUgY29ycmVjdCBjb250ZXh0XG4gICAgICAgICAgICBlc3Blci5XZWJHTENvbnRleHQuYmluZCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgLy8gYWxsb2NhdGUgYXZhaWxhYmxlIGNodW5rc1xuICAgICAgICAgICAgdGhpcy5fYXZhaWxhYmxlQ2h1bmtzID0gbmV3IEFycmF5KE1BWF9USUxFUyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8TUFYX1RJTEVTOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYnl0ZU9mZnNldCA9IGkgKiBNQVhfVElMRV9CWVRFX1NJWkU7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXZhaWxhYmxlQ2h1bmtzW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0OiBieXRlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyOiBuZXcgZXNwZXIuVmVydGV4QnVmZmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0QnVmZmVyLmJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdVTlNJR05FRF9TSE9SVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IGJ5dGVPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogJ1BPSU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUxlbmd0aDogTUFYX0JVRkZFUl9CWVRFX1NJWkVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VzZWRDaHVua3MgPSB7fTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlTW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGUub3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICBsZXQgbGF5ZXJQaXhlbCA9IHRoaXMuZ2V0TGF5ZXJQb2ludEZyb21FdmVudChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgbGV0IHJhZGl1cyA9IHRoaXMuZ2V0Q29sbGlzaW9uUmFkaXVzKCk7XG4gICAgICAgICAgICBsZXQgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICAgICAgICBsZXQgY29sbGlzaW9uID0gdGhpcy5waWNrKGxheWVyUGl4ZWwsIHJhZGl1cywgem9vbSk7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IE1hdGgucG93KDIsIHpvb20pO1xuICAgICAgICAgICAgaWYgKGNvbGxpc2lvbikge1xuICAgICAgICAgICAgICAgIC8vIG1pbWljIG1vdXNlb3ZlciAvIG1vdXNlb3V0IGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkLnZhbHVlICE9PSBjb2xsaXNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ldyBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGUgbW91c2VvdXQgZm9yIG9sZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW91dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuaGlnaGxpZ2h0ZWQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhlY3V0ZSBtb3VzZW92ZXIgZm9yIG5ld1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW92ZXInLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbTogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gcHJldmlvdXMgY29sbGlzaW9uLCBleGVjdXRlIG1vdXNlb3ZlclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3ZlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW06IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVzZSBjb2xsaXNpb24gcG9pbnQgdG8gZmluZCB0aWxlXG4gICAgICAgICAgICAgICAgbGV0IGNvb3JkID0gdGhpcy5nZXRUaWxlQ29vcmRGcm9tTGF5ZXJQb2ludChjb2xsaXNpb24pO1xuICAgICAgICAgICAgICAgIGxldCBoYXNoID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZCk7XG4gICAgICAgICAgICAgICAgLy8gZmxhZyBhcyBoaWdobGlnaHRlZFxuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVzOiB0aGlzLl9jYWNoZVtoYXNoXS50aWxlcyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbGxpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgKHNpemUgKiBUSUxFX1NJWkUpIC0gY29sbGlzaW9uLnlcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gc2V0IGN1cnNvclxuICAgICAgICAgICAgICAgICQodGhpcy5fbWFwLl9jb250YWluZXIpLmNzcygnY3Vyc29yJywgJ3BvaW50ZXInKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtb3VzZSBvdXRcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW91dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbTogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5oaWdobGlnaHRlZC52YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xlYXIgaGlnaGxpZ2h0ZWQgZmxhZ1xuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZCA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGUub3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICBsZXQgbGF5ZXJQaXhlbCA9IHRoaXMuZ2V0TGF5ZXJQb2ludEZyb21FdmVudChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgbGV0IHJhZGl1cyA9IHRoaXMuZ2V0Q29sbGlzaW9uUmFkaXVzKCk7XG4gICAgICAgICAgICBsZXQgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IE1hdGgucG93KDIsIHpvb20pO1xuICAgICAgICAgICAgbGV0IGNvbGxpc2lvbiA9IHRoaXMucGljayhsYXllclBpeGVsLCByYWRpdXMsIHpvb20pO1xuICAgICAgICAgICAgaWYgKGNvbGxpc2lvbikge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBjb2xsaXNpb24gcG9pbnQgdG8gZmluZCB0aWxlXG4gICAgICAgICAgICAgICAgbGV0IGNvb3JkID0gdGhpcy5nZXRUaWxlQ29vcmRGcm9tTGF5ZXJQb2ludChjb2xsaXNpb24pO1xuICAgICAgICAgICAgICAgIGxldCBoYXNoID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZCk7XG4gICAgICAgICAgICAgICAgLy8gZmxhZyBhcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVzOiB0aGlzLl9jYWNoZVtoYXNoXS50aWxlcyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbGxpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgKHNpemUgKiBUSUxFX1NJWkUpIC0gY29sbGlzaW9uLnlcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdjbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbTogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkVGlsZVRvQnVmZmVyOiBmdW5jdGlvbihjb29yZHMsIGRhdGEsIGNvdW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYXZhaWxhYmxlQ2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTm8gYXZhaWxhYmxlIGNodW5rcyByZW1haW5pbmcgdG8gYnVmZmVyIGRhdGEnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZXQgYW4gYXZhaWxhYmxlIGNodW5rXG4gICAgICAgICAgICBsZXQgY2h1bmsgPSB0aGlzLl9hdmFpbGFibGVDaHVua3MucG9wKCk7XG4gICAgICAgICAgICAvLyBzZXQgY291bnRcbiAgICAgICAgICAgIGNodW5rLmNvdW50ID0gY291bnQ7XG4gICAgICAgICAgICAvLyBidWZmZXIgdGhlIGRhdGEgaW50byB0aGUgcGh5c2ljYWwgY2h1bmtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldEJ1ZmZlci5idWZmZXJTdWJEYXRhKGRhdGEsIGNodW5rLmJ5dGVPZmZzZXQpO1xuICAgICAgICAgICAgLy8gZmxhZyBhcyB1c2VkXG4gICAgICAgICAgICBsZXQgbmNvb3JkcyA9IHRoaXMuZ2V0Tm9ybWFsaXplZENvb3Jkcyhjb29yZHMpO1xuICAgICAgICAgICAgbGV0IGhhc2ggPSB0aGlzLmNhY2hlS2V5RnJvbUNvb3JkKG5jb29yZHMpO1xuICAgICAgICAgICAgdGhpcy5fdXNlZENodW5rc1toYXNoXSA9IGNodW5rO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZVRpbGVGcm9tQnVmZmVyOiBmdW5jdGlvbihjb29yZHMpIHtcbiAgICAgICAgICAgIGxldCBuY29vcmRzID0gdGhpcy5nZXROb3JtYWxpemVkQ29vcmRzKGNvb3Jkcyk7XG4gICAgICAgICAgICBsZXQgaGFzaCA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQobmNvb3Jkcyk7XG4gICAgICAgICAgICBsZXQgY2h1bmsgPSB0aGlzLl91c2VkQ2h1bmtzW2hhc2hdO1xuICAgICAgICAgICAgLy8gY2xlYXIgdGhlIGNvdW50XG4gICAgICAgICAgICBjaHVuay5jb3VudCA9IDA7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdXNlZENodW5rc1toYXNoXTtcbiAgICAgICAgICAgIC8vIGFkZCBhcyBhIG5ldyBhdmFpbGFibGUgY2h1bmtcbiAgICAgICAgICAgIHRoaXMuX2F2YWlsYWJsZUNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gYWN0dWFsbHkgdW5idWZmZXIgdGhlIGRhdGFcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNhY2hlTG9hZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGxldCBjYWNoZWQgPSBldmVudC5lbnRyeTtcbiAgICAgICAgICAgIGxldCBjb29yZHMgPSBldmVudC5jb29yZHM7XG4gICAgICAgICAgICBpZiAoY2FjaGVkLmRhdGEgJiYgY2FjaGVkLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgeCAvIHkgdG8gdGlsZSBwaXhlbHNcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IGNhY2hlZC5kYXRhO1xuICAgICAgICAgICAgICAgIGxldCB4RmllbGQgPSB0aGlzLmdldFhGaWVsZCgpO1xuICAgICAgICAgICAgICAgIGxldCB5RmllbGQgPSB0aGlzLmdldFlGaWVsZCgpO1xuICAgICAgICAgICAgICAgIGxldCB6b29tID0gY29vcmRzLno7XG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSBNYXRoLnBvdygyLCB6b29tKTtcbiAgICAgICAgICAgICAgICBsZXQgcmFkaXVzID0gdGhpcy5nZXRDb2xsaXNpb25SYWRpdXMoKTtcbiAgICAgICAgICAgICAgICBsZXQgbnVtQnl0ZXMgPSBkYXRhLmxlbmd0aCAqIENPTVBPTkVOVF9CWVRFX1NJWkUgKiBDT01QT05FTlRTX1BFUl9QT0lOVDtcbiAgICAgICAgICAgICAgICBsZXQgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKE1hdGgubWluKG51bUJ5dGVzLCBNQVhfVElMRV9CWVRFX1NJWkUpKTtcbiAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb25zID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgbnVtRGF0dW0gPSBNYXRoLm1pbihkYXRhLmxlbmd0aCwgTUFYX1BPSU5UU19QRVJfVElMRSk7XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBjb2xsaXNpb25zID0ge307XG4gICAgICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICAgICAgLy8gY2FsYyBwaXhlbCBsb2NhdGlvbnNcbiAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxudW1EYXR1bTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoaXQgPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICBsZXQgeCA9IF8uZ2V0KGhpdCwgeEZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHkgPSBfLmdldChoaXQsIHlGaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4ICE9PSB1bmRlZmluZWQgJiYgeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgcG9zaXRpb24gaW4gbGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYXllclBvaW50ID0gdGhpcy5nZXRMYXllclBvaW50RnJvbURhdGFQb2ludCh4LCB5LCB6b29tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBwaXhlbFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGxheWVyUG9pbnQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBsYXllclBvaW50LnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaGl0XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhhc2ggPSBwb2ludC54ICsgJzonICsgcG9pbnQueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaml0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxpc2lvbnNbaGFzaF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlKaXR0ZXIocG9pbnQsIHRoaXMub3B0aW9ucy5qaXR0ZXJEaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbnNbaGFzaF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5jb2RlIHRoZSBwb2ludCBpbnRvIHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVBvaW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKjQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2l6ZSAqIFRJTEVfU0laRSkgLSBwb2ludC55KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHBvaW50IHRvIHNwYXRpYWwgaGFzaFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludChwb2ludCwgcmFkaXVzLCB6b29tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBjb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHBvaW50cyBpbiB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgICAgICAgICAgICAgLy8gYnVmZmVyIHRoZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGlsZVRvQnVmZmVyKGNvb3JkcywgcG9zaXRpb25zLCBjb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2FjaGVVbmxvYWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBsZXQgY2FjaGVkID0gZXZlbnQuZW50cnk7XG4gICAgICAgICAgICBsZXQgY29vcmRzID0gZXZlbnQuY29vcmRzO1xuICAgICAgICAgICAgaWYgKGNhY2hlZC5wb2ludHMpIHsgLy9jYWNoZWQuZGF0YSAmJiBjYWNoZWQuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUaWxlRnJvbUJ1ZmZlcihjb29yZHMpO1xuICAgICAgICAgICAgICAgIGxldCByYWRpdXMgPSB0aGlzLmdldENvbGxpc2lvblJhZGl1cygpO1xuICAgICAgICAgICAgICAgIGNhY2hlZC5wb2ludHMuZm9yRWFjaChwb2ludCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUG9pbnQocG9pbnQsIHJhZGl1cywgY29vcmRzLnopO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhY2hlZC5wb2ludHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldFdyYXBBcm91bmRPZmZzZXQ6IGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBNYXRoLnBvdygyLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBtb2RlbCBtYXRyaXhcbiAgICAgICAgICAgIGxldCB4V3JhcCA9IE1hdGguZmxvb3IoY29vcmRzLnggLyBzaXplKTtcbiAgICAgICAgICAgIGxldCB5V3JhcCA9IE1hdGguZmxvb3IoY29vcmRzLnkgLyBzaXplKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgc2l6ZSAqIFRJTEVfU0laRSAqIHhXcmFwLFxuICAgICAgICAgICAgICAgIHNpemUgKiBUSUxFX1NJWkUgKiB5V3JhcFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9ydGhvTWF0cml4KFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgc2l6ZS54LFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgc2l6ZS55LFxuICAgICAgICAgICAgICAgIC0xLCAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRWaWV3T2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxldCBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxCb3VuZHMoKTtcbiAgICAgICAgICAgIGxldCBkaW0gPSBNYXRoLnBvdygyLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpKSAqIFRJTEVfU0laRTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYm91bmRzLm1pbi54LFxuICAgICAgICAgICAgICAgIGRpbSAtIGJvdW5kcy5tYXgueVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBkcmF3SW5zdGFuY2VkOiBmdW5jdGlvbihidWZmZXIsIGNvbG9yLCByYWRpdXMpIHtcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuX2dsO1xuICAgICAgICAgICAgbGV0IGV4dCA9IHRoaXMuX2V4dDtcbiAgICAgICAgICAgIGxldCBzaGFkZXIgPSB0aGlzLl9pbnN0YW5jZWRTaGFkZXI7XG4gICAgICAgICAgICBsZXQgY2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICAgICAgICAgIGxldCB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmxlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBlbmFibGUgYmxlbmRpbmdcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1c2Ugc2hhZGVyXG4gICAgICAgICAgICBzaGFkZXIudXNlKCk7XG4gICAgICAgICAgICAvLyBzZXQgdW5pZm9ybXNcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1Q29sb3InLCBjb2xvcik7XG4gICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndVByb2plY3Rpb25NYXRyaXgnLCB0aGlzLmdldFByb2plY3Rpb25NYXRyaXgoKSk7XG4gICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndU9wYWNpdHknLCB0aGlzLmdldE9wYWNpdHkoKSk7XG4gICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndVNjYWxlJywgcmFkaXVzKTtcbiAgICAgICAgICAgIC8vIGNhbGMgdmlldyBvZmZzZXRcbiAgICAgICAgICAgIGxldCB2aWV3T2Zmc2V0ID0gdGhpcy5nZXRWaWV3T2Zmc2V0KCk7XG4gICAgICAgICAgICAvLyBiaW5kcyB0aGUgYnVmZmVyIHRvIGluc3RhbmNlXG4gICAgICAgICAgICBidWZmZXIuYmluZCgpO1xuICAgICAgICAgICAgLy8gZW5hYmxlIGluc3RhbmNpbmdcbiAgICAgICAgICAgIGV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoT0ZGU0VUU19JTkRFWCwgMSk7XG4gICAgICAgICAgICAvLyBmb3IgZWFjaCBhbGxvY2F0ZWQgY2h1bmtcbiAgICAgICAgICAgIF8uZm9ySW4odGhpcy5fdXNlZENodW5rcywgKGNodW5rLCBoYXNoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggdGlsZSByZWZlcnJpbmcgdG8gdGhlIGRhdGFcbiAgICAgICAgICAgICAgICBsZXQgY2FjaGVkID0gY2FjaGVbaGFzaF07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBiaW5kIHRoZSBjaHVuaydzIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICBjaHVuay52ZXJ0ZXhCdWZmZXIuYmluZCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZW5kZXIgZm9yIGVhY2ggdGlsZVxuICAgICAgICAgICAgICAgICAgICBfLmtleXMoY2FjaGVkLnRpbGVzKS5mb3JFYWNoKGhhc2ggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvb3JkcyA9IHRoaXMuY29vcmRGcm9tQ2FjaGVLZXkoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29vcmRzLnogIT09IHpvb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBoYXZlIHRvIGNoZWNrIGhlcmUgaWYgdGhlIHRpbGVzIGFyZSBzdGFsZSBvciBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGxvYWQgdmlldyBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmdldFdyYXBBcm91bmRPZmZzZXQoY29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbE9mZnNldCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3T2Zmc2V0WzBdIC0gb2Zmc2V0WzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdPZmZzZXRbMV0gLSBvZmZzZXRbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VWaWV3T2Zmc2V0JywgdG90YWxPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHJhdyB0aGUgaXN0YW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dC5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoZ2xbYnVmZmVyLm1vZGVdLCAwLCBidWZmZXIuY291bnQsIGNodW5rLmNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVuYmluZFxuICAgICAgICAgICAgICAgICAgICBjaHVuay52ZXJ0ZXhCdWZmZXIudW5iaW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBkaXNhYmxlIGluc3RhbmNpbmdcbiAgICAgICAgICAgIGV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoT0ZGU0VUU19JTkRFWCwgMCk7XG4gICAgICAgICAgICAvLyB1bmJpbmQgYnVmZmVyXG4gICAgICAgICAgICBidWZmZXIudW5iaW5kKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZHJhd0luZGl2aWR1YWw6IGZ1bmN0aW9uKGJ1ZmZlciwgY29sb3IsIHJhZGl1cywgdGlsZXMsIHBvaW50KSB7XG4gICAgICAgICAgICAvLyBkcmF3IHNlbGVjdGVkIHBvaW50c1xuICAgICAgICAgICAgbGV0IGdsID0gdGhpcy5fZ2w7XG4gICAgICAgICAgICBsZXQgc2hhZGVyID0gdGhpcy5faW5kaXZpZHVhbFNoYWRlcjtcbiAgICAgICAgICAgIGxldCB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgICAgICAgICAgIC8vIGJpbmQgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgYnVmZmVyLmJpbmQoKTtcbiAgICAgICAgICAgIC8vIGRpc2FibGUgYmxlbmRpbmdcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgLy8gdXNlIHNoYWRlclxuICAgICAgICAgICAgc2hhZGVyLnVzZSgpO1xuICAgICAgICAgICAgLy8gdXNlIHVuaWZvcm0gZm9yIG9mZnNldFxuICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VQcm9qZWN0aW9uTWF0cml4JywgdGhpcy5nZXRQcm9qZWN0aW9uTWF0cml4KCkpO1xuICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VPcGFjaXR5JywgdGhpcy5nZXRPcGFjaXR5KCkpO1xuICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VTY2FsZScsIHJhZGl1cyk7XG4gICAgICAgICAgICAvLyB2aWV3IG9mZnNldFxuICAgICAgICAgICAgbGV0IHZpZXdPZmZzZXQgPSB0aGlzLmdldFZpZXdPZmZzZXQoKTtcbiAgICAgICAgICAgIF8uZm9ySW4odGlsZXMsIHRpbGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aWxlLmNvb3Jkcy56ICE9PSB6b29tKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIGhhdmUgdG8gY2hlY2sgaGVyZSBpZiB0aGUgdGlsZXMgYXJlIHN0YWxlIG9yIG5vdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVwbG9hZCB2aWV3IG9mZnNldFxuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmdldFdyYXBBcm91bmRPZmZzZXQodGlsZS5jb29yZHMpO1xuICAgICAgICAgICAgICAgIGxldCB0b3RhbE9mZnNldCA9IFtcbiAgICAgICAgICAgICAgICAgICAgdmlld09mZnNldFswXSAtIG9mZnNldFswXSxcbiAgICAgICAgICAgICAgICAgICAgdmlld09mZnNldFsxXSAtIG9mZnNldFsxXSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1Vmlld09mZnNldCcsIHRvdGFsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndU9mZnNldCcsIHBvaW50KTtcbiAgICAgICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndUNvbG9yJywgY29sb3IpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5kcmF3KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHVuYmluZCB0aGUgYnVmZmVyXG4gICAgICAgICAgICBidWZmZXIudW5iaW5kKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyRnJhbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gc2V0dXBcbiAgICAgICAgICAgIGxldCBnbCA9IHRoaXMuX2dsO1xuICAgICAgICAgICAgbGV0IHZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnQ7XG4gICAgICAgICAgICB2aWV3cG9ydC5wdXNoKCk7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgaW5zdGFuY2VkIHBvaW50c1xuXG4gICAgICAgICAgICAvLyBkcmF3IGluc3RhbmNlZCBmaWxsXG4gICAgICAgICAgICB0aGlzLmRyYXdJbnN0YW5jZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlRmlsbEJ1ZmZlcixcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucG9pbnRGaWxsQ29sb3IsXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBvaW50UmFkaXVzKTtcbiAgICAgICAgICAgIC8vIGRyYXcgaW5zdGFuY2VkIG91dGxpbmVzXG4gICAgICAgICAgICBnbC5saW5lV2lkdGgodGhpcy5vcHRpb25zLnBvaW50T3V0bGluZSk7XG4gICAgICAgICAgICB0aGlzLmRyYXdJbnN0YW5jZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlT3V0bGluZUJ1ZmZlcixcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucG9pbnRPdXRsaW5lQ29sb3IsXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBvaW50UmFkaXVzKTtcblxuICAgICAgICAgICAgLy8gZHJhdyBpbmRpdmlkdWFsIHBvaW50c1xuXG4gICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgICAgIC8vIGRyYXcgaW5kaXZpZHVhbCBmaWxsXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3SW5kaXZpZHVhbChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlRmlsbEJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmhpZ2hsaWdodGVkRmlsbENvbG9yLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ZWRSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQudGlsZXMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQucG9pbnQpO1xuICAgICAgICAgICAgICAgIC8vIGRyYXcgaW5kaXZpZHVhbCBvdXRsaW5lXG4gICAgICAgICAgICAgICAgZ2wubGluZVdpZHRoKHRoaXMub3B0aW9ucy5wb2ludE91dGxpbmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0luZGl2aWR1YWwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZU91dGxpbmVCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5oaWdobGlnaHRlZE91dGxpbmVDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmhpZ2hsaWdodGVkUmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkLnRpbGVzLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkLnBvaW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBkcmF3IGluZGl2aWR1YWwgZmlsbFxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0luZGl2aWR1YWwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZUZpbGxCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zZWxlY3RlZEZpbGxDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNlbGVjdGVkUmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkLnRpbGVzLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkLnBvaW50KTtcbiAgICAgICAgICAgICAgICAvLyBkcmF3IGluZGl2aWR1YWwgb3V0bGluZVxuICAgICAgICAgICAgICAgIGdsLmxpbmVXaWR0aCh0aGlzLm9wdGlvbnMucG9pbnRPdXRsaW5lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdJbmRpdmlkdWFsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGVPdXRsaW5lQnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRPdXRsaW5lQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zZWxlY3RlZFJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC50aWxlcyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC5wb2ludCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRlYXJkb3duXG4gICAgICAgICAgICB2aWV3cG9ydC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbGV0IENvbG9yUmFtcCA9IHJlcXVpcmUoJy4uLy4uL21peGluL0NvbG9yUmFtcCcpO1xuXG4gICAgLyoqXG4gICAgICogcHJlY2lzaW9uXG4gICAgICovXG4gICAgbGV0IHByZWNpc2lvbiA9XG4gICAgICAgIGBcbiAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICAgICBwcmVjaXNpb24gaGlnaHAgaW50O1xuICAgICAgICBgO1xuXG4gICAgLyoqXG4gICAgICogZGVjb2RlIGZsb2F0XG4gICAgICovXG4gICAgbGV0IGRlY29kZVJHQkFUb0Zsb2F0ID1cbiAgICAgICAgYFxuICAgICAgICBmbG9hdCBkZWNvZGVSR0JBVG9GbG9hdCh2ZWM0IHYpIHtcbiAgICAgICAgICAgIHJldHVybiAodi54ICogMjU1LjAgKiAxNjc3NzIxNi4wKSArXG4gICAgICAgICAgICAgICAgKHYueSAqIDI1NS4wICogNjU1MzYuMCkgK1xuICAgICAgICAgICAgICAgICh2LnogKiAyNTUuMCAqIDI1Ni4wKSArXG4gICAgICAgICAgICAgICAgdi53ICogMjU1LjA7XG4gICAgICAgIH1cbiAgICAgICAgYDtcblxuICAgIGxldCBkZWNvZGVVaW50MTZUb1VpbnQzMiA9XG4gICAgICAgIGBcbiAgICAgICAgaW50IGRlY29kZVVpbnQxNlRvVWludDMyKGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnQoYSAqIDY1NTM2LjApICsgaW50KGIpO1xuICAgICAgICB9XG4gICAgICAgIGA7XG5cbiAgICAvKipcbiAgICAgKiB0cmFuc2Zvcm1zXG4gICAgICovXG5cbiAgICAvLyBsb2cxMFxuICAgIGxldCBsb2cxMFRyYW5zZm9ybSA9XG4gICAgICAgIGBcbiAgICAgICAgZmxvYXQgbG9nMTAoZmxvYXQgdmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nKHZhbCkgLyBsb2coMTAuMCk7XG4gICAgICAgIH1cbiAgICAgICAgZmxvYXQgbG9nMTBUcmFuc2Zvcm0oZmxvYXQgdmFsLCBmbG9hdCBtaW5WYWwsIGZsb2F0IG1heFZhbCkge1xuICAgICAgICAgICAgaWYgKG1pblZhbCA8IDEuMCkgeyBtaW5WYWwgPSAxLjA7IH1cbiAgICAgICAgICAgIGlmIChtYXhWYWwgPCAxLjApIHsgbWF4VmFsID0gMS4wOyB9XG4gICAgICAgICAgICBpZiAodmFsIDwgMS4wKSB7IHZhbCA9IDEuMDsgfVxuICAgICAgICAgICAgZmxvYXQgbG9nTWluID0gbG9nMTAobWluVmFsKTtcbiAgICAgICAgICAgIGZsb2F0IGxvZ01heCA9IGxvZzEwKG1heFZhbCk7XG4gICAgICAgICAgICBmbG9hdCBsb2dWYWwgPSBsb2cxMCh2YWwpO1xuICAgICAgICAgICAgZmxvYXQgcmFuZ2UgPSBsb2dNYXggLSBsb2dNaW47XG4gICAgICAgICAgICBpZiAocmFuZ2UgPT0gMC4wKSB7IHJhbmdlID0gMS4wOyB9XG4gICAgICAgICAgICByZXR1cm4gKGxvZ1ZhbCAtIGxvZ01pbikgLyByYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBgO1xuXG4gICAgLy8gc2lnbW9pZFxuICAgIGxldCBzaWdtb2lkVHJhbnNmb3JtID1cbiAgICAgICAgYFxuICAgICAgICBmbG9hdCBzaWdtb2lkVHJhbnNmb3JtKGZsb2F0IHZhbCwgZmxvYXQgbWluVmFsLCBmbG9hdCBtYXhWYWwpIHtcbiAgICAgICAgICAgIG1pblZhbCA9IGFicyhtaW5WYWwpO1xuICAgICAgICAgICAgbWF4VmFsID0gYWJzKG1heFZhbCk7XG4gICAgICAgICAgICBmbG9hdCBkaXN0ID0gbWF4KG1pblZhbCwgbWF4VmFsKTtcbiAgICAgICAgICAgIGZsb2F0IFNJR01PSURfU0NBTEUgPSAwLjE1O1xuICAgICAgICAgICAgZmxvYXQgc2NhbGVkVmFsID0gdmFsIC8gKFNJR01PSURfU0NBTEUgKiBkaXN0KTtcbiAgICAgICAgICAgIHJldHVybiAxLjAgLyAoMS4wICsgZXhwKC1zY2FsZWRWYWwpKTtcbiAgICAgICAgfVxuICAgICAgICBgO1xuXG4gICAgLy8gbGluZWFyXG4gICAgbGV0IGxpbmVhclRyYW5zZm9ybSA9XG4gICAgICAgIGBcbiAgICAgICAgZmxvYXQgbGluZWFyVHJhbnNmb3JtKGZsb2F0IHZhbCwgZmxvYXQgbWluVmFsLCBmbG9hdCBtYXhWYWwpIHtcbiAgICAgICAgICAgIGZsb2F0IHJhbmdlID0gbWF4VmFsIC0gbWluVmFsO1xuICAgICAgICAgICAgaWYgKHJhbmdlID09IDAuMCkgeyByYW5nZSA9IDEuMDsgfVxuICAgICAgICAgICAgcmV0dXJuICh2YWwgLSBtaW5WYWwpIC8gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgYDtcblxuICAgIGxldCB0cmFuc2Zvcm0gPVxuICAgICAgICBsb2cxMFRyYW5zZm9ybSArXG4gICAgICAgIHNpZ21vaWRUcmFuc2Zvcm0gK1xuICAgICAgICBsaW5lYXJUcmFuc2Zvcm0gK1xuICAgICAgICBgXG4gICAgICAgICNkZWZpbmUgTE9HX1RSQU5TRk9STSAwXG4gICAgICAgICNkZWZpbmUgTElORUFSX1RSQU5TRk9STSAxXG4gICAgICAgICNkZWZpbmUgU0lHTU9JRF9UUkFOU0ZPUk0gMlxuICAgICAgICB1bmlmb3JtIGludCB1VHJhbnNmb3JtVHlwZTtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCB1TWluO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHVNYXg7XG4gICAgICAgIGZsb2F0IHRyYW5zZm9ybShmbG9hdCB2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwgPCB1TWluKSB7IHZhbCA9IHVNaW47IH1cbiAgICAgICAgICAgIGlmICh2YWwgPiB1TWF4KSB7IHZhbCA9IHVNYXg7IH1cbiAgICAgICAgICAgIGlmICh1VHJhbnNmb3JtVHlwZSA9PSBMSU5FQVJfVFJBTlNGT1JNKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVhclRyYW5zZm9ybSh2YWwsIHVNaW4sIHVNYXgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1VHJhbnNmb3JtVHlwZSA9PSBTSUdNT0lEX1RSQU5TRk9STSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWdtb2lkVHJhbnNmb3JtKHZhbCwgdU1pbiwgdU1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nMTBUcmFuc2Zvcm0odmFsLCB1TWluLCB1TWF4KTtcbiAgICAgICAgfVxuICAgICAgICBgO1xuXG4gICAgLyoqXG4gICAgICogQ29sb3IgcmFtcFxuICAgICAqL1xuICAgIGxldCBjb2xvclJhbXAgPVxuICAgICAgICBgXG4gICAgICAgICNkZWZpbmUgUkFNUF9WQUxVRVMgJHtDb2xvclJhbXAuTlVNX0dSQURJRU5UX1NURVBTfVxuICAgICAgICB1bmlmb3JtIHZlYzQgdVJhbXBbUkFNUF9WQUxVRVNdO1xuICAgICAgICB2ZWM0IGNvbG9yUmFtcChmbG9hdCB2YWx1ZSkge1xuICAgICAgICAgICAgZmxvYXQgbWF4SW5kZXggPSBmbG9hdChSQU1QX1ZBTFVFUyAtIDEpO1xuICAgICAgICAgICAgaW50IGluZGV4ID0gaW50KHZhbHVlICogbWF4SW5kZXgpO1xuICAgICAgICAgICAgLy8gTk9URTogSSBSRUFMTFkgZG9uJ3QgbGlrZSB0aGlzLCBidXQgaXQgc2VlbXMgdG8gYmUgdGhlIG9ubHkgd2F5XG4gICAgICAgICAgICAvLyB0byBpbmRleCB0aGUgdVJhbXAgYXJyYXlcbiAgICAgICAgICAgIGZvciAoaW50IGk9MDsgaTxSQU1QX1ZBTFVFUzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVSYW1wW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2ZWM0KDEuMCwgMC4wLCAxLjAsIDEuMCk7XG4gICAgICAgIH1cbiAgICAgICAgYDtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIFJhbmdlXG4gICAgICovXG4gICAgbGV0IHZhbHVlUmFuZ2UgPVxuICAgICAgICBgXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVJhbmdlTWluO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHVSYW5nZU1heDtcbiAgICAgICAgZmxvYXQgaW50ZXJwb2xhdGVUb1JhbmdlKGZsb2F0IG52YWwpIHtcbiAgICAgICAgICAgIGZsb2F0IHJ2YWwgPSAobnZhbCAtIHVSYW5nZU1pbikgLyAodVJhbmdlTWF4IC0gdVJhbmdlTWluKTtcbiAgICAgICAgICAgIGlmIChydmFsID4gMS4wKSB7XG4gICAgICAgICAgICAgICAgcnZhbCA9IDEuMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocnZhbCA8IDAuMCkge1xuICAgICAgICAgICAgICAgIHJ2YWwgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnZhbDtcbiAgICAgICAgfVxuICAgICAgICBgO1xuXG4gICAgLyoqXG4gICAgICogaGVhdG1hcCBzaGFkZXJcbiAgICAgKi9cbiAgICBsZXQgaGVhdG1hcCA9IHtcbiAgICAgICAgdmVydDpcbiAgICAgICAgICAgIHByZWNpc2lvbiArXG4gICAgICAgICAgICBgXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xuICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFQb3NpdGlvbiwgMC4wLCAxLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYCxcbiAgICAgICAgZnJhZzpcbiAgICAgICAgICAgIHByZWNpc2lvbiArXG4gICAgICAgICAgICBkZWNvZGVSR0JBVG9GbG9hdCArXG4gICAgICAgICAgICB0cmFuc2Zvcm0gK1xuICAgICAgICAgICAgY29sb3JSYW1wICtcbiAgICAgICAgICAgIHZhbHVlUmFuZ2UgK1xuICAgICAgICAgICAgYFxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmVTYW1wbGVyO1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTtcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIHZlYzQgZW5jID0gdGV4dHVyZTJEKHVUZXh0dXJlU2FtcGxlciwgdlRleHR1cmVDb29yZCk7XG4gICAgICAgICAgICAgICAgZmxvYXQgY291bnQgPSBkZWNvZGVSR0JBVG9GbG9hdChlbmMpO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzY2FyZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmxvYXQgbnZhbCA9IHRyYW5zZm9ybShjb3VudCk7XG4gICAgICAgICAgICAgICAgZmxvYXQgcnZhbCA9IGludGVycG9sYXRlVG9SYW5nZShudmFsKTtcbiAgICAgICAgICAgICAgICB2ZWM0IGNvbG9yID0gY29sb3JSYW1wKHJ2YWwpO1xuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IucmdiLCBjb2xvci5hICogdU9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBpbnN0YW5jZWQgcG9pbnQgc2hhZGVyXG4gICAgICovXG4gICAgbGV0IGluc3RhbmNlZFBvaW50ID0ge1xuICAgICAgICB2ZXJ0OlxuICAgICAgICAgICAgcHJlY2lzaW9uICtcbiAgICAgICAgICAgIGRlY29kZVVpbnQxNlRvVWludDMyICtcbiAgICAgICAgICAgIGBcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWM0IGFPZmZzZXQ7XG4gICAgICAgICAgICB1bmlmb3JtIGl2ZWMyIHVWaWV3T2Zmc2V0O1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1U2NhbGU7XG4gICAgICAgICAgICB1bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgaXZlYzIgaU9mZnNldCA9IGl2ZWMyKFxuICAgICAgICAgICAgICAgICAgICBkZWNvZGVVaW50MTZUb1VpbnQzMihhT2Zmc2V0LngsIGFPZmZzZXQueSksXG4gICAgICAgICAgICAgICAgICAgIGRlY29kZVVpbnQxNlRvVWludDMyKGFPZmZzZXQueiwgYU9mZnNldC53KSk7XG4gICAgICAgICAgICAgICAgdmVjMiBtUG9zaXRpb24gPSB1U2NhbGUgKiBhUG9zaXRpb24gKyB2ZWMyKGlPZmZzZXQgLSB1Vmlld09mZnNldCk7XG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQobVBvc2l0aW9uLCAwLjAsIDEuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBgLFxuICAgICAgICBmcmFnOlxuICAgICAgICAgICAgcHJlY2lzaW9uICtcbiAgICAgICAgICAgIGBcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdU9wYWNpdHk7XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzQgdUNvbG9yO1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodUNvbG9yLnJnYiwgdUNvbG9yLmEgKiB1T3BhY2l0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBgXG4gICAgfTtcblxuICAgIGxldCBwb2ludCA9IHtcbiAgICAgICAgdmVydDpcbiAgICAgICAgICAgIHByZWNpc2lvbiArXG4gICAgICAgICAgICBgXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG4gICAgICAgICAgICB1bmlmb3JtIGl2ZWMyIHVPZmZzZXQ7XG4gICAgICAgICAgICB1bmlmb3JtIGl2ZWMyIHVWaWV3T2Zmc2V0O1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1U2NhbGU7XG4gICAgICAgICAgICB1bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgdmVjMiBtUG9zaXRpb24gPSB1U2NhbGUgKiBhUG9zaXRpb24gKyB2ZWMyKHVPZmZzZXQgLSB1Vmlld09mZnNldCk7XG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQobVBvc2l0aW9uLCAwLjAsIDEuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBgLFxuICAgICAgICBmcmFnOlxuICAgICAgICAgICAgcHJlY2lzaW9uICtcbiAgICAgICAgICAgIGBcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdU9wYWNpdHk7XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzQgdUNvbG9yO1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodUNvbG9yLnJnYiwgdUNvbG9yLmEgKiB1T3BhY2l0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBgXG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoZWF0bWFwIHNoYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgaGVhdG1hcDogaGVhdG1hcCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogaW5zdGFuY2VkIHBvaW50IHNoYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgaW5zdGFuY2VkUG9pbnQ6IGluc3RhbmNlZFBvaW50LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwb2ludCBzaGFkZXJcbiAgICAgICAgICovXG4gICAgICAgIHBvaW50OiBwb2ludFxuXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBSZXF1ZXN0b3IgPSByZXF1aXJlKCcuL1JlcXVlc3RvcicpO1xuXG4gICAgY2xhc3MgTWV0YVJlcXVlc3RvciBleHRlbmRzIFJlcXVlc3RvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHVybCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHN1cGVyKHVybCwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGdldEhhc2gocmVxKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7cmVxLnR5cGV9LSR7cmVxLmluZGV4fS0ke3JlcS5zdG9yZX1gO1xuICAgICAgICB9XG4gICAgICAgIGdldFVSTChyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBgbWV0YS8ke3Jlcy50eXBlfS8ke3Jlcy5lbmRwb2ludH0vJHtyZXMuaW5kZXh9LyR7cmVzLnN0b3JlfWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1ldGFSZXF1ZXN0b3I7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgUkVUUllfSU5URVJWQUwgPSA1MDAwO1xuXG4gICAgZnVuY3Rpb24gZ2V0SG9zdCgpIHtcbiAgICAgICAgbGV0IGxvYyA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgICAgbGV0IG5ld191cmk7XG4gICAgICAgIGlmIChsb2MucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICAgICAgICBuZXdfdXJpID0gJ3dzczonO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3X3VyaSA9ICd3czonO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtuZXdfdXJpfS8vJHtsb2MuaG9zdH0ke2xvYy5wYXRobmFtZX1gO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzdGFibGlzaENvbm5lY3Rpb24ocmVxdWVzdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXF1ZXN0b3Iuc29ja2V0ID0gbmV3IFdlYlNvY2tldChnZXRIb3N0KCkgKyByZXF1ZXN0b3IudXJsKTtcbiAgICAgICAgLy8gb24gb3BlblxuICAgICAgICByZXF1ZXN0b3Iuc29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVxdWVzdG9yLmlzT3BlbiA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV2Vic29ja2V0IGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQnKTtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIG9uIG1lc3NhZ2VcbiAgICAgICAgcmVxdWVzdG9yLnNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgbGV0IHJlcyA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBsZXQgaGFzaCA9IHJlcXVlc3Rvci5nZXRIYXNoKHJlcyk7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IHJlcXVlc3Rvci5yZXF1ZXN0c1toYXNoXTtcbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0b3IucmVxdWVzdHNbaGFzaF07XG4gICAgICAgICAgICBpZiAocmVzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc29sdmUocmVxdWVzdG9yLmdldFVSTChyZXMpLCByZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlamVjdChyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBvbiBjbG9zZVxuICAgICAgICByZXF1ZXN0b3Iuc29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGxvZyBjbG9zZSBvbmx5IGlmIGNvbm5lY3Rpb24gd2FzIGV2ZXIgb3BlblxuICAgICAgICAgICAgaWYgKHJlcXVlc3Rvci5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dlYnNvY2tldCBjb25uZWN0aW9uIGNsb3NlZCwgYXR0ZW1wdGluZyB0byByZS1jb25uZWN0IGluJywgUkVUUllfSU5URVJWQUwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdG9yLnNvY2tldCA9IG51bGw7XG4gICAgICAgICAgICByZXF1ZXN0b3IuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAvLyByZWplY3QgYWxsIHBlbmRpbmcgcmVxdWVzdHNcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlcXVlc3Rvci5yZXF1ZXN0cykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0b3IucmVxdWVzdHNba2V5XS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gY2xlYXIgcmVxdWVzdCBtYXBcbiAgICAgICAgICAgIHJlcXVlc3Rvci5yZXF1ZXN0cyA9IHt9O1xuICAgICAgICAgICAgLy8gYXR0ZW1wdCB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBlc3RhYmxpc2hDb25uZWN0aW9uKHJlcXVlc3RvciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9uY2UgY29ubmVjdGlvbiBpcyByZS1lc3RhYmxpc2hlZCwgc2VuZCBwZW5kaW5nIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Rvci5wZW5kaW5nLmZvckVhY2goZnVuY3Rpb24ocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0b3IuZ2V0KHJlcSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0b3IucGVuZGluZyA9IFtdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgUkVUUllfSU5URVJWQUwpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNsYXNzIFJlcXVlc3RvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHVybCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0cyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gW107XG4gICAgICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgZXN0YWJsaXNoQ29ubmVjdGlvbih0aGlzLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0SGFzaCgpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH1cbiAgICAgICAgZ2V0VVJMKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfVxuICAgICAgICBnZXQocmVxKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gY29ubmVjdGlvbiwgYWRkIHJlcXVlc3QgdG8gcGVuZGluZyBxdWV1ZVxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZy5wdXNoKHJlcSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhhc2ggPSB0aGlzLmdldEhhc2gocmVxKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0c1toYXNoXTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QucHJvbWlzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdCA9IHRoaXMucmVxdWVzdHNbaGFzaF0gPSAkLkRlZmVycmVkKCk7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHJlcSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QucHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25jbG9zZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0b3I7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgc3RyaW5naWZ5ID0gcmVxdWlyZSgnanNvbi1zdGFibGUtc3RyaW5naWZ5Jyk7XG4gICAgbGV0IFJlcXVlc3RvciA9IHJlcXVpcmUoJy4vUmVxdWVzdG9yJyk7XG5cbiAgICBmdW5jdGlvbiBwcnVuZUVtcHR5KG9iaikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcHJ1bmUoY3VycmVudCkge1xuICAgICAgICAgICAgXy5mb3JPd24oY3VycmVudCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQodmFsdWUpIHx8IF8uaXNOdWxsKHZhbHVlKSB8fCBfLmlzTmFOKHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIChfLmlzU3RyaW5nKHZhbHVlKSAmJiBfLmlzRW1wdHkodmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgIChfLmlzT2JqZWN0KHZhbHVlKSAmJiBfLmlzRW1wdHkocHJ1bmUodmFsdWUpKSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudFtrZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbnkgbGVmdG92ZXIgdW5kZWZpbmVkIHZhbHVlcyBmcm9tIHRoZSBkZWxldGVcbiAgICAgICAgICAgIC8vIG9wZXJhdGlvbiBvbiBhbiBhcnJheVxuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgIF8ucHVsbChjdXJyZW50LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH0oXy5jbG9uZURlZXAob2JqKSk7IC8vIGRvIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIG9iamVjdCwgY3JlYXRlIGEgY2xvbmUgaW5zdGVhZFxuICAgIH1cblxuICAgIGNsYXNzIFRpbGVSZXF1ZXN0b3IgZXh0ZW5kcyBSZXF1ZXN0b3Ige1xuICAgICAgICBjb25zdHJ1Y3Rvcih1cmwsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzdXBlcih1cmwsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRIYXNoKHJlcSkge1xuICAgICAgICAgICAgbGV0IGNvb3JkID0gcmVxLmNvb3JkO1xuICAgICAgICAgICAgbGV0IGhhc2ggPSBzdHJpbmdpZnkocHJ1bmVFbXB0eShyZXEucGFyYW1zKSk7XG4gICAgICAgICAgICByZXR1cm4gYCR7cmVxLnR5cGV9LSR7cmVxLmluZGV4fS0ke3JlcS5zdG9yZX0tJHtjb29yZC56fS0ke2Nvb3JkLnh9LSR7Y29vcmQueX0tJHtoYXNofWA7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VVJMKHJlcykge1xuICAgICAgICAgICAgbGV0IGNvb3JkID0gcmVzLmNvb3JkO1xuICAgICAgICAgICAgcmV0dXJuIGB0aWxlLyR7cmVzLnR5cGV9LyR7cmVzLmluZGV4fS8ke3Jlcy5zdG9yZX0vJHtjb29yZC56fS8ke2Nvb3JkLnh9LyR7Y29vcmQueX1gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUaWxlUmVxdWVzdG9yO1xuXG59KCkpO1xuIl19
